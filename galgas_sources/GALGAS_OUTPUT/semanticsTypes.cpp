//---------------------------------------------------------------------------*
//                                                                           *
//                        File 'semanticsTypes.cpp'                          *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                     november 14th, 2010, at 15h5'23"                      *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if CURRENT_LIBPM_VERSION != VERSION_OF_LIBPM_USED_BY_GALGAS_COMPILER
  #error "This file has been compiled with a version of GALGAS that uses libpm version VERSION_OF_LIBPM_USED_BY_GALGAS_COMPILER, different than the current version (CURRENT_LIBPM_VERSION) of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "galgas2/C_galgas_CLI_Options.h"
#include "semanticsTypes.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "semanticsTypes.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@unifiedTypeMapProxyList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_unifiedTypeMapProxyList::
elementOf_GGS_unifiedTypeMapProxyList (const GGS_unifiedTypeMapProxy & argument_0
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mType (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_unifiedTypeMapProxyList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_unifiedTypeMapProxyList * ptr = dynamic_cast <const elementOf_GGS_unifiedTypeMapProxyList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_unifiedTypeMapProxyList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mType.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@unifiedTypeMapProxyList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_unifiedTypeMapProxyList ("unifiedTypeMapProxyList", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_unifiedTypeMapProxyList::
internalAppendValues (const GGS_unifiedTypeMapProxy & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_unifiedTypeMapProxyList::
internalPrependValues (const GGS_unifiedTypeMapProxy & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_unifiedTypeMapProxyList::
addAssign_operation (const GGS_unifiedTypeMapProxy & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapProxyList GGS_unifiedTypeMapProxyList::
operator_concat (const GGS_unifiedTypeMapProxyList & inOperand) const {
  GGS_unifiedTypeMapProxyList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_unifiedTypeMapProxyList::
dotAssign_operation (const GGS_unifiedTypeMapProxyList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_unifiedTypeMapProxyList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_unifiedTypeMapProxy  p_0 = p->mType ;
          internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_unifiedTypeMapProxyList::
modifier_prependValue (C_CompilerEx & /* inLexique */,
                     const GGS_unifiedTypeMapProxy & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_unifiedTypeMapProxyList::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mType
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapProxyList  GGS_unifiedTypeMapProxyList::
constructor_emptyList (void) {
  GGS_unifiedTypeMapProxyList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapProxyList  GGS_unifiedTypeMapProxyList::
constructor_listWithValue (const GGS_unifiedTypeMapProxy & argument_0) {
  GGS_unifiedTypeMapProxyList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_unifiedTypeMapProxyList::
internalSubListWithRange (GGS_unifiedTypeMapProxyList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mType) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapProxyList GGS_unifiedTypeMapProxyList::
reader_subListWithRange (C_CompilerEx & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_unifiedTypeMapProxyList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapProxyList GGS_unifiedTypeMapProxyList::
reader_subListFromIndex (C_CompilerEx & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_unifiedTypeMapProxyList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_unifiedTypeMapProxyList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@unifiedTypeMapProxyList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_unifiedTypeMapProxyList::
method_first (C_CompilerEx & inLexique,
              GGS_unifiedTypeMapProxy & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mType ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_unifiedTypeMapProxyList::
method_last (C_CompilerEx & inLexique,
             GGS_unifiedTypeMapProxy & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mType ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_unifiedTypeMapProxyList::
modifier_popFirst (C_CompilerEx & inLexique,
                 GGS_unifiedTypeMapProxy & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mType ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_unifiedTypeMapProxyList::
modifier_popLast (C_CompilerEx & inLexique,
                GGS_unifiedTypeMapProxy & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mType ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapProxy  GGS_unifiedTypeMapProxyList::
reader_mTypeAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_unifiedTypeMapProxy  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mType ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_unifiedTypeMapProxyList::
modifier_setMTypeAtIndex (C_CompilerEx & inLexique,
                              const GGS_unifiedTypeMapProxy  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mType = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_unifiedTypeMapProxy  & GGS_unifiedTypeMapProxyList::cEnumerator::_mType (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mType ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_unifiedTypeMapProxyList::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_unifiedTypeMapProxyList * p = NULL ;
    macroMyNew (p, GGS_unifiedTypeMapProxyList (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapProxyList GGS_unifiedTypeMapProxyList::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_unifiedTypeMapProxyList result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_unifiedTypeMapProxyList * p = dynamic_cast <const GGS_unifiedTypeMapProxyList *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_unifiedTypeMapProxyList, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_unifiedTypeMapProxyList::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_unifiedTypeMapProxyList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'e_constructorMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

e_constructorMap::e_constructorMap (void) :
mArgumentTypeList (),
mHasCompilerArgument (),
mReturnedType () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map '@constructorMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_constructorMap ("constructorMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_constructorMap::
elementOf_GGS_constructorMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_constructorMap & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_constructorMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mArgumentTypeList.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mHasCompilerArgument.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mReturnedType.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_constructorMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_constructorMap * ptr = dynamic_cast <const elementOf_GGS_constructorMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mArgumentTypeList.operator_isEqual (ptr->mInfo.mArgumentTypeList)).boolValue ()
           && (mInfo.mHasCompilerArgument.operator_isEqual (ptr->mInfo.mHasCompilerArgument)).boolValue ()
           && (mInfo.mReturnedType.operator_isEqual (ptr->mInfo.mReturnedType)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_constructorMap::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_constructorMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_constructorMap * info = (e_constructorMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_constructorMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_constructorMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_constructorMap * info = (e_constructorMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_constructorMap GGS_constructorMap::
constructor_emptyMap (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_constructorMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_constructorMap::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_constructorMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

void GGS_constructorMap::modifier_insertFakeKey (C_CompilerEx & inCompiler,
                         const GGS_string & inKey,
                         const GGS_location & inHelperMessageErrorLocation,
                         const GGS_string & inHelperMessage
                         COMMA_LOCATION_ARGS) {
  e_constructorMap info  ;
  internal_insertFakeKey (inCompiler,
                          (void *) & info,
                          inKey,
                          inHelperMessageErrorLocation,
                          inHelperMessage
                          COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_constructorMap::
operator_isEqual (const GGS_constructorMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_constructorMap::
operator_isNotEqual (const GGS_constructorMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_constructorMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_constructorMap::
insertElement (C_CompilerEx & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_unifiedTypeMapProxyList & inParameter0,
               const GGS_bool& inParameter1,
               const GGS_unifiedTypeMapProxy & inParameter2,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inParameter2.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap (THERE) ;
    e_constructorMap info  ;
    info.mArgumentTypeList = inParameter0 ;
    info.mHasCompilerArgument = inParameter1 ;
    info.mReturnedType = inParameter2 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_constructorMap::
searchElement (C_CompilerEx & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_unifiedTypeMapProxyList   & outParameter0,
               GGS_bool  & outParameter1,
               GGS_unifiedTypeMapProxy   & outParameter2,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inLexique, inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    outParameter2.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    outParameter0 = node->mInfo.mArgumentTypeList ;
    outParameter1 = node->mInfo.mHasCompilerArgument ;
    outParameter2 = node->mInfo.mReturnedType ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_constructorMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE ('s'),
  TO_UNICODE ('t'),
  TO_UNICODE ('u'),
  TO_UNICODE ('c'),
  TO_UNICODE ('t'),
  TO_UNICODE ('o'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_constructorMap::
method_searchKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                GGS_unifiedTypeMapProxyList   & outParameter0,
                                GGS_bool  & outParameter1,
                                GGS_unifiedTypeMapProxy   & outParameter2 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 0,
                 kSearchMessage_searchKey,
                 inKey,
                 outParameter0,
                 outParameter1,
                 outParameter2,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_constructorMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE ('s'),
  TO_UNICODE ('t'),
  TO_UNICODE ('r'),
  TO_UNICODE ('u'),
  TO_UNICODE ('c'),
  TO_UNICODE ('t'),
  TO_UNICODE ('o'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_constructorMap::
modifier_insertKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_unifiedTypeMapProxyList & inParameter0,
                                const GGS_bool& inParameter1,
                                const GGS_unifiedTypeMapProxy & inParameter2 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                NULL
                COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_constructorMap GGS_constructorMap::
constructor_mapWithMapToOverride (C_CompilerEx & /* inLexique */,
                                  const GGS_constructorMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_constructorMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_constructorMap GGS_constructorMap::
reader_overriddenMap (C_CompilerEx & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_constructorMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_constructorMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @constructorMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_unifiedTypeMapProxyList  & GGS_constructorMap::cEnumerator::_mArgumentTypeList (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mArgumentTypeList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_constructorMap::cEnumerator::_mHasCompilerArgument (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mHasCompilerArgument ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_unifiedTypeMapProxy  & GGS_constructorMap::cEnumerator::_mReturnedType (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mReturnedType ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_constructorMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_constructorMap * p = NULL ;
    macroMyNew (p, GGS_constructorMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_constructorMap GGS_constructorMap::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_constructorMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_constructorMap * p = dynamic_cast <const GGS_constructorMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_constructorMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_constructorMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_constructorMap ;
}

//---------------------------------------------------------------------------*

GGS_constructorMap GGS_constructorMap::constructor_mapWithKeyAndValue (C_CompilerEx & inLexique,
                                             const GGS_lstring & inKey,
                                             const GGS_unifiedTypeMapProxyList & inValue0,
                                             const GGS_bool& inValue1,
                                             const GGS_unifiedTypeMapProxy & inValue2
                                             COMMA_LOCATION_ARGS) {
  GGS_constructorMap result = constructor_emptyMap (inLexique COMMA_THERE) ;
  result.insertElement (inLexique,
                        0,
                        NULL,
                        inKey,
                        inValue0,
                        inValue1,
                        inValue2,
                        NULL
                        COMMA_THERE) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 Class for 'methodQualifier' Enumeration                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_methodQualifier ("methodQualifier", false, NULL) ;

//---------------------------------------------------------------------------*

bool GGS_methodQualifier::
isBuilt (void) const {
  return mValue > kNotBuilt ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_methodQualifier::
operator_isEqual (const GGS_methodQualifier inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_methodQualifier::
operator_isNotEqual (const GGS_methodQualifier inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_methodQualifier::
operator_infOrEqual (const GGS_methodQualifier inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_methodQualifier::
operator_supOrEqual (const GGS_methodQualifier inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_methodQualifier::
operator_strictInf (const GGS_methodQualifier inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_methodQualifier::
operator_strictSup (const GGS_methodQualifier inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_methodQualifier::
reader_description (const PMSInt32 /* inIndentation */) const {
  C_String s ;
  s << "<enum @methodQualifier" ;
  switch (mValue) {
  case enum_isAbstract:
    s << " isAbstract>" ;
    break ;
  case enum_isBasic:
    s << " isBasic>" ;
    break ;
  case enum_isBasicFinal:
    s << " isBasicFinal>" ;
    break ;
  case enum_isInherited:
    s << " isInherited>" ;
    break ;
  case enum_isOverriding:
    s << " isOverriding>" ;
    break ;
  case enum_isOverridingAbstract:
    s << " isOverridingAbstract>" ;
    break ;
  case kNotBuilt:
    s << " (not built)>" ;
    break ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_methodQualifier::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_methodQualifier * p = NULL ;
    macroMyNew (p, GGS_methodQualifier (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_methodQualifier GGS_methodQualifier::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_methodQualifier result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_methodQualifier * p = dynamic_cast <const GGS_methodQualifier *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_methodQualifier, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_methodQualifier::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_methodQualifier ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'e_readerMap'                             *
//                                                                           *
//---------------------------------------------------------------------------*

e_readerMap::e_readerMap (void) :
mIsCategory (),
mArgumentTypeList (),
mDeclarationLocation (),
mHasCompilerArgument (),
mReturnedType (),
mQualifier () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class map '@readerMap'                           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_readerMap ("readerMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_readerMap::
elementOf_GGS_readerMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_readerMap & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_readerMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mIsCategory.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mArgumentTypeList.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mDeclarationLocation.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mHasCompilerArgument.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mReturnedType.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mQualifier.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_readerMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_readerMap * ptr = dynamic_cast <const elementOf_GGS_readerMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mIsCategory.operator_isEqual (ptr->mInfo.mIsCategory)).boolValue ()
           && (mInfo.mArgumentTypeList.operator_isEqual (ptr->mInfo.mArgumentTypeList)).boolValue ()
           && (mInfo.mDeclarationLocation.operator_isEqual (ptr->mInfo.mDeclarationLocation)).boolValue ()
           && (mInfo.mHasCompilerArgument.operator_isEqual (ptr->mInfo.mHasCompilerArgument)).boolValue ()
           && (mInfo.mReturnedType.operator_isEqual (ptr->mInfo.mReturnedType)).boolValue ()
           && (mInfo.mQualifier.operator_isEqual (ptr->mInfo.mQualifier)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_readerMap::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_readerMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_readerMap * info = (e_readerMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_readerMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_readerMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_readerMap * info = (e_readerMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_readerMap GGS_readerMap::
constructor_emptyMap (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_readerMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_readerMap::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_readerMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

void GGS_readerMap::modifier_insertFakeKey (C_CompilerEx & inCompiler,
                         const GGS_string & inKey,
                         const GGS_location & inHelperMessageErrorLocation,
                         const GGS_string & inHelperMessage
                         COMMA_LOCATION_ARGS) {
  e_readerMap info  ;
  internal_insertFakeKey (inCompiler,
                          (void *) & info,
                          inKey,
                          inHelperMessageErrorLocation,
                          inHelperMessage
                          COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_readerMap::
operator_isEqual (const GGS_readerMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_readerMap::
operator_isNotEqual (const GGS_readerMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_readerMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_readerMap::
insertElement (C_CompilerEx & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_bool& inParameter0,
               const GGS_unifiedTypeMapProxyList & inParameter1,
               const GGS_location & inParameter2,
               const GGS_bool& inParameter3,
               const GGS_unifiedTypeMapProxy & inParameter4,
               const GGS_methodQualifier& inParameter5,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inParameter2.isBuilt ()
   && inParameter3.isBuilt ()
   && inParameter4.isBuilt ()
   && inParameter5.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap (THERE) ;
    e_readerMap info  ;
    info.mIsCategory = inParameter0 ;
    info.mArgumentTypeList = inParameter1 ;
    info.mDeclarationLocation = inParameter2 ;
    info.mHasCompilerArgument = inParameter3 ;
    info.mReturnedType = inParameter4 ;
    info.mQualifier = inParameter5 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_readerMap::
searchElement (C_CompilerEx & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_bool  & outParameter0,
               GGS_unifiedTypeMapProxyList   & outParameter1,
               GGS_location   & outParameter2,
               GGS_bool  & outParameter3,
               GGS_unifiedTypeMapProxy   & outParameter4,
               GGS_methodQualifier  & outParameter5,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inLexique, inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    outParameter2.drop () ;
    outParameter3.drop () ;
    outParameter4.drop () ;
    outParameter5.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    outParameter0 = node->mInfo.mIsCategory ;
    outParameter1 = node->mInfo.mArgumentTypeList ;
    outParameter2 = node->mInfo.mDeclarationLocation ;
    outParameter3 = node->mInfo.mHasCompilerArgument ;
    outParameter4 = node->mInfo.mReturnedType ;
    outParameter5 = node->mInfo.mQualifier ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_readerMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_readerMap::
method_searchKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                GGS_bool  & outParameter0,
                                GGS_unifiedTypeMapProxyList   & outParameter1,
                                GGS_location   & outParameter2,
                                GGS_bool  & outParameter3,
                                GGS_unifiedTypeMapProxy   & outParameter4,
                                GGS_methodQualifier  & outParameter5 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 0,
                 kSearchMessage_searchKey,
                 inKey,
                 outParameter0,
                 outParameter1,
                 outParameter2,
                 outParameter3,
                 outParameter4,
                 outParameter5,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_readerMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_readerMap::
modifier_insertKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_bool& inParameter0,
                                const GGS_unifiedTypeMapProxyList & inParameter1,
                                const GGS_location & inParameter2,
                                const GGS_bool& inParameter3,
                                const GGS_unifiedTypeMapProxy & inParameter4,
                                const GGS_methodQualifier& inParameter5 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 inParameter3,
                 inParameter4,
                 inParameter5,
                NULL
                COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_readerMap GGS_readerMap::
constructor_mapWithMapToOverride (C_CompilerEx & /* inLexique */,
                                  const GGS_readerMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_readerMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_readerMap GGS_readerMap::
reader_overriddenMap (C_CompilerEx & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_readerMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_readerMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @readerMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_readerMap::cEnumerator::_mIsCategory (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mIsCategory ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_unifiedTypeMapProxyList  & GGS_readerMap::cEnumerator::_mArgumentTypeList (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mArgumentTypeList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_location  & GGS_readerMap::cEnumerator::_mDeclarationLocation (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mDeclarationLocation ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_readerMap::cEnumerator::_mHasCompilerArgument (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mHasCompilerArgument ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_unifiedTypeMapProxy  & GGS_readerMap::cEnumerator::_mReturnedType (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mReturnedType ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_methodQualifier & GGS_readerMap::cEnumerator::_mQualifier (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mQualifier ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_readerMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_readerMap * p = NULL ;
    macroMyNew (p, GGS_readerMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_readerMap GGS_readerMap::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_readerMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_readerMap * p = dynamic_cast <const GGS_readerMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_readerMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_readerMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_readerMap ;
}

//---------------------------------------------------------------------------*

void GGS_readerMap::modifier_insertOrReplace (C_CompilerEx & /* inLexique */,
                                const GGS_lstring & inKey,
                                const GGS_bool&  inParameter0,
                                const GGS_unifiedTypeMapProxyList &  inParameter1,
                                const GGS_location &  inParameter2,
                                const GGS_bool&  inParameter3,
                                const GGS_unifiedTypeMapProxy &  inParameter4,
                                const GGS_methodQualifier&  inParameter5 COMMA_LOCATION_ARGS) {
  if (isBuilt () && inKey.isBuilt ()
  && inParameter0.isBuilt ()
  && inParameter1.isBuilt ()
  && inParameter2.isBuilt ()
  && inParameter3.isBuilt ()
  && inParameter4.isBuilt ()
  && inParameter5.isBuilt ()) {
    insulateMap (THERE) ;
    e_readerMap info ;
    info.mIsCategory =  inParameter0 ;
    info.mArgumentTypeList =  inParameter1 ;
    info.mDeclarationLocation =  inParameter2 ;
    info.mHasCompilerArgument =  inParameter3 ;
    info.mReturnedType =  inParameter4 ;
    info.mQualifier =  inParameter5 ;
    insertOrReplaceElement (inKey, (void *) & info) ;
  }
}

//---------------------------------------------------------------------------*

GGS_readerMap GGS_readerMap::constructor_mapWithKeyAndValue (C_CompilerEx & inLexique,
                                             const GGS_lstring & inKey,
                                             const GGS_bool& inValue0,
                                             const GGS_unifiedTypeMapProxyList & inValue1,
                                             const GGS_location & inValue2,
                                             const GGS_bool& inValue3,
                                             const GGS_unifiedTypeMapProxy & inValue4,
                                             const GGS_methodQualifier& inValue5
                                             COMMA_LOCATION_ARGS) {
  GGS_readerMap result = constructor_emptyMap (inLexique COMMA_THERE) ;
  result.insertElement (inLexique,
                        0,
                        NULL,
                        inKey,
                        inValue0,
                        inValue1,
                        inValue2,
                        inValue3,
                        inValue4,
                        inValue5,
                        NULL
                        COMMA_THERE) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@formalParameterSignature'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_formalParameterSignature::
elementOf_GGS_formalParameterSignature (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_formalArgumentPassingModeAST& argument_1
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mFormalArgumentType (argument_0),
mFormalArgumentPassingMode (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_formalParameterSignature::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_formalParameterSignature * ptr = dynamic_cast <const elementOf_GGS_formalParameterSignature *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mFormalArgumentType.operator_isEqual (ptr->mFormalArgumentType).boolValue ()
         && mFormalArgumentPassingMode.operator_isEqual (ptr->mFormalArgumentPassingMode).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_formalParameterSignature::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFormalArgumentType.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFormalArgumentPassingMode.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@formalParameterSignature'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_formalParameterSignature ("formalParameterSignature", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_formalParameterSignature::
internalAppendValues (const GGS_unifiedTypeMapProxy & argument_0,
                    const GGS_formalArgumentPassingModeAST& argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_formalParameterSignature::
internalPrependValues (const GGS_unifiedTypeMapProxy & argument_0,
                    const GGS_formalArgumentPassingModeAST& argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_formalParameterSignature::
addAssign_operation (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_formalArgumentPassingModeAST& argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_formalParameterSignature GGS_formalParameterSignature::
operator_concat (const GGS_formalParameterSignature & inOperand) const {
  GGS_formalParameterSignature result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_formalParameterSignature::
dotAssign_operation (const GGS_formalParameterSignature inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_formalParameterSignature * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_unifiedTypeMapProxy  p_0 = p->mFormalArgumentType ;
          GGS_formalArgumentPassingModeAST p_1 = p->mFormalArgumentPassingMode ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_formalParameterSignature::
modifier_prependValue (C_CompilerEx & /* inLexique */,
                     const GGS_unifiedTypeMapProxy & argument_0,
                     const GGS_formalArgumentPassingModeAST& argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_formalParameterSignature::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mFormalArgumentType,
                                ptr->mFormalArgumentPassingMode
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_formalParameterSignature  GGS_formalParameterSignature::
constructor_emptyList (void) {
  GGS_formalParameterSignature result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameterSignature  GGS_formalParameterSignature::
constructor_listWithValue (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_formalArgumentPassingModeAST& argument_1) {
  GGS_formalParameterSignature result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_formalParameterSignature::
internalSubListWithRange (GGS_formalParameterSignature & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mFormalArgumentType, ptr->mFormalArgumentPassingMode) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_formalParameterSignature GGS_formalParameterSignature::
reader_subListWithRange (C_CompilerEx & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_formalParameterSignature result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameterSignature GGS_formalParameterSignature::
reader_subListFromIndex (C_CompilerEx & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_formalParameterSignature result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_formalParameterSignature::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@formalParameterSignature", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_formalParameterSignature::
method_first (C_CompilerEx & inLexique,
              GGS_unifiedTypeMapProxy & _out_0,
              GGS_formalArgumentPassingModeAST& _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mFormalArgumentType ;
    _out_1 = ptr->mFormalArgumentPassingMode ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_formalParameterSignature::
method_last (C_CompilerEx & inLexique,
             GGS_unifiedTypeMapProxy & _out_0,
             GGS_formalArgumentPassingModeAST& _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mFormalArgumentType ;
    _out_1 = ptr->mFormalArgumentPassingMode ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_formalParameterSignature::
modifier_popFirst (C_CompilerEx & inLexique,
                 GGS_unifiedTypeMapProxy & _out_0,
                 GGS_formalArgumentPassingModeAST& _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mFormalArgumentType ;
    _out_1 = ptr->mFormalArgumentPassingMode ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_formalParameterSignature::
modifier_popLast (C_CompilerEx & inLexique,
                GGS_unifiedTypeMapProxy & _out_0,
                GGS_formalArgumentPassingModeAST& _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mFormalArgumentType ;
    _out_1 = ptr->mFormalArgumentPassingMode ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapProxy  GGS_formalParameterSignature::
reader_mFormalArgumentTypeAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_unifiedTypeMapProxy  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mFormalArgumentType ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalArgumentPassingModeAST GGS_formalParameterSignature::
reader_mFormalArgumentPassingModeAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_formalArgumentPassingModeAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mFormalArgumentPassingMode ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_formalParameterSignature::
modifier_setMFormalArgumentTypeAtIndex (C_CompilerEx & inLexique,
                              const GGS_unifiedTypeMapProxy  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mFormalArgumentType = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_formalParameterSignature::
modifier_setMFormalArgumentPassingModeAtIndex (C_CompilerEx & inLexique,
                              const GGS_formalArgumentPassingModeAST & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mFormalArgumentPassingMode = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_unifiedTypeMapProxy  & GGS_formalParameterSignature::cEnumerator::_mFormalArgumentType (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mFormalArgumentType ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_formalArgumentPassingModeAST & GGS_formalParameterSignature::cEnumerator::_mFormalArgumentPassingMode (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mFormalArgumentPassingMode ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_formalParameterSignature::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_formalParameterSignature * p = NULL ;
    macroMyNew (p, GGS_formalParameterSignature (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameterSignature GGS_formalParameterSignature::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_formalParameterSignature result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_formalParameterSignature * p = dynamic_cast <const GGS_formalParameterSignature *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_formalParameterSignature, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_formalParameterSignature::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_formalParameterSignature ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'e_modifierMap'                            *
//                                                                           *
//---------------------------------------------------------------------------*

e_modifierMap::e_modifierMap (void) :
mParameterList (),
mHasCompilerArgument (),
mQualifier () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class map '@modifierMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_modifierMap ("modifierMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_modifierMap::
elementOf_GGS_modifierMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_modifierMap & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_modifierMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mParameterList.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mHasCompilerArgument.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mQualifier.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_modifierMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_modifierMap * ptr = dynamic_cast <const elementOf_GGS_modifierMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mParameterList.operator_isEqual (ptr->mInfo.mParameterList)).boolValue ()
           && (mInfo.mHasCompilerArgument.operator_isEqual (ptr->mInfo.mHasCompilerArgument)).boolValue ()
           && (mInfo.mQualifier.operator_isEqual (ptr->mInfo.mQualifier)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_modifierMap::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_modifierMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_modifierMap * info = (e_modifierMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_modifierMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_modifierMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_modifierMap * info = (e_modifierMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_modifierMap GGS_modifierMap::
constructor_emptyMap (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_modifierMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_modifierMap::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_modifierMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

void GGS_modifierMap::modifier_insertFakeKey (C_CompilerEx & inCompiler,
                         const GGS_string & inKey,
                         const GGS_location & inHelperMessageErrorLocation,
                         const GGS_string & inHelperMessage
                         COMMA_LOCATION_ARGS) {
  e_modifierMap info  ;
  internal_insertFakeKey (inCompiler,
                          (void *) & info,
                          inKey,
                          inHelperMessageErrorLocation,
                          inHelperMessage
                          COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_modifierMap::
operator_isEqual (const GGS_modifierMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_modifierMap::
operator_isNotEqual (const GGS_modifierMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_modifierMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_modifierMap::
insertElement (C_CompilerEx & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_formalParameterSignature & inParameter0,
               const GGS_bool& inParameter1,
               const GGS_methodQualifier& inParameter2,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inParameter2.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap (THERE) ;
    e_modifierMap info  ;
    info.mParameterList = inParameter0 ;
    info.mHasCompilerArgument = inParameter1 ;
    info.mQualifier = inParameter2 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_modifierMap::
searchElement (C_CompilerEx & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_formalParameterSignature   & outParameter0,
               GGS_bool  & outParameter1,
               GGS_methodQualifier  & outParameter2,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inLexique, inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    outParameter2.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    outParameter0 = node->mInfo.mParameterList ;
    outParameter1 = node->mInfo.mHasCompilerArgument ;
    outParameter2 = node->mInfo.mQualifier ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_modifierMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('o'),
  TO_UNICODE ('d'),
  TO_UNICODE ('i'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_modifierMap::
method_searchKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                GGS_formalParameterSignature   & outParameter0,
                                GGS_bool  & outParameter1,
                                GGS_methodQualifier  & outParameter2 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 0,
                 kSearchMessage_searchKey,
                 inKey,
                 outParameter0,
                 outParameter1,
                 outParameter2,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_modifierMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('o'),
  TO_UNICODE ('d'),
  TO_UNICODE ('i'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_modifierMap::
modifier_insertKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_formalParameterSignature & inParameter0,
                                const GGS_bool& inParameter1,
                                const GGS_methodQualifier& inParameter2 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                NULL
                COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_modifierMap GGS_modifierMap::
constructor_mapWithMapToOverride (C_CompilerEx & /* inLexique */,
                                  const GGS_modifierMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_modifierMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_modifierMap GGS_modifierMap::
reader_overriddenMap (C_CompilerEx & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_modifierMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_modifierMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @modifierMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_formalParameterSignature  & GGS_modifierMap::cEnumerator::_mParameterList (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mParameterList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_modifierMap::cEnumerator::_mHasCompilerArgument (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mHasCompilerArgument ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_methodQualifier & GGS_modifierMap::cEnumerator::_mQualifier (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mQualifier ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_modifierMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_modifierMap * p = NULL ;
    macroMyNew (p, GGS_modifierMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_modifierMap GGS_modifierMap::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_modifierMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_modifierMap * p = dynamic_cast <const GGS_modifierMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_modifierMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_modifierMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_modifierMap ;
}

//---------------------------------------------------------------------------*

void GGS_modifierMap::modifier_insertOrReplace (C_CompilerEx & /* inLexique */,
                                const GGS_lstring & inKey,
                                const GGS_formalParameterSignature &  inParameter0,
                                const GGS_bool&  inParameter1,
                                const GGS_methodQualifier&  inParameter2 COMMA_LOCATION_ARGS) {
  if (isBuilt () && inKey.isBuilt ()
  && inParameter0.isBuilt ()
  && inParameter1.isBuilt ()
  && inParameter2.isBuilt ()) {
    insulateMap (THERE) ;
    e_modifierMap info ;
    info.mParameterList =  inParameter0 ;
    info.mHasCompilerArgument =  inParameter1 ;
    info.mQualifier =  inParameter2 ;
    insertOrReplaceElement (inKey, (void *) & info) ;
  }
}

//---------------------------------------------------------------------------*

GGS_modifierMap GGS_modifierMap::constructor_mapWithKeyAndValue (C_CompilerEx & inLexique,
                                             const GGS_lstring & inKey,
                                             const GGS_formalParameterSignature & inValue0,
                                             const GGS_bool& inValue1,
                                             const GGS_methodQualifier& inValue2
                                             COMMA_LOCATION_ARGS) {
  GGS_modifierMap result = constructor_emptyMap (inLexique COMMA_THERE) ;
  result.insertElement (inLexique,
                        0,
                        NULL,
                        inKey,
                        inValue0,
                        inValue1,
                        inValue2,
                        NULL
                        COMMA_THERE) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'e_instanceMethodMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

e_instanceMethodMap::e_instanceMethodMap (void) :
mIsCategory (),
mParameterList (),
mDeclarationLocation (),
mHasCompilerArgument (),
mQualifier () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class map '@instanceMethodMap'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_instanceMethodMap ("instanceMethodMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_instanceMethodMap::
elementOf_GGS_instanceMethodMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_instanceMethodMap & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_instanceMethodMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mIsCategory.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mParameterList.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mDeclarationLocation.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mHasCompilerArgument.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mQualifier.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_instanceMethodMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_instanceMethodMap * ptr = dynamic_cast <const elementOf_GGS_instanceMethodMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mIsCategory.operator_isEqual (ptr->mInfo.mIsCategory)).boolValue ()
           && (mInfo.mParameterList.operator_isEqual (ptr->mInfo.mParameterList)).boolValue ()
           && (mInfo.mDeclarationLocation.operator_isEqual (ptr->mInfo.mDeclarationLocation)).boolValue ()
           && (mInfo.mHasCompilerArgument.operator_isEqual (ptr->mInfo.mHasCompilerArgument)).boolValue ()
           && (mInfo.mQualifier.operator_isEqual (ptr->mInfo.mQualifier)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_instanceMethodMap::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_instanceMethodMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_instanceMethodMap * info = (e_instanceMethodMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_instanceMethodMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_instanceMethodMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_instanceMethodMap * info = (e_instanceMethodMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_instanceMethodMap GGS_instanceMethodMap::
constructor_emptyMap (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_instanceMethodMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_instanceMethodMap::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_instanceMethodMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

void GGS_instanceMethodMap::modifier_insertFakeKey (C_CompilerEx & inCompiler,
                         const GGS_string & inKey,
                         const GGS_location & inHelperMessageErrorLocation,
                         const GGS_string & inHelperMessage
                         COMMA_LOCATION_ARGS) {
  e_instanceMethodMap info  ;
  internal_insertFakeKey (inCompiler,
                          (void *) & info,
                          inKey,
                          inHelperMessageErrorLocation,
                          inHelperMessage
                          COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_instanceMethodMap::
operator_isEqual (const GGS_instanceMethodMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_instanceMethodMap::
operator_isNotEqual (const GGS_instanceMethodMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_instanceMethodMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_instanceMethodMap::
insertElement (C_CompilerEx & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_bool& inParameter0,
               const GGS_formalParameterSignature & inParameter1,
               const GGS_location & inParameter2,
               const GGS_bool& inParameter3,
               const GGS_methodQualifier& inParameter4,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inParameter2.isBuilt ()
   && inParameter3.isBuilt ()
   && inParameter4.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap (THERE) ;
    e_instanceMethodMap info  ;
    info.mIsCategory = inParameter0 ;
    info.mParameterList = inParameter1 ;
    info.mDeclarationLocation = inParameter2 ;
    info.mHasCompilerArgument = inParameter3 ;
    info.mQualifier = inParameter4 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_instanceMethodMap::
searchElement (C_CompilerEx & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_bool  & outParameter0,
               GGS_formalParameterSignature   & outParameter1,
               GGS_location   & outParameter2,
               GGS_bool  & outParameter3,
               GGS_methodQualifier  & outParameter4,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inLexique, inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    outParameter2.drop () ;
    outParameter3.drop () ;
    outParameter4.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    outParameter0 = node->mInfo.mIsCategory ;
    outParameter1 = node->mInfo.mParameterList ;
    outParameter2 = node->mInfo.mDeclarationLocation ;
    outParameter3 = node->mInfo.mHasCompilerArgument ;
    outParameter4 = node->mInfo.mQualifier ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_instanceMethodMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('s'),
  TO_UNICODE ('t'),
  TO_UNICODE ('a'),
  TO_UNICODE ('n'),
  TO_UNICODE ('c'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('o'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

const utf32 GGS_instanceMethodMap::kSearchMessage_searchInheritedKey [] = {
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('o'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('a'),
  TO_UNICODE ('g'),
  TO_UNICODE ('g'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('o'),
  TO_UNICODE ('v'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('\''),
  TO_UNICODE (','),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('s'),
  TO_UNICODE ('h'),
  TO_UNICODE ('o'),
  TO_UNICODE ('u'),
  TO_UNICODE ('l'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('s'),
  TO_UNICODE ('u'),
  TO_UNICODE ('p'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE ('s'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_instanceMethodMap::
method_searchKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                GGS_bool  & outParameter0,
                                GGS_formalParameterSignature   & outParameter1,
                                GGS_location   & outParameter2,
                                GGS_bool  & outParameter3,
                                GGS_methodQualifier  & outParameter4 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 0,
                 kSearchMessage_searchKey,
                 inKey,
                 outParameter0,
                 outParameter1,
                 outParameter2,
                 outParameter3,
                 outParameter4,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_instanceMethodMap::
method_searchInheritedKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                GGS_bool  & outParameter0,
                                GGS_formalParameterSignature   & outParameter1,
                                GGS_location   & outParameter2,
                                GGS_bool  & outParameter3,
                                GGS_methodQualifier  & outParameter4 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 0,
                 kSearchMessage_searchInheritedKey,
                 inKey,
                 outParameter0,
                 outParameter1,
                 outParameter2,
                 outParameter3,
                 outParameter4,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_instanceMethodMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('s'),
  TO_UNICODE ('t'),
  TO_UNICODE ('a'),
  TO_UNICODE ('n'),
  TO_UNICODE ('c'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('o'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_instanceMethodMap::
modifier_insertKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_bool& inParameter0,
                                const GGS_formalParameterSignature & inParameter1,
                                const GGS_location & inParameter2,
                                const GGS_bool& inParameter3,
                                const GGS_methodQualifier& inParameter4 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 inParameter3,
                 inParameter4,
                NULL
                COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_instanceMethodMap GGS_instanceMethodMap::
constructor_mapWithMapToOverride (C_CompilerEx & /* inLexique */,
                                  const GGS_instanceMethodMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_instanceMethodMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_instanceMethodMap GGS_instanceMethodMap::
reader_overriddenMap (C_CompilerEx & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_instanceMethodMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_instanceMethodMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @instanceMethodMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_instanceMethodMap::cEnumerator::_mIsCategory (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mIsCategory ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_formalParameterSignature  & GGS_instanceMethodMap::cEnumerator::_mParameterList (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mParameterList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_location  & GGS_instanceMethodMap::cEnumerator::_mDeclarationLocation (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mDeclarationLocation ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_instanceMethodMap::cEnumerator::_mHasCompilerArgument (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mHasCompilerArgument ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_methodQualifier & GGS_instanceMethodMap::cEnumerator::_mQualifier (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mQualifier ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_instanceMethodMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_instanceMethodMap * p = NULL ;
    macroMyNew (p, GGS_instanceMethodMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_instanceMethodMap GGS_instanceMethodMap::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_instanceMethodMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_instanceMethodMap * p = dynamic_cast <const GGS_instanceMethodMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_instanceMethodMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_instanceMethodMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_instanceMethodMap ;
}

//---------------------------------------------------------------------------*

GGS_instanceMethodMap GGS_instanceMethodMap::constructor_mapWithKeyAndValue (C_CompilerEx & inLexique,
                                             const GGS_lstring & inKey,
                                             const GGS_bool& inValue0,
                                             const GGS_formalParameterSignature & inValue1,
                                             const GGS_location & inValue2,
                                             const GGS_bool& inValue3,
                                             const GGS_methodQualifier& inValue4
                                             COMMA_LOCATION_ARGS) {
  GGS_instanceMethodMap result = constructor_emptyMap (inLexique COMMA_THERE) ;
  result.insertElement (inLexique,
                        0,
                        NULL,
                        inKey,
                        inValue0,
                        inValue1,
                        inValue2,
                        inValue3,
                        inValue4,
                        NULL
                        COMMA_THERE) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'e_classMethodMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

e_classMethodMap::e_classMethodMap (void) :
mParameterList (),
mHasCompilerArgument () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map '@classMethodMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_classMethodMap ("classMethodMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_classMethodMap::
elementOf_GGS_classMethodMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_classMethodMap & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_classMethodMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mParameterList.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mHasCompilerArgument.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_classMethodMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_classMethodMap * ptr = dynamic_cast <const elementOf_GGS_classMethodMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mParameterList.operator_isEqual (ptr->mInfo.mParameterList)).boolValue ()
           && (mInfo.mHasCompilerArgument.operator_isEqual (ptr->mInfo.mHasCompilerArgument)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_classMethodMap::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_classMethodMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_classMethodMap * info = (e_classMethodMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_classMethodMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_classMethodMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_classMethodMap * info = (e_classMethodMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_classMethodMap GGS_classMethodMap::
constructor_emptyMap (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_classMethodMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_classMethodMap::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_classMethodMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

void GGS_classMethodMap::modifier_insertFakeKey (C_CompilerEx & inCompiler,
                         const GGS_string & inKey,
                         const GGS_location & inHelperMessageErrorLocation,
                         const GGS_string & inHelperMessage
                         COMMA_LOCATION_ARGS) {
  e_classMethodMap info  ;
  internal_insertFakeKey (inCompiler,
                          (void *) & info,
                          inKey,
                          inHelperMessageErrorLocation,
                          inHelperMessage
                          COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_classMethodMap::
operator_isEqual (const GGS_classMethodMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_classMethodMap::
operator_isNotEqual (const GGS_classMethodMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_classMethodMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_classMethodMap::
insertElement (C_CompilerEx & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_formalParameterSignature & inParameter0,
               const GGS_bool& inParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap (THERE) ;
    e_classMethodMap info  ;
    info.mParameterList = inParameter0 ;
    info.mHasCompilerArgument = inParameter1 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_classMethodMap::
searchElement (C_CompilerEx & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_formalParameterSignature   & outParameter0,
               GGS_bool  & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inLexique, inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    outParameter0 = node->mInfo.mParameterList ;
    outParameter1 = node->mInfo.mHasCompilerArgument ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_classMethodMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('o'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_classMethodMap::
method_searchKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                GGS_formalParameterSignature   & outParameter0,
                                GGS_bool  & outParameter1 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 0,
                 kSearchMessage_searchKey,
                 inKey,
                 outParameter0,
                 outParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_classMethodMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('o'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_classMethodMap::
modifier_insertKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_formalParameterSignature & inParameter0,
                                const GGS_bool& inParameter1 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                NULL
                COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_classMethodMap GGS_classMethodMap::
constructor_mapWithMapToOverride (C_CompilerEx & /* inLexique */,
                                  const GGS_classMethodMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_classMethodMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_classMethodMap GGS_classMethodMap::
reader_overriddenMap (C_CompilerEx & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_classMethodMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_classMethodMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @classMethodMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_formalParameterSignature  & GGS_classMethodMap::cEnumerator::_mParameterList (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mParameterList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_classMethodMap::cEnumerator::_mHasCompilerArgument (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mHasCompilerArgument ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_classMethodMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_classMethodMap * p = NULL ;
    macroMyNew (p, GGS_classMethodMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_classMethodMap GGS_classMethodMap::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_classMethodMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_classMethodMap * p = dynamic_cast <const GGS_classMethodMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_classMethodMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_classMethodMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_classMethodMap ;
}

//---------------------------------------------------------------------------*

void GGS_classMethodMap::modifier_insertOrReplace (C_CompilerEx & /* inLexique */,
                                const GGS_lstring & inKey,
                                const GGS_formalParameterSignature &  inParameter0,
                                const GGS_bool&  inParameter1 COMMA_LOCATION_ARGS) {
  if (isBuilt () && inKey.isBuilt ()
  && inParameter0.isBuilt ()
  && inParameter1.isBuilt ()) {
    insulateMap (THERE) ;
    e_classMethodMap info ;
    info.mParameterList =  inParameter0 ;
    info.mHasCompilerArgument =  inParameter1 ;
    insertOrReplaceElement (inKey, (void *) & info) ;
  }
}

//---------------------------------------------------------------------------*

GGS_classMethodMap GGS_classMethodMap::constructor_mapWithKeyAndValue (C_CompilerEx & inLexique,
                                             const GGS_lstring & inKey,
                                             const GGS_formalParameterSignature & inValue0,
                                             const GGS_bool& inValue1
                                             COMMA_LOCATION_ARGS) {
  GGS_classMethodMap result = constructor_emptyMap (inLexique COMMA_THERE) ;
  result.insertElement (inLexique,
                        0,
                        NULL,
                        inKey,
                        inValue0,
                        inValue1,
                        NULL
                        COMMA_THERE) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'e_withAccessorMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

e_withAccessorMap::e_withAccessorMap (void) :
mArgumentType () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map '@withAccessorMap'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_withAccessorMap ("withAccessorMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_withAccessorMap::
elementOf_GGS_withAccessorMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_withAccessorMap & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_withAccessorMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mArgumentType.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_withAccessorMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_withAccessorMap * ptr = dynamic_cast <const elementOf_GGS_withAccessorMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mArgumentType.operator_isEqual (ptr->mInfo.mArgumentType)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_withAccessorMap::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_withAccessorMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_withAccessorMap * info = (e_withAccessorMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_withAccessorMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_withAccessorMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_withAccessorMap * info = (e_withAccessorMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_withAccessorMap GGS_withAccessorMap::
constructor_emptyMap (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_withAccessorMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_withAccessorMap::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_withAccessorMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

void GGS_withAccessorMap::modifier_insertFakeKey (C_CompilerEx & inCompiler,
                         const GGS_string & inKey,
                         const GGS_location & inHelperMessageErrorLocation,
                         const GGS_string & inHelperMessage
                         COMMA_LOCATION_ARGS) {
  e_withAccessorMap info  ;
  internal_insertFakeKey (inCompiler,
                          (void *) & info,
                          inKey,
                          inHelperMessageErrorLocation,
                          inHelperMessage
                          COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_withAccessorMap::
operator_isEqual (const GGS_withAccessorMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_withAccessorMap::
operator_isNotEqual (const GGS_withAccessorMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_withAccessorMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_withAccessorMap::
insertElement (C_CompilerEx & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_unifiedTypeMapProxy & inParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap (THERE) ;
    e_withAccessorMap info  ;
    info.mArgumentType = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_withAccessorMap::
searchElement (C_CompilerEx & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_unifiedTypeMapProxy   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inLexique, inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    outParameter0 = node->mInfo.mArgumentType ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_withAccessorMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('w'),
  TO_UNICODE ('i'),
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('c'),
  TO_UNICODE ('c'),
  TO_UNICODE ('e'),
  TO_UNICODE ('s'),
  TO_UNICODE ('s'),
  TO_UNICODE ('o'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_withAccessorMap::
method_searchKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                GGS_unifiedTypeMapProxy   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 0,
                 kSearchMessage_searchKey,
                 inKey,
                 outParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_withAccessorMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('w'),
  TO_UNICODE ('i'),
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('c'),
  TO_UNICODE ('c'),
  TO_UNICODE ('e'),
  TO_UNICODE ('s'),
  TO_UNICODE ('s'),
  TO_UNICODE ('o'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_withAccessorMap::
modifier_insertKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_unifiedTypeMapProxy & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                NULL
                COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_withAccessorMap GGS_withAccessorMap::
constructor_mapWithMapToOverride (C_CompilerEx & /* inLexique */,
                                  const GGS_withAccessorMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_withAccessorMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_withAccessorMap GGS_withAccessorMap::
reader_overriddenMap (C_CompilerEx & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_withAccessorMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_withAccessorMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @withAccessorMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_unifiedTypeMapProxy  & GGS_withAccessorMap::cEnumerator::_mArgumentType (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mArgumentType ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_withAccessorMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_withAccessorMap * p = NULL ;
    macroMyNew (p, GGS_withAccessorMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_withAccessorMap GGS_withAccessorMap::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_withAccessorMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_withAccessorMap * p = dynamic_cast <const GGS_withAccessorMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_withAccessorMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_withAccessorMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_withAccessorMap ;
}

//---------------------------------------------------------------------------*

GGS_withAccessorMap GGS_withAccessorMap::constructor_mapWithKeyAndValue (C_CompilerEx & inLexique,
                                             const GGS_lstring & inKey,
                                             const GGS_unifiedTypeMapProxy & inValue0
                                             COMMA_LOCATION_ARGS) {
  GGS_withAccessorMap result = constructor_emptyMap (inLexique COMMA_THERE) ;
  result.insertElement (inLexique,
                        0,
                        NULL,
                        inKey,
                        inValue0,
                        NULL
                        COMMA_THERE) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@enumerationDescriptorList'                *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_enumerationDescriptorList::
elementOf_GGS_enumerationDescriptorList (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_string& argument_1
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mEnumeratedType (argument_0),
mEnumerationName (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_enumerationDescriptorList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_enumerationDescriptorList * ptr = dynamic_cast <const elementOf_GGS_enumerationDescriptorList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mEnumeratedType.operator_isEqual (ptr->mEnumeratedType).boolValue ()
         && mEnumerationName.operator_isEqual (ptr->mEnumerationName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_enumerationDescriptorList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEnumeratedType.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEnumerationName.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@enumerationDescriptorList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_enumerationDescriptorList ("enumerationDescriptorList", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_enumerationDescriptorList::
internalAppendValues (const GGS_unifiedTypeMapProxy & argument_0,
                    const GGS_string& argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_enumerationDescriptorList::
internalPrependValues (const GGS_unifiedTypeMapProxy & argument_0,
                    const GGS_string& argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_enumerationDescriptorList::
addAssign_operation (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_string& argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_enumerationDescriptorList GGS_enumerationDescriptorList::
operator_concat (const GGS_enumerationDescriptorList & inOperand) const {
  GGS_enumerationDescriptorList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumerationDescriptorList::
dotAssign_operation (const GGS_enumerationDescriptorList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_enumerationDescriptorList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_unifiedTypeMapProxy  p_0 = p->mEnumeratedType ;
          GGS_string p_1 = p->mEnumerationName ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumerationDescriptorList::
modifier_prependValue (C_CompilerEx & /* inLexique */,
                     const GGS_unifiedTypeMapProxy & argument_0,
                     const GGS_string& argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumerationDescriptorList::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mEnumeratedType,
                                ptr->mEnumerationName
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_enumerationDescriptorList  GGS_enumerationDescriptorList::
constructor_emptyList (void) {
  GGS_enumerationDescriptorList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumerationDescriptorList  GGS_enumerationDescriptorList::
constructor_listWithValue (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_string& argument_1) {
  GGS_enumerationDescriptorList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumerationDescriptorList::
internalSubListWithRange (GGS_enumerationDescriptorList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mEnumeratedType, ptr->mEnumerationName) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_enumerationDescriptorList GGS_enumerationDescriptorList::
reader_subListWithRange (C_CompilerEx & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_enumerationDescriptorList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumerationDescriptorList GGS_enumerationDescriptorList::
reader_subListFromIndex (C_CompilerEx & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_enumerationDescriptorList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_enumerationDescriptorList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@enumerationDescriptorList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_enumerationDescriptorList::
method_first (C_CompilerEx & inLexique,
              GGS_unifiedTypeMapProxy & _out_0,
              GGS_string& _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mEnumeratedType ;
    _out_1 = ptr->mEnumerationName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumerationDescriptorList::
method_last (C_CompilerEx & inLexique,
             GGS_unifiedTypeMapProxy & _out_0,
             GGS_string& _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mEnumeratedType ;
    _out_1 = ptr->mEnumerationName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumerationDescriptorList::
modifier_popFirst (C_CompilerEx & inLexique,
                 GGS_unifiedTypeMapProxy & _out_0,
                 GGS_string& _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mEnumeratedType ;
    _out_1 = ptr->mEnumerationName ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumerationDescriptorList::
modifier_popLast (C_CompilerEx & inLexique,
                GGS_unifiedTypeMapProxy & _out_0,
                GGS_string& _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mEnumeratedType ;
    _out_1 = ptr->mEnumerationName ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapProxy  GGS_enumerationDescriptorList::
reader_mEnumeratedTypeAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_unifiedTypeMapProxy  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mEnumeratedType ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_enumerationDescriptorList::
reader_mEnumerationNameAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_string result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mEnumerationName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumerationDescriptorList::
modifier_setMEnumeratedTypeAtIndex (C_CompilerEx & inLexique,
                              const GGS_unifiedTypeMapProxy  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mEnumeratedType = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumerationDescriptorList::
modifier_setMEnumerationNameAtIndex (C_CompilerEx & inLexique,
                              const GGS_string & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mEnumerationName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_unifiedTypeMapProxy  & GGS_enumerationDescriptorList::cEnumerator::_mEnumeratedType (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mEnumeratedType ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_enumerationDescriptorList::cEnumerator::_mEnumerationName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mEnumerationName ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_enumerationDescriptorList::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_enumerationDescriptorList * p = NULL ;
    macroMyNew (p, GGS_enumerationDescriptorList (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumerationDescriptorList GGS_enumerationDescriptorList::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_enumerationDescriptorList result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_enumerationDescriptorList * p = dynamic_cast <const GGS_enumerationDescriptorList *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_enumerationDescriptorList, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_enumerationDescriptorList::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_enumerationDescriptorList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@typedAttributeList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typedAttributeList::
elementOf_GGS_typedAttributeList (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_bool& argument_2,
                                const GGS_bool& argument_3
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mAttributeTypeProxy (argument_0),
mAttributeName (argument_1),
mHasSetter (argument_2),
mHasGetter (argument_3) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typedAttributeList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_typedAttributeList * ptr = dynamic_cast <const elementOf_GGS_typedAttributeList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mAttributeTypeProxy.operator_isEqual (ptr->mAttributeTypeProxy).boolValue ()
         && mAttributeName.operator_isEqual (ptr->mAttributeName).boolValue ()
         && mHasSetter.operator_isEqual (ptr->mHasSetter).boolValue ()
         && mHasGetter.operator_isEqual (ptr->mHasGetter).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typedAttributeList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAttributeTypeProxy.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAttributeName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mHasSetter.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mHasGetter.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        List '@typedAttributeList'                         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typedAttributeList ("typedAttributeList", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_typedAttributeList::
internalAppendValues (const GGS_unifiedTypeMapProxy & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_bool& argument_2,
                    const GGS_bool& argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typedAttributeList::
internalPrependValues (const GGS_unifiedTypeMapProxy & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_bool& argument_2,
                    const GGS_bool& argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typedAttributeList::
addAssign_operation (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_bool& argument_2,
                                const GGS_bool& argument_3) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()&& argument_3.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typedAttributeList GGS_typedAttributeList::
operator_concat (const GGS_typedAttributeList & inOperand) const {
  GGS_typedAttributeList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typedAttributeList::
dotAssign_operation (const GGS_typedAttributeList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_typedAttributeList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_unifiedTypeMapProxy  p_0 = p->mAttributeTypeProxy ;
          GGS_lstring  p_1 = p->mAttributeName ;
          GGS_bool p_2 = p->mHasSetter ;
          GGS_bool p_3 = p->mHasGetter ;
          internalAppendValues (p_0, p_1, p_2, p_3 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typedAttributeList::
modifier_prependValue (C_CompilerEx & /* inLexique */,
                     const GGS_unifiedTypeMapProxy & argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_bool& argument_2,
                     const GGS_bool& argument_3
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typedAttributeList::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mAttributeTypeProxy,
                                ptr->mAttributeName,
                                ptr->mHasSetter,
                                ptr->mHasGetter
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typedAttributeList  GGS_typedAttributeList::
constructor_emptyList (void) {
  GGS_typedAttributeList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typedAttributeList  GGS_typedAttributeList::
constructor_listWithValue (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_bool& argument_2,
                                const GGS_bool& argument_3) {
  GGS_typedAttributeList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2, argument_3) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typedAttributeList::
internalSubListWithRange (GGS_typedAttributeList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mAttributeTypeProxy, ptr->mAttributeName, ptr->mHasSetter, ptr->mHasGetter) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typedAttributeList GGS_typedAttributeList::
reader_subListWithRange (C_CompilerEx & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_typedAttributeList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typedAttributeList GGS_typedAttributeList::
reader_subListFromIndex (C_CompilerEx & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_typedAttributeList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typedAttributeList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@typedAttributeList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_typedAttributeList::
method_first (C_CompilerEx & inLexique,
              GGS_unifiedTypeMapProxy & _out_0,
              GGS_lstring & _out_1,
              GGS_bool& _out_2,
              GGS_bool& _out_3
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAttributeTypeProxy ;
    _out_1 = ptr->mAttributeName ;
    _out_2 = ptr->mHasSetter ;
    _out_3 = ptr->mHasGetter ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typedAttributeList::
method_last (C_CompilerEx & inLexique,
             GGS_unifiedTypeMapProxy & _out_0,
             GGS_lstring & _out_1,
             GGS_bool& _out_2,
             GGS_bool& _out_3
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAttributeTypeProxy ;
    _out_1 = ptr->mAttributeName ;
    _out_2 = ptr->mHasSetter ;
    _out_3 = ptr->mHasGetter ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typedAttributeList::
modifier_popFirst (C_CompilerEx & inLexique,
                 GGS_unifiedTypeMapProxy & _out_0,
                 GGS_lstring & _out_1,
                 GGS_bool& _out_2,
                 GGS_bool& _out_3
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAttributeTypeProxy ;
    _out_1 = ptr->mAttributeName ;
    _out_2 = ptr->mHasSetter ;
    _out_3 = ptr->mHasGetter ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typedAttributeList::
modifier_popLast (C_CompilerEx & inLexique,
                GGS_unifiedTypeMapProxy & _out_0,
                GGS_lstring & _out_1,
                GGS_bool& _out_2,
                GGS_bool& _out_3
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAttributeTypeProxy ;
    _out_1 = ptr->mAttributeName ;
    _out_2 = ptr->mHasSetter ;
    _out_3 = ptr->mHasGetter ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapProxy  GGS_typedAttributeList::
reader_mAttributeTypeProxyAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_unifiedTypeMapProxy  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mAttributeTypeProxy ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typedAttributeList::
reader_mAttributeNameAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mAttributeName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typedAttributeList::
reader_mHasSetterAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mHasSetter ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typedAttributeList::
reader_mHasGetterAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mHasGetter ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typedAttributeList::
modifier_setMAttributeTypeProxyAtIndex (C_CompilerEx & inLexique,
                              const GGS_unifiedTypeMapProxy  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mAttributeTypeProxy = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typedAttributeList::
modifier_setMAttributeNameAtIndex (C_CompilerEx & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mAttributeName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typedAttributeList::
modifier_setMHasSetterAtIndex (C_CompilerEx & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mHasSetter = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typedAttributeList::
modifier_setMHasGetterAtIndex (C_CompilerEx & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mHasGetter = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_unifiedTypeMapProxy  & GGS_typedAttributeList::cEnumerator::_mAttributeTypeProxy (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mAttributeTypeProxy ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_typedAttributeList::cEnumerator::_mAttributeName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mAttributeName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_typedAttributeList::cEnumerator::_mHasSetter (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mHasSetter ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_typedAttributeList::cEnumerator::_mHasGetter (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mHasGetter ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_typedAttributeList::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typedAttributeList * p = NULL ;
    macroMyNew (p, GGS_typedAttributeList (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typedAttributeList GGS_typedAttributeList::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typedAttributeList result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typedAttributeList * p = dynamic_cast <const GGS_typedAttributeList *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typedAttributeList, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typedAttributeList::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typedAttributeList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Class for 'predefinedTypeKindEnum' Enumeration               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_predefinedTypeKindEnum ("predefinedTypeKindEnum", false, NULL) ;

//---------------------------------------------------------------------------*

bool GGS_predefinedTypeKindEnum::
isBuilt (void) const {
  return mValue > kNotBuilt ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_predefinedTypeKindEnum::
operator_isEqual (const GGS_predefinedTypeKindEnum inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_predefinedTypeKindEnum::
operator_isNotEqual (const GGS_predefinedTypeKindEnum inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_predefinedTypeKindEnum::
operator_infOrEqual (const GGS_predefinedTypeKindEnum inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_predefinedTypeKindEnum::
operator_supOrEqual (const GGS_predefinedTypeKindEnum inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_predefinedTypeKindEnum::
operator_strictInf (const GGS_predefinedTypeKindEnum inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_predefinedTypeKindEnum::
operator_strictSup (const GGS_predefinedTypeKindEnum inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_predefinedTypeKindEnum::
reader_description (const PMSInt32 /* inIndentation */) const {
  C_String s ;
  s << "<enum @predefinedTypeKindEnum" ;
  switch (mValue) {
  case enum_predefined_application:
    s << " predefined_application>" ;
    break ;
  case enum_predefined_binaryset:
    s << " predefined_binaryset>" ;
    break ;
  case enum_predefined_bool:
    s << " predefined_bool>" ;
    break ;
  case enum_predefined_char:
    s << " predefined_char>" ;
    break ;
  case enum_predefined_data:
    s << " predefined_data>" ;
    break ;
  case enum_predefined_double:
    s << " predefined_double>" ;
    break ;
  case enum_predefined_filewrapper:
    s << " predefined_filewrapper>" ;
    break ;
  case enum_predefined_function:
    s << " predefined_function>" ;
    break ;
  case enum_predefined_location:
    s << " predefined_location>" ;
    break ;
  case enum_predefined_object:
    s << " predefined_object>" ;
    break ;
  case enum_predefined_sint:
    s << " predefined_sint>" ;
    break ;
  case enum_predefined_sint64:
    s << " predefined_sint64>" ;
    break ;
  case enum_predefined_string:
    s << " predefined_string>" ;
    break ;
  case enum_predefined_stringset:
    s << " predefined_stringset>" ;
    break ;
  case enum_predefined_type:
    s << " predefined_type>" ;
    break ;
  case enum_predefined_uint:
    s << " predefined_uint>" ;
    break ;
  case enum_predefined_uint64:
    s << " predefined_uint64>" ;
    break ;
  case kNotBuilt:
    s << " (not built)>" ;
    break ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_predefinedTypeKindEnum::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_predefinedTypeKindEnum * p = NULL ;
    macroMyNew (p, GGS_predefinedTypeKindEnum (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_predefinedTypeKindEnum GGS_predefinedTypeKindEnum::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_predefinedTypeKindEnum result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_predefinedTypeKindEnum * p = dynamic_cast <const GGS_predefinedTypeKindEnum *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_predefinedTypeKindEnum, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_predefinedTypeKindEnum::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_predefinedTypeKindEnum ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   Class for 'typeKindEnum' Enumeration                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeKindEnum ("typeKindEnum", false, NULL) ;

//---------------------------------------------------------------------------*

bool GGS_typeKindEnum::
isBuilt (void) const {
  return mValue > kNotBuilt ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeKindEnum::
operator_isEqual (const GGS_typeKindEnum inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeKindEnum::
operator_isNotEqual (const GGS_typeKindEnum inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeKindEnum::
operator_infOrEqual (const GGS_typeKindEnum inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeKindEnum::
operator_supOrEqual (const GGS_typeKindEnum inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeKindEnum::
operator_strictInf (const GGS_typeKindEnum inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeKindEnum::
operator_strictSup (const GGS_typeKindEnum inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeKindEnum::
reader_kind (C_CompilerEx & /* inLexique */
                       COMMA_UNUSED_LOCATION_ARGS) const {
  const char * kMessages [11] = {"",
    "class",
    "enumeration",
    "list map",
    "list",
    "map proxy",
    "map",
    "predefined",
    "sorted list",
    "struct",
    "unique map"
  } ;
  return GGS_string (mValue > 0, kMessages [mValue]) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeKindEnum::
reader_description (const PMSInt32 /* inIndentation */) const {
  C_String s ;
  s << "<enum @typeKindEnum" ;
  switch (mValue) {
  case enum_classType:
    s << " classType>" ;
    break ;
  case enum_enumType:
    s << " enumType>" ;
    break ;
  case enum_listMapType:
    s << " listMapType>" ;
    break ;
  case enum_listType:
    s << " listType>" ;
    break ;
  case enum_mapProxyType:
    s << " mapProxyType>" ;
    break ;
  case enum_mapType:
    s << " mapType>" ;
    break ;
  case enum_predefinedType:
    s << " predefinedType>" ;
    break ;
  case enum_sortedListType:
    s << " sortedListType>" ;
    break ;
  case enum_structType:
    s << " structType>" ;
    break ;
  case enum_uniqueMapType:
    s << " uniqueMapType>" ;
    break ;
  case kNotBuilt:
    s << " (not built)>" ;
    break ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_typeKindEnum::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeKindEnum * p = NULL ;
    macroMyNew (p, GGS_typeKindEnum (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeKindEnum GGS_typeKindEnum::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeKindEnum result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeKindEnum * p = dynamic_cast <const GGS_typeKindEnum *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeKindEnum, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeKindEnum::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeKindEnum ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Implementation of once function "binaryAddOperator"             *
//                                                                           *
//---------------------------------------------------------------------------*

static GGS_uint  gCachedResultForOnceFunction_binaryAddOperator ;
static bool gCacheFlagForOnceFunction_binaryAddOperator = false ;

//---------------------------------------------------------------------------*

GGS_uint  function_binaryAddOperator (C_CompilerEx & COMMA_UNUSED_LOCATION_ARGS) {
  if (! gCacheFlagForOnceFunction_binaryAddOperator) {
    #ifdef DEBUG_TRACE_ENABLED
      printf ("ENTER function_binaryAddOperator at %s:%d\n", __FILE__, __LINE__) ;
    #endif
  GGS_uint  var_cas_outMask ;
    var_cas_outMask = GGS_uint (1U) ;
    #ifdef DEBUG_TRACE_ENABLED
      printf ("LEAVE function_binaryAddOperator\n") ;
    #endif
    gCacheFlagForOnceFunction_binaryAddOperator = true ;
    gCachedResultForOnceFunction_binaryAddOperator = var_cas_outMask ;
  }
  return gCachedResultForOnceFunction_binaryAddOperator ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_binaryAddOperator (C_CompilerEx & inLexique,
                           const GGS_objectlist & /* inEffectiveParameterArray */,
                           const GGS_location & /* inErrorLocation */
                           COMMA_LOCATION_ARGS) {
  const GGS_uint  result = function_binaryAddOperator (inLexique
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

const C_galgas_function_descriptorEX kFunction_descriptor_binaryAddOperator ("binaryAddOperator",
                              functionForGenericCall_binaryAddOperator,
                              & kTypeDescriptor_GGS_uint ,
                              0,
                              NULL) ;

//---------------------------------------------------------------------------*
//                                                                           *
//           Implementation of once function "binarySubOperator"             *
//                                                                           *
//---------------------------------------------------------------------------*

static GGS_uint  gCachedResultForOnceFunction_binarySubOperator ;
static bool gCacheFlagForOnceFunction_binarySubOperator = false ;

//---------------------------------------------------------------------------*

GGS_uint  function_binarySubOperator (C_CompilerEx & inLexique COMMA_UNUSED_LOCATION_ARGS) {
  if (! gCacheFlagForOnceFunction_binarySubOperator) {
    #ifdef DEBUG_TRACE_ENABLED
      printf ("ENTER function_binarySubOperator at %s:%d\n", __FILE__, __LINE__) ;
    #endif
  GGS_uint  var_cas_outMask ;
    var_cas_outMask = GGS_uint (1U).left_shift_operation (inLexique, GGS_uint (1U) COMMA_SOURCE_FILE_AT_LINE (236)) ;
    #ifdef DEBUG_TRACE_ENABLED
      printf ("LEAVE function_binarySubOperator\n") ;
    #endif
    gCacheFlagForOnceFunction_binarySubOperator = true ;
    gCachedResultForOnceFunction_binarySubOperator = var_cas_outMask ;
  }
  return gCachedResultForOnceFunction_binarySubOperator ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_binarySubOperator (C_CompilerEx & inLexique,
                           const GGS_objectlist & /* inEffectiveParameterArray */,
                           const GGS_location & /* inErrorLocation */
                           COMMA_LOCATION_ARGS) {
  const GGS_uint  result = function_binarySubOperator (inLexique
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

const C_galgas_function_descriptorEX kFunction_descriptor_binarySubOperator ("binarySubOperator",
                              functionForGenericCall_binarySubOperator,
                              & kTypeDescriptor_GGS_uint ,
                              0,
                              NULL) ;

//---------------------------------------------------------------------------*
//                                                                           *
//           Implementation of once function "binaryMulOperator"             *
//                                                                           *
//---------------------------------------------------------------------------*

static GGS_uint  gCachedResultForOnceFunction_binaryMulOperator ;
static bool gCacheFlagForOnceFunction_binaryMulOperator = false ;

//---------------------------------------------------------------------------*

GGS_uint  function_binaryMulOperator (C_CompilerEx & inLexique COMMA_UNUSED_LOCATION_ARGS) {
  if (! gCacheFlagForOnceFunction_binaryMulOperator) {
    #ifdef DEBUG_TRACE_ENABLED
      printf ("ENTER function_binaryMulOperator at %s:%d\n", __FILE__, __LINE__) ;
    #endif
  GGS_uint  var_cas_outMask ;
    var_cas_outMask = GGS_uint (1U).left_shift_operation (inLexique, GGS_uint (2U) COMMA_SOURCE_FILE_AT_LINE (237)) ;
    #ifdef DEBUG_TRACE_ENABLED
      printf ("LEAVE function_binaryMulOperator\n") ;
    #endif
    gCacheFlagForOnceFunction_binaryMulOperator = true ;
    gCachedResultForOnceFunction_binaryMulOperator = var_cas_outMask ;
  }
  return gCachedResultForOnceFunction_binaryMulOperator ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_binaryMulOperator (C_CompilerEx & inLexique,
                           const GGS_objectlist & /* inEffectiveParameterArray */,
                           const GGS_location & /* inErrorLocation */
                           COMMA_LOCATION_ARGS) {
  const GGS_uint  result = function_binaryMulOperator (inLexique
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

const C_galgas_function_descriptorEX kFunction_descriptor_binaryMulOperator ("binaryMulOperator",
                              functionForGenericCall_binaryMulOperator,
                              & kTypeDescriptor_GGS_uint ,
                              0,
                              NULL) ;

//---------------------------------------------------------------------------*
//                                                                           *
//           Implementation of once function "binaryDivOperator"             *
//                                                                           *
//---------------------------------------------------------------------------*

static GGS_uint  gCachedResultForOnceFunction_binaryDivOperator ;
static bool gCacheFlagForOnceFunction_binaryDivOperator = false ;

//---------------------------------------------------------------------------*

GGS_uint  function_binaryDivOperator (C_CompilerEx & inLexique COMMA_UNUSED_LOCATION_ARGS) {
  if (! gCacheFlagForOnceFunction_binaryDivOperator) {
    #ifdef DEBUG_TRACE_ENABLED
      printf ("ENTER function_binaryDivOperator at %s:%d\n", __FILE__, __LINE__) ;
    #endif
  GGS_uint  var_cas_outMask ;
    var_cas_outMask = GGS_uint (1U).left_shift_operation (inLexique, GGS_uint (3U) COMMA_SOURCE_FILE_AT_LINE (238)) ;
    #ifdef DEBUG_TRACE_ENABLED
      printf ("LEAVE function_binaryDivOperator\n") ;
    #endif
    gCacheFlagForOnceFunction_binaryDivOperator = true ;
    gCachedResultForOnceFunction_binaryDivOperator = var_cas_outMask ;
  }
  return gCachedResultForOnceFunction_binaryDivOperator ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_binaryDivOperator (C_CompilerEx & inLexique,
                           const GGS_objectlist & /* inEffectiveParameterArray */,
                           const GGS_location & /* inErrorLocation */
                           COMMA_LOCATION_ARGS) {
  const GGS_uint  result = function_binaryDivOperator (inLexique
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

const C_galgas_function_descriptorEX kFunction_descriptor_binaryDivOperator ("binaryDivOperator",
                              functionForGenericCall_binaryDivOperator,
                              & kTypeDescriptor_GGS_uint ,
                              0,
                              NULL) ;

//---------------------------------------------------------------------------*
//                                                                           *
//           Implementation of once function "binaryModOperator"             *
//                                                                           *
//---------------------------------------------------------------------------*

static GGS_uint  gCachedResultForOnceFunction_binaryModOperator ;
static bool gCacheFlagForOnceFunction_binaryModOperator = false ;

//---------------------------------------------------------------------------*

GGS_uint  function_binaryModOperator (C_CompilerEx & inLexique COMMA_UNUSED_LOCATION_ARGS) {
  if (! gCacheFlagForOnceFunction_binaryModOperator) {
    #ifdef DEBUG_TRACE_ENABLED
      printf ("ENTER function_binaryModOperator at %s:%d\n", __FILE__, __LINE__) ;
    #endif
  GGS_uint  var_cas_outMask ;
    var_cas_outMask = GGS_uint (1U).left_shift_operation (inLexique, GGS_uint (4U) COMMA_SOURCE_FILE_AT_LINE (239)) ;
    #ifdef DEBUG_TRACE_ENABLED
      printf ("LEAVE function_binaryModOperator\n") ;
    #endif
    gCacheFlagForOnceFunction_binaryModOperator = true ;
    gCachedResultForOnceFunction_binaryModOperator = var_cas_outMask ;
  }
  return gCachedResultForOnceFunction_binaryModOperator ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_binaryModOperator (C_CompilerEx & inLexique,
                           const GGS_objectlist & /* inEffectiveParameterArray */,
                           const GGS_location & /* inErrorLocation */
                           COMMA_LOCATION_ARGS) {
  const GGS_uint  result = function_binaryModOperator (inLexique
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

const C_galgas_function_descriptorEX kFunction_descriptor_binaryModOperator ("binaryModOperator",
                              functionForGenericCall_binaryModOperator,
                              & kTypeDescriptor_GGS_uint ,
                              0,
                              NULL) ;

//---------------------------------------------------------------------------*
//                                                                           *
//          Implementation of once function "binaryShiftOperator"            *
//                                                                           *
//---------------------------------------------------------------------------*

static GGS_uint  gCachedResultForOnceFunction_binaryShiftOperator ;
static bool gCacheFlagForOnceFunction_binaryShiftOperator = false ;

//---------------------------------------------------------------------------*

GGS_uint  function_binaryShiftOperator (C_CompilerEx & inLexique COMMA_UNUSED_LOCATION_ARGS) {
  if (! gCacheFlagForOnceFunction_binaryShiftOperator) {
    #ifdef DEBUG_TRACE_ENABLED
      printf ("ENTER function_binaryShiftOperator at %s:%d\n", __FILE__, __LINE__) ;
    #endif
  GGS_uint  var_cas_outMask ;
    var_cas_outMask = GGS_uint (1U).left_shift_operation (inLexique, GGS_uint (5U) COMMA_SOURCE_FILE_AT_LINE (240)) ;
    #ifdef DEBUG_TRACE_ENABLED
      printf ("LEAVE function_binaryShiftOperator\n") ;
    #endif
    gCacheFlagForOnceFunction_binaryShiftOperator = true ;
    gCachedResultForOnceFunction_binaryShiftOperator = var_cas_outMask ;
  }
  return gCachedResultForOnceFunction_binaryShiftOperator ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_binaryShiftOperator (C_CompilerEx & inLexique,
                           const GGS_objectlist & /* inEffectiveParameterArray */,
                           const GGS_location & /* inErrorLocation */
                           COMMA_LOCATION_ARGS) {
  const GGS_uint  result = function_binaryShiftOperator (inLexique
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

const C_galgas_function_descriptorEX kFunction_descriptor_binaryShiftOperator ("binaryShiftOperator",
                              functionForGenericCall_binaryShiftOperator,
                              & kTypeDescriptor_GGS_uint ,
                              0,
                              NULL) ;

//---------------------------------------------------------------------------*
//                                                                           *
//           Implementation of once function "unaryPlusOperator"             *
//                                                                           *
//---------------------------------------------------------------------------*

static GGS_uint  gCachedResultForOnceFunction_unaryPlusOperator ;
static bool gCacheFlagForOnceFunction_unaryPlusOperator = false ;

//---------------------------------------------------------------------------*

GGS_uint  function_unaryPlusOperator (C_CompilerEx & inLexique COMMA_UNUSED_LOCATION_ARGS) {
  if (! gCacheFlagForOnceFunction_unaryPlusOperator) {
    #ifdef DEBUG_TRACE_ENABLED
      printf ("ENTER function_unaryPlusOperator at %s:%d\n", __FILE__, __LINE__) ;
    #endif
  GGS_uint  var_cas_outMask ;
    var_cas_outMask = GGS_uint (1U).left_shift_operation (inLexique, GGS_uint (6U) COMMA_SOURCE_FILE_AT_LINE (241)) ;
    #ifdef DEBUG_TRACE_ENABLED
      printf ("LEAVE function_unaryPlusOperator\n") ;
    #endif
    gCacheFlagForOnceFunction_unaryPlusOperator = true ;
    gCachedResultForOnceFunction_unaryPlusOperator = var_cas_outMask ;
  }
  return gCachedResultForOnceFunction_unaryPlusOperator ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_unaryPlusOperator (C_CompilerEx & inLexique,
                           const GGS_objectlist & /* inEffectiveParameterArray */,
                           const GGS_location & /* inErrorLocation */
                           COMMA_LOCATION_ARGS) {
  const GGS_uint  result = function_unaryPlusOperator (inLexique
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

const C_galgas_function_descriptorEX kFunction_descriptor_unaryPlusOperator ("unaryPlusOperator",
                              functionForGenericCall_unaryPlusOperator,
                              & kTypeDescriptor_GGS_uint ,
                              0,
                              NULL) ;

//---------------------------------------------------------------------------*
//                                                                           *
//           Implementation of once function "unaryMinusOperator"            *
//                                                                           *
//---------------------------------------------------------------------------*

static GGS_uint  gCachedResultForOnceFunction_unaryMinusOperator ;
static bool gCacheFlagForOnceFunction_unaryMinusOperator = false ;

//---------------------------------------------------------------------------*

GGS_uint  function_unaryMinusOperator (C_CompilerEx & inLexique COMMA_UNUSED_LOCATION_ARGS) {
  if (! gCacheFlagForOnceFunction_unaryMinusOperator) {
    #ifdef DEBUG_TRACE_ENABLED
      printf ("ENTER function_unaryMinusOperator at %s:%d\n", __FILE__, __LINE__) ;
    #endif
  GGS_uint  var_cas_outMask ;
    var_cas_outMask = GGS_uint (1U).left_shift_operation (inLexique, GGS_uint (7U) COMMA_SOURCE_FILE_AT_LINE (242)) ;
    #ifdef DEBUG_TRACE_ENABLED
      printf ("LEAVE function_unaryMinusOperator\n") ;
    #endif
    gCacheFlagForOnceFunction_unaryMinusOperator = true ;
    gCachedResultForOnceFunction_unaryMinusOperator = var_cas_outMask ;
  }
  return gCachedResultForOnceFunction_unaryMinusOperator ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_unaryMinusOperator (C_CompilerEx & inLexique,
                           const GGS_objectlist & /* inEffectiveParameterArray */,
                           const GGS_location & /* inErrorLocation */
                           COMMA_LOCATION_ARGS) {
  const GGS_uint  result = function_unaryMinusOperator (inLexique
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

const C_galgas_function_descriptorEX kFunction_descriptor_unaryMinusOperator ("unaryMinusOperator",
                              functionForGenericCall_unaryMinusOperator,
                              & kTypeDescriptor_GGS_uint ,
                              0,
                              NULL) ;

//---------------------------------------------------------------------------*
//                                                                           *
//           Implementation of once function "unaryTildeOperator"            *
//                                                                           *
//---------------------------------------------------------------------------*

static GGS_uint  gCachedResultForOnceFunction_unaryTildeOperator ;
static bool gCacheFlagForOnceFunction_unaryTildeOperator = false ;

//---------------------------------------------------------------------------*

GGS_uint  function_unaryTildeOperator (C_CompilerEx & inLexique COMMA_UNUSED_LOCATION_ARGS) {
  if (! gCacheFlagForOnceFunction_unaryTildeOperator) {
    #ifdef DEBUG_TRACE_ENABLED
      printf ("ENTER function_unaryTildeOperator at %s:%d\n", __FILE__, __LINE__) ;
    #endif
  GGS_uint  var_cas_outMask ;
    var_cas_outMask = GGS_uint (1U).left_shift_operation (inLexique, GGS_uint (8U) COMMA_SOURCE_FILE_AT_LINE (243)) ;
    #ifdef DEBUG_TRACE_ENABLED
      printf ("LEAVE function_unaryTildeOperator\n") ;
    #endif
    gCacheFlagForOnceFunction_unaryTildeOperator = true ;
    gCachedResultForOnceFunction_unaryTildeOperator = var_cas_outMask ;
  }
  return gCachedResultForOnceFunction_unaryTildeOperator ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_unaryTildeOperator (C_CompilerEx & inLexique,
                           const GGS_objectlist & /* inEffectiveParameterArray */,
                           const GGS_location & /* inErrorLocation */
                           COMMA_LOCATION_ARGS) {
  const GGS_uint  result = function_unaryTildeOperator (inLexique
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

const C_galgas_function_descriptorEX kFunction_descriptor_unaryTildeOperator ("unaryTildeOperator",
                              functionForGenericCall_unaryTildeOperator,
                              & kTypeDescriptor_GGS_uint ,
                              0,
                              NULL) ;

//---------------------------------------------------------------------------*
//                                                                           *
//             Implementation of once function "incDecOperator"              *
//                                                                           *
//---------------------------------------------------------------------------*

static GGS_uint  gCachedResultForOnceFunction_incDecOperator ;
static bool gCacheFlagForOnceFunction_incDecOperator = false ;

//---------------------------------------------------------------------------*

GGS_uint  function_incDecOperator (C_CompilerEx & inLexique COMMA_UNUSED_LOCATION_ARGS) {
  if (! gCacheFlagForOnceFunction_incDecOperator) {
    #ifdef DEBUG_TRACE_ENABLED
      printf ("ENTER function_incDecOperator at %s:%d\n", __FILE__, __LINE__) ;
    #endif
  GGS_uint  var_cas_outMask ;
    var_cas_outMask = GGS_uint (1U).left_shift_operation (inLexique, GGS_uint (9U) COMMA_SOURCE_FILE_AT_LINE (244)) ;
    #ifdef DEBUG_TRACE_ENABLED
      printf ("LEAVE function_incDecOperator\n") ;
    #endif
    gCacheFlagForOnceFunction_incDecOperator = true ;
    gCachedResultForOnceFunction_incDecOperator = var_cas_outMask ;
  }
  return gCachedResultForOnceFunction_incDecOperator ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_incDecOperator (C_CompilerEx & inLexique,
                           const GGS_objectlist & /* inEffectiveParameterArray */,
                           const GGS_location & /* inErrorLocation */
                           COMMA_LOCATION_ARGS) {
  const GGS_uint  result = function_incDecOperator (inLexique
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

const C_galgas_function_descriptorEX kFunction_descriptor_incDecOperator ("incDecOperator",
                              functionForGenericCall_incDecOperator,
                              & kTypeDescriptor_GGS_uint ,
                              0,
                              NULL) ;

//---------------------------------------------------------------------------*
//                                                                           *
//           Implementation of once function "binaryAndOperator"             *
//                                                                           *
//---------------------------------------------------------------------------*

static GGS_uint  gCachedResultForOnceFunction_binaryAndOperator ;
static bool gCacheFlagForOnceFunction_binaryAndOperator = false ;

//---------------------------------------------------------------------------*

GGS_uint  function_binaryAndOperator (C_CompilerEx & inLexique COMMA_UNUSED_LOCATION_ARGS) {
  if (! gCacheFlagForOnceFunction_binaryAndOperator) {
    #ifdef DEBUG_TRACE_ENABLED
      printf ("ENTER function_binaryAndOperator at %s:%d\n", __FILE__, __LINE__) ;
    #endif
  GGS_uint  var_cas_outMask ;
    var_cas_outMask = GGS_uint (1U).left_shift_operation (inLexique, GGS_uint (10U) COMMA_SOURCE_FILE_AT_LINE (246)) ;
    #ifdef DEBUG_TRACE_ENABLED
      printf ("LEAVE function_binaryAndOperator\n") ;
    #endif
    gCacheFlagForOnceFunction_binaryAndOperator = true ;
    gCachedResultForOnceFunction_binaryAndOperator = var_cas_outMask ;
  }
  return gCachedResultForOnceFunction_binaryAndOperator ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_binaryAndOperator (C_CompilerEx & inLexique,
                           const GGS_objectlist & /* inEffectiveParameterArray */,
                           const GGS_location & /* inErrorLocation */
                           COMMA_LOCATION_ARGS) {
  const GGS_uint  result = function_binaryAndOperator (inLexique
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

const C_galgas_function_descriptorEX kFunction_descriptor_binaryAndOperator ("binaryAndOperator",
                              functionForGenericCall_binaryAndOperator,
                              & kTypeDescriptor_GGS_uint ,
                              0,
                              NULL) ;

//---------------------------------------------------------------------------*
//                                                                           *
//            Implementation of once function "binaryOrOperator"             *
//                                                                           *
//---------------------------------------------------------------------------*

static GGS_uint  gCachedResultForOnceFunction_binaryOrOperator ;
static bool gCacheFlagForOnceFunction_binaryOrOperator = false ;

//---------------------------------------------------------------------------*

GGS_uint  function_binaryOrOperator (C_CompilerEx & inLexique COMMA_UNUSED_LOCATION_ARGS) {
  if (! gCacheFlagForOnceFunction_binaryOrOperator) {
    #ifdef DEBUG_TRACE_ENABLED
      printf ("ENTER function_binaryOrOperator at %s:%d\n", __FILE__, __LINE__) ;
    #endif
  GGS_uint  var_cas_outMask ;
    var_cas_outMask = GGS_uint (1U).left_shift_operation (inLexique, GGS_uint (11U) COMMA_SOURCE_FILE_AT_LINE (247)) ;
    #ifdef DEBUG_TRACE_ENABLED
      printf ("LEAVE function_binaryOrOperator\n") ;
    #endif
    gCacheFlagForOnceFunction_binaryOrOperator = true ;
    gCachedResultForOnceFunction_binaryOrOperator = var_cas_outMask ;
  }
  return gCachedResultForOnceFunction_binaryOrOperator ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_binaryOrOperator (C_CompilerEx & inLexique,
                           const GGS_objectlist & /* inEffectiveParameterArray */,
                           const GGS_location & /* inErrorLocation */
                           COMMA_LOCATION_ARGS) {
  const GGS_uint  result = function_binaryOrOperator (inLexique
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

const C_galgas_function_descriptorEX kFunction_descriptor_binaryOrOperator ("binaryOrOperator",
                              functionForGenericCall_binaryOrOperator,
                              & kTypeDescriptor_GGS_uint ,
                              0,
                              NULL) ;

//---------------------------------------------------------------------------*
//                                                                           *
//           Implementation of once function "binaryXorOperator"             *
//                                                                           *
//---------------------------------------------------------------------------*

static GGS_uint  gCachedResultForOnceFunction_binaryXorOperator ;
static bool gCacheFlagForOnceFunction_binaryXorOperator = false ;

//---------------------------------------------------------------------------*

GGS_uint  function_binaryXorOperator (C_CompilerEx & inLexique COMMA_UNUSED_LOCATION_ARGS) {
  if (! gCacheFlagForOnceFunction_binaryXorOperator) {
    #ifdef DEBUG_TRACE_ENABLED
      printf ("ENTER function_binaryXorOperator at %s:%d\n", __FILE__, __LINE__) ;
    #endif
  GGS_uint  var_cas_outMask ;
    var_cas_outMask = GGS_uint (1U).left_shift_operation (inLexique, GGS_uint (12U) COMMA_SOURCE_FILE_AT_LINE (248)) ;
    #ifdef DEBUG_TRACE_ENABLED
      printf ("LEAVE function_binaryXorOperator\n") ;
    #endif
    gCacheFlagForOnceFunction_binaryXorOperator = true ;
    gCachedResultForOnceFunction_binaryXorOperator = var_cas_outMask ;
  }
  return gCachedResultForOnceFunction_binaryXorOperator ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_binaryXorOperator (C_CompilerEx & inLexique,
                           const GGS_objectlist & /* inEffectiveParameterArray */,
                           const GGS_location & /* inErrorLocation */
                           COMMA_LOCATION_ARGS) {
  const GGS_uint  result = function_binaryXorOperator (inLexique
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

const C_galgas_function_descriptorEX kFunction_descriptor_binaryXorOperator ("binaryXorOperator",
                              functionForGenericCall_binaryXorOperator,
                              & kTypeDescriptor_GGS_uint ,
                              0,
                              NULL) ;

//---------------------------------------------------------------------------*
//                                                                           *
//            Implementation of once function "unaryNotOperator"             *
//                                                                           *
//---------------------------------------------------------------------------*

static GGS_uint  gCachedResultForOnceFunction_unaryNotOperator ;
static bool gCacheFlagForOnceFunction_unaryNotOperator = false ;

//---------------------------------------------------------------------------*

GGS_uint  function_unaryNotOperator (C_CompilerEx & inLexique COMMA_UNUSED_LOCATION_ARGS) {
  if (! gCacheFlagForOnceFunction_unaryNotOperator) {
    #ifdef DEBUG_TRACE_ENABLED
      printf ("ENTER function_unaryNotOperator at %s:%d\n", __FILE__, __LINE__) ;
    #endif
  GGS_uint  var_cas_outMask ;
    var_cas_outMask = GGS_uint (1U).left_shift_operation (inLexique, GGS_uint (13U) COMMA_SOURCE_FILE_AT_LINE (249)) ;
    #ifdef DEBUG_TRACE_ENABLED
      printf ("LEAVE function_unaryNotOperator\n") ;
    #endif
    gCacheFlagForOnceFunction_unaryNotOperator = true ;
    gCachedResultForOnceFunction_unaryNotOperator = var_cas_outMask ;
  }
  return gCachedResultForOnceFunction_unaryNotOperator ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_unaryNotOperator (C_CompilerEx & inLexique,
                           const GGS_objectlist & /* inEffectiveParameterArray */,
                           const GGS_location & /* inErrorLocation */
                           COMMA_LOCATION_ARGS) {
  const GGS_uint  result = function_unaryNotOperator (inLexique
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

const C_galgas_function_descriptorEX kFunction_descriptor_unaryNotOperator ("unaryNotOperator",
                              functionForGenericCall_unaryNotOperator,
                              & kTypeDescriptor_GGS_uint ,
                              0,
                              NULL) ;

//---------------------------------------------------------------------------*
//                                                                           *
//          Implementation of once function "binaryConcatOperator"           *
//                                                                           *
//---------------------------------------------------------------------------*

static GGS_uint  gCachedResultForOnceFunction_binaryConcatOperator ;
static bool gCacheFlagForOnceFunction_binaryConcatOperator = false ;

//---------------------------------------------------------------------------*

GGS_uint  function_binaryConcatOperator (C_CompilerEx & inLexique COMMA_UNUSED_LOCATION_ARGS) {
  if (! gCacheFlagForOnceFunction_binaryConcatOperator) {
    #ifdef DEBUG_TRACE_ENABLED
      printf ("ENTER function_binaryConcatOperator at %s:%d\n", __FILE__, __LINE__) ;
    #endif
  GGS_uint  var_cas_outMask ;
    var_cas_outMask = GGS_uint (1U).left_shift_operation (inLexique, GGS_uint (14U) COMMA_SOURCE_FILE_AT_LINE (251)) ;
    #ifdef DEBUG_TRACE_ENABLED
      printf ("LEAVE function_binaryConcatOperator\n") ;
    #endif
    gCacheFlagForOnceFunction_binaryConcatOperator = true ;
    gCachedResultForOnceFunction_binaryConcatOperator = var_cas_outMask ;
  }
  return gCachedResultForOnceFunction_binaryConcatOperator ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_binaryConcatOperator (C_CompilerEx & inLexique,
                           const GGS_objectlist & /* inEffectiveParameterArray */,
                           const GGS_location & /* inErrorLocation */
                           COMMA_LOCATION_ARGS) {
  const GGS_uint  result = function_binaryConcatOperator (inLexique
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

const C_galgas_function_descriptorEX kFunction_descriptor_binaryConcatOperator ("binaryConcatOperator",
                              functionForGenericCall_binaryConcatOperator,
                              & kTypeDescriptor_GGS_uint ,
                              0,
                              NULL) ;

//---------------------------------------------------------------------------*
//                                                                           *
//           Implementation of once function "dotAssignOperator"             *
//                                                                           *
//---------------------------------------------------------------------------*

static GGS_uint  gCachedResultForOnceFunction_dotAssignOperator ;
static bool gCacheFlagForOnceFunction_dotAssignOperator = false ;

//---------------------------------------------------------------------------*

GGS_uint  function_dotAssignOperator (C_CompilerEx & inLexique COMMA_UNUSED_LOCATION_ARGS) {
  if (! gCacheFlagForOnceFunction_dotAssignOperator) {
    #ifdef DEBUG_TRACE_ENABLED
      printf ("ENTER function_dotAssignOperator at %s:%d\n", __FILE__, __LINE__) ;
    #endif
  GGS_uint  var_cas_outMask ;
    var_cas_outMask = GGS_uint (1U).left_shift_operation (inLexique, GGS_uint (15U) COMMA_SOURCE_FILE_AT_LINE (252)) ;
    #ifdef DEBUG_TRACE_ENABLED
      printf ("LEAVE function_dotAssignOperator\n") ;
    #endif
    gCacheFlagForOnceFunction_dotAssignOperator = true ;
    gCachedResultForOnceFunction_dotAssignOperator = var_cas_outMask ;
  }
  return gCachedResultForOnceFunction_dotAssignOperator ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_dotAssignOperator (C_CompilerEx & inLexique,
                           const GGS_objectlist & /* inEffectiveParameterArray */,
                           const GGS_location & /* inErrorLocation */
                           COMMA_LOCATION_ARGS) {
  const GGS_uint  result = function_dotAssignOperator (inLexique
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

const C_galgas_function_descriptorEX kFunction_descriptor_dotAssignOperator ("dotAssignOperator",
                              functionForGenericCall_dotAssignOperator,
                              & kTypeDescriptor_GGS_uint ,
                              0,
                              NULL) ;

//---------------------------------------------------------------------------*
//                                                                           *
//              Implementation of once function "isComparable"               *
//                                                                           *
//---------------------------------------------------------------------------*

static GGS_uint  gCachedResultForOnceFunction_isComparable ;
static bool gCacheFlagForOnceFunction_isComparable = false ;

//---------------------------------------------------------------------------*

GGS_uint  function_isComparable (C_CompilerEx & inLexique COMMA_UNUSED_LOCATION_ARGS) {
  if (! gCacheFlagForOnceFunction_isComparable) {
    #ifdef DEBUG_TRACE_ENABLED
      printf ("ENTER function_isComparable at %s:%d\n", __FILE__, __LINE__) ;
    #endif
  GGS_uint  var_cas_outMask ;
    var_cas_outMask = GGS_uint (1U).left_shift_operation (inLexique, GGS_uint (16U) COMMA_SOURCE_FILE_AT_LINE (253)) ;
    #ifdef DEBUG_TRACE_ENABLED
      printf ("LEAVE function_isComparable\n") ;
    #endif
    gCacheFlagForOnceFunction_isComparable = true ;
    gCachedResultForOnceFunction_isComparable = var_cas_outMask ;
  }
  return gCachedResultForOnceFunction_isComparable ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_isComparable (C_CompilerEx & inLexique,
                           const GGS_objectlist & /* inEffectiveParameterArray */,
                           const GGS_location & /* inErrorLocation */
                           COMMA_LOCATION_ARGS) {
  const GGS_uint  result = function_isComparable (inLexique
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

const C_galgas_function_descriptorEX kFunction_descriptor_isComparable ("isComparable",
                              functionForGenericCall_isComparable,
                              & kTypeDescriptor_GGS_uint ,
                              0,
                              NULL) ;

//---------------------------------------------------------------------------*
//                                                                           *
//    Implementation of once function "generateEnumerationHelperMethods"     *
//                                                                           *
//---------------------------------------------------------------------------*

static GGS_uint  gCachedResultForOnceFunction_generateEnumerationHelperMethods ;
static bool gCacheFlagForOnceFunction_generateEnumerationHelperMethods = false ;

//---------------------------------------------------------------------------*

GGS_uint  function_generateEnumerationHelperMethods (C_CompilerEx & inLexique COMMA_UNUSED_LOCATION_ARGS) {
  if (! gCacheFlagForOnceFunction_generateEnumerationHelperMethods) {
    #ifdef DEBUG_TRACE_ENABLED
      printf ("ENTER function_generateEnumerationHelperMethods at %s:%d\n", __FILE__, __LINE__) ;
    #endif
  GGS_uint  var_cas_outMask ;
    var_cas_outMask = GGS_uint (1U).left_shift_operation (inLexique, GGS_uint (28U) COMMA_SOURCE_FILE_AT_LINE (255)) ;
    #ifdef DEBUG_TRACE_ENABLED
      printf ("LEAVE function_generateEnumerationHelperMethods\n") ;
    #endif
    gCacheFlagForOnceFunction_generateEnumerationHelperMethods = true ;
    gCachedResultForOnceFunction_generateEnumerationHelperMethods = var_cas_outMask ;
  }
  return gCachedResultForOnceFunction_generateEnumerationHelperMethods ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_generateEnumerationHelperMethods (C_CompilerEx & inLexique,
                           const GGS_objectlist & /* inEffectiveParameterArray */,
                           const GGS_location & /* inErrorLocation */
                           COMMA_LOCATION_ARGS) {
  const GGS_uint  result = function_generateEnumerationHelperMethods (inLexique
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

const C_galgas_function_descriptorEX kFunction_descriptor_generateEnumerationHelperMethods ("generateEnumerationHelperMethods",
                              functionForGenericCall_generateEnumerationHelperMethods,
                              & kTypeDescriptor_GGS_uint ,
                              0,
                              NULL) ;

//---------------------------------------------------------------------------*
//                                                                           *
//      Implementation of once function "doNotGenererateObjectCompare"       *
//                                                                           *
//---------------------------------------------------------------------------*

static GGS_uint  gCachedResultForOnceFunction_doNotGenererateObjectCompare ;
static bool gCacheFlagForOnceFunction_doNotGenererateObjectCompare = false ;

//---------------------------------------------------------------------------*

GGS_uint  function_doNotGenererateObjectCompare (C_CompilerEx & inLexique COMMA_UNUSED_LOCATION_ARGS) {
  if (! gCacheFlagForOnceFunction_doNotGenererateObjectCompare) {
    #ifdef DEBUG_TRACE_ENABLED
      printf ("ENTER function_doNotGenererateObjectCompare at %s:%d\n", __FILE__, __LINE__) ;
    #endif
  GGS_uint  var_cas_outMask ;
    var_cas_outMask = GGS_uint (1U).left_shift_operation (inLexique, GGS_uint (29U) COMMA_SOURCE_FILE_AT_LINE (256)) ;
    #ifdef DEBUG_TRACE_ENABLED
      printf ("LEAVE function_doNotGenererateObjectCompare\n") ;
    #endif
    gCacheFlagForOnceFunction_doNotGenererateObjectCompare = true ;
    gCachedResultForOnceFunction_doNotGenererateObjectCompare = var_cas_outMask ;
  }
  return gCachedResultForOnceFunction_doNotGenererateObjectCompare ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_doNotGenererateObjectCompare (C_CompilerEx & inLexique,
                           const GGS_objectlist & /* inEffectiveParameterArray */,
                           const GGS_location & /* inErrorLocation */
                           COMMA_LOCATION_ARGS) {
  const GGS_uint  result = function_doNotGenererateObjectCompare (inLexique
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

const C_galgas_function_descriptorEX kFunction_descriptor_doNotGenererateObjectCompare ("doNotGenererateObjectCompare",
                              functionForGenericCall_doNotGenererateObjectCompare,
                              & kTypeDescriptor_GGS_uint ,
                              0,
                              NULL) ;

//---------------------------------------------------------------------------*
//                                                                           *
// Implementation of once function "generateDescriptionReaderUtilityMethod"  *
//                                                                           *
//---------------------------------------------------------------------------*

static GGS_uint  gCachedResultForOnceFunction_generateDescriptionReaderUtilityMethod ;
static bool gCacheFlagForOnceFunction_generateDescriptionReaderUtilityMethod = false ;

//---------------------------------------------------------------------------*

GGS_uint  function_generateDescriptionReaderUtilityMethod (C_CompilerEx & inLexique COMMA_UNUSED_LOCATION_ARGS) {
  if (! gCacheFlagForOnceFunction_generateDescriptionReaderUtilityMethod) {
    #ifdef DEBUG_TRACE_ENABLED
      printf ("ENTER function_generateDescriptionReaderUtilityMethod at %s:%d\n", __FILE__, __LINE__) ;
    #endif
  GGS_uint  var_cas_outMask ;
    var_cas_outMask = GGS_uint (1U).left_shift_operation (inLexique, GGS_uint (30U) COMMA_SOURCE_FILE_AT_LINE (257)) ;
    #ifdef DEBUG_TRACE_ENABLED
      printf ("LEAVE function_generateDescriptionReaderUtilityMethod\n") ;
    #endif
    gCacheFlagForOnceFunction_generateDescriptionReaderUtilityMethod = true ;
    gCachedResultForOnceFunction_generateDescriptionReaderUtilityMethod = var_cas_outMask ;
  }
  return gCachedResultForOnceFunction_generateDescriptionReaderUtilityMethod ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_generateDescriptionReaderUtilityMethod (C_CompilerEx & inLexique,
                           const GGS_objectlist & /* inEffectiveParameterArray */,
                           const GGS_location & /* inErrorLocation */
                           COMMA_LOCATION_ARGS) {
  const GGS_uint  result = function_generateDescriptionReaderUtilityMethod (inLexique
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

const C_galgas_function_descriptorEX kFunction_descriptor_generateDescriptionReaderUtilityMethod ("generateDescriptionReaderUtilityMethod",
                              functionForGenericCall_generateDescriptionReaderUtilityMethod,
                              & kTypeDescriptor_GGS_uint ,
                              0,
                              NULL) ;

//---------------------------------------------------------------------------*
//                                                                           *
//Implementation of once function "generateCopyConstructorAndAssignmentOperator"*
//                                                                           *
//---------------------------------------------------------------------------*

static GGS_uint  gCachedResultForOnceFunction_generateCopyConstructorAndAssignmentOperator ;
static bool gCacheFlagForOnceFunction_generateCopyConstructorAndAssignmentOperator = false ;

//---------------------------------------------------------------------------*

GGS_uint  function_generateCopyConstructorAndAssignmentOperator (C_CompilerEx & inLexique COMMA_UNUSED_LOCATION_ARGS) {
  if (! gCacheFlagForOnceFunction_generateCopyConstructorAndAssignmentOperator) {
    #ifdef DEBUG_TRACE_ENABLED
      printf ("ENTER function_generateCopyConstructorAndAssignmentOperator at %s:%d\n", __FILE__, __LINE__) ;
    #endif
  GGS_uint  var_cas_outMask ;
    var_cas_outMask = GGS_uint (1U).left_shift_operation (inLexique, GGS_uint (31U) COMMA_SOURCE_FILE_AT_LINE (258)) ;
    #ifdef DEBUG_TRACE_ENABLED
      printf ("LEAVE function_generateCopyConstructorAndAssignmentOperator\n") ;
    #endif
    gCacheFlagForOnceFunction_generateCopyConstructorAndAssignmentOperator = true ;
    gCachedResultForOnceFunction_generateCopyConstructorAndAssignmentOperator = var_cas_outMask ;
  }
  return gCachedResultForOnceFunction_generateCopyConstructorAndAssignmentOperator ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_generateCopyConstructorAndAssignmentOperator (C_CompilerEx & inLexique,
                           const GGS_objectlist & /* inEffectiveParameterArray */,
                           const GGS_location & /* inErrorLocation */
                           COMMA_LOCATION_ARGS) {
  const GGS_uint  result = function_generateCopyConstructorAndAssignmentOperator (inLexique
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

const C_galgas_function_descriptorEX kFunction_descriptor_generateCopyConstructorAndAssignmentOperator ("generateCopyConstructorAndAssignmentOperator",
                              functionForGenericCall_generateCopyConstructorAndAssignmentOperator,
                              & kTypeDescriptor_GGS_uint ,
                              0,
                              NULL) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'e_attributeMap'                           *
//                                                                           *
//---------------------------------------------------------------------------*

e_attributeMap::e_attributeMap (void) :
mAttributeType () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class map '@attributeMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_attributeMap ("attributeMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_attributeMap::
elementOf_GGS_attributeMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_attributeMap & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_attributeMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mAttributeType.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_attributeMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_attributeMap * ptr = dynamic_cast <const elementOf_GGS_attributeMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mAttributeType.operator_isEqual (ptr->mInfo.mAttributeType)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_attributeMap::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_attributeMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_attributeMap * info = (e_attributeMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_attributeMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_attributeMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_attributeMap * info = (e_attributeMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_attributeMap GGS_attributeMap::
constructor_emptyMap (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_attributeMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_attributeMap::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_attributeMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

void GGS_attributeMap::modifier_insertFakeKey (C_CompilerEx & inCompiler,
                         const GGS_string & inKey,
                         const GGS_location & inHelperMessageErrorLocation,
                         const GGS_string & inHelperMessage
                         COMMA_LOCATION_ARGS) {
  e_attributeMap info  ;
  internal_insertFakeKey (inCompiler,
                          (void *) & info,
                          inKey,
                          inHelperMessageErrorLocation,
                          inHelperMessage
                          COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_attributeMap::
operator_isEqual (const GGS_attributeMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_attributeMap::
operator_isNotEqual (const GGS_attributeMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_attributeMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_attributeMap::
insertElement (C_CompilerEx & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_unifiedTypeMapProxy & inParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap (THERE) ;
    e_attributeMap info  ;
    info.mAttributeType = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_attributeMap::
searchElement (C_CompilerEx & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_unifiedTypeMapProxy   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inLexique, inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    outParameter0 = node->mInfo.mAttributeType ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_attributeMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('t'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('b'),
  TO_UNICODE ('u'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_attributeMap::
method_searchKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                GGS_unifiedTypeMapProxy   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 0,
                 kSearchMessage_searchKey,
                 inKey,
                 outParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_attributeMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('t'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('b'),
  TO_UNICODE ('u'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_attributeMap::
modifier_insertKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_unifiedTypeMapProxy & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                NULL
                COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_attributeMap GGS_attributeMap::
constructor_mapWithMapToOverride (C_CompilerEx & /* inLexique */,
                                  const GGS_attributeMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_attributeMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_attributeMap GGS_attributeMap::
reader_overriddenMap (C_CompilerEx & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_attributeMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_attributeMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @attributeMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_unifiedTypeMapProxy  & GGS_attributeMap::cEnumerator::_mAttributeType (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mAttributeType ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_attributeMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_attributeMap * p = NULL ;
    macroMyNew (p, GGS_attributeMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_attributeMap GGS_attributeMap::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_attributeMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_attributeMap * p = dynamic_cast <const GGS_attributeMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_attributeMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_attributeMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_attributeMap ;
}

//---------------------------------------------------------------------------*

GGS_attributeMap GGS_attributeMap::constructor_mapWithKeyAndValue (C_CompilerEx & inLexique,
                                             const GGS_lstring & inKey,
                                             const GGS_unifiedTypeMapProxy & inValue0
                                             COMMA_LOCATION_ARGS) {
  GGS_attributeMap result = constructor_emptyMap (inLexique COMMA_THERE) ;
  result.insertElement (inLexique,
                        0,
                        NULL,
                        inKey,
                        inValue0,
                        NULL
                        COMMA_THERE) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'e_unifiedTypeMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

e_unifiedTypeMap::e_unifiedTypeMap (void) :
mIsConcrete (),
mSuperType (),
mTypeKindEnum (),
mAllTypedAttributeList (),
mAttributeMap (),
mCurrentTypedAttributeList (),
mConstructorMap (),
mReaderMap (),
mModifierMap (),
mInstanceMethodMap (),
mClassMethodMap (),
mEnumerationDescriptor (),
mHandledOperatorFlags (),
mAddAssignOperatorArguments (),
mEnumConstantSet (),
mEnumConstantList (),
mMapSearchMethodList (),
mMapProxySearchConstructorList (),
mWithAccessorMap (),
mGenerateHeaderInSeparateFile () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map '@unifiedTypeMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_unifiedTypeMap ("unifiedTypeMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_unifiedTypeMap::
elementOf_GGS_unifiedTypeMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_unifiedTypeMap & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_unifiedTypeMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mIsConcrete.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mSuperType.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mTypeKindEnum.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mAllTypedAttributeList.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mAttributeMap.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mCurrentTypedAttributeList.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mConstructorMap.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mReaderMap.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mModifierMap.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mInstanceMethodMap.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mClassMethodMap.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mEnumerationDescriptor.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mHandledOperatorFlags.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mAddAssignOperatorArguments.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mEnumConstantSet.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mEnumConstantList.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mMapSearchMethodList.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mMapProxySearchConstructorList.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mWithAccessorMap.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mGenerateHeaderInSeparateFile.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_unifiedTypeMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_unifiedTypeMap * ptr = dynamic_cast <const elementOf_GGS_unifiedTypeMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mIsConcrete.operator_isEqual (ptr->mInfo.mIsConcrete)).boolValue ()
           && (mInfo.mSuperType.operator_isEqual (ptr->mInfo.mSuperType)).boolValue ()
           && (mInfo.mTypeKindEnum.operator_isEqual (ptr->mInfo.mTypeKindEnum)).boolValue ()
           && (mInfo.mAllTypedAttributeList.operator_isEqual (ptr->mInfo.mAllTypedAttributeList)).boolValue ()
           && (mInfo.mAttributeMap.operator_isEqual (ptr->mInfo.mAttributeMap)).boolValue ()
           && (mInfo.mCurrentTypedAttributeList.operator_isEqual (ptr->mInfo.mCurrentTypedAttributeList)).boolValue ()
           && (mInfo.mConstructorMap.operator_isEqual (ptr->mInfo.mConstructorMap)).boolValue ()
           && (mInfo.mReaderMap.operator_isEqual (ptr->mInfo.mReaderMap)).boolValue ()
           && (mInfo.mModifierMap.operator_isEqual (ptr->mInfo.mModifierMap)).boolValue ()
           && (mInfo.mInstanceMethodMap.operator_isEqual (ptr->mInfo.mInstanceMethodMap)).boolValue ()
           && (mInfo.mClassMethodMap.operator_isEqual (ptr->mInfo.mClassMethodMap)).boolValue ()
           && (mInfo.mEnumerationDescriptor.operator_isEqual (ptr->mInfo.mEnumerationDescriptor)).boolValue ()
           && (mInfo.mHandledOperatorFlags.operator_isEqual (ptr->mInfo.mHandledOperatorFlags)).boolValue ()
           && (mInfo.mAddAssignOperatorArguments.operator_isEqual (ptr->mInfo.mAddAssignOperatorArguments)).boolValue ()
           && (mInfo.mEnumConstantSet.operator_isEqual (ptr->mInfo.mEnumConstantSet)).boolValue ()
           && (mInfo.mEnumConstantList.operator_isEqual (ptr->mInfo.mEnumConstantList)).boolValue ()
           && (mInfo.mMapSearchMethodList.operator_isEqual (ptr->mInfo.mMapSearchMethodList)).boolValue ()
           && (mInfo.mMapProxySearchConstructorList.operator_isEqual (ptr->mInfo.mMapProxySearchConstructorList)).boolValue ()
           && (mInfo.mWithAccessorMap.operator_isEqual (ptr->mInfo.mWithAccessorMap)).boolValue ()
           && (mInfo.mGenerateHeaderInSeparateFile.operator_isEqual (ptr->mInfo.mGenerateHeaderInSeparateFile)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_unifiedTypeMap::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_unifiedTypeMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_unifiedTypeMap * info = (e_unifiedTypeMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_unifiedTypeMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_unifiedTypeMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_unifiedTypeMap * info = (e_unifiedTypeMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMap GGS_unifiedTypeMap::
constructor_emptyMap (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_unifiedTypeMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_unifiedTypeMap::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_unifiedTypeMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

void GGS_unifiedTypeMap::modifier_insertFakeKey (C_CompilerEx & inCompiler,
                         const GGS_string & inKey,
                         const GGS_location & inHelperMessageErrorLocation,
                         const GGS_string & inHelperMessage
                         COMMA_LOCATION_ARGS) {
  e_unifiedTypeMap info  ;
  internal_insertFakeKey (inCompiler,
                          (void *) & info,
                          inKey,
                          inHelperMessageErrorLocation,
                          inHelperMessage
                          COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_unifiedTypeMap::
operator_isEqual (const GGS_unifiedTypeMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_unifiedTypeMap::
operator_isNotEqual (const GGS_unifiedTypeMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_unifiedTypeMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_unifiedTypeMap::
insertElement (C_CompilerEx & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_bool& inParameter0,
               const GGS_unifiedTypeMapProxy & inParameter1,
               const GGS_typeKindEnum& inParameter2,
               const GGS_typedAttributeList & inParameter3,
               const GGS_attributeMap & inParameter4,
               const GGS_typedAttributeList & inParameter5,
               const GGS_constructorMap & inParameter6,
               const GGS_readerMap & inParameter7,
               const GGS_modifierMap & inParameter8,
               const GGS_instanceMethodMap & inParameter9,
               const GGS_classMethodMap & inParameter10,
               const GGS_enumerationDescriptorList & inParameter11,
               const GGS_uint & inParameter12,
               const GGS_unifiedTypeMapProxyList & inParameter13,
               const GGS_stringset & inParameter14,
               const GGS_lstringlist & inParameter15,
               const GGS_mapSearchMethodListAST & inParameter16,
               const GGS_mapSearchMethodListAST & inParameter17,
               const GGS_withAccessorMap & inParameter18,
               const GGS_bool& inParameter19,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inParameter2.isBuilt ()
   && inParameter3.isBuilt ()
   && inParameter4.isBuilt ()
   && inParameter5.isBuilt ()
   && inParameter6.isBuilt ()
   && inParameter7.isBuilt ()
   && inParameter8.isBuilt ()
   && inParameter9.isBuilt ()
   && inParameter10.isBuilt ()
   && inParameter11.isBuilt ()
   && inParameter12.isBuilt ()
   && inParameter13.isBuilt ()
   && inParameter14.isBuilt ()
   && inParameter15.isBuilt ()
   && inParameter16.isBuilt ()
   && inParameter17.isBuilt ()
   && inParameter18.isBuilt ()
   && inParameter19.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap (THERE) ;
    e_unifiedTypeMap info  ;
    info.mIsConcrete = inParameter0 ;
    info.mSuperType = inParameter1 ;
    info.mTypeKindEnum = inParameter2 ;
    info.mAllTypedAttributeList = inParameter3 ;
    info.mAttributeMap = inParameter4 ;
    info.mCurrentTypedAttributeList = inParameter5 ;
    info.mConstructorMap = inParameter6 ;
    info.mReaderMap = inParameter7 ;
    info.mModifierMap = inParameter8 ;
    info.mInstanceMethodMap = inParameter9 ;
    info.mClassMethodMap = inParameter10 ;
    info.mEnumerationDescriptor = inParameter11 ;
    info.mHandledOperatorFlags = inParameter12 ;
    info.mAddAssignOperatorArguments = inParameter13 ;
    info.mEnumConstantSet = inParameter14 ;
    info.mEnumConstantList = inParameter15 ;
    info.mMapSearchMethodList = inParameter16 ;
    info.mMapProxySearchConstructorList = inParameter17 ;
    info.mWithAccessorMap = inParameter18 ;
    info.mGenerateHeaderInSeparateFile = inParameter19 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_unifiedTypeMap::
searchElement (C_CompilerEx & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_bool  & outParameter0,
               GGS_unifiedTypeMapProxy   & outParameter1,
               GGS_typeKindEnum  & outParameter2,
               GGS_typedAttributeList   & outParameter3,
               GGS_attributeMap   & outParameter4,
               GGS_typedAttributeList   & outParameter5,
               GGS_constructorMap   & outParameter6,
               GGS_readerMap   & outParameter7,
               GGS_modifierMap   & outParameter8,
               GGS_instanceMethodMap   & outParameter9,
               GGS_classMethodMap   & outParameter10,
               GGS_enumerationDescriptorList   & outParameter11,
               GGS_uint   & outParameter12,
               GGS_unifiedTypeMapProxyList   & outParameter13,
               GGS_stringset   & outParameter14,
               GGS_lstringlist   & outParameter15,
               GGS_mapSearchMethodListAST   & outParameter16,
               GGS_mapSearchMethodListAST   & outParameter17,
               GGS_withAccessorMap   & outParameter18,
               GGS_bool  & outParameter19,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inLexique, inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    outParameter2.drop () ;
    outParameter3.drop () ;
    outParameter4.drop () ;
    outParameter5.drop () ;
    outParameter6.drop () ;
    outParameter7.drop () ;
    outParameter8.drop () ;
    outParameter9.drop () ;
    outParameter10.drop () ;
    outParameter11.drop () ;
    outParameter12.drop () ;
    outParameter13.drop () ;
    outParameter14.drop () ;
    outParameter15.drop () ;
    outParameter16.drop () ;
    outParameter17.drop () ;
    outParameter18.drop () ;
    outParameter19.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    outParameter0 = node->mInfo.mIsConcrete ;
    outParameter1 = node->mInfo.mSuperType ;
    outParameter2 = node->mInfo.mTypeKindEnum ;
    outParameter3 = node->mInfo.mAllTypedAttributeList ;
    outParameter4 = node->mInfo.mAttributeMap ;
    outParameter5 = node->mInfo.mCurrentTypedAttributeList ;
    outParameter6 = node->mInfo.mConstructorMap ;
    outParameter7 = node->mInfo.mReaderMap ;
    outParameter8 = node->mInfo.mModifierMap ;
    outParameter9 = node->mInfo.mInstanceMethodMap ;
    outParameter10 = node->mInfo.mClassMethodMap ;
    outParameter11 = node->mInfo.mEnumerationDescriptor ;
    outParameter12 = node->mInfo.mHandledOperatorFlags ;
    outParameter13 = node->mInfo.mAddAssignOperatorArguments ;
    outParameter14 = node->mInfo.mEnumConstantSet ;
    outParameter15 = node->mInfo.mEnumConstantList ;
    outParameter16 = node->mInfo.mMapSearchMethodList ;
    outParameter17 = node->mInfo.mMapProxySearchConstructorList ;
    outParameter18 = node->mInfo.mWithAccessorMap ;
    outParameter19 = node->mInfo.mGenerateHeaderInSeparateFile ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_unifiedTypeMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('@'),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('y'),
  TO_UNICODE ('p'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_unifiedTypeMap::
method_searchKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                GGS_bool  & outParameter0,
                                GGS_unifiedTypeMapProxy   & outParameter1,
                                GGS_typeKindEnum  & outParameter2,
                                GGS_typedAttributeList   & outParameter3,
                                GGS_attributeMap   & outParameter4,
                                GGS_typedAttributeList   & outParameter5,
                                GGS_constructorMap   & outParameter6,
                                GGS_readerMap   & outParameter7,
                                GGS_modifierMap   & outParameter8,
                                GGS_instanceMethodMap   & outParameter9,
                                GGS_classMethodMap   & outParameter10,
                                GGS_enumerationDescriptorList   & outParameter11,
                                GGS_uint   & outParameter12,
                                GGS_unifiedTypeMapProxyList   & outParameter13,
                                GGS_stringset   & outParameter14,
                                GGS_lstringlist   & outParameter15,
                                GGS_mapSearchMethodListAST   & outParameter16,
                                GGS_mapSearchMethodListAST   & outParameter17,
                                GGS_withAccessorMap   & outParameter18,
                                GGS_bool  & outParameter19 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 0,
                 kSearchMessage_searchKey,
                 inKey,
                 outParameter0,
                 outParameter1,
                 outParameter2,
                 outParameter3,
                 outParameter4,
                 outParameter5,
                 outParameter6,
                 outParameter7,
                 outParameter8,
                 outParameter9,
                 outParameter10,
                 outParameter11,
                 outParameter12,
                 outParameter13,
                 outParameter14,
                 outParameter15,
                 outParameter16,
                 outParameter17,
                 outParameter18,
                 outParameter19,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_unifiedTypeMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('@'),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('y'),
  TO_UNICODE ('p'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_unifiedTypeMap::
modifier_insertKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_bool& inParameter0,
                                const GGS_unifiedTypeMapProxy & inParameter1,
                                const GGS_typeKindEnum& inParameter2,
                                const GGS_typedAttributeList & inParameter3,
                                const GGS_attributeMap & inParameter4,
                                const GGS_typedAttributeList & inParameter5,
                                const GGS_constructorMap & inParameter6,
                                const GGS_readerMap & inParameter7,
                                const GGS_modifierMap & inParameter8,
                                const GGS_instanceMethodMap & inParameter9,
                                const GGS_classMethodMap & inParameter10,
                                const GGS_enumerationDescriptorList & inParameter11,
                                const GGS_uint & inParameter12,
                                const GGS_unifiedTypeMapProxyList & inParameter13,
                                const GGS_stringset & inParameter14,
                                const GGS_lstringlist & inParameter15,
                                const GGS_mapSearchMethodListAST & inParameter16,
                                const GGS_mapSearchMethodListAST & inParameter17,
                                const GGS_withAccessorMap & inParameter18,
                                const GGS_bool& inParameter19 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 inParameter3,
                 inParameter4,
                 inParameter5,
                 inParameter6,
                 inParameter7,
                 inParameter8,
                 inParameter9,
                 inParameter10,
                 inParameter11,
                 inParameter12,
                 inParameter13,
                 inParameter14,
                 inParameter15,
                 inParameter16,
                 inParameter17,
                 inParameter18,
                 inParameter19,
                NULL
                COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMap GGS_unifiedTypeMap::
constructor_mapWithMapToOverride (C_CompilerEx & /* inLexique */,
                                  const GGS_unifiedTypeMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_unifiedTypeMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMap GGS_unifiedTypeMap::
reader_overriddenMap (C_CompilerEx & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_unifiedTypeMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_unifiedTypeMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @unifiedTypeMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_unifiedTypeMap::cEnumerator::_mIsConcrete (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mIsConcrete ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_unifiedTypeMapProxy  & GGS_unifiedTypeMap::cEnumerator::_mSuperType (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mSuperType ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeKindEnum & GGS_unifiedTypeMap::cEnumerator::_mTypeKindEnum (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mTypeKindEnum ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_typedAttributeList  & GGS_unifiedTypeMap::cEnumerator::_mAllTypedAttributeList (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mAllTypedAttributeList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_attributeMap  & GGS_unifiedTypeMap::cEnumerator::_mAttributeMap (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mAttributeMap ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_typedAttributeList  & GGS_unifiedTypeMap::cEnumerator::_mCurrentTypedAttributeList (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mCurrentTypedAttributeList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_constructorMap  & GGS_unifiedTypeMap::cEnumerator::_mConstructorMap (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mConstructorMap ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_readerMap  & GGS_unifiedTypeMap::cEnumerator::_mReaderMap (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mReaderMap ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_modifierMap  & GGS_unifiedTypeMap::cEnumerator::_mModifierMap (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mModifierMap ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_instanceMethodMap  & GGS_unifiedTypeMap::cEnumerator::_mInstanceMethodMap (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mInstanceMethodMap ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_classMethodMap  & GGS_unifiedTypeMap::cEnumerator::_mClassMethodMap (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mClassMethodMap ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_enumerationDescriptorList  & GGS_unifiedTypeMap::cEnumerator::_mEnumerationDescriptor (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mEnumerationDescriptor ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_unifiedTypeMap::cEnumerator::_mHandledOperatorFlags (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mHandledOperatorFlags ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_unifiedTypeMapProxyList  & GGS_unifiedTypeMap::cEnumerator::_mAddAssignOperatorArguments (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mAddAssignOperatorArguments ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_stringset  & GGS_unifiedTypeMap::cEnumerator::_mEnumConstantSet (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mEnumConstantSet ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstringlist  & GGS_unifiedTypeMap::cEnumerator::_mEnumConstantList (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mEnumConstantList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_mapSearchMethodListAST  & GGS_unifiedTypeMap::cEnumerator::_mMapSearchMethodList (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mMapSearchMethodList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_mapSearchMethodListAST  & GGS_unifiedTypeMap::cEnumerator::_mMapProxySearchConstructorList (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mMapProxySearchConstructorList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_withAccessorMap  & GGS_unifiedTypeMap::cEnumerator::_mWithAccessorMap (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mWithAccessorMap ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_unifiedTypeMap::cEnumerator::_mGenerateHeaderInSeparateFile (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mGenerateHeaderInSeparateFile ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_unifiedTypeMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_unifiedTypeMap * p = NULL ;
    macroMyNew (p, GGS_unifiedTypeMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMap GGS_unifiedTypeMap::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_unifiedTypeMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_unifiedTypeMap * p = dynamic_cast <const GGS_unifiedTypeMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_unifiedTypeMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_unifiedTypeMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_unifiedTypeMap ;
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMap GGS_unifiedTypeMap::constructor_mapWithKeyAndValue (C_CompilerEx & inLexique,
                                             const GGS_lstring & inKey,
                                             const GGS_bool& inValue0,
                                             const GGS_unifiedTypeMapProxy & inValue1,
                                             const GGS_typeKindEnum& inValue2,
                                             const GGS_typedAttributeList & inValue3,
                                             const GGS_attributeMap & inValue4,
                                             const GGS_typedAttributeList & inValue5,
                                             const GGS_constructorMap & inValue6,
                                             const GGS_readerMap & inValue7,
                                             const GGS_modifierMap & inValue8,
                                             const GGS_instanceMethodMap & inValue9,
                                             const GGS_classMethodMap & inValue10,
                                             const GGS_enumerationDescriptorList & inValue11,
                                             const GGS_uint & inValue12,
                                             const GGS_unifiedTypeMapProxyList & inValue13,
                                             const GGS_stringset & inValue14,
                                             const GGS_lstringlist & inValue15,
                                             const GGS_mapSearchMethodListAST & inValue16,
                                             const GGS_mapSearchMethodListAST & inValue17,
                                             const GGS_withAccessorMap & inValue18,
                                             const GGS_bool& inValue19
                                             COMMA_LOCATION_ARGS) {
  GGS_unifiedTypeMap result = constructor_emptyMap (inLexique COMMA_THERE) ;
  result.insertElement (inLexique,
                        0,
                        NULL,
                        inKey,
                        inValue0,
                        inValue1,
                        inValue2,
                        inValue3,
                        inValue4,
                        inValue5,
                        inValue6,
                        inValue7,
                        inValue8,
                        inValue9,
                        inValue10,
                        inValue11,
                        inValue12,
                        inValue13,
                        inValue14,
                        inValue15,
                        inValue16,
                        inValue17,
                        inValue18,
                        inValue19,
                        NULL
                        COMMA_THERE) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     map index '@unifiedTypeMapProxy'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_unifiedTypeMapProxy ("unifiedTypeMapProxy", false, NULL) ;

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapProxy GGS_unifiedTypeMapProxy::
constructor_null (C_CompilerEx & /* inLexique */
                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_unifiedTypeMapProxy result ;
  result.mState = kNull ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_unifiedTypeMapProxy::
operator_isEqual (const GGS_unifiedTypeMapProxy & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   (mState == inOperand.mState) && (mIndex.retrieve () == inOperand.mIndex.retrieve ())) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_unifiedTypeMapProxy::
operator_isNotEqual (const GGS_unifiedTypeMapProxy & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   (mState != inOperand.mState) || (mIndex.retrieve () != inOperand.mIndex.retrieve ())) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_unifiedTypeMapProxy::
reader_description (const PMSInt32 /* inIndentation */) const {
  C_String s ;
  s << "<mapproxy @unifiedTypeMapProxy" ;
  switch (mState) {
  case kNotBuilt:
    break ;
    s << " (not built)" ;
  case kNull:
    s << ": null" ;
    break ;
  case kRegular:
    s << ": regular (\"" << mKey << "\", " ;
    if (mIndex.retrieve () == NULL) {
      s << "deleted" ;
    }else if (mIndex.retrieve ()->mIsDefined) {
      s << "defined" ;
    }else{
      s << "unsolved" ;
    }
    s << ")" ;
    break ;
  }
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

void GGS_unifiedTypeMapProxy::
class_method_makeRegularProxy (C_CompilerEx & /* inLexique*/ ,
                               GGS_unifiedTypeMap & ioMap,
                               const GGS_string & inKey,
                               GGS_unifiedTypeMapProxy & outIndex
                               COMMA_UNUSED_LOCATION_ARGS) {
  outIndex.mState = kRegular ;
  outIndex.mKey = inKey ;
  ioMap.enterIndex (inKey, outIndex.mIndex) ;
  if (outIndex.mIndex.retrieve () == NULL) {
    outIndex.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapProxy GGS_unifiedTypeMapProxy::constructor_searchKey (C_CompilerEx & inLexique,
              const GGS_unifiedTypeMap & inMap,
              const GGS_lstring & inKey
              COMMA_LOCATION_ARGS) {
  GGS_unifiedTypeMapProxy result ;
  result.mState = kRegular ;
  result.mKey = inKey.ggs_string () ;
  inMap.searchIndex (inLexique, inKey, GGS_unifiedTypeMap::kSearchMessage_searchKey, result.mIndex COMMA_THERE) ;
  if (result.mIndex.retrieve () == NULL) {
    result.drop () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_unifiedTypeMapProxy::reader_mIsConcrete (C_CompilerEx & inLexique COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  switch (mState) {
  case kNotBuilt :
    break ;
  case kNull :
    inLexique.onTheFlyRunTimeError ("this map index is a null index" COMMA_THERE) ;
    break ;
  case kRegular :
    if (mIndex.retrieve () == NULL) {
      C_String message ;
      message << "bound entry for '" << mKey.string () << "' key has been deleted" ;
      inLexique.onTheFlyRunTimeError (message COMMA_THERE) ;
    }else if (! mIndex.retrieve ()->mIsDefined) {
      inLexique.onTheFlyRunTimeError (C_String ("entry '") + mKey.string () + "' is not solved" COMMA_THERE) ;
    }else{
      MF_Assert (reinterpret_cast <const elementOf_GGS_unifiedTypeMap *> (mIndex.retrieve ()) != NULL, "Dynamic cast error", 0, 0) ;
      const elementOf_GGS_unifiedTypeMap * p = (const elementOf_GGS_unifiedTypeMap *) mIndex.retrieve () ;
      result = p->mInfo.mIsConcrete ;
    }
    break ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapProxy  GGS_unifiedTypeMapProxy::reader_mSuperType (C_CompilerEx & inLexique COMMA_LOCATION_ARGS) const {
  GGS_unifiedTypeMapProxy  result ;
  switch (mState) {
  case kNotBuilt :
    break ;
  case kNull :
    inLexique.onTheFlyRunTimeError ("this map index is a null index" COMMA_THERE) ;
    break ;
  case kRegular :
    if (mIndex.retrieve () == NULL) {
      C_String message ;
      message << "bound entry for '" << mKey.string () << "' key has been deleted" ;
      inLexique.onTheFlyRunTimeError (message COMMA_THERE) ;
    }else if (! mIndex.retrieve ()->mIsDefined) {
      inLexique.onTheFlyRunTimeError (C_String ("entry '") + mKey.string () + "' is not solved" COMMA_THERE) ;
    }else{
      MF_Assert (reinterpret_cast <const elementOf_GGS_unifiedTypeMap *> (mIndex.retrieve ()) != NULL, "Dynamic cast error", 0, 0) ;
      const elementOf_GGS_unifiedTypeMap * p = (const elementOf_GGS_unifiedTypeMap *) mIndex.retrieve () ;
      result = p->mInfo.mSuperType ;
    }
    break ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeKindEnum GGS_unifiedTypeMapProxy::reader_mTypeKindEnum (C_CompilerEx & inLexique COMMA_LOCATION_ARGS) const {
  GGS_typeKindEnum result ;
  switch (mState) {
  case kNotBuilt :
    break ;
  case kNull :
    inLexique.onTheFlyRunTimeError ("this map index is a null index" COMMA_THERE) ;
    break ;
  case kRegular :
    if (mIndex.retrieve () == NULL) {
      C_String message ;
      message << "bound entry for '" << mKey.string () << "' key has been deleted" ;
      inLexique.onTheFlyRunTimeError (message COMMA_THERE) ;
    }else if (! mIndex.retrieve ()->mIsDefined) {
      inLexique.onTheFlyRunTimeError (C_String ("entry '") + mKey.string () + "' is not solved" COMMA_THERE) ;
    }else{
      MF_Assert (reinterpret_cast <const elementOf_GGS_unifiedTypeMap *> (mIndex.retrieve ()) != NULL, "Dynamic cast error", 0, 0) ;
      const elementOf_GGS_unifiedTypeMap * p = (const elementOf_GGS_unifiedTypeMap *) mIndex.retrieve () ;
      result = p->mInfo.mTypeKindEnum ;
    }
    break ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typedAttributeList  GGS_unifiedTypeMapProxy::reader_mAllTypedAttributeList (C_CompilerEx & inLexique COMMA_LOCATION_ARGS) const {
  GGS_typedAttributeList  result ;
  switch (mState) {
  case kNotBuilt :
    break ;
  case kNull :
    inLexique.onTheFlyRunTimeError ("this map index is a null index" COMMA_THERE) ;
    break ;
  case kRegular :
    if (mIndex.retrieve () == NULL) {
      C_String message ;
      message << "bound entry for '" << mKey.string () << "' key has been deleted" ;
      inLexique.onTheFlyRunTimeError (message COMMA_THERE) ;
    }else if (! mIndex.retrieve ()->mIsDefined) {
      inLexique.onTheFlyRunTimeError (C_String ("entry '") + mKey.string () + "' is not solved" COMMA_THERE) ;
    }else{
      MF_Assert (reinterpret_cast <const elementOf_GGS_unifiedTypeMap *> (mIndex.retrieve ()) != NULL, "Dynamic cast error", 0, 0) ;
      const elementOf_GGS_unifiedTypeMap * p = (const elementOf_GGS_unifiedTypeMap *) mIndex.retrieve () ;
      result = p->mInfo.mAllTypedAttributeList ;
    }
    break ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_attributeMap  GGS_unifiedTypeMapProxy::reader_mAttributeMap (C_CompilerEx & inLexique COMMA_LOCATION_ARGS) const {
  GGS_attributeMap  result ;
  switch (mState) {
  case kNotBuilt :
    break ;
  case kNull :
    inLexique.onTheFlyRunTimeError ("this map index is a null index" COMMA_THERE) ;
    break ;
  case kRegular :
    if (mIndex.retrieve () == NULL) {
      C_String message ;
      message << "bound entry for '" << mKey.string () << "' key has been deleted" ;
      inLexique.onTheFlyRunTimeError (message COMMA_THERE) ;
    }else if (! mIndex.retrieve ()->mIsDefined) {
      inLexique.onTheFlyRunTimeError (C_String ("entry '") + mKey.string () + "' is not solved" COMMA_THERE) ;
    }else{
      MF_Assert (reinterpret_cast <const elementOf_GGS_unifiedTypeMap *> (mIndex.retrieve ()) != NULL, "Dynamic cast error", 0, 0) ;
      const elementOf_GGS_unifiedTypeMap * p = (const elementOf_GGS_unifiedTypeMap *) mIndex.retrieve () ;
      result = p->mInfo.mAttributeMap ;
    }
    break ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typedAttributeList  GGS_unifiedTypeMapProxy::reader_mCurrentTypedAttributeList (C_CompilerEx & inLexique COMMA_LOCATION_ARGS) const {
  GGS_typedAttributeList  result ;
  switch (mState) {
  case kNotBuilt :
    break ;
  case kNull :
    inLexique.onTheFlyRunTimeError ("this map index is a null index" COMMA_THERE) ;
    break ;
  case kRegular :
    if (mIndex.retrieve () == NULL) {
      C_String message ;
      message << "bound entry for '" << mKey.string () << "' key has been deleted" ;
      inLexique.onTheFlyRunTimeError (message COMMA_THERE) ;
    }else if (! mIndex.retrieve ()->mIsDefined) {
      inLexique.onTheFlyRunTimeError (C_String ("entry '") + mKey.string () + "' is not solved" COMMA_THERE) ;
    }else{
      MF_Assert (reinterpret_cast <const elementOf_GGS_unifiedTypeMap *> (mIndex.retrieve ()) != NULL, "Dynamic cast error", 0, 0) ;
      const elementOf_GGS_unifiedTypeMap * p = (const elementOf_GGS_unifiedTypeMap *) mIndex.retrieve () ;
      result = p->mInfo.mCurrentTypedAttributeList ;
    }
    break ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_constructorMap  GGS_unifiedTypeMapProxy::reader_mConstructorMap (C_CompilerEx & inLexique COMMA_LOCATION_ARGS) const {
  GGS_constructorMap  result ;
  switch (mState) {
  case kNotBuilt :
    break ;
  case kNull :
    inLexique.onTheFlyRunTimeError ("this map index is a null index" COMMA_THERE) ;
    break ;
  case kRegular :
    if (mIndex.retrieve () == NULL) {
      C_String message ;
      message << "bound entry for '" << mKey.string () << "' key has been deleted" ;
      inLexique.onTheFlyRunTimeError (message COMMA_THERE) ;
    }else if (! mIndex.retrieve ()->mIsDefined) {
      inLexique.onTheFlyRunTimeError (C_String ("entry '") + mKey.string () + "' is not solved" COMMA_THERE) ;
    }else{
      MF_Assert (reinterpret_cast <const elementOf_GGS_unifiedTypeMap *> (mIndex.retrieve ()) != NULL, "Dynamic cast error", 0, 0) ;
      const elementOf_GGS_unifiedTypeMap * p = (const elementOf_GGS_unifiedTypeMap *) mIndex.retrieve () ;
      result = p->mInfo.mConstructorMap ;
    }
    break ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_readerMap  GGS_unifiedTypeMapProxy::reader_mReaderMap (C_CompilerEx & inLexique COMMA_LOCATION_ARGS) const {
  GGS_readerMap  result ;
  switch (mState) {
  case kNotBuilt :
    break ;
  case kNull :
    inLexique.onTheFlyRunTimeError ("this map index is a null index" COMMA_THERE) ;
    break ;
  case kRegular :
    if (mIndex.retrieve () == NULL) {
      C_String message ;
      message << "bound entry for '" << mKey.string () << "' key has been deleted" ;
      inLexique.onTheFlyRunTimeError (message COMMA_THERE) ;
    }else if (! mIndex.retrieve ()->mIsDefined) {
      inLexique.onTheFlyRunTimeError (C_String ("entry '") + mKey.string () + "' is not solved" COMMA_THERE) ;
    }else{
      MF_Assert (reinterpret_cast <const elementOf_GGS_unifiedTypeMap *> (mIndex.retrieve ()) != NULL, "Dynamic cast error", 0, 0) ;
      const elementOf_GGS_unifiedTypeMap * p = (const elementOf_GGS_unifiedTypeMap *) mIndex.retrieve () ;
      result = p->mInfo.mReaderMap ;
    }
    break ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_modifierMap  GGS_unifiedTypeMapProxy::reader_mModifierMap (C_CompilerEx & inLexique COMMA_LOCATION_ARGS) const {
  GGS_modifierMap  result ;
  switch (mState) {
  case kNotBuilt :
    break ;
  case kNull :
    inLexique.onTheFlyRunTimeError ("this map index is a null index" COMMA_THERE) ;
    break ;
  case kRegular :
    if (mIndex.retrieve () == NULL) {
      C_String message ;
      message << "bound entry for '" << mKey.string () << "' key has been deleted" ;
      inLexique.onTheFlyRunTimeError (message COMMA_THERE) ;
    }else if (! mIndex.retrieve ()->mIsDefined) {
      inLexique.onTheFlyRunTimeError (C_String ("entry '") + mKey.string () + "' is not solved" COMMA_THERE) ;
    }else{
      MF_Assert (reinterpret_cast <const elementOf_GGS_unifiedTypeMap *> (mIndex.retrieve ()) != NULL, "Dynamic cast error", 0, 0) ;
      const elementOf_GGS_unifiedTypeMap * p = (const elementOf_GGS_unifiedTypeMap *) mIndex.retrieve () ;
      result = p->mInfo.mModifierMap ;
    }
    break ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_instanceMethodMap  GGS_unifiedTypeMapProxy::reader_mInstanceMethodMap (C_CompilerEx & inLexique COMMA_LOCATION_ARGS) const {
  GGS_instanceMethodMap  result ;
  switch (mState) {
  case kNotBuilt :
    break ;
  case kNull :
    inLexique.onTheFlyRunTimeError ("this map index is a null index" COMMA_THERE) ;
    break ;
  case kRegular :
    if (mIndex.retrieve () == NULL) {
      C_String message ;
      message << "bound entry for '" << mKey.string () << "' key has been deleted" ;
      inLexique.onTheFlyRunTimeError (message COMMA_THERE) ;
    }else if (! mIndex.retrieve ()->mIsDefined) {
      inLexique.onTheFlyRunTimeError (C_String ("entry '") + mKey.string () + "' is not solved" COMMA_THERE) ;
    }else{
      MF_Assert (reinterpret_cast <const elementOf_GGS_unifiedTypeMap *> (mIndex.retrieve ()) != NULL, "Dynamic cast error", 0, 0) ;
      const elementOf_GGS_unifiedTypeMap * p = (const elementOf_GGS_unifiedTypeMap *) mIndex.retrieve () ;
      result = p->mInfo.mInstanceMethodMap ;
    }
    break ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_classMethodMap  GGS_unifiedTypeMapProxy::reader_mClassMethodMap (C_CompilerEx & inLexique COMMA_LOCATION_ARGS) const {
  GGS_classMethodMap  result ;
  switch (mState) {
  case kNotBuilt :
    break ;
  case kNull :
    inLexique.onTheFlyRunTimeError ("this map index is a null index" COMMA_THERE) ;
    break ;
  case kRegular :
    if (mIndex.retrieve () == NULL) {
      C_String message ;
      message << "bound entry for '" << mKey.string () << "' key has been deleted" ;
      inLexique.onTheFlyRunTimeError (message COMMA_THERE) ;
    }else if (! mIndex.retrieve ()->mIsDefined) {
      inLexique.onTheFlyRunTimeError (C_String ("entry '") + mKey.string () + "' is not solved" COMMA_THERE) ;
    }else{
      MF_Assert (reinterpret_cast <const elementOf_GGS_unifiedTypeMap *> (mIndex.retrieve ()) != NULL, "Dynamic cast error", 0, 0) ;
      const elementOf_GGS_unifiedTypeMap * p = (const elementOf_GGS_unifiedTypeMap *) mIndex.retrieve () ;
      result = p->mInfo.mClassMethodMap ;
    }
    break ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumerationDescriptorList  GGS_unifiedTypeMapProxy::reader_mEnumerationDescriptor (C_CompilerEx & inLexique COMMA_LOCATION_ARGS) const {
  GGS_enumerationDescriptorList  result ;
  switch (mState) {
  case kNotBuilt :
    break ;
  case kNull :
    inLexique.onTheFlyRunTimeError ("this map index is a null index" COMMA_THERE) ;
    break ;
  case kRegular :
    if (mIndex.retrieve () == NULL) {
      C_String message ;
      message << "bound entry for '" << mKey.string () << "' key has been deleted" ;
      inLexique.onTheFlyRunTimeError (message COMMA_THERE) ;
    }else if (! mIndex.retrieve ()->mIsDefined) {
      inLexique.onTheFlyRunTimeError (C_String ("entry '") + mKey.string () + "' is not solved" COMMA_THERE) ;
    }else{
      MF_Assert (reinterpret_cast <const elementOf_GGS_unifiedTypeMap *> (mIndex.retrieve ()) != NULL, "Dynamic cast error", 0, 0) ;
      const elementOf_GGS_unifiedTypeMap * p = (const elementOf_GGS_unifiedTypeMap *) mIndex.retrieve () ;
      result = p->mInfo.mEnumerationDescriptor ;
    }
    break ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_unifiedTypeMapProxy::reader_mHandledOperatorFlags (C_CompilerEx & inLexique COMMA_LOCATION_ARGS) const {
  GGS_uint  result ;
  switch (mState) {
  case kNotBuilt :
    break ;
  case kNull :
    inLexique.onTheFlyRunTimeError ("this map index is a null index" COMMA_THERE) ;
    break ;
  case kRegular :
    if (mIndex.retrieve () == NULL) {
      C_String message ;
      message << "bound entry for '" << mKey.string () << "' key has been deleted" ;
      inLexique.onTheFlyRunTimeError (message COMMA_THERE) ;
    }else if (! mIndex.retrieve ()->mIsDefined) {
      inLexique.onTheFlyRunTimeError (C_String ("entry '") + mKey.string () + "' is not solved" COMMA_THERE) ;
    }else{
      MF_Assert (reinterpret_cast <const elementOf_GGS_unifiedTypeMap *> (mIndex.retrieve ()) != NULL, "Dynamic cast error", 0, 0) ;
      const elementOf_GGS_unifiedTypeMap * p = (const elementOf_GGS_unifiedTypeMap *) mIndex.retrieve () ;
      result = p->mInfo.mHandledOperatorFlags ;
    }
    break ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapProxyList  GGS_unifiedTypeMapProxy::reader_mAddAssignOperatorArguments (C_CompilerEx & inLexique COMMA_LOCATION_ARGS) const {
  GGS_unifiedTypeMapProxyList  result ;
  switch (mState) {
  case kNotBuilt :
    break ;
  case kNull :
    inLexique.onTheFlyRunTimeError ("this map index is a null index" COMMA_THERE) ;
    break ;
  case kRegular :
    if (mIndex.retrieve () == NULL) {
      C_String message ;
      message << "bound entry for '" << mKey.string () << "' key has been deleted" ;
      inLexique.onTheFlyRunTimeError (message COMMA_THERE) ;
    }else if (! mIndex.retrieve ()->mIsDefined) {
      inLexique.onTheFlyRunTimeError (C_String ("entry '") + mKey.string () + "' is not solved" COMMA_THERE) ;
    }else{
      MF_Assert (reinterpret_cast <const elementOf_GGS_unifiedTypeMap *> (mIndex.retrieve ()) != NULL, "Dynamic cast error", 0, 0) ;
      const elementOf_GGS_unifiedTypeMap * p = (const elementOf_GGS_unifiedTypeMap *) mIndex.retrieve () ;
      result = p->mInfo.mAddAssignOperatorArguments ;
    }
    break ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringset  GGS_unifiedTypeMapProxy::reader_mEnumConstantSet (C_CompilerEx & inLexique COMMA_LOCATION_ARGS) const {
  GGS_stringset  result ;
  switch (mState) {
  case kNotBuilt :
    break ;
  case kNull :
    inLexique.onTheFlyRunTimeError ("this map index is a null index" COMMA_THERE) ;
    break ;
  case kRegular :
    if (mIndex.retrieve () == NULL) {
      C_String message ;
      message << "bound entry for '" << mKey.string () << "' key has been deleted" ;
      inLexique.onTheFlyRunTimeError (message COMMA_THERE) ;
    }else if (! mIndex.retrieve ()->mIsDefined) {
      inLexique.onTheFlyRunTimeError (C_String ("entry '") + mKey.string () + "' is not solved" COMMA_THERE) ;
    }else{
      MF_Assert (reinterpret_cast <const elementOf_GGS_unifiedTypeMap *> (mIndex.retrieve ()) != NULL, "Dynamic cast error", 0, 0) ;
      const elementOf_GGS_unifiedTypeMap * p = (const elementOf_GGS_unifiedTypeMap *) mIndex.retrieve () ;
      result = p->mInfo.mEnumConstantSet ;
    }
    break ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_unifiedTypeMapProxy::reader_mEnumConstantList (C_CompilerEx & inLexique COMMA_LOCATION_ARGS) const {
  GGS_lstringlist  result ;
  switch (mState) {
  case kNotBuilt :
    break ;
  case kNull :
    inLexique.onTheFlyRunTimeError ("this map index is a null index" COMMA_THERE) ;
    break ;
  case kRegular :
    if (mIndex.retrieve () == NULL) {
      C_String message ;
      message << "bound entry for '" << mKey.string () << "' key has been deleted" ;
      inLexique.onTheFlyRunTimeError (message COMMA_THERE) ;
    }else if (! mIndex.retrieve ()->mIsDefined) {
      inLexique.onTheFlyRunTimeError (C_String ("entry '") + mKey.string () + "' is not solved" COMMA_THERE) ;
    }else{
      MF_Assert (reinterpret_cast <const elementOf_GGS_unifiedTypeMap *> (mIndex.retrieve ()) != NULL, "Dynamic cast error", 0, 0) ;
      const elementOf_GGS_unifiedTypeMap * p = (const elementOf_GGS_unifiedTypeMap *) mIndex.retrieve () ;
      result = p->mInfo.mEnumConstantList ;
    }
    break ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapSearchMethodListAST  GGS_unifiedTypeMapProxy::reader_mMapSearchMethodList (C_CompilerEx & inLexique COMMA_LOCATION_ARGS) const {
  GGS_mapSearchMethodListAST  result ;
  switch (mState) {
  case kNotBuilt :
    break ;
  case kNull :
    inLexique.onTheFlyRunTimeError ("this map index is a null index" COMMA_THERE) ;
    break ;
  case kRegular :
    if (mIndex.retrieve () == NULL) {
      C_String message ;
      message << "bound entry for '" << mKey.string () << "' key has been deleted" ;
      inLexique.onTheFlyRunTimeError (message COMMA_THERE) ;
    }else if (! mIndex.retrieve ()->mIsDefined) {
      inLexique.onTheFlyRunTimeError (C_String ("entry '") + mKey.string () + "' is not solved" COMMA_THERE) ;
    }else{
      MF_Assert (reinterpret_cast <const elementOf_GGS_unifiedTypeMap *> (mIndex.retrieve ()) != NULL, "Dynamic cast error", 0, 0) ;
      const elementOf_GGS_unifiedTypeMap * p = (const elementOf_GGS_unifiedTypeMap *) mIndex.retrieve () ;
      result = p->mInfo.mMapSearchMethodList ;
    }
    break ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapSearchMethodListAST  GGS_unifiedTypeMapProxy::reader_mMapProxySearchConstructorList (C_CompilerEx & inLexique COMMA_LOCATION_ARGS) const {
  GGS_mapSearchMethodListAST  result ;
  switch (mState) {
  case kNotBuilt :
    break ;
  case kNull :
    inLexique.onTheFlyRunTimeError ("this map index is a null index" COMMA_THERE) ;
    break ;
  case kRegular :
    if (mIndex.retrieve () == NULL) {
      C_String message ;
      message << "bound entry for '" << mKey.string () << "' key has been deleted" ;
      inLexique.onTheFlyRunTimeError (message COMMA_THERE) ;
    }else if (! mIndex.retrieve ()->mIsDefined) {
      inLexique.onTheFlyRunTimeError (C_String ("entry '") + mKey.string () + "' is not solved" COMMA_THERE) ;
    }else{
      MF_Assert (reinterpret_cast <const elementOf_GGS_unifiedTypeMap *> (mIndex.retrieve ()) != NULL, "Dynamic cast error", 0, 0) ;
      const elementOf_GGS_unifiedTypeMap * p = (const elementOf_GGS_unifiedTypeMap *) mIndex.retrieve () ;
      result = p->mInfo.mMapProxySearchConstructorList ;
    }
    break ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_withAccessorMap  GGS_unifiedTypeMapProxy::reader_mWithAccessorMap (C_CompilerEx & inLexique COMMA_LOCATION_ARGS) const {
  GGS_withAccessorMap  result ;
  switch (mState) {
  case kNotBuilt :
    break ;
  case kNull :
    inLexique.onTheFlyRunTimeError ("this map index is a null index" COMMA_THERE) ;
    break ;
  case kRegular :
    if (mIndex.retrieve () == NULL) {
      C_String message ;
      message << "bound entry for '" << mKey.string () << "' key has been deleted" ;
      inLexique.onTheFlyRunTimeError (message COMMA_THERE) ;
    }else if (! mIndex.retrieve ()->mIsDefined) {
      inLexique.onTheFlyRunTimeError (C_String ("entry '") + mKey.string () + "' is not solved" COMMA_THERE) ;
    }else{
      MF_Assert (reinterpret_cast <const elementOf_GGS_unifiedTypeMap *> (mIndex.retrieve ()) != NULL, "Dynamic cast error", 0, 0) ;
      const elementOf_GGS_unifiedTypeMap * p = (const elementOf_GGS_unifiedTypeMap *) mIndex.retrieve () ;
      result = p->mInfo.mWithAccessorMap ;
    }
    break ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_unifiedTypeMapProxy::reader_mGenerateHeaderInSeparateFile (C_CompilerEx & inLexique COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  switch (mState) {
  case kNotBuilt :
    break ;
  case kNull :
    inLexique.onTheFlyRunTimeError ("this map index is a null index" COMMA_THERE) ;
    break ;
  case kRegular :
    if (mIndex.retrieve () == NULL) {
      C_String message ;
      message << "bound entry for '" << mKey.string () << "' key has been deleted" ;
      inLexique.onTheFlyRunTimeError (message COMMA_THERE) ;
    }else if (! mIndex.retrieve ()->mIsDefined) {
      inLexique.onTheFlyRunTimeError (C_String ("entry '") + mKey.string () + "' is not solved" COMMA_THERE) ;
    }else{
      MF_Assert (reinterpret_cast <const elementOf_GGS_unifiedTypeMap *> (mIndex.retrieve ()) != NULL, "Dynamic cast error", 0, 0) ;
      const elementOf_GGS_unifiedTypeMap * p = (const elementOf_GGS_unifiedTypeMap *) mIndex.retrieve () ;
      result = p->mInfo.mGenerateHeaderInSeparateFile ;
    }
    break ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_unifiedTypeMapProxy::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_unifiedTypeMapProxy * p = NULL ;
    macroMyNew (p, GGS_unifiedTypeMapProxy (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapProxy GGS_unifiedTypeMapProxy::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_unifiedTypeMapProxy result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_unifiedTypeMapProxy * p = dynamic_cast <const GGS_unifiedTypeMapProxy *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_unifiedTypeMapProxy, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_unifiedTypeMapProxy::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_unifiedTypeMapProxy ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_predefinedTypeAST'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_predefinedTypeAST::
cPtr_predefinedTypeAST (const GGS_string& argument_0,
                                const GGS_predefinedTypeKindEnum& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticDeclarationAST (THERE),
mPredefinedTypeName (argument_0),
mKind (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_predefinedTypeAST * GGS_predefinedTypeAST::
  operator () (LOCATION_ARGS) const {
    macroValidSharedObjectThere (mPointer, cPtr_predefinedTypeAST) ;
    return (cPtr_predefinedTypeAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_predefinedTypeAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@predefinedTypeAST:"
           << mPredefinedTypeName.reader_description (inIndentation + 1)
           << mKind.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_predefinedTypeAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_predefinedTypeAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_predefinedTypeAST (& typeid (cPtr_predefinedTypeAST), & typeid (cPtr_semanticDeclarationAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_predefinedTypeAST::galgasRTTI (void) const {
  return & gClassInfoFor__predefinedTypeAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_predefinedTypeAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_predefinedTypeAST ("predefinedTypeAST", true, & kTypeDescriptor_GGS_semanticDeclarationAST) ;

//---------------------------------------------------------------------------*

GGS_predefinedTypeAST::
GGS_predefinedTypeAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignSharedObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_predefinedTypeAST::
GGS_predefinedTypeAST (cPtr__AC_galgas_class & inObject) {
  macroAssignSharedObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_predefinedTypeAST GGS_predefinedTypeAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_predefinedTypeAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_predefinedTypeAST *> (inPointer) != NULL)
      : (typeid (cPtr_predefinedTypeAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_predefinedTypeAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_predefinedTypeAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_predefinedTypeAST::
reader_mPredefinedTypeName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_predefinedTypeAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_predefinedTypeAST *) mPointer)->mPredefinedTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_predefinedTypeKindEnum GGS_predefinedTypeAST::
reader_mKind (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_predefinedTypeKindEnum  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_predefinedTypeAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_predefinedTypeAST *) mPointer)->mKind ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_predefinedTypeAST::actualTypeName (void) const {
  return "predefinedTypeAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__predefinedTypeAST ("predefinedTypeAST", gClassInfoFor__semanticDeclarationAST, & kTypeDescriptor_GGS_predefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_predefinedTypeAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_predefinedTypeAST * p = NULL ;
    macroMyNew (p, GGS_predefinedTypeAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_predefinedTypeAST GGS_predefinedTypeAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_predefinedTypeAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_predefinedTypeAST * p = dynamic_cast <const GGS_predefinedTypeAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_predefinedTypeAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_predefinedTypeAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_predefinedTypeAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_applicationPredefinedTypeAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_applicationPredefinedTypeAST::
cPtr_applicationPredefinedTypeAST (const GGS_string& argument_0,
                                const GGS_predefinedTypeKindEnum& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_predefinedTypeAST (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_applicationPredefinedTypeAST * GGS_applicationPredefinedTypeAST::
  operator () (LOCATION_ARGS) const {
    macroValidSharedObjectThere (mPointer, cPtr_applicationPredefinedTypeAST) ;
    return (cPtr_applicationPredefinedTypeAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_applicationPredefinedTypeAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_applicationPredefinedTypeAST * ptr = dynamic_cast <const cPtr_applicationPredefinedTypeAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mPredefinedTypeName.operator_isEqual (ptr->mPredefinedTypeName).boolValue ()
         && mKind.operator_isEqual (ptr->mKind).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_applicationPredefinedTypeAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@applicationPredefinedTypeAST:"
           << mPredefinedTypeName.reader_description (inIndentation + 1)
           << mKind.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_applicationPredefinedTypeAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_applicationPredefinedTypeAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_applicationPredefinedTypeAST (& typeid (cPtr_applicationPredefinedTypeAST), & typeid (cPtr_predefinedTypeAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_applicationPredefinedTypeAST::galgasRTTI (void) const {
  return & gClassInfoFor__applicationPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_applicationPredefinedTypeAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_applicationPredefinedTypeAST (mPredefinedTypeName, mKind COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_applicationPredefinedTypeAST'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_applicationPredefinedTypeAST ("applicationPredefinedTypeAST", true, & kTypeDescriptor_GGS_predefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_applicationPredefinedTypeAST::
GGS_applicationPredefinedTypeAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignSharedObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_applicationPredefinedTypeAST::
GGS_applicationPredefinedTypeAST (cPtr__AC_galgas_class & inObject) {
  macroAssignSharedObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_applicationPredefinedTypeAST GGS_applicationPredefinedTypeAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_applicationPredefinedTypeAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_applicationPredefinedTypeAST *> (inPointer) != NULL)
      : (typeid (cPtr_applicationPredefinedTypeAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_applicationPredefinedTypeAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_applicationPredefinedTypeAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_applicationPredefinedTypeAST GGS_applicationPredefinedTypeAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_string& argument_0,
                 const GGS_predefinedTypeKindEnum& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_applicationPredefinedTypeAST result ;
  macroMyNew (result.mPointer, cPtr_applicationPredefinedTypeAST (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_applicationPredefinedTypeAST::actualTypeName (void) const {
  return "applicationPredefinedTypeAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__applicationPredefinedTypeAST ("applicationPredefinedTypeAST", gClassInfoFor__predefinedTypeAST, & kTypeDescriptor_GGS_applicationPredefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_applicationPredefinedTypeAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_applicationPredefinedTypeAST * p = NULL ;
    macroMyNew (p, GGS_applicationPredefinedTypeAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_applicationPredefinedTypeAST GGS_applicationPredefinedTypeAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_applicationPredefinedTypeAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_applicationPredefinedTypeAST * p = dynamic_cast <const GGS_applicationPredefinedTypeAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_applicationPredefinedTypeAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_applicationPredefinedTypeAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_applicationPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_objectPredefinedTypeAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_objectPredefinedTypeAST::
cPtr_objectPredefinedTypeAST (const GGS_string& argument_0,
                                const GGS_predefinedTypeKindEnum& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_predefinedTypeAST (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_objectPredefinedTypeAST * GGS_objectPredefinedTypeAST::
  operator () (LOCATION_ARGS) const {
    macroValidSharedObjectThere (mPointer, cPtr_objectPredefinedTypeAST) ;
    return (cPtr_objectPredefinedTypeAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_objectPredefinedTypeAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_objectPredefinedTypeAST * ptr = dynamic_cast <const cPtr_objectPredefinedTypeAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mPredefinedTypeName.operator_isEqual (ptr->mPredefinedTypeName).boolValue ()
         && mKind.operator_isEqual (ptr->mKind).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_objectPredefinedTypeAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@objectPredefinedTypeAST:"
           << mPredefinedTypeName.reader_description (inIndentation + 1)
           << mKind.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_objectPredefinedTypeAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_objectPredefinedTypeAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_objectPredefinedTypeAST (& typeid (cPtr_objectPredefinedTypeAST), & typeid (cPtr_predefinedTypeAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_objectPredefinedTypeAST::galgasRTTI (void) const {
  return & gClassInfoFor__objectPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_objectPredefinedTypeAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_objectPredefinedTypeAST (mPredefinedTypeName, mKind COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_objectPredefinedTypeAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_objectPredefinedTypeAST ("objectPredefinedTypeAST", true, & kTypeDescriptor_GGS_predefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_objectPredefinedTypeAST::
GGS_objectPredefinedTypeAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignSharedObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_objectPredefinedTypeAST::
GGS_objectPredefinedTypeAST (cPtr__AC_galgas_class & inObject) {
  macroAssignSharedObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_objectPredefinedTypeAST GGS_objectPredefinedTypeAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_objectPredefinedTypeAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_objectPredefinedTypeAST *> (inPointer) != NULL)
      : (typeid (cPtr_objectPredefinedTypeAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_objectPredefinedTypeAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_objectPredefinedTypeAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_objectPredefinedTypeAST GGS_objectPredefinedTypeAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_string& argument_0,
                 const GGS_predefinedTypeKindEnum& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_objectPredefinedTypeAST result ;
  macroMyNew (result.mPointer, cPtr_objectPredefinedTypeAST (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_objectPredefinedTypeAST::actualTypeName (void) const {
  return "objectPredefinedTypeAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__objectPredefinedTypeAST ("objectPredefinedTypeAST", gClassInfoFor__predefinedTypeAST, & kTypeDescriptor_GGS_objectPredefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_objectPredefinedTypeAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_objectPredefinedTypeAST * p = NULL ;
    macroMyNew (p, GGS_objectPredefinedTypeAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_objectPredefinedTypeAST GGS_objectPredefinedTypeAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_objectPredefinedTypeAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_objectPredefinedTypeAST * p = dynamic_cast <const GGS_objectPredefinedTypeAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_objectPredefinedTypeAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_objectPredefinedTypeAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_objectPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_filewrapperPredefinedTypeAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_filewrapperPredefinedTypeAST::
cPtr_filewrapperPredefinedTypeAST (const GGS_string& argument_0,
                                const GGS_predefinedTypeKindEnum& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_predefinedTypeAST (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_filewrapperPredefinedTypeAST * GGS_filewrapperPredefinedTypeAST::
  operator () (LOCATION_ARGS) const {
    macroValidSharedObjectThere (mPointer, cPtr_filewrapperPredefinedTypeAST) ;
    return (cPtr_filewrapperPredefinedTypeAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_filewrapperPredefinedTypeAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_filewrapperPredefinedTypeAST * ptr = dynamic_cast <const cPtr_filewrapperPredefinedTypeAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mPredefinedTypeName.operator_isEqual (ptr->mPredefinedTypeName).boolValue ()
         && mKind.operator_isEqual (ptr->mKind).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_filewrapperPredefinedTypeAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@filewrapperPredefinedTypeAST:"
           << mPredefinedTypeName.reader_description (inIndentation + 1)
           << mKind.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_filewrapperPredefinedTypeAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_filewrapperPredefinedTypeAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_filewrapperPredefinedTypeAST (& typeid (cPtr_filewrapperPredefinedTypeAST), & typeid (cPtr_predefinedTypeAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_filewrapperPredefinedTypeAST::galgasRTTI (void) const {
  return & gClassInfoFor__filewrapperPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_filewrapperPredefinedTypeAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_filewrapperPredefinedTypeAST (mPredefinedTypeName, mKind COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_filewrapperPredefinedTypeAST'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_filewrapperPredefinedTypeAST ("filewrapperPredefinedTypeAST", true, & kTypeDescriptor_GGS_predefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_filewrapperPredefinedTypeAST::
GGS_filewrapperPredefinedTypeAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignSharedObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperPredefinedTypeAST::
GGS_filewrapperPredefinedTypeAST (cPtr__AC_galgas_class & inObject) {
  macroAssignSharedObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_filewrapperPredefinedTypeAST GGS_filewrapperPredefinedTypeAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_filewrapperPredefinedTypeAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_filewrapperPredefinedTypeAST *> (inPointer) != NULL)
      : (typeid (cPtr_filewrapperPredefinedTypeAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_filewrapperPredefinedTypeAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_filewrapperPredefinedTypeAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperPredefinedTypeAST GGS_filewrapperPredefinedTypeAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_string& argument_0,
                 const GGS_predefinedTypeKindEnum& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_filewrapperPredefinedTypeAST result ;
  macroMyNew (result.mPointer, cPtr_filewrapperPredefinedTypeAST (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_filewrapperPredefinedTypeAST::actualTypeName (void) const {
  return "filewrapperPredefinedTypeAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__filewrapperPredefinedTypeAST ("filewrapperPredefinedTypeAST", gClassInfoFor__predefinedTypeAST, & kTypeDescriptor_GGS_filewrapperPredefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_filewrapperPredefinedTypeAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_filewrapperPredefinedTypeAST * p = NULL ;
    macroMyNew (p, GGS_filewrapperPredefinedTypeAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperPredefinedTypeAST GGS_filewrapperPredefinedTypeAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_filewrapperPredefinedTypeAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_filewrapperPredefinedTypeAST * p = dynamic_cast <const GGS_filewrapperPredefinedTypeAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_filewrapperPredefinedTypeAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_filewrapperPredefinedTypeAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_filewrapperPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_binarysetPredefinedTypeAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_binarysetPredefinedTypeAST::
cPtr_binarysetPredefinedTypeAST (const GGS_string& argument_0,
                                const GGS_predefinedTypeKindEnum& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_predefinedTypeAST (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_binarysetPredefinedTypeAST * GGS_binarysetPredefinedTypeAST::
  operator () (LOCATION_ARGS) const {
    macroValidSharedObjectThere (mPointer, cPtr_binarysetPredefinedTypeAST) ;
    return (cPtr_binarysetPredefinedTypeAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_binarysetPredefinedTypeAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_binarysetPredefinedTypeAST * ptr = dynamic_cast <const cPtr_binarysetPredefinedTypeAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mPredefinedTypeName.operator_isEqual (ptr->mPredefinedTypeName).boolValue ()
         && mKind.operator_isEqual (ptr->mKind).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_binarysetPredefinedTypeAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@binarysetPredefinedTypeAST:"
           << mPredefinedTypeName.reader_description (inIndentation + 1)
           << mKind.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_binarysetPredefinedTypeAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_binarysetPredefinedTypeAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_binarysetPredefinedTypeAST (& typeid (cPtr_binarysetPredefinedTypeAST), & typeid (cPtr_predefinedTypeAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_binarysetPredefinedTypeAST::galgasRTTI (void) const {
  return & gClassInfoFor__binarysetPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_binarysetPredefinedTypeAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_binarysetPredefinedTypeAST (mPredefinedTypeName, mKind COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_binarysetPredefinedTypeAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_binarysetPredefinedTypeAST ("binarysetPredefinedTypeAST", true, & kTypeDescriptor_GGS_predefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_binarysetPredefinedTypeAST::
GGS_binarysetPredefinedTypeAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignSharedObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_binarysetPredefinedTypeAST::
GGS_binarysetPredefinedTypeAST (cPtr__AC_galgas_class & inObject) {
  macroAssignSharedObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_binarysetPredefinedTypeAST GGS_binarysetPredefinedTypeAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_binarysetPredefinedTypeAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_binarysetPredefinedTypeAST *> (inPointer) != NULL)
      : (typeid (cPtr_binarysetPredefinedTypeAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_binarysetPredefinedTypeAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_binarysetPredefinedTypeAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_binarysetPredefinedTypeAST GGS_binarysetPredefinedTypeAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_string& argument_0,
                 const GGS_predefinedTypeKindEnum& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_binarysetPredefinedTypeAST result ;
  macroMyNew (result.mPointer, cPtr_binarysetPredefinedTypeAST (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_binarysetPredefinedTypeAST::actualTypeName (void) const {
  return "binarysetPredefinedTypeAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__binarysetPredefinedTypeAST ("binarysetPredefinedTypeAST", gClassInfoFor__predefinedTypeAST, & kTypeDescriptor_GGS_binarysetPredefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_binarysetPredefinedTypeAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_binarysetPredefinedTypeAST * p = NULL ;
    macroMyNew (p, GGS_binarysetPredefinedTypeAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_binarysetPredefinedTypeAST GGS_binarysetPredefinedTypeAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_binarysetPredefinedTypeAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_binarysetPredefinedTypeAST * p = dynamic_cast <const GGS_binarysetPredefinedTypeAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_binarysetPredefinedTypeAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_binarysetPredefinedTypeAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_binarysetPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_boolPredefinedTypeAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_boolPredefinedTypeAST::
cPtr_boolPredefinedTypeAST (const GGS_string& argument_0,
                                const GGS_predefinedTypeKindEnum& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_predefinedTypeAST (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_boolPredefinedTypeAST * GGS_boolPredefinedTypeAST::
  operator () (LOCATION_ARGS) const {
    macroValidSharedObjectThere (mPointer, cPtr_boolPredefinedTypeAST) ;
    return (cPtr_boolPredefinedTypeAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_boolPredefinedTypeAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_boolPredefinedTypeAST * ptr = dynamic_cast <const cPtr_boolPredefinedTypeAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mPredefinedTypeName.operator_isEqual (ptr->mPredefinedTypeName).boolValue ()
         && mKind.operator_isEqual (ptr->mKind).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_boolPredefinedTypeAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@boolPredefinedTypeAST:"
           << mPredefinedTypeName.reader_description (inIndentation + 1)
           << mKind.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_boolPredefinedTypeAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_boolPredefinedTypeAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_boolPredefinedTypeAST (& typeid (cPtr_boolPredefinedTypeAST), & typeid (cPtr_predefinedTypeAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_boolPredefinedTypeAST::galgasRTTI (void) const {
  return & gClassInfoFor__boolPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_boolPredefinedTypeAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_boolPredefinedTypeAST (mPredefinedTypeName, mKind COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_boolPredefinedTypeAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_boolPredefinedTypeAST ("boolPredefinedTypeAST", true, & kTypeDescriptor_GGS_predefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_boolPredefinedTypeAST::
GGS_boolPredefinedTypeAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignSharedObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_boolPredefinedTypeAST::
GGS_boolPredefinedTypeAST (cPtr__AC_galgas_class & inObject) {
  macroAssignSharedObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_boolPredefinedTypeAST GGS_boolPredefinedTypeAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_boolPredefinedTypeAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_boolPredefinedTypeAST *> (inPointer) != NULL)
      : (typeid (cPtr_boolPredefinedTypeAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_boolPredefinedTypeAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_boolPredefinedTypeAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_boolPredefinedTypeAST GGS_boolPredefinedTypeAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_string& argument_0,
                 const GGS_predefinedTypeKindEnum& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_boolPredefinedTypeAST result ;
  macroMyNew (result.mPointer, cPtr_boolPredefinedTypeAST (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_boolPredefinedTypeAST::actualTypeName (void) const {
  return "boolPredefinedTypeAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__boolPredefinedTypeAST ("boolPredefinedTypeAST", gClassInfoFor__predefinedTypeAST, & kTypeDescriptor_GGS_boolPredefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_boolPredefinedTypeAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_boolPredefinedTypeAST * p = NULL ;
    macroMyNew (p, GGS_boolPredefinedTypeAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_boolPredefinedTypeAST GGS_boolPredefinedTypeAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_boolPredefinedTypeAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_boolPredefinedTypeAST * p = dynamic_cast <const GGS_boolPredefinedTypeAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_boolPredefinedTypeAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_boolPredefinedTypeAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_boolPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_uintPredefinedTypeAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_uintPredefinedTypeAST::
cPtr_uintPredefinedTypeAST (const GGS_string& argument_0,
                                const GGS_predefinedTypeKindEnum& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_predefinedTypeAST (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_uintPredefinedTypeAST * GGS_uintPredefinedTypeAST::
  operator () (LOCATION_ARGS) const {
    macroValidSharedObjectThere (mPointer, cPtr_uintPredefinedTypeAST) ;
    return (cPtr_uintPredefinedTypeAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_uintPredefinedTypeAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_uintPredefinedTypeAST * ptr = dynamic_cast <const cPtr_uintPredefinedTypeAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mPredefinedTypeName.operator_isEqual (ptr->mPredefinedTypeName).boolValue ()
         && mKind.operator_isEqual (ptr->mKind).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_uintPredefinedTypeAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@uintPredefinedTypeAST:"
           << mPredefinedTypeName.reader_description (inIndentation + 1)
           << mKind.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_uintPredefinedTypeAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_uintPredefinedTypeAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_uintPredefinedTypeAST (& typeid (cPtr_uintPredefinedTypeAST), & typeid (cPtr_predefinedTypeAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_uintPredefinedTypeAST::galgasRTTI (void) const {
  return & gClassInfoFor__uintPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_uintPredefinedTypeAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_uintPredefinedTypeAST (mPredefinedTypeName, mKind COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_uintPredefinedTypeAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_uintPredefinedTypeAST ("uintPredefinedTypeAST", true, & kTypeDescriptor_GGS_predefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_uintPredefinedTypeAST::
GGS_uintPredefinedTypeAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignSharedObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_uintPredefinedTypeAST::
GGS_uintPredefinedTypeAST (cPtr__AC_galgas_class & inObject) {
  macroAssignSharedObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_uintPredefinedTypeAST GGS_uintPredefinedTypeAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_uintPredefinedTypeAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_uintPredefinedTypeAST *> (inPointer) != NULL)
      : (typeid (cPtr_uintPredefinedTypeAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_uintPredefinedTypeAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_uintPredefinedTypeAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uintPredefinedTypeAST GGS_uintPredefinedTypeAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_string& argument_0,
                 const GGS_predefinedTypeKindEnum& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_uintPredefinedTypeAST result ;
  macroMyNew (result.mPointer, cPtr_uintPredefinedTypeAST (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_uintPredefinedTypeAST::actualTypeName (void) const {
  return "uintPredefinedTypeAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__uintPredefinedTypeAST ("uintPredefinedTypeAST", gClassInfoFor__predefinedTypeAST, & kTypeDescriptor_GGS_uintPredefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_uintPredefinedTypeAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_uintPredefinedTypeAST * p = NULL ;
    macroMyNew (p, GGS_uintPredefinedTypeAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uintPredefinedTypeAST GGS_uintPredefinedTypeAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_uintPredefinedTypeAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_uintPredefinedTypeAST * p = dynamic_cast <const GGS_uintPredefinedTypeAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_uintPredefinedTypeAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_uintPredefinedTypeAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_uintPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_uint64PredefinedTypeAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_uint64PredefinedTypeAST::
cPtr_uint64PredefinedTypeAST (const GGS_string& argument_0,
                                const GGS_predefinedTypeKindEnum& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_predefinedTypeAST (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_uint64PredefinedTypeAST * GGS_uint64PredefinedTypeAST::
  operator () (LOCATION_ARGS) const {
    macroValidSharedObjectThere (mPointer, cPtr_uint64PredefinedTypeAST) ;
    return (cPtr_uint64PredefinedTypeAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_uint64PredefinedTypeAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_uint64PredefinedTypeAST * ptr = dynamic_cast <const cPtr_uint64PredefinedTypeAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mPredefinedTypeName.operator_isEqual (ptr->mPredefinedTypeName).boolValue ()
         && mKind.operator_isEqual (ptr->mKind).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_uint64PredefinedTypeAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@uint64PredefinedTypeAST:"
           << mPredefinedTypeName.reader_description (inIndentation + 1)
           << mKind.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_uint64PredefinedTypeAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_uint64PredefinedTypeAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_uint64PredefinedTypeAST (& typeid (cPtr_uint64PredefinedTypeAST), & typeid (cPtr_predefinedTypeAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_uint64PredefinedTypeAST::galgasRTTI (void) const {
  return & gClassInfoFor__uint64PredefinedTypeAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_uint64PredefinedTypeAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_uint64PredefinedTypeAST (mPredefinedTypeName, mKind COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_uint64PredefinedTypeAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_uint64PredefinedTypeAST ("uint64PredefinedTypeAST", true, & kTypeDescriptor_GGS_predefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_uint64PredefinedTypeAST::
GGS_uint64PredefinedTypeAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignSharedObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_uint64PredefinedTypeAST::
GGS_uint64PredefinedTypeAST (cPtr__AC_galgas_class & inObject) {
  macroAssignSharedObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_uint64PredefinedTypeAST GGS_uint64PredefinedTypeAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_uint64PredefinedTypeAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_uint64PredefinedTypeAST *> (inPointer) != NULL)
      : (typeid (cPtr_uint64PredefinedTypeAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_uint64PredefinedTypeAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_uint64PredefinedTypeAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint64PredefinedTypeAST GGS_uint64PredefinedTypeAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_string& argument_0,
                 const GGS_predefinedTypeKindEnum& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_uint64PredefinedTypeAST result ;
  macroMyNew (result.mPointer, cPtr_uint64PredefinedTypeAST (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_uint64PredefinedTypeAST::actualTypeName (void) const {
  return "uint64PredefinedTypeAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__uint64PredefinedTypeAST ("uint64PredefinedTypeAST", gClassInfoFor__predefinedTypeAST, & kTypeDescriptor_GGS_uint64PredefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_uint64PredefinedTypeAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_uint64PredefinedTypeAST * p = NULL ;
    macroMyNew (p, GGS_uint64PredefinedTypeAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint64PredefinedTypeAST GGS_uint64PredefinedTypeAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_uint64PredefinedTypeAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_uint64PredefinedTypeAST * p = dynamic_cast <const GGS_uint64PredefinedTypeAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_uint64PredefinedTypeAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_uint64PredefinedTypeAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_uint64PredefinedTypeAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_sintPredefinedTypeAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_sintPredefinedTypeAST::
cPtr_sintPredefinedTypeAST (const GGS_string& argument_0,
                                const GGS_predefinedTypeKindEnum& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_predefinedTypeAST (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_sintPredefinedTypeAST * GGS_sintPredefinedTypeAST::
  operator () (LOCATION_ARGS) const {
    macroValidSharedObjectThere (mPointer, cPtr_sintPredefinedTypeAST) ;
    return (cPtr_sintPredefinedTypeAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_sintPredefinedTypeAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_sintPredefinedTypeAST * ptr = dynamic_cast <const cPtr_sintPredefinedTypeAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mPredefinedTypeName.operator_isEqual (ptr->mPredefinedTypeName).boolValue ()
         && mKind.operator_isEqual (ptr->mKind).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_sintPredefinedTypeAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@sintPredefinedTypeAST:"
           << mPredefinedTypeName.reader_description (inIndentation + 1)
           << mKind.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_sintPredefinedTypeAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_sintPredefinedTypeAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_sintPredefinedTypeAST (& typeid (cPtr_sintPredefinedTypeAST), & typeid (cPtr_predefinedTypeAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_sintPredefinedTypeAST::galgasRTTI (void) const {
  return & gClassInfoFor__sintPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_sintPredefinedTypeAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_sintPredefinedTypeAST (mPredefinedTypeName, mKind COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_sintPredefinedTypeAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_sintPredefinedTypeAST ("sintPredefinedTypeAST", true, & kTypeDescriptor_GGS_predefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_sintPredefinedTypeAST::
GGS_sintPredefinedTypeAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignSharedObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_sintPredefinedTypeAST::
GGS_sintPredefinedTypeAST (cPtr__AC_galgas_class & inObject) {
  macroAssignSharedObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_sintPredefinedTypeAST GGS_sintPredefinedTypeAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_sintPredefinedTypeAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_sintPredefinedTypeAST *> (inPointer) != NULL)
      : (typeid (cPtr_sintPredefinedTypeAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_sintPredefinedTypeAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_sintPredefinedTypeAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sintPredefinedTypeAST GGS_sintPredefinedTypeAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_string& argument_0,
                 const GGS_predefinedTypeKindEnum& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_sintPredefinedTypeAST result ;
  macroMyNew (result.mPointer, cPtr_sintPredefinedTypeAST (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_sintPredefinedTypeAST::actualTypeName (void) const {
  return "sintPredefinedTypeAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__sintPredefinedTypeAST ("sintPredefinedTypeAST", gClassInfoFor__predefinedTypeAST, & kTypeDescriptor_GGS_sintPredefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_sintPredefinedTypeAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_sintPredefinedTypeAST * p = NULL ;
    macroMyNew (p, GGS_sintPredefinedTypeAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sintPredefinedTypeAST GGS_sintPredefinedTypeAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_sintPredefinedTypeAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_sintPredefinedTypeAST * p = dynamic_cast <const GGS_sintPredefinedTypeAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_sintPredefinedTypeAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_sintPredefinedTypeAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_sintPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_sint64PredefinedTypeAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_sint64PredefinedTypeAST::
cPtr_sint64PredefinedTypeAST (const GGS_string& argument_0,
                                const GGS_predefinedTypeKindEnum& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_predefinedTypeAST (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_sint64PredefinedTypeAST * GGS_sint64PredefinedTypeAST::
  operator () (LOCATION_ARGS) const {
    macroValidSharedObjectThere (mPointer, cPtr_sint64PredefinedTypeAST) ;
    return (cPtr_sint64PredefinedTypeAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_sint64PredefinedTypeAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_sint64PredefinedTypeAST * ptr = dynamic_cast <const cPtr_sint64PredefinedTypeAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mPredefinedTypeName.operator_isEqual (ptr->mPredefinedTypeName).boolValue ()
         && mKind.operator_isEqual (ptr->mKind).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_sint64PredefinedTypeAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@sint64PredefinedTypeAST:"
           << mPredefinedTypeName.reader_description (inIndentation + 1)
           << mKind.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_sint64PredefinedTypeAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_sint64PredefinedTypeAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_sint64PredefinedTypeAST (& typeid (cPtr_sint64PredefinedTypeAST), & typeid (cPtr_predefinedTypeAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_sint64PredefinedTypeAST::galgasRTTI (void) const {
  return & gClassInfoFor__sint64PredefinedTypeAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_sint64PredefinedTypeAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_sint64PredefinedTypeAST (mPredefinedTypeName, mKind COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_sint64PredefinedTypeAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_sint64PredefinedTypeAST ("sint64PredefinedTypeAST", true, & kTypeDescriptor_GGS_predefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_sint64PredefinedTypeAST::
GGS_sint64PredefinedTypeAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignSharedObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_sint64PredefinedTypeAST::
GGS_sint64PredefinedTypeAST (cPtr__AC_galgas_class & inObject) {
  macroAssignSharedObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_sint64PredefinedTypeAST GGS_sint64PredefinedTypeAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_sint64PredefinedTypeAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_sint64PredefinedTypeAST *> (inPointer) != NULL)
      : (typeid (cPtr_sint64PredefinedTypeAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_sint64PredefinedTypeAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_sint64PredefinedTypeAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sint64PredefinedTypeAST GGS_sint64PredefinedTypeAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_string& argument_0,
                 const GGS_predefinedTypeKindEnum& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_sint64PredefinedTypeAST result ;
  macroMyNew (result.mPointer, cPtr_sint64PredefinedTypeAST (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_sint64PredefinedTypeAST::actualTypeName (void) const {
  return "sint64PredefinedTypeAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__sint64PredefinedTypeAST ("sint64PredefinedTypeAST", gClassInfoFor__predefinedTypeAST, & kTypeDescriptor_GGS_sint64PredefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_sint64PredefinedTypeAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_sint64PredefinedTypeAST * p = NULL ;
    macroMyNew (p, GGS_sint64PredefinedTypeAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sint64PredefinedTypeAST GGS_sint64PredefinedTypeAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_sint64PredefinedTypeAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_sint64PredefinedTypeAST * p = dynamic_cast <const GGS_sint64PredefinedTypeAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_sint64PredefinedTypeAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_sint64PredefinedTypeAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_sint64PredefinedTypeAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_charPredefinedTypeAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_charPredefinedTypeAST::
cPtr_charPredefinedTypeAST (const GGS_string& argument_0,
                                const GGS_predefinedTypeKindEnum& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_predefinedTypeAST (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_charPredefinedTypeAST * GGS_charPredefinedTypeAST::
  operator () (LOCATION_ARGS) const {
    macroValidSharedObjectThere (mPointer, cPtr_charPredefinedTypeAST) ;
    return (cPtr_charPredefinedTypeAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_charPredefinedTypeAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_charPredefinedTypeAST * ptr = dynamic_cast <const cPtr_charPredefinedTypeAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mPredefinedTypeName.operator_isEqual (ptr->mPredefinedTypeName).boolValue ()
         && mKind.operator_isEqual (ptr->mKind).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_charPredefinedTypeAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@charPredefinedTypeAST:"
           << mPredefinedTypeName.reader_description (inIndentation + 1)
           << mKind.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_charPredefinedTypeAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_charPredefinedTypeAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_charPredefinedTypeAST (& typeid (cPtr_charPredefinedTypeAST), & typeid (cPtr_predefinedTypeAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_charPredefinedTypeAST::galgasRTTI (void) const {
  return & gClassInfoFor__charPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_charPredefinedTypeAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_charPredefinedTypeAST (mPredefinedTypeName, mKind COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_charPredefinedTypeAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_charPredefinedTypeAST ("charPredefinedTypeAST", true, & kTypeDescriptor_GGS_predefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_charPredefinedTypeAST::
GGS_charPredefinedTypeAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignSharedObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_charPredefinedTypeAST::
GGS_charPredefinedTypeAST (cPtr__AC_galgas_class & inObject) {
  macroAssignSharedObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_charPredefinedTypeAST GGS_charPredefinedTypeAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_charPredefinedTypeAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_charPredefinedTypeAST *> (inPointer) != NULL)
      : (typeid (cPtr_charPredefinedTypeAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_charPredefinedTypeAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_charPredefinedTypeAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_charPredefinedTypeAST GGS_charPredefinedTypeAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_string& argument_0,
                 const GGS_predefinedTypeKindEnum& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_charPredefinedTypeAST result ;
  macroMyNew (result.mPointer, cPtr_charPredefinedTypeAST (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_charPredefinedTypeAST::actualTypeName (void) const {
  return "charPredefinedTypeAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__charPredefinedTypeAST ("charPredefinedTypeAST", gClassInfoFor__predefinedTypeAST, & kTypeDescriptor_GGS_charPredefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_charPredefinedTypeAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_charPredefinedTypeAST * p = NULL ;
    macroMyNew (p, GGS_charPredefinedTypeAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_charPredefinedTypeAST GGS_charPredefinedTypeAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_charPredefinedTypeAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_charPredefinedTypeAST * p = dynamic_cast <const GGS_charPredefinedTypeAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_charPredefinedTypeAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_charPredefinedTypeAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_charPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_doublePredefinedTypeAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_doublePredefinedTypeAST::
cPtr_doublePredefinedTypeAST (const GGS_string& argument_0,
                                const GGS_predefinedTypeKindEnum& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_predefinedTypeAST (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_doublePredefinedTypeAST * GGS_doublePredefinedTypeAST::
  operator () (LOCATION_ARGS) const {
    macroValidSharedObjectThere (mPointer, cPtr_doublePredefinedTypeAST) ;
    return (cPtr_doublePredefinedTypeAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_doublePredefinedTypeAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_doublePredefinedTypeAST * ptr = dynamic_cast <const cPtr_doublePredefinedTypeAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mPredefinedTypeName.operator_isEqual (ptr->mPredefinedTypeName).boolValue ()
         && mKind.operator_isEqual (ptr->mKind).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_doublePredefinedTypeAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@doublePredefinedTypeAST:"
           << mPredefinedTypeName.reader_description (inIndentation + 1)
           << mKind.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_doublePredefinedTypeAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_doublePredefinedTypeAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_doublePredefinedTypeAST (& typeid (cPtr_doublePredefinedTypeAST), & typeid (cPtr_predefinedTypeAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_doublePredefinedTypeAST::galgasRTTI (void) const {
  return & gClassInfoFor__doublePredefinedTypeAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_doublePredefinedTypeAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_doublePredefinedTypeAST (mPredefinedTypeName, mKind COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_doublePredefinedTypeAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_doublePredefinedTypeAST ("doublePredefinedTypeAST", true, & kTypeDescriptor_GGS_predefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_doublePredefinedTypeAST::
GGS_doublePredefinedTypeAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignSharedObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_doublePredefinedTypeAST::
GGS_doublePredefinedTypeAST (cPtr__AC_galgas_class & inObject) {
  macroAssignSharedObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_doublePredefinedTypeAST GGS_doublePredefinedTypeAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_doublePredefinedTypeAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_doublePredefinedTypeAST *> (inPointer) != NULL)
      : (typeid (cPtr_doublePredefinedTypeAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_doublePredefinedTypeAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_doublePredefinedTypeAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_doublePredefinedTypeAST GGS_doublePredefinedTypeAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_string& argument_0,
                 const GGS_predefinedTypeKindEnum& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_doublePredefinedTypeAST result ;
  macroMyNew (result.mPointer, cPtr_doublePredefinedTypeAST (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_doublePredefinedTypeAST::actualTypeName (void) const {
  return "doublePredefinedTypeAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__doublePredefinedTypeAST ("doublePredefinedTypeAST", gClassInfoFor__predefinedTypeAST, & kTypeDescriptor_GGS_doublePredefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_doublePredefinedTypeAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_doublePredefinedTypeAST * p = NULL ;
    macroMyNew (p, GGS_doublePredefinedTypeAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_doublePredefinedTypeAST GGS_doublePredefinedTypeAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_doublePredefinedTypeAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_doublePredefinedTypeAST * p = dynamic_cast <const GGS_doublePredefinedTypeAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_doublePredefinedTypeAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_doublePredefinedTypeAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_doublePredefinedTypeAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_stringPredefinedTypeAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_stringPredefinedTypeAST::
cPtr_stringPredefinedTypeAST (const GGS_string& argument_0,
                                const GGS_predefinedTypeKindEnum& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_predefinedTypeAST (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_stringPredefinedTypeAST * GGS_stringPredefinedTypeAST::
  operator () (LOCATION_ARGS) const {
    macroValidSharedObjectThere (mPointer, cPtr_stringPredefinedTypeAST) ;
    return (cPtr_stringPredefinedTypeAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_stringPredefinedTypeAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_stringPredefinedTypeAST * ptr = dynamic_cast <const cPtr_stringPredefinedTypeAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mPredefinedTypeName.operator_isEqual (ptr->mPredefinedTypeName).boolValue ()
         && mKind.operator_isEqual (ptr->mKind).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_stringPredefinedTypeAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@stringPredefinedTypeAST:"
           << mPredefinedTypeName.reader_description (inIndentation + 1)
           << mKind.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_stringPredefinedTypeAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_stringPredefinedTypeAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_stringPredefinedTypeAST (& typeid (cPtr_stringPredefinedTypeAST), & typeid (cPtr_predefinedTypeAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_stringPredefinedTypeAST::galgasRTTI (void) const {
  return & gClassInfoFor__stringPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_stringPredefinedTypeAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_stringPredefinedTypeAST (mPredefinedTypeName, mKind COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_stringPredefinedTypeAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_stringPredefinedTypeAST ("stringPredefinedTypeAST", true, & kTypeDescriptor_GGS_predefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_stringPredefinedTypeAST::
GGS_stringPredefinedTypeAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignSharedObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_stringPredefinedTypeAST::
GGS_stringPredefinedTypeAST (cPtr__AC_galgas_class & inObject) {
  macroAssignSharedObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_stringPredefinedTypeAST GGS_stringPredefinedTypeAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_stringPredefinedTypeAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_stringPredefinedTypeAST *> (inPointer) != NULL)
      : (typeid (cPtr_stringPredefinedTypeAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_stringPredefinedTypeAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_stringPredefinedTypeAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringPredefinedTypeAST GGS_stringPredefinedTypeAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_string& argument_0,
                 const GGS_predefinedTypeKindEnum& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_stringPredefinedTypeAST result ;
  macroMyNew (result.mPointer, cPtr_stringPredefinedTypeAST (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_stringPredefinedTypeAST::actualTypeName (void) const {
  return "stringPredefinedTypeAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__stringPredefinedTypeAST ("stringPredefinedTypeAST", gClassInfoFor__predefinedTypeAST, & kTypeDescriptor_GGS_stringPredefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_stringPredefinedTypeAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_stringPredefinedTypeAST * p = NULL ;
    macroMyNew (p, GGS_stringPredefinedTypeAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringPredefinedTypeAST GGS_stringPredefinedTypeAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_stringPredefinedTypeAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_stringPredefinedTypeAST * p = dynamic_cast <const GGS_stringPredefinedTypeAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_stringPredefinedTypeAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_stringPredefinedTypeAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_stringPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_locationPredefinedTypeAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_locationPredefinedTypeAST::
cPtr_locationPredefinedTypeAST (const GGS_string& argument_0,
                                const GGS_predefinedTypeKindEnum& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_predefinedTypeAST (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_locationPredefinedTypeAST * GGS_locationPredefinedTypeAST::
  operator () (LOCATION_ARGS) const {
    macroValidSharedObjectThere (mPointer, cPtr_locationPredefinedTypeAST) ;
    return (cPtr_locationPredefinedTypeAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_locationPredefinedTypeAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_locationPredefinedTypeAST * ptr = dynamic_cast <const cPtr_locationPredefinedTypeAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mPredefinedTypeName.operator_isEqual (ptr->mPredefinedTypeName).boolValue ()
         && mKind.operator_isEqual (ptr->mKind).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_locationPredefinedTypeAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@locationPredefinedTypeAST:"
           << mPredefinedTypeName.reader_description (inIndentation + 1)
           << mKind.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_locationPredefinedTypeAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_locationPredefinedTypeAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_locationPredefinedTypeAST (& typeid (cPtr_locationPredefinedTypeAST), & typeid (cPtr_predefinedTypeAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_locationPredefinedTypeAST::galgasRTTI (void) const {
  return & gClassInfoFor__locationPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_locationPredefinedTypeAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_locationPredefinedTypeAST (mPredefinedTypeName, mKind COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_locationPredefinedTypeAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_locationPredefinedTypeAST ("locationPredefinedTypeAST", true, & kTypeDescriptor_GGS_predefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_locationPredefinedTypeAST::
GGS_locationPredefinedTypeAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignSharedObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_locationPredefinedTypeAST::
GGS_locationPredefinedTypeAST (cPtr__AC_galgas_class & inObject) {
  macroAssignSharedObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_locationPredefinedTypeAST GGS_locationPredefinedTypeAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_locationPredefinedTypeAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_locationPredefinedTypeAST *> (inPointer) != NULL)
      : (typeid (cPtr_locationPredefinedTypeAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_locationPredefinedTypeAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_locationPredefinedTypeAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_locationPredefinedTypeAST GGS_locationPredefinedTypeAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_string& argument_0,
                 const GGS_predefinedTypeKindEnum& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_locationPredefinedTypeAST result ;
  macroMyNew (result.mPointer, cPtr_locationPredefinedTypeAST (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_locationPredefinedTypeAST::actualTypeName (void) const {
  return "locationPredefinedTypeAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__locationPredefinedTypeAST ("locationPredefinedTypeAST", gClassInfoFor__predefinedTypeAST, & kTypeDescriptor_GGS_locationPredefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_locationPredefinedTypeAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_locationPredefinedTypeAST * p = NULL ;
    macroMyNew (p, GGS_locationPredefinedTypeAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_locationPredefinedTypeAST GGS_locationPredefinedTypeAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_locationPredefinedTypeAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_locationPredefinedTypeAST * p = dynamic_cast <const GGS_locationPredefinedTypeAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_locationPredefinedTypeAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_locationPredefinedTypeAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_locationPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_stringsetPredefinedTypeAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_stringsetPredefinedTypeAST::
cPtr_stringsetPredefinedTypeAST (const GGS_string& argument_0,
                                const GGS_predefinedTypeKindEnum& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_predefinedTypeAST (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_stringsetPredefinedTypeAST * GGS_stringsetPredefinedTypeAST::
  operator () (LOCATION_ARGS) const {
    macroValidSharedObjectThere (mPointer, cPtr_stringsetPredefinedTypeAST) ;
    return (cPtr_stringsetPredefinedTypeAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_stringsetPredefinedTypeAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_stringsetPredefinedTypeAST * ptr = dynamic_cast <const cPtr_stringsetPredefinedTypeAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mPredefinedTypeName.operator_isEqual (ptr->mPredefinedTypeName).boolValue ()
         && mKind.operator_isEqual (ptr->mKind).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_stringsetPredefinedTypeAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@stringsetPredefinedTypeAST:"
           << mPredefinedTypeName.reader_description (inIndentation + 1)
           << mKind.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_stringsetPredefinedTypeAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_stringsetPredefinedTypeAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_stringsetPredefinedTypeAST (& typeid (cPtr_stringsetPredefinedTypeAST), & typeid (cPtr_predefinedTypeAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_stringsetPredefinedTypeAST::galgasRTTI (void) const {
  return & gClassInfoFor__stringsetPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_stringsetPredefinedTypeAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_stringsetPredefinedTypeAST (mPredefinedTypeName, mKind COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_stringsetPredefinedTypeAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_stringsetPredefinedTypeAST ("stringsetPredefinedTypeAST", true, & kTypeDescriptor_GGS_predefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_stringsetPredefinedTypeAST::
GGS_stringsetPredefinedTypeAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignSharedObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_stringsetPredefinedTypeAST::
GGS_stringsetPredefinedTypeAST (cPtr__AC_galgas_class & inObject) {
  macroAssignSharedObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_stringsetPredefinedTypeAST GGS_stringsetPredefinedTypeAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_stringsetPredefinedTypeAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_stringsetPredefinedTypeAST *> (inPointer) != NULL)
      : (typeid (cPtr_stringsetPredefinedTypeAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_stringsetPredefinedTypeAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_stringsetPredefinedTypeAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringsetPredefinedTypeAST GGS_stringsetPredefinedTypeAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_string& argument_0,
                 const GGS_predefinedTypeKindEnum& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_stringsetPredefinedTypeAST result ;
  macroMyNew (result.mPointer, cPtr_stringsetPredefinedTypeAST (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_stringsetPredefinedTypeAST::actualTypeName (void) const {
  return "stringsetPredefinedTypeAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__stringsetPredefinedTypeAST ("stringsetPredefinedTypeAST", gClassInfoFor__predefinedTypeAST, & kTypeDescriptor_GGS_stringsetPredefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_stringsetPredefinedTypeAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_stringsetPredefinedTypeAST * p = NULL ;
    macroMyNew (p, GGS_stringsetPredefinedTypeAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringsetPredefinedTypeAST GGS_stringsetPredefinedTypeAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_stringsetPredefinedTypeAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_stringsetPredefinedTypeAST * p = dynamic_cast <const GGS_stringsetPredefinedTypeAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_stringsetPredefinedTypeAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_stringsetPredefinedTypeAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_stringsetPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_functionPredefinedTypeAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_functionPredefinedTypeAST::
cPtr_functionPredefinedTypeAST (const GGS_string& argument_0,
                                const GGS_predefinedTypeKindEnum& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_predefinedTypeAST (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_functionPredefinedTypeAST * GGS_functionPredefinedTypeAST::
  operator () (LOCATION_ARGS) const {
    macroValidSharedObjectThere (mPointer, cPtr_functionPredefinedTypeAST) ;
    return (cPtr_functionPredefinedTypeAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_functionPredefinedTypeAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_functionPredefinedTypeAST * ptr = dynamic_cast <const cPtr_functionPredefinedTypeAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mPredefinedTypeName.operator_isEqual (ptr->mPredefinedTypeName).boolValue ()
         && mKind.operator_isEqual (ptr->mKind).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_functionPredefinedTypeAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@functionPredefinedTypeAST:"
           << mPredefinedTypeName.reader_description (inIndentation + 1)
           << mKind.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_functionPredefinedTypeAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_functionPredefinedTypeAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_functionPredefinedTypeAST (& typeid (cPtr_functionPredefinedTypeAST), & typeid (cPtr_predefinedTypeAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_functionPredefinedTypeAST::galgasRTTI (void) const {
  return & gClassInfoFor__functionPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_functionPredefinedTypeAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_functionPredefinedTypeAST (mPredefinedTypeName, mKind COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_functionPredefinedTypeAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_functionPredefinedTypeAST ("functionPredefinedTypeAST", true, & kTypeDescriptor_GGS_predefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_functionPredefinedTypeAST::
GGS_functionPredefinedTypeAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignSharedObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_functionPredefinedTypeAST::
GGS_functionPredefinedTypeAST (cPtr__AC_galgas_class & inObject) {
  macroAssignSharedObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_functionPredefinedTypeAST GGS_functionPredefinedTypeAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_functionPredefinedTypeAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_functionPredefinedTypeAST *> (inPointer) != NULL)
      : (typeid (cPtr_functionPredefinedTypeAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_functionPredefinedTypeAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_functionPredefinedTypeAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_functionPredefinedTypeAST GGS_functionPredefinedTypeAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_string& argument_0,
                 const GGS_predefinedTypeKindEnum& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_functionPredefinedTypeAST result ;
  macroMyNew (result.mPointer, cPtr_functionPredefinedTypeAST (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_functionPredefinedTypeAST::actualTypeName (void) const {
  return "functionPredefinedTypeAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__functionPredefinedTypeAST ("functionPredefinedTypeAST", gClassInfoFor__predefinedTypeAST, & kTypeDescriptor_GGS_functionPredefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_functionPredefinedTypeAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_functionPredefinedTypeAST * p = NULL ;
    macroMyNew (p, GGS_functionPredefinedTypeAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_functionPredefinedTypeAST GGS_functionPredefinedTypeAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_functionPredefinedTypeAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_functionPredefinedTypeAST * p = dynamic_cast <const GGS_functionPredefinedTypeAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_functionPredefinedTypeAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_functionPredefinedTypeAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_functionPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_typePredefinedTypeAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typePredefinedTypeAST::
cPtr_typePredefinedTypeAST (const GGS_string& argument_0,
                                const GGS_predefinedTypeKindEnum& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_predefinedTypeAST (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typePredefinedTypeAST * GGS_typePredefinedTypeAST::
  operator () (LOCATION_ARGS) const {
    macroValidSharedObjectThere (mPointer, cPtr_typePredefinedTypeAST) ;
    return (cPtr_typePredefinedTypeAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typePredefinedTypeAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typePredefinedTypeAST * ptr = dynamic_cast <const cPtr_typePredefinedTypeAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mPredefinedTypeName.operator_isEqual (ptr->mPredefinedTypeName).boolValue ()
         && mKind.operator_isEqual (ptr->mKind).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typePredefinedTypeAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typePredefinedTypeAST:"
           << mPredefinedTypeName.reader_description (inIndentation + 1)
           << mKind.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typePredefinedTypeAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typePredefinedTypeAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typePredefinedTypeAST (& typeid (cPtr_typePredefinedTypeAST), & typeid (cPtr_predefinedTypeAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typePredefinedTypeAST::galgasRTTI (void) const {
  return & gClassInfoFor__typePredefinedTypeAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typePredefinedTypeAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typePredefinedTypeAST (mPredefinedTypeName, mKind COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typePredefinedTypeAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typePredefinedTypeAST ("typePredefinedTypeAST", true, & kTypeDescriptor_GGS_predefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_typePredefinedTypeAST::
GGS_typePredefinedTypeAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignSharedObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typePredefinedTypeAST::
GGS_typePredefinedTypeAST (cPtr__AC_galgas_class & inObject) {
  macroAssignSharedObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typePredefinedTypeAST GGS_typePredefinedTypeAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typePredefinedTypeAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typePredefinedTypeAST *> (inPointer) != NULL)
      : (typeid (cPtr_typePredefinedTypeAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typePredefinedTypeAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typePredefinedTypeAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typePredefinedTypeAST GGS_typePredefinedTypeAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_string& argument_0,
                 const GGS_predefinedTypeKindEnum& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typePredefinedTypeAST result ;
  macroMyNew (result.mPointer, cPtr_typePredefinedTypeAST (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typePredefinedTypeAST::actualTypeName (void) const {
  return "typePredefinedTypeAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typePredefinedTypeAST ("typePredefinedTypeAST", gClassInfoFor__predefinedTypeAST, & kTypeDescriptor_GGS_typePredefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typePredefinedTypeAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typePredefinedTypeAST * p = NULL ;
    macroMyNew (p, GGS_typePredefinedTypeAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typePredefinedTypeAST GGS_typePredefinedTypeAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typePredefinedTypeAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typePredefinedTypeAST * p = dynamic_cast <const GGS_typePredefinedTypeAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typePredefinedTypeAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typePredefinedTypeAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typePredefinedTypeAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_dataPredefinedTypeAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_dataPredefinedTypeAST::
cPtr_dataPredefinedTypeAST (const GGS_string& argument_0,
                                const GGS_predefinedTypeKindEnum& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_predefinedTypeAST (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_dataPredefinedTypeAST * GGS_dataPredefinedTypeAST::
  operator () (LOCATION_ARGS) const {
    macroValidSharedObjectThere (mPointer, cPtr_dataPredefinedTypeAST) ;
    return (cPtr_dataPredefinedTypeAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_dataPredefinedTypeAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_dataPredefinedTypeAST * ptr = dynamic_cast <const cPtr_dataPredefinedTypeAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mPredefinedTypeName.operator_isEqual (ptr->mPredefinedTypeName).boolValue ()
         && mKind.operator_isEqual (ptr->mKind).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_dataPredefinedTypeAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@dataPredefinedTypeAST:"
           << mPredefinedTypeName.reader_description (inIndentation + 1)
           << mKind.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_dataPredefinedTypeAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_dataPredefinedTypeAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_dataPredefinedTypeAST (& typeid (cPtr_dataPredefinedTypeAST), & typeid (cPtr_predefinedTypeAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_dataPredefinedTypeAST::galgasRTTI (void) const {
  return & gClassInfoFor__dataPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_dataPredefinedTypeAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_dataPredefinedTypeAST (mPredefinedTypeName, mKind COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_dataPredefinedTypeAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_dataPredefinedTypeAST ("dataPredefinedTypeAST", true, & kTypeDescriptor_GGS_predefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_dataPredefinedTypeAST::
GGS_dataPredefinedTypeAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignSharedObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_dataPredefinedTypeAST::
GGS_dataPredefinedTypeAST (cPtr__AC_galgas_class & inObject) {
  macroAssignSharedObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_dataPredefinedTypeAST GGS_dataPredefinedTypeAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_dataPredefinedTypeAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_dataPredefinedTypeAST *> (inPointer) != NULL)
      : (typeid (cPtr_dataPredefinedTypeAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_dataPredefinedTypeAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_dataPredefinedTypeAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_dataPredefinedTypeAST GGS_dataPredefinedTypeAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_string& argument_0,
                 const GGS_predefinedTypeKindEnum& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_dataPredefinedTypeAST result ;
  macroMyNew (result.mPointer, cPtr_dataPredefinedTypeAST (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_dataPredefinedTypeAST::actualTypeName (void) const {
  return "dataPredefinedTypeAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__dataPredefinedTypeAST ("dataPredefinedTypeAST", gClassInfoFor__predefinedTypeAST, & kTypeDescriptor_GGS_dataPredefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_dataPredefinedTypeAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_dataPredefinedTypeAST * p = NULL ;
    macroMyNew (p, GGS_dataPredefinedTypeAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_dataPredefinedTypeAST GGS_dataPredefinedTypeAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_dataPredefinedTypeAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_dataPredefinedTypeAST * p = dynamic_cast <const GGS_dataPredefinedTypeAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_dataPredefinedTypeAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_dataPredefinedTypeAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_dataPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Category method '@predefinedTypeAST.getConstructorMap'           *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__predefinedTypeAST__getConstructorMap (C_CompilerEx & inLexique,
                                const cPtr_predefinedTypeAST * operand_15668,
                                GGS_unifiedTypeMap  & /* var_cas_ioUnifiedTypeMap */,
                                GGS_constructorMap  & var_cas_outConstructorMap
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_15668 != NULL) {
    var_cas_outConstructorMap = GGS_constructorMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (357)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
// Virtual Table for category method '@predefinedTypeAST.getConstructorMap'  *
//                                                                           *
//---------------------------------------------------------------------------*

static TC_UniqueArray <typeCategoryMethod__predefinedTypeAST__getConstructorMap> gDispatchTableForMethod__predefinedTypeAST__getConstructorMap ;

//---------------------------------------------------------------------------*

void
enterCategoryMethod__predefinedTypeAST__getConstructorMap (typeCategoryMethod__predefinedTypeAST__getConstructorMap inRoutine,
                     const PMSInt32 inClassID) {
  gDispatchTableForMethod__predefinedTypeAST__getConstructorMap.forceObjectAtIndex (inClassID, inRoutine, NULL COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

typeCategoryMethod__predefinedTypeAST__getConstructorMap
findCategoryMethod__predefinedTypeAST__getConstructorMap (AC_galgasClassRunTimeInformationEX * inClassPtr) {
  typeCategoryMethod__predefinedTypeAST__getConstructorMap result = NULL ;
  if (NULL != inClassPtr) {
    if (inClassPtr->slotID () < gDispatchTableForMethod__predefinedTypeAST__getConstructorMap.count ()) {
      result = gDispatchTableForMethod__predefinedTypeAST__getConstructorMap (inClassPtr->slotID () COMMA_HERE) ;
    }
    if (NULL == result) {
      AC_galgasClassRunTimeInformationEX * superClassPtr = inClassPtr->superClassPtr () ;
      if (superClassPtr != NULL) {
        result = findCategoryMethod__predefinedTypeAST__getConstructorMap (superClassPtr) ;
        gDispatchTableForMethod__predefinedTypeAST__getConstructorMap.forceObjectAtIndex (inClassPtr->slotID (), result, NULL COMMA_HERE) ;
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Category method '@predefinedTypeAST.getReaderMap'              *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__predefinedTypeAST__getReaderMap (C_CompilerEx & inLexique,
                                const cPtr_predefinedTypeAST * operand_15935,
                                GGS_unifiedTypeMap  & /* var_cas_ioUnifiedTypeMap */,
                                GGS_readerMap  & var_cas_outReaderMap
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_15935 != NULL) {
    var_cas_outReaderMap = GGS_readerMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (366)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//   Virtual Table for category method '@predefinedTypeAST.getReaderMap'     *
//                                                                           *
//---------------------------------------------------------------------------*

static TC_UniqueArray <typeCategoryMethod__predefinedTypeAST__getReaderMap> gDispatchTableForMethod__predefinedTypeAST__getReaderMap ;

//---------------------------------------------------------------------------*

void
enterCategoryMethod__predefinedTypeAST__getReaderMap (typeCategoryMethod__predefinedTypeAST__getReaderMap inRoutine,
                     const PMSInt32 inClassID) {
  gDispatchTableForMethod__predefinedTypeAST__getReaderMap.forceObjectAtIndex (inClassID, inRoutine, NULL COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

typeCategoryMethod__predefinedTypeAST__getReaderMap
findCategoryMethod__predefinedTypeAST__getReaderMap (AC_galgasClassRunTimeInformationEX * inClassPtr) {
  typeCategoryMethod__predefinedTypeAST__getReaderMap result = NULL ;
  if (NULL != inClassPtr) {
    if (inClassPtr->slotID () < gDispatchTableForMethod__predefinedTypeAST__getReaderMap.count ()) {
      result = gDispatchTableForMethod__predefinedTypeAST__getReaderMap (inClassPtr->slotID () COMMA_HERE) ;
    }
    if (NULL == result) {
      AC_galgasClassRunTimeInformationEX * superClassPtr = inClassPtr->superClassPtr () ;
      if (superClassPtr != NULL) {
        result = findCategoryMethod__predefinedTypeAST__getReaderMap (superClassPtr) ;
        gDispatchTableForMethod__predefinedTypeAST__getReaderMap.forceObjectAtIndex (inClassPtr->slotID (), result, NULL COMMA_HERE) ;
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Category method '@predefinedTypeAST.getModifierMap'             *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__predefinedTypeAST__getModifierMap (C_CompilerEx & inLexique,
                                const cPtr_predefinedTypeAST * operand_16184,
                                GGS_unifiedTypeMap  & /* var_cas_ioUnifiedTypeMap */,
                                GGS_modifierMap  & var_cas_outModifierMap
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_16184 != NULL) {
    var_cas_outModifierMap = GGS_modifierMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (375)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//  Virtual Table for category method '@predefinedTypeAST.getModifierMap'    *
//                                                                           *
//---------------------------------------------------------------------------*

static TC_UniqueArray <typeCategoryMethod__predefinedTypeAST__getModifierMap> gDispatchTableForMethod__predefinedTypeAST__getModifierMap ;

//---------------------------------------------------------------------------*

void
enterCategoryMethod__predefinedTypeAST__getModifierMap (typeCategoryMethod__predefinedTypeAST__getModifierMap inRoutine,
                     const PMSInt32 inClassID) {
  gDispatchTableForMethod__predefinedTypeAST__getModifierMap.forceObjectAtIndex (inClassID, inRoutine, NULL COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

typeCategoryMethod__predefinedTypeAST__getModifierMap
findCategoryMethod__predefinedTypeAST__getModifierMap (AC_galgasClassRunTimeInformationEX * inClassPtr) {
  typeCategoryMethod__predefinedTypeAST__getModifierMap result = NULL ;
  if (NULL != inClassPtr) {
    if (inClassPtr->slotID () < gDispatchTableForMethod__predefinedTypeAST__getModifierMap.count ()) {
      result = gDispatchTableForMethod__predefinedTypeAST__getModifierMap (inClassPtr->slotID () COMMA_HERE) ;
    }
    if (NULL == result) {
      AC_galgasClassRunTimeInformationEX * superClassPtr = inClassPtr->superClassPtr () ;
      if (superClassPtr != NULL) {
        result = findCategoryMethod__predefinedTypeAST__getModifierMap (superClassPtr) ;
        gDispatchTableForMethod__predefinedTypeAST__getModifierMap.forceObjectAtIndex (inClassPtr->slotID (), result, NULL COMMA_HERE) ;
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        Category method '@predefinedTypeAST.getInstanceMethodMap'          *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__predefinedTypeAST__getInstanceMethodMap (C_CompilerEx & inLexique,
                                const cPtr_predefinedTypeAST * operand_16447,
                                GGS_unifiedTypeMap  & /* var_cas_ioUnifiedTypeMap */,
                                GGS_instanceMethodMap  & var_cas_outInstanceMethodMap
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_16447 != NULL) {
    var_cas_outInstanceMethodMap = GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (384)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//Virtual Table for category method '@predefinedTypeAST.getInstanceMethodMap'*
//                                                                           *
//---------------------------------------------------------------------------*

static TC_UniqueArray <typeCategoryMethod__predefinedTypeAST__getInstanceMethodMap> gDispatchTableForMethod__predefinedTypeAST__getInstanceMethodMap ;

//---------------------------------------------------------------------------*

void
enterCategoryMethod__predefinedTypeAST__getInstanceMethodMap (typeCategoryMethod__predefinedTypeAST__getInstanceMethodMap inRoutine,
                     const PMSInt32 inClassID) {
  gDispatchTableForMethod__predefinedTypeAST__getInstanceMethodMap.forceObjectAtIndex (inClassID, inRoutine, NULL COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

typeCategoryMethod__predefinedTypeAST__getInstanceMethodMap
findCategoryMethod__predefinedTypeAST__getInstanceMethodMap (AC_galgasClassRunTimeInformationEX * inClassPtr) {
  typeCategoryMethod__predefinedTypeAST__getInstanceMethodMap result = NULL ;
  if (NULL != inClassPtr) {
    if (inClassPtr->slotID () < gDispatchTableForMethod__predefinedTypeAST__getInstanceMethodMap.count ()) {
      result = gDispatchTableForMethod__predefinedTypeAST__getInstanceMethodMap (inClassPtr->slotID () COMMA_HERE) ;
    }
    if (NULL == result) {
      AC_galgasClassRunTimeInformationEX * superClassPtr = inClassPtr->superClassPtr () ;
      if (superClassPtr != NULL) {
        result = findCategoryMethod__predefinedTypeAST__getInstanceMethodMap (superClassPtr) ;
        gDispatchTableForMethod__predefinedTypeAST__getInstanceMethodMap.forceObjectAtIndex (inClassPtr->slotID (), result, NULL COMMA_HERE) ;
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Category method '@predefinedTypeAST.getClassMethodMap'           *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__predefinedTypeAST__getClassMethodMap (C_CompilerEx & inLexique,
                                const cPtr_predefinedTypeAST * operand_16731,
                                GGS_unifiedTypeMap  & /* var_cas_ioUnifiedTypeMap */,
                                GGS_classMethodMap  & var_cas_outClassMethodMap
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_16731 != NULL) {
    var_cas_outClassMethodMap = GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (393)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
// Virtual Table for category method '@predefinedTypeAST.getClassMethodMap'  *
//                                                                           *
//---------------------------------------------------------------------------*

static TC_UniqueArray <typeCategoryMethod__predefinedTypeAST__getClassMethodMap> gDispatchTableForMethod__predefinedTypeAST__getClassMethodMap ;

//---------------------------------------------------------------------------*

void
enterCategoryMethod__predefinedTypeAST__getClassMethodMap (typeCategoryMethod__predefinedTypeAST__getClassMethodMap inRoutine,
                     const PMSInt32 inClassID) {
  gDispatchTableForMethod__predefinedTypeAST__getClassMethodMap.forceObjectAtIndex (inClassID, inRoutine, NULL COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

typeCategoryMethod__predefinedTypeAST__getClassMethodMap
findCategoryMethod__predefinedTypeAST__getClassMethodMap (AC_galgasClassRunTimeInformationEX * inClassPtr) {
  typeCategoryMethod__predefinedTypeAST__getClassMethodMap result = NULL ;
  if (NULL != inClassPtr) {
    if (inClassPtr->slotID () < gDispatchTableForMethod__predefinedTypeAST__getClassMethodMap.count ()) {
      result = gDispatchTableForMethod__predefinedTypeAST__getClassMethodMap (inClassPtr->slotID () COMMA_HERE) ;
    }
    if (NULL == result) {
      AC_galgasClassRunTimeInformationEX * superClassPtr = inClassPtr->superClassPtr () ;
      if (superClassPtr != NULL) {
        result = findCategoryMethod__predefinedTypeAST__getClassMethodMap (superClassPtr) ;
        gDispatchTableForMethod__predefinedTypeAST__getClassMethodMap.forceObjectAtIndex (inClassPtr->slotID (), result, NULL COMMA_HERE) ;
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Category reader '@predefinedTypeAST.getSupportedOperatorFlags'       *
//                                                                           *
//---------------------------------------------------------------------------*

static GGS_uint 
category_reader__predefinedTypeAST__getSupportedOperatorFlags (C_CompilerEx &,
                                const cPtr_predefinedTypeAST * operand_17011
                                COMMA_UNUSED_LOCATION_ARGS) {
  GGS_uint  var_cas_outFlags ;
  if (operand_17011 != NULL) {
    var_cas_outFlags = GGS_uint (0U) ;
  }
  return var_cas_outFlags ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//Virtual Table for category reader '@predefinedTypeAST.getSupportedOperatorFlags'*
//                                                                           *
//---------------------------------------------------------------------------*

static TC_UniqueArray <typeCategoryReader__predefinedTypeAST__getSupportedOperatorFlags> gDispatchTableForReader__predefinedTypeAST__getSupportedOperatorFlags ;

//---------------------------------------------------------------------------*

void
enterCategoryReader__predefinedTypeAST__getSupportedOperatorFlags (typeCategoryReader__predefinedTypeAST__getSupportedOperatorFlags inRoutine,
                     const PMSInt32 inClassID) {
  gDispatchTableForReader__predefinedTypeAST__getSupportedOperatorFlags.forceObjectAtIndex (inClassID, inRoutine, NULL COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

static GGS_uint 
category_reader__predefinedTypeAST_defaultReader_getSupportedOperatorFlags (C_CompilerEx &,
                                const cPtr_predefinedTypeAST *
                                COMMA_UNUSED_LOCATION_ARGS) {
  return GGS_uint  () ;
}

//---------------------------------------------------------------------------*

typeCategoryReader__predefinedTypeAST__getSupportedOperatorFlags
findCategoryReader__predefinedTypeAST__getSupportedOperatorFlags (AC_galgasClassRunTimeInformationEX * inClassPtr) {
  typeCategoryReader__predefinedTypeAST__getSupportedOperatorFlags result = NULL ;
  if (NULL != inClassPtr) {
    if (inClassPtr->slotID () < gDispatchTableForReader__predefinedTypeAST__getSupportedOperatorFlags.count ()) {
      result = gDispatchTableForReader__predefinedTypeAST__getSupportedOperatorFlags (inClassPtr->slotID () COMMA_HERE) ;
    }
    if (NULL == result) {
      AC_galgasClassRunTimeInformationEX * superClassPtr = inClassPtr->superClassPtr () ;
      if (superClassPtr != NULL) {
        result = findCategoryReader__predefinedTypeAST__getSupportedOperatorFlags (superClassPtr) ;
        gDispatchTableForReader__predefinedTypeAST__getSupportedOperatorFlags.forceObjectAtIndex (inClassPtr->slotID (), result, NULL COMMA_HERE) ;
      }
    }
    if (NULL == result) {
      result = category_reader__predefinedTypeAST_defaultReader_getSupportedOperatorFlags ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Category method '@predefinedTypeAST.getAddAssignArgumentList'        *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__predefinedTypeAST__getAddAssignArgumentList (C_CompilerEx &,
                                const cPtr_predefinedTypeAST * operand_17218,
                                GGS_unifiedTypeMap  & /* var_cas_ioUnifiedTypeMap */,
                                GGS_unifiedTypeMapProxyList  & var_cas_outAddAssignArgumentList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_17218 != NULL) {
    var_cas_outAddAssignArgumentList = GGS_unifiedTypeMapProxyList ::constructor_emptyList () ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//Virtual Table for category method '@predefinedTypeAST.getAddAssignArgumentList'*
//                                                                           *
//---------------------------------------------------------------------------*

static TC_UniqueArray <typeCategoryMethod__predefinedTypeAST__getAddAssignArgumentList> gDispatchTableForMethod__predefinedTypeAST__getAddAssignArgumentList ;

//---------------------------------------------------------------------------*

void
enterCategoryMethod__predefinedTypeAST__getAddAssignArgumentList (typeCategoryMethod__predefinedTypeAST__getAddAssignArgumentList inRoutine,
                     const PMSInt32 inClassID) {
  gDispatchTableForMethod__predefinedTypeAST__getAddAssignArgumentList.forceObjectAtIndex (inClassID, inRoutine, NULL COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

typeCategoryMethod__predefinedTypeAST__getAddAssignArgumentList
findCategoryMethod__predefinedTypeAST__getAddAssignArgumentList (AC_galgasClassRunTimeInformationEX * inClassPtr) {
  typeCategoryMethod__predefinedTypeAST__getAddAssignArgumentList result = NULL ;
  if (NULL != inClassPtr) {
    if (inClassPtr->slotID () < gDispatchTableForMethod__predefinedTypeAST__getAddAssignArgumentList.count ()) {
      result = gDispatchTableForMethod__predefinedTypeAST__getAddAssignArgumentList (inClassPtr->slotID () COMMA_HERE) ;
    }
    if (NULL == result) {
      AC_galgasClassRunTimeInformationEX * superClassPtr = inClassPtr->superClassPtr () ;
      if (superClassPtr != NULL) {
        result = findCategoryMethod__predefinedTypeAST__getAddAssignArgumentList (superClassPtr) ;
        gDispatchTableForMethod__predefinedTypeAST__getAddAssignArgumentList.forceObjectAtIndex (inClassPtr->slotID (), result, NULL COMMA_HERE) ;
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         Category method '@predefinedTypeAST.getEnumerationList'           *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__predefinedTypeAST__getEnumerationList (C_CompilerEx &,
                                const cPtr_predefinedTypeAST * operand_17858,
                                GGS_unifiedTypeMap  & /* var_cas_ioUnifiedTypeMap */,
                                GGS_enumerationDescriptorList  & var_cas_outEnumerationList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_17858 != NULL) {
    var_cas_outEnumerationList = GGS_enumerationDescriptorList ::constructor_emptyList () ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//Virtual Table for category method '@predefinedTypeAST.getEnumerationList'  *
//                                                                           *
//---------------------------------------------------------------------------*

static TC_UniqueArray <typeCategoryMethod__predefinedTypeAST__getEnumerationList> gDispatchTableForMethod__predefinedTypeAST__getEnumerationList ;

//---------------------------------------------------------------------------*

void
enterCategoryMethod__predefinedTypeAST__getEnumerationList (typeCategoryMethod__predefinedTypeAST__getEnumerationList inRoutine,
                     const PMSInt32 inClassID) {
  gDispatchTableForMethod__predefinedTypeAST__getEnumerationList.forceObjectAtIndex (inClassID, inRoutine, NULL COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

typeCategoryMethod__predefinedTypeAST__getEnumerationList
findCategoryMethod__predefinedTypeAST__getEnumerationList (AC_galgasClassRunTimeInformationEX * inClassPtr) {
  typeCategoryMethod__predefinedTypeAST__getEnumerationList result = NULL ;
  if (NULL != inClassPtr) {
    if (inClassPtr->slotID () < gDispatchTableForMethod__predefinedTypeAST__getEnumerationList.count ()) {
      result = gDispatchTableForMethod__predefinedTypeAST__getEnumerationList (inClassPtr->slotID () COMMA_HERE) ;
    }
    if (NULL == result) {
      AC_galgasClassRunTimeInformationEX * superClassPtr = inClassPtr->superClassPtr () ;
      if (superClassPtr != NULL) {
        result = findCategoryMethod__predefinedTypeAST__getEnumerationList (superClassPtr) ;
        gDispatchTableForMethod__predefinedTypeAST__getEnumerationList.forceObjectAtIndex (inClassPtr->slotID (), result, NULL COMMA_HERE) ;
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      Prologue and epilogue actions                        *
//                                                                           *
//---------------------------------------------------------------------------*

static void prologueRoutineFor_semanticsTypes (void) {
  enterCategoryMethod__predefinedTypeAST__getConstructorMap (category_method__predefinedTypeAST__getConstructorMap, gClassInfoFor__predefinedTypeAST.slotID ()) ;
  enterCategoryMethod__predefinedTypeAST__getReaderMap (category_method__predefinedTypeAST__getReaderMap, gClassInfoFor__predefinedTypeAST.slotID ()) ;
  enterCategoryMethod__predefinedTypeAST__getModifierMap (category_method__predefinedTypeAST__getModifierMap, gClassInfoFor__predefinedTypeAST.slotID ()) ;
  enterCategoryMethod__predefinedTypeAST__getInstanceMethodMap (category_method__predefinedTypeAST__getInstanceMethodMap, gClassInfoFor__predefinedTypeAST.slotID ()) ;
  enterCategoryMethod__predefinedTypeAST__getClassMethodMap (category_method__predefinedTypeAST__getClassMethodMap, gClassInfoFor__predefinedTypeAST.slotID ()) ;
  enterCategoryReader__predefinedTypeAST__getSupportedOperatorFlags (category_reader__predefinedTypeAST__getSupportedOperatorFlags, gClassInfoFor__predefinedTypeAST.slotID ()) ;
  enterCategoryMethod__predefinedTypeAST__getAddAssignArgumentList (category_method__predefinedTypeAST__getAddAssignArgumentList, gClassInfoFor__predefinedTypeAST.slotID ()) ;
  enterCategoryMethod__predefinedTypeAST__getEnumerationList (category_method__predefinedTypeAST__getEnumerationList, gClassInfoFor__predefinedTypeAST.slotID ()) ;
}

//---------------------------------------------------------------------------*

static void epilogueRoutineFor_semanticsTypes (void) {
  gCachedResultForOnceFunction_binaryAddOperator.drop () ;
  gCachedResultForOnceFunction_binarySubOperator.drop () ;
  gCachedResultForOnceFunction_binaryMulOperator.drop () ;
  gCachedResultForOnceFunction_binaryDivOperator.drop () ;
  gCachedResultForOnceFunction_binaryModOperator.drop () ;
  gCachedResultForOnceFunction_binaryShiftOperator.drop () ;
  gCachedResultForOnceFunction_unaryPlusOperator.drop () ;
  gCachedResultForOnceFunction_unaryMinusOperator.drop () ;
  gCachedResultForOnceFunction_unaryTildeOperator.drop () ;
  gCachedResultForOnceFunction_incDecOperator.drop () ;
  gCachedResultForOnceFunction_binaryAndOperator.drop () ;
  gCachedResultForOnceFunction_binaryOrOperator.drop () ;
  gCachedResultForOnceFunction_binaryXorOperator.drop () ;
  gCachedResultForOnceFunction_unaryNotOperator.drop () ;
  gCachedResultForOnceFunction_binaryConcatOperator.drop () ;
  gCachedResultForOnceFunction_dotAssignOperator.drop () ;
  gCachedResultForOnceFunction_isComparable.drop () ;
  gCachedResultForOnceFunction_generateEnumerationHelperMethods.drop () ;
  gCachedResultForOnceFunction_doNotGenererateObjectCompare.drop () ;
  gCachedResultForOnceFunction_generateDescriptionReaderUtilityMethod.drop () ;
  gCachedResultForOnceFunction_generateCopyConstructorAndAssignmentOperator.drop () ;
  gDispatchTableForMethod__predefinedTypeAST__getConstructorMap.free () ;
  gDispatchTableForMethod__predefinedTypeAST__getReaderMap.free () ;
  gDispatchTableForMethod__predefinedTypeAST__getModifierMap.free () ;
  gDispatchTableForMethod__predefinedTypeAST__getInstanceMethodMap.free () ;
  gDispatchTableForMethod__predefinedTypeAST__getClassMethodMap.free () ;
  gDispatchTableForReader__predefinedTypeAST__getSupportedOperatorFlags.free () ;
  gDispatchTableForMethod__predefinedTypeAST__getAddAssignArgumentList.free () ;
  gDispatchTableForMethod__predefinedTypeAST__getEnumerationList.free () ;
}

//---------------------------------------------------------------------------*

C_PrologueEpilogue prologueEpilogueObjectFor_semanticsTypes (prologueRoutineFor_semanticsTypes, epilogueRoutineFor_semanticsTypes) ;

//---------------------------------------------------------------------------*

