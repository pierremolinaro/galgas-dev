//---------------------------------------------------------------------------*
//                                                                           *
//                        File 'scanner_semantics.h'                         *
//         Generated by version GALGAS_BETA_VERSION (LL(1) grammar)          *
//                      april 25th, 2006, at 18h13'14"                       *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

#ifndef scanner_semantics_DEFINED
#define scanner_semantics_DEFINED

#include <string.h>

#include "galgas/C_GGS_Object.h"
#include "galgas/AC_galgas_io.h"
#include "galgas/GGS_location.h"
#include "galgas/GGS_lbool.h"
#include "galgas/GGS_lchar.h"
#include "galgas/GGS_lstring.h"
#include "galgas/GGS_ldouble.h"
#include "galgas/GGS_luint.h"
#include "galgas/GGS_lsint.h"
#include "galgas/GGS_stringset.h"
#include "galgas/AC_galgas_map.h"
#include "galgas/C_Lexique.h"

// Include imported semantics
#include "common_semantics.h"

//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                          Class Predeclarations                            *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeLexicalAttributesMap ;
class GGS_lexicalTypeMap ;
class GGS_typeTableMessagesErreurs ;
class GGS_M_styles ;
class GGS_typeTableDefinitionTerminaux ;
class GGS_typeTableMotsReserves ;
class GGS_typeTableTablesDeMotsReserves ;
class GGS_typeConditionLexicale ;
class GGS_typeConditionChaine ;
class GGS_typeConditionCaractere ;
class GGS_typeConditionIntervalle ;
class GGS_typeListeConditionsLexicales ;
class GGS_typeInstructionLexicale ;
class GGS_tListeInstructionsLexicales ;
class GGS_typeListeTestsEtInstructions ;
class GGS_typeArgumentRoutineExterne ;
class GGS_typeListeArgumentsRoutExterne ;
class GGS_typeArgumentAttribut ;
class GGS_typeArgumentCaractere ;
class GGS_typeArgumentCaractereCourant ;
class GGS_typeArgumentEntier ;
class GGS_typeArgumentRoutine ;
class GGS_typeListeMessagesErreur ;
class GGS_typeEmissionParDefaut ;
class GGS_typeEmissionTerminalParDefaut ;
class GGS_typeEmissionErreurParDefaut ;
class GGS_typeListeRecherche ;
class GGS_typeInstructionActionExterne ;
class GGS_typeInstructionRepetitionLexicale ;
class GGS_typeInstructionSiLexical ;
class GGS_typeInstructionEmettreSimple ;
class GGS_typeInstructionEmettre ;
class GGS_typeInstructionErreurLexicale ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     Map '@typeLexicalAttributesMap'                       *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_typeLexicalAttributesMap ;

class GGS_typeLexicalAttributesMap : public AC_galgas_map {
//--- Element Class
  public : typedef elementOf_GGS_typeLexicalAttributesMap element_type ;
//--- Get pointers
  public : inline element_type * rootObject (void) const { return (element_type *) internalRootObject () ; }
  public : inline element_type * firstObject (void) const { return (element_type *) internalFirstObject () ; }
  public : inline element_type * lastObject (void) const { return (element_type *) internalLastObject () ; }
//--- Create a new element
  protected : virtual AC_galgas_map_element * new_element (const GGS_lstring & inKey, void * inInfo) ;
//--- Get object pointer (for method call)
  public : inline GGS_typeLexicalAttributesMap * operator () (UNUSED_LOCATION_ARGS) { return this ; }
//--- 'empty' constructor
  public : static GGS_typeLexicalAttributesMap constructor_empty (LOCATION_ARGS) ;
//--- Method used for duplicate a map
  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;
//--- 'insertKey' Insert Method
  public : void methode_insertKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0 COMMA_LOCATION_ARGS) ;
//--- 'searchKey' Search Method
  public : void methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_AC_galgasType   & outParameter0 COMMA_LOCATION_ARGS) ;
//--- Internal method for inserting an element
  protected : void insertElement (C_Lexique & inLexique,
                                  const char * inErrorMessage,
                                  const GGS_lstring & inKey,
                                  const GGS_AC_galgasType & inParameter0,
                                  GGS_luint * outIndex
                                  COMMA_LOCATION_ARGS) ;
//--- Internal method for searching for an element
  protected : void searchElement (C_Lexique & inLexique,
                                  const char * inErrorMessage,
                                  const GGS_lstring & inKey,
                                  GGS_AC_galgasType & outParameter0,
                                  GGS_luint * outIndex
                                  COMMA_LOCATION_ARGS) ;
  public : GGS_string reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                          Map '@lexicalTypeMap'                            *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_lexicalTypeMap ;

class GGS_lexicalTypeMap : public AC_galgas_map {
//--- Element Class
  public : typedef elementOf_GGS_lexicalTypeMap element_type ;
//--- Get pointers
  public : inline element_type * rootObject (void) const { return (element_type *) internalRootObject () ; }
  public : inline element_type * firstObject (void) const { return (element_type *) internalFirstObject () ; }
  public : inline element_type * lastObject (void) const { return (element_type *) internalLastObject () ; }
//--- Create a new element
  protected : virtual AC_galgas_map_element * new_element (const GGS_lstring & inKey, void * inInfo) ;
//--- Get object pointer (for method call)
  public : inline GGS_lexicalTypeMap * operator () (UNUSED_LOCATION_ARGS) { return this ; }
//--- 'empty' constructor
  public : static GGS_lexicalTypeMap constructor_empty (LOCATION_ARGS) ;
//--- Method used for duplicate a map
  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;
//--- 'insertKey' Insert Method
  public : void methode_insertKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0 COMMA_LOCATION_ARGS) ;
//--- 'searchKey' Search Method
  public : void methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_AC_galgasType   & outParameter0 COMMA_LOCATION_ARGS) ;
//--- Internal method for inserting an element
  protected : void insertElement (C_Lexique & inLexique,
                                  const char * inErrorMessage,
                                  const GGS_lstring & inKey,
                                  const GGS_AC_galgasType & inParameter0,
                                  GGS_luint * outIndex
                                  COMMA_LOCATION_ARGS) ;
//--- Internal method for searching for an element
  protected : void searchElement (C_Lexique & inLexique,
                                  const char * inErrorMessage,
                                  const GGS_lstring & inKey,
                                  GGS_AC_galgasType & outParameter0,
                                  GGS_luint * outIndex
                                  COMMA_LOCATION_ARGS) ;
  public : GGS_string reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     Map '@typeTableMessagesErreurs'                       *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_typeTableMessagesErreurs ;

class GGS_typeTableMessagesErreurs : public AC_galgas_map {
//--- Element Class
  public : typedef elementOf_GGS_typeTableMessagesErreurs element_type ;
//--- Get pointers
  public : inline element_type * rootObject (void) const { return (element_type *) internalRootObject () ; }
  public : inline element_type * firstObject (void) const { return (element_type *) internalFirstObject () ; }
  public : inline element_type * lastObject (void) const { return (element_type *) internalLastObject () ; }
//--- Create a new element
  protected : virtual AC_galgas_map_element * new_element (const GGS_lstring & inKey, void * inInfo) ;
//--- Get object pointer (for method call)
  public : inline GGS_typeTableMessagesErreurs * operator () (UNUSED_LOCATION_ARGS) { return this ; }
//--- 'empty' constructor
  public : static GGS_typeTableMessagesErreurs constructor_empty (LOCATION_ARGS) ;
//--- Method used for duplicate a map
  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;
//--- 'insertKey' Insert Method
  public : void methode_insertKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lstring &  inParameter0 COMMA_LOCATION_ARGS) ;
//--- 'searchKey' Search Method
  public : void methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lstring   & outParameter0 COMMA_LOCATION_ARGS) ;
//--- 'searchKeyGetIndex' Search Method
  public : void methode_searchKeyGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_lstring   & outParameter0 COMMA_LOCATION_ARGS) ;
//--- Internal method for inserting an element
  protected : void insertElement (C_Lexique & inLexique,
                                  const char * inErrorMessage,
                                  const GGS_lstring & inKey,
                                  const GGS_lstring & inParameter0,
                                  GGS_luint * outIndex
                                  COMMA_LOCATION_ARGS) ;
//--- Internal method for searching for an element
  protected : void searchElement (C_Lexique & inLexique,
                                  const char * inErrorMessage,
                                  const GGS_lstring & inKey,
                                  GGS_lstring & outParameter0,
                                  GGS_luint * outIndex
                                  COMMA_LOCATION_ARGS) ;
  public : GGS_string reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                             Map '@M_styles'                               *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_M_styles ;

class GGS_M_styles : public AC_galgas_map {
//--- Element Class
  public : typedef elementOf_GGS_M_styles element_type ;
//--- Get pointers
  public : inline element_type * rootObject (void) const { return (element_type *) internalRootObject () ; }
  public : inline element_type * firstObject (void) const { return (element_type *) internalFirstObject () ; }
  public : inline element_type * lastObject (void) const { return (element_type *) internalLastObject () ; }
//--- Create a new element
  protected : virtual AC_galgas_map_element * new_element (const GGS_lstring & inKey, void * inInfo) ;
//--- Get object pointer (for method call)
  public : inline GGS_M_styles * operator () (UNUSED_LOCATION_ARGS) { return this ; }
//--- 'empty' constructor
  public : static GGS_M_styles constructor_empty (LOCATION_ARGS) ;
//--- Method used for duplicate a map
  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;
//--- 'insertKey' Insert Method
  public : void methode_insertKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lstring &  inParameter0 COMMA_LOCATION_ARGS) ;
//--- 'searchKey' Search Method
  public : void methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lstring   & outParameter0 COMMA_LOCATION_ARGS) ;
//--- 'searchKeyGetIndex' Search Method
  public : void methode_searchKeyGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_lstring   & outParameter0 COMMA_LOCATION_ARGS) ;
//--- Internal method for inserting an element
  protected : void insertElement (C_Lexique & inLexique,
                                  const char * inErrorMessage,
                                  const GGS_lstring & inKey,
                                  const GGS_lstring & inParameter0,
                                  GGS_luint * outIndex
                                  COMMA_LOCATION_ARGS) ;
//--- Internal method for searching for an element
  protected : void searchElement (C_Lexique & inLexique,
                                  const char * inErrorMessage,
                                  const GGS_lstring & inKey,
                                  GGS_lstring & outParameter0,
                                  GGS_luint * outIndex
                                  COMMA_LOCATION_ARGS) ;
  public : GGS_string reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   Map '@typeTableDefinitionTerminaux'                     *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_typeTableDefinitionTerminaux ;

class GGS_typeTableDefinitionTerminaux : public AC_galgas_map {
//--- Element Class
  public : typedef elementOf_GGS_typeTableDefinitionTerminaux element_type ;
//--- Get pointers
  public : inline element_type * rootObject (void) const { return (element_type *) internalRootObject () ; }
  public : inline element_type * firstObject (void) const { return (element_type *) internalFirstObject () ; }
  public : inline element_type * lastObject (void) const { return (element_type *) internalLastObject () ; }
//--- Create a new element
  protected : virtual AC_galgas_map_element * new_element (const GGS_lstring & inKey, void * inInfo) ;
//--- Get object pointer (for method call)
  public : inline GGS_typeTableDefinitionTerminaux * operator () (UNUSED_LOCATION_ARGS) { return this ; }
//--- 'empty' constructor
  public : static GGS_typeTableDefinitionTerminaux constructor_empty (LOCATION_ARGS) ;
//--- Method used for duplicate a map
  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;
//--- 'insertKey' Insert Method
  public : void methode_insertKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_string&  inParameter0,
                                const GGS_typeListeAttributsSemantiques &  inParameter1,
                                const GGS_luint &  inParameter2 COMMA_LOCATION_ARGS) ;
//--- 'searchKey' Search Method
  public : void methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_string  & outParameter0,
                                GGS_typeListeAttributsSemantiques   & outParameter1,
                                GGS_luint   & outParameter2 COMMA_LOCATION_ARGS) ;
//--- Internal method for inserting an element
  protected : void insertElement (C_Lexique & inLexique,
                                  const char * inErrorMessage,
                                  const GGS_lstring & inKey,
                                  const GGS_string& inParameter0,
                                  const GGS_typeListeAttributsSemantiques & inParameter1,
                                  const GGS_luint & inParameter2,
                                  GGS_luint * outIndex
                                  COMMA_LOCATION_ARGS) ;
//--- Internal method for searching for an element
  protected : void searchElement (C_Lexique & inLexique,
                                  const char * inErrorMessage,
                                  const GGS_lstring & inKey,
                                  GGS_string& outParameter0,
                                  GGS_typeListeAttributsSemantiques & outParameter1,
                                  GGS_luint & outParameter2,
                                  GGS_luint * outIndex
                                  COMMA_LOCATION_ARGS) ;
  public : GGS_string reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       Map '@typeTableMotsReserves'                        *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_typeTableMotsReserves ;

class GGS_typeTableMotsReserves : public AC_galgas_map {
//--- Element Class
  public : typedef elementOf_GGS_typeTableMotsReserves element_type ;
//--- Get pointers
  public : inline element_type * rootObject (void) const { return (element_type *) internalRootObject () ; }
  public : inline element_type * firstObject (void) const { return (element_type *) internalFirstObject () ; }
  public : inline element_type * lastObject (void) const { return (element_type *) internalLastObject () ; }
//--- Create a new element
  protected : virtual AC_galgas_map_element * new_element (const GGS_lstring & inKey, void * inInfo) ;
//--- Get object pointer (for method call)
  public : inline GGS_typeTableMotsReserves * operator () (UNUSED_LOCATION_ARGS) { return this ; }
//--- 'empty' constructor
  public : static GGS_typeTableMotsReserves constructor_empty (LOCATION_ARGS) ;
//--- Method used for duplicate a map
  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;
//--- 'insertKey' Insert Method
  public : void methode_insertKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lstring &  inParameter0 COMMA_LOCATION_ARGS) ;
//--- 'searchKey' Search Method
  public : void methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lstring   & outParameter0 COMMA_LOCATION_ARGS) ;
//--- Internal method for inserting an element
  protected : void insertElement (C_Lexique & inLexique,
                                  const char * inErrorMessage,
                                  const GGS_lstring & inKey,
                                  const GGS_lstring & inParameter0,
                                  GGS_luint * outIndex
                                  COMMA_LOCATION_ARGS) ;
//--- Internal method for searching for an element
  protected : void searchElement (C_Lexique & inLexique,
                                  const char * inErrorMessage,
                                  const GGS_lstring & inKey,
                                  GGS_lstring & outParameter0,
                                  GGS_luint * outIndex
                                  COMMA_LOCATION_ARGS) ;
  public : GGS_string reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   Map '@typeTableTablesDeMotsReserves'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_typeTableTablesDeMotsReserves ;

class GGS_typeTableTablesDeMotsReserves : public AC_galgas_map {
//--- Element Class
  public : typedef elementOf_GGS_typeTableTablesDeMotsReserves element_type ;
//--- Get pointers
  public : inline element_type * rootObject (void) const { return (element_type *) internalRootObject () ; }
  public : inline element_type * firstObject (void) const { return (element_type *) internalFirstObject () ; }
  public : inline element_type * lastObject (void) const { return (element_type *) internalLastObject () ; }
//--- Create a new element
  protected : virtual AC_galgas_map_element * new_element (const GGS_lstring & inKey, void * inInfo) ;
//--- Get object pointer (for method call)
  public : inline GGS_typeTableTablesDeMotsReserves * operator () (UNUSED_LOCATION_ARGS) { return this ; }
//--- 'empty' constructor
  public : static GGS_typeTableTablesDeMotsReserves constructor_empty (LOCATION_ARGS) ;
//--- Method used for duplicate a map
  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;
//--- 'insertKey' Insert Method
  public : void methode_insertKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_typeTableMotsReserves &  inParameter0 COMMA_LOCATION_ARGS) ;
//--- 'searchKey' Search Method
  public : void methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_typeTableMotsReserves   & outParameter0 COMMA_LOCATION_ARGS) ;
//--- Internal method for inserting an element
  protected : void insertElement (C_Lexique & inLexique,
                                  const char * inErrorMessage,
                                  const GGS_lstring & inKey,
                                  const GGS_typeTableMotsReserves & inParameter0,
                                  GGS_luint * outIndex
                                  COMMA_LOCATION_ARGS) ;
//--- Internal method for searching for an element
  protected : void searchElement (C_Lexique & inLexique,
                                  const char * inErrorMessage,
                                  const GGS_lstring & inKey,
                                  GGS_typeTableMotsReserves & outParameter0,
                                  GGS_luint * outIndex
                                  COMMA_LOCATION_ARGS) ;
  public : GGS_string reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const ;
} ;

class cPtr_typeConditionLexicale ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeConditionLexicale'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeConditionLexicale {
  protected : cPtr_typeConditionLexicale * mPointer ;
  public : GGS_typeConditionLexicale (void) ;
  public : GGS_typeConditionLexicale (const GGS_typeConditionLexicale &) ;
  public : virtual ~GGS_typeConditionLexicale (void) ;
  public : void operator = (const GGS_typeConditionLexicale &) ;
  public : inline bool isBuilt (void) const { return mPointer != NULL ; }
  public : inline bool isEqualTo (const GGS_typeConditionLexicale & operand_) const {
    return mPointer == operand_.mPointer ;
  }
  public : void operator = (cPtr_typeConditionLexicale * inSource) ;
  public : GGS_typeConditionLexicale (cPtr_typeConditionLexicale * inSource) ;
  public : inline cPtr_typeConditionLexicale * getPtr (void) const {
    return mPointer ;
  }
  public : void drop_operation (void) ;
  public : GGS_string reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const ;
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_typeConditionLexicale * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_typeConditionLexicale * operator () (LOCATION_ARGS) const { return mPointer ; }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   list '@typeListeConditionsLexicales'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_typeListeConditionsLexicales ;

class GGS_typeListeConditionsLexicales {
  public : typedef elementOf_GGS_typeListeConditionsLexicales element_type ;
  private : element_type * mFirstItem ;
  private : element_type * mLastItem ;
  private : sint32 mListLength ;
  public : inline sint32 count (void) const {
    return mListLength ;
  }
  private : sint32 * mCountReference ;
  public : GGS_typeListeConditionsLexicales (void) ; // Default Constructor
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : GGS_typeListeConditionsLexicales (LOCATION_ARGS) ; // Constructor for debug mode
  #endif
  public : GGS_typeListeConditionsLexicales (const GGS_typeListeConditionsLexicales &) ; // Copy constructor
  public : void operator = (const GGS_typeListeConditionsLexicales &) ; // Assignment operator
//--- Virtual destructor
  public : virtual ~GGS_typeListeConditionsLexicales (void) ;

//--- Constructor 'empty'
  public : static GGS_typeListeConditionsLexicales constructor_empty (LOCATION_ARGS) ;
//--- Reader 'description'
  public : GGS_string reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const ;
//--- Get first item
  public : inline element_type * firstObject (void) const { return mFirstItem ; }
  public : void addAssign_operation (const GGS_typeConditionLexicale & argument_0) ;
  protected : void internalAppendItem (const GGS_typeConditionLexicale & argument_0) ;
  public : void insulateList (void) ;
  public : void emptyList (void) ;
  public : inline bool isBuilt (void) const {
    return mCountReference != NULL ;
  }
  public : void drop_operation (void) ;
  public : inline GGS_uint reader_length (C_Lexique & /* inLexique */
                                          COMMA_UNUSED_LOCATION_ARGS)  const {
    return GGS_uint (mCountReference != NULL, (uint32) mListLength) ;
  }
} ;

class cPtr_typeInstructionLexicale ;

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeInstructionLexicale'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeInstructionLexicale {
  protected : cPtr_typeInstructionLexicale * mPointer ;
  public : GGS_typeInstructionLexicale (void) ;
  public : GGS_typeInstructionLexicale (const GGS_typeInstructionLexicale &) ;
  public : virtual ~GGS_typeInstructionLexicale (void) ;
  public : void operator = (const GGS_typeInstructionLexicale &) ;
  public : inline bool isBuilt (void) const { return mPointer != NULL ; }
  public : inline bool isEqualTo (const GGS_typeInstructionLexicale & operand_) const {
    return mPointer == operand_.mPointer ;
  }
  public : void operator = (cPtr_typeInstructionLexicale * inSource) ;
  public : GGS_typeInstructionLexicale (cPtr_typeInstructionLexicale * inSource) ;
  public : inline cPtr_typeInstructionLexicale * getPtr (void) const {
    return mPointer ;
  }
  public : void drop_operation (void) ;
  public : GGS_string reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const ;
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_typeInstructionLexicale * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_typeInstructionLexicale * operator () (LOCATION_ARGS) const { return mPointer ; }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   list '@tListeInstructionsLexicales'                     *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_tListeInstructionsLexicales ;

class GGS_tListeInstructionsLexicales {
  public : typedef elementOf_GGS_tListeInstructionsLexicales element_type ;
  private : element_type * mFirstItem ;
  private : element_type * mLastItem ;
  private : sint32 mListLength ;
  public : inline sint32 count (void) const {
    return mListLength ;
  }
  private : sint32 * mCountReference ;
  public : GGS_tListeInstructionsLexicales (void) ; // Default Constructor
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : GGS_tListeInstructionsLexicales (LOCATION_ARGS) ; // Constructor for debug mode
  #endif
  public : GGS_tListeInstructionsLexicales (const GGS_tListeInstructionsLexicales &) ; // Copy constructor
  public : void operator = (const GGS_tListeInstructionsLexicales &) ; // Assignment operator
//--- Virtual destructor
  public : virtual ~GGS_tListeInstructionsLexicales (void) ;

//--- Constructor 'empty'
  public : static GGS_tListeInstructionsLexicales constructor_empty (LOCATION_ARGS) ;
//--- Reader 'description'
  public : GGS_string reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const ;
//--- Get first item
  public : inline element_type * firstObject (void) const { return mFirstItem ; }
  public : void addAssign_operation (const GGS_typeInstructionLexicale & argument_0) ;
  protected : void internalAppendItem (const GGS_typeInstructionLexicale & argument_0) ;
  public : void insulateList (void) ;
  public : void emptyList (void) ;
  public : inline bool isBuilt (void) const {
    return mCountReference != NULL ;
  }
  public : void drop_operation (void) ;
  public : inline GGS_uint reader_length (C_Lexique & /* inLexique */
                                          COMMA_UNUSED_LOCATION_ARGS)  const {
    return GGS_uint (mCountReference != NULL, (uint32) mListLength) ;
  }
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   list '@typeListeTestsEtInstructions'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_typeListeTestsEtInstructions ;

class GGS_typeListeTestsEtInstructions {
  public : typedef elementOf_GGS_typeListeTestsEtInstructions element_type ;
  private : element_type * mFirstItem ;
  private : element_type * mLastItem ;
  private : sint32 mListLength ;
  public : inline sint32 count (void) const {
    return mListLength ;
  }
  private : sint32 * mCountReference ;
  public : GGS_typeListeTestsEtInstructions (void) ; // Default Constructor
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : GGS_typeListeTestsEtInstructions (LOCATION_ARGS) ; // Constructor for debug mode
  #endif
  public : GGS_typeListeTestsEtInstructions (const GGS_typeListeTestsEtInstructions &) ; // Copy constructor
  public : void operator = (const GGS_typeListeTestsEtInstructions &) ; // Assignment operator
//--- Virtual destructor
  public : virtual ~GGS_typeListeTestsEtInstructions (void) ;

//--- Constructor 'empty'
  public : static GGS_typeListeTestsEtInstructions constructor_empty (LOCATION_ARGS) ;
//--- Reader 'description'
  public : GGS_string reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const ;
//--- Get first item
  public : inline element_type * firstObject (void) const { return mFirstItem ; }
  public : void addAssign_operation (const GGS_typeListeConditionsLexicales & argument_0,
                                const GGS_tListeInstructionsLexicales & argument_1) ;
  protected : void internalAppendItem (const GGS_typeListeConditionsLexicales & argument_0,
                                const GGS_tListeInstructionsLexicales & argument_1) ;
  public : void insulateList (void) ;
  public : void emptyList (void) ;
  public : inline bool isBuilt (void) const {
    return mCountReference != NULL ;
  }
  public : void drop_operation (void) ;
  public : inline GGS_uint reader_length (C_Lexique & /* inLexique */
                                          COMMA_UNUSED_LOCATION_ARGS)  const {
    return GGS_uint (mCountReference != NULL, (uint32) mListLength) ;
  }
} ;

class cPtr_typeArgumentRoutineExterne ;

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeArgumentRoutineExterne'                *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeArgumentRoutineExterne {
  protected : cPtr_typeArgumentRoutineExterne * mPointer ;
  public : GGS_typeArgumentRoutineExterne (void) ;
  public : GGS_typeArgumentRoutineExterne (const GGS_typeArgumentRoutineExterne &) ;
  public : virtual ~GGS_typeArgumentRoutineExterne (void) ;
  public : void operator = (const GGS_typeArgumentRoutineExterne &) ;
  public : inline bool isBuilt (void) const { return mPointer != NULL ; }
  public : inline bool isEqualTo (const GGS_typeArgumentRoutineExterne & operand_) const {
    return mPointer == operand_.mPointer ;
  }
  public : void operator = (cPtr_typeArgumentRoutineExterne * inSource) ;
  public : GGS_typeArgumentRoutineExterne (cPtr_typeArgumentRoutineExterne * inSource) ;
  public : inline cPtr_typeArgumentRoutineExterne * getPtr (void) const {
    return mPointer ;
  }
  public : void drop_operation (void) ;
  public : GGS_string reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const ;
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_typeArgumentRoutineExterne * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_typeArgumentRoutineExterne * operator () (LOCATION_ARGS) const { return mPointer ; }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  list '@typeListeArgumentsRoutExterne'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_typeListeArgumentsRoutExterne ;

class GGS_typeListeArgumentsRoutExterne {
  public : typedef elementOf_GGS_typeListeArgumentsRoutExterne element_type ;
  private : element_type * mFirstItem ;
  private : element_type * mLastItem ;
  private : sint32 mListLength ;
  public : inline sint32 count (void) const {
    return mListLength ;
  }
  private : sint32 * mCountReference ;
  public : GGS_typeListeArgumentsRoutExterne (void) ; // Default Constructor
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : GGS_typeListeArgumentsRoutExterne (LOCATION_ARGS) ; // Constructor for debug mode
  #endif
  public : GGS_typeListeArgumentsRoutExterne (const GGS_typeListeArgumentsRoutExterne &) ; // Copy constructor
  public : void operator = (const GGS_typeListeArgumentsRoutExterne &) ; // Assignment operator
//--- Virtual destructor
  public : virtual ~GGS_typeListeArgumentsRoutExterne (void) ;

//--- Constructor 'empty'
  public : static GGS_typeListeArgumentsRoutExterne constructor_empty (LOCATION_ARGS) ;
//--- Reader 'description'
  public : GGS_string reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const ;
//--- Get first item
  public : inline element_type * firstObject (void) const { return mFirstItem ; }
  public : void addAssign_operation (const GGS_typeArgumentRoutineExterne & argument_0) ;
  protected : void internalAppendItem (const GGS_typeArgumentRoutineExterne & argument_0) ;
  public : void insulateList (void) ;
  public : void emptyList (void) ;
  public : inline bool isBuilt (void) const {
    return mCountReference != NULL ;
  }
  public : void drop_operation (void) ;
  public : inline GGS_uint reader_length (C_Lexique & /* inLexique */
                                          COMMA_UNUSED_LOCATION_ARGS)  const {
    return GGS_uint (mCountReference != NULL, (uint32) mListLength) ;
  }
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     list '@typeListeMessagesErreur'                       *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_typeListeMessagesErreur ;

class GGS_typeListeMessagesErreur {
  public : typedef elementOf_GGS_typeListeMessagesErreur element_type ;
  private : element_type * mFirstItem ;
  private : element_type * mLastItem ;
  private : sint32 mListLength ;
  public : inline sint32 count (void) const {
    return mListLength ;
  }
  private : sint32 * mCountReference ;
  public : GGS_typeListeMessagesErreur (void) ; // Default Constructor
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : GGS_typeListeMessagesErreur (LOCATION_ARGS) ; // Constructor for debug mode
  #endif
  public : GGS_typeListeMessagesErreur (const GGS_typeListeMessagesErreur &) ; // Copy constructor
  public : void operator = (const GGS_typeListeMessagesErreur &) ; // Assignment operator
//--- Virtual destructor
  public : virtual ~GGS_typeListeMessagesErreur (void) ;

//--- Constructor 'empty'
  public : static GGS_typeListeMessagesErreur constructor_empty (LOCATION_ARGS) ;
//--- Reader 'description'
  public : GGS_string reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const ;
//--- Get first item
  public : inline element_type * firstObject (void) const { return mFirstItem ; }
  public : void addAssign_operation (const GGS_luint & argument_0) ;
  protected : void internalAppendItem (const GGS_luint & argument_0) ;
  public : void insulateList (void) ;
  public : void emptyList (void) ;
  public : inline bool isBuilt (void) const {
    return mCountReference != NULL ;
  }
  public : void drop_operation (void) ;
  public : inline GGS_uint reader_length (C_Lexique & /* inLexique */
                                          COMMA_UNUSED_LOCATION_ARGS)  const {
    return GGS_uint (mCountReference != NULL, (uint32) mListLength) ;
  }
} ;

class cPtr_typeEmissionParDefaut ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeEmissionParDefaut'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeEmissionParDefaut {
  protected : cPtr_typeEmissionParDefaut * mPointer ;
  public : GGS_typeEmissionParDefaut (void) ;
  public : GGS_typeEmissionParDefaut (const GGS_typeEmissionParDefaut &) ;
  public : virtual ~GGS_typeEmissionParDefaut (void) ;
  public : void operator = (const GGS_typeEmissionParDefaut &) ;
  public : inline bool isBuilt (void) const { return mPointer != NULL ; }
  public : inline bool isEqualTo (const GGS_typeEmissionParDefaut & operand_) const {
    return mPointer == operand_.mPointer ;
  }
  public : void operator = (cPtr_typeEmissionParDefaut * inSource) ;
  public : GGS_typeEmissionParDefaut (cPtr_typeEmissionParDefaut * inSource) ;
  public : inline cPtr_typeEmissionParDefaut * getPtr (void) const {
    return mPointer ;
  }
  public : void drop_operation (void) ;
  public : GGS_string reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const ;
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_typeEmissionParDefaut * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_typeEmissionParDefaut * operator () (LOCATION_ARGS) const { return mPointer ; }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        list '@typeListeRecherche'                         *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_typeListeRecherche ;

class GGS_typeListeRecherche {
  public : typedef elementOf_GGS_typeListeRecherche element_type ;
  private : element_type * mFirstItem ;
  private : element_type * mLastItem ;
  private : sint32 mListLength ;
  public : inline sint32 count (void) const {
    return mListLength ;
  }
  private : sint32 * mCountReference ;
  public : GGS_typeListeRecherche (void) ; // Default Constructor
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : GGS_typeListeRecherche (LOCATION_ARGS) ; // Constructor for debug mode
  #endif
  public : GGS_typeListeRecherche (const GGS_typeListeRecherche &) ; // Copy constructor
  public : void operator = (const GGS_typeListeRecherche &) ; // Assignment operator
//--- Virtual destructor
  public : virtual ~GGS_typeListeRecherche (void) ;

//--- Constructor 'empty'
  public : static GGS_typeListeRecherche constructor_empty (LOCATION_ARGS) ;
//--- Reader 'description'
  public : GGS_string reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const ;
//--- Get first item
  public : inline element_type * firstObject (void) const { return mFirstItem ; }
  public : void addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) ;
  protected : void internalAppendItem (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) ;
  public : void insulateList (void) ;
  public : void emptyList (void) ;
  public : inline bool isBuilt (void) const {
    return mCountReference != NULL ;
  }
  public : void drop_operation (void) ;
  public : inline GGS_uint reader_length (C_Lexique & /* inLexique */
                                          COMMA_UNUSED_LOCATION_ARGS)  const {
    return GGS_uint (mCountReference != NULL, (uint32) mListLength) ;
  }
} ;

void routine_appendToLexicalInstructionList (C_Lexique &,
                                GGS_typeListeTestsEtInstructions  &,
                                const GGS_lstring  &,
                                GGS_lstring  & COMMA_LOCATION_ARGS) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of map '@typeLexicalAttributesMap'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class e_typeLexicalAttributesMap {
  public : GGS_AC_galgasType  attributType ;
} ;

//---------------------------------------------------------------------------*

class elementOf_GGS_typeLexicalAttributesMap : public AC_galgas_map_element {
//--- Constructor
  public : elementOf_GGS_typeLexicalAttributesMap (const GGS_lstring & inKey,
                                    const sint32 inIndex,
                                     const e_typeLexicalAttributesMap & inInfo) ;
//--- Get pointers
  public : inline elementOf_GGS_typeLexicalAttributesMap * nextObject (void) const { return (elementOf_GGS_typeLexicalAttributesMap *) mNextItem ; }
  public : inline elementOf_GGS_typeLexicalAttributesMap * infObject (void) const { return (elementOf_GGS_typeLexicalAttributesMap *) mInfPtr ; }
  public : inline elementOf_GGS_typeLexicalAttributesMap * supObject (void) const { return (elementOf_GGS_typeLexicalAttributesMap *) mSupPtr ; }
//--- Data member
  public : e_typeLexicalAttributesMap mInfo ;
//--- Method for 'description' reader
  public : void appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     Element of map '@lexicalTypeMap'                      *
//                                                                           *
//---------------------------------------------------------------------------*

class e_lexicalTypeMap {
  public : GGS_AC_galgasType  mAttributType ;
} ;

//---------------------------------------------------------------------------*

class elementOf_GGS_lexicalTypeMap : public AC_galgas_map_element {
//--- Constructor
  public : elementOf_GGS_lexicalTypeMap (const GGS_lstring & inKey,
                                    const sint32 inIndex,
                                     const e_lexicalTypeMap & inInfo) ;
//--- Get pointers
  public : inline elementOf_GGS_lexicalTypeMap * nextObject (void) const { return (elementOf_GGS_lexicalTypeMap *) mNextItem ; }
  public : inline elementOf_GGS_lexicalTypeMap * infObject (void) const { return (elementOf_GGS_lexicalTypeMap *) mInfPtr ; }
  public : inline elementOf_GGS_lexicalTypeMap * supObject (void) const { return (elementOf_GGS_lexicalTypeMap *) mSupPtr ; }
//--- Data member
  public : e_lexicalTypeMap mInfo ;
//--- Method for 'description' reader
  public : void appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of map '@typeTableMessagesErreurs'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class e_typeTableMessagesErreurs {
  public : GGS_lstring  mErrorMessage ;
} ;

//---------------------------------------------------------------------------*

class elementOf_GGS_typeTableMessagesErreurs : public AC_galgas_map_element {
//--- Constructor
  public : elementOf_GGS_typeTableMessagesErreurs (const GGS_lstring & inKey,
                                    const sint32 inIndex,
                                     const e_typeTableMessagesErreurs & inInfo) ;
//--- Get pointers
  public : inline elementOf_GGS_typeTableMessagesErreurs * nextObject (void) const { return (elementOf_GGS_typeTableMessagesErreurs *) mNextItem ; }
  public : inline elementOf_GGS_typeTableMessagesErreurs * infObject (void) const { return (elementOf_GGS_typeTableMessagesErreurs *) mInfPtr ; }
  public : inline elementOf_GGS_typeTableMessagesErreurs * supObject (void) const { return (elementOf_GGS_typeTableMessagesErreurs *) mSupPtr ; }
//--- Data member
  public : e_typeTableMessagesErreurs mInfo ;
//--- Method for 'description' reader
  public : void appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        Element of map '@M_styles'                         *
//                                                                           *
//---------------------------------------------------------------------------*

class e_M_styles {
  public : GGS_lstring  mTitle ;
} ;

//---------------------------------------------------------------------------*

class elementOf_GGS_M_styles : public AC_galgas_map_element {
//--- Constructor
  public : elementOf_GGS_M_styles (const GGS_lstring & inKey,
                                    const sint32 inIndex,
                                     const e_M_styles & inInfo) ;
//--- Get pointers
  public : inline elementOf_GGS_M_styles * nextObject (void) const { return (elementOf_GGS_M_styles *) mNextItem ; }
  public : inline elementOf_GGS_M_styles * infObject (void) const { return (elementOf_GGS_M_styles *) mInfPtr ; }
  public : inline elementOf_GGS_M_styles * supObject (void) const { return (elementOf_GGS_M_styles *) mSupPtr ; }
//--- Data member
  public : e_M_styles mInfo ;
//--- Method for 'description' reader
  public : void appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of map '@typeTableDefinitionTerminaux'               *
//                                                                           *
//---------------------------------------------------------------------------*

class e_typeTableDefinitionTerminaux {
  public : GGS_string mErrorMessage ;
  public : GGS_typeListeAttributsSemantiques  attributListeDesAttributs ;
  public : GGS_luint  mStyleIndex ;
} ;

//---------------------------------------------------------------------------*

class elementOf_GGS_typeTableDefinitionTerminaux : public AC_galgas_map_element {
//--- Constructor
  public : elementOf_GGS_typeTableDefinitionTerminaux (const GGS_lstring & inKey,
                                    const sint32 inIndex,
                                     const e_typeTableDefinitionTerminaux & inInfo) ;
//--- Get pointers
  public : inline elementOf_GGS_typeTableDefinitionTerminaux * nextObject (void) const { return (elementOf_GGS_typeTableDefinitionTerminaux *) mNextItem ; }
  public : inline elementOf_GGS_typeTableDefinitionTerminaux * infObject (void) const { return (elementOf_GGS_typeTableDefinitionTerminaux *) mInfPtr ; }
  public : inline elementOf_GGS_typeTableDefinitionTerminaux * supObject (void) const { return (elementOf_GGS_typeTableDefinitionTerminaux *) mSupPtr ; }
//--- Data member
  public : e_typeTableDefinitionTerminaux mInfo ;
//--- Method for 'description' reader
  public : void appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of map '@typeTableMotsReserves'                   *
//                                                                           *
//---------------------------------------------------------------------------*

class e_typeTableMotsReserves {
  public : GGS_lstring  attributNomTerminal ;
} ;

//---------------------------------------------------------------------------*

class elementOf_GGS_typeTableMotsReserves : public AC_galgas_map_element {
//--- Constructor
  public : elementOf_GGS_typeTableMotsReserves (const GGS_lstring & inKey,
                                    const sint32 inIndex,
                                     const e_typeTableMotsReserves & inInfo) ;
//--- Get pointers
  public : inline elementOf_GGS_typeTableMotsReserves * nextObject (void) const { return (elementOf_GGS_typeTableMotsReserves *) mNextItem ; }
  public : inline elementOf_GGS_typeTableMotsReserves * infObject (void) const { return (elementOf_GGS_typeTableMotsReserves *) mInfPtr ; }
  public : inline elementOf_GGS_typeTableMotsReserves * supObject (void) const { return (elementOf_GGS_typeTableMotsReserves *) mSupPtr ; }
//--- Data member
  public : e_typeTableMotsReserves mInfo ;
//--- Method for 'description' reader
  public : void appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of map '@typeTableTablesDeMotsReserves'               *
//                                                                           *
//---------------------------------------------------------------------------*

class e_typeTableTablesDeMotsReserves {
  public : GGS_typeTableMotsReserves  attributSimpleTable ;
} ;

//---------------------------------------------------------------------------*

class elementOf_GGS_typeTableTablesDeMotsReserves : public AC_galgas_map_element {
//--- Constructor
  public : elementOf_GGS_typeTableTablesDeMotsReserves (const GGS_lstring & inKey,
                                    const sint32 inIndex,
                                     const e_typeTableTablesDeMotsReserves & inInfo) ;
//--- Get pointers
  public : inline elementOf_GGS_typeTableTablesDeMotsReserves * nextObject (void) const { return (elementOf_GGS_typeTableTablesDeMotsReserves *) mNextItem ; }
  public : inline elementOf_GGS_typeTableTablesDeMotsReserves * infObject (void) const { return (elementOf_GGS_typeTableTablesDeMotsReserves *) mInfPtr ; }
  public : inline elementOf_GGS_typeTableTablesDeMotsReserves * supObject (void) const { return (elementOf_GGS_typeTableTablesDeMotsReserves *) mSupPtr ; }
//--- Data member
  public : e_typeTableTablesDeMotsReserves mInfo ;
//--- Method for 'description' reader
  public : void appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const ;
} ;

//---------------------------------------------------------------------------*


#include "include_typeConditionLexicale.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeConditionChaine'                         *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeConditionChaine.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeConditionChaine'                   *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeConditionChaine {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeConditionChaine * constructor_new (const GGS_lstring & argument_0 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeConditionChaine * constructor_new (const GGS_lstring & argument_0 COMMA_LOCATION_ARGS) {
      return new cPtr_typeConditionChaine(argument_0 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'typeConditionCaractere'                       *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeConditionCaractere.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeConditionCaractere'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeConditionCaractere {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeConditionCaractere * constructor_new (const GGS_lchar & argument_0 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeConditionCaractere * constructor_new (const GGS_lchar & argument_0 COMMA_LOCATION_ARGS) {
      return new cPtr_typeConditionCaractere(argument_0 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'typeConditionIntervalle'                       *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeConditionIntervalle.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeConditionIntervalle'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeConditionIntervalle {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeConditionIntervalle * constructor_new (const GGS_lchar & argument_0,
                                const GGS_lchar & argument_1 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeConditionIntervalle * constructor_new (const GGS_lchar & argument_0,
                                const GGS_lchar & argument_1 COMMA_LOCATION_ARGS) {
      return new cPtr_typeConditionIntervalle(argument_0,
                                argument_1 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@typeListeConditionsLexicales'               *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_typeListeConditionsLexicales {
  private : elementOf_GGS_typeListeConditionsLexicales * mNextItem ;
    public : GGS_typeConditionLexicale  attributCondition ;
  public : elementOf_GGS_typeListeConditionsLexicales (const GGS_typeConditionLexicale & ) ;

  public : inline elementOf_GGS_typeListeConditionsLexicales * nextObject (void) const { return mNextItem ; }
  private : elementOf_GGS_typeListeConditionsLexicales (const elementOf_GGS_typeListeConditionsLexicales &) ;
  private : void operator = (const elementOf_GGS_typeListeConditionsLexicales &) ;
  public : inline ~elementOf_GGS_typeListeConditionsLexicales (void) {}
  public : void appendForListDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const ;
  friend class GGS_typeListeConditionsLexicales ;
} ;

//---------------------------------------------------------------------------*


#include "include_typeInstructionLexicale.h"

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@tListeInstructionsLexicales'               *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_tListeInstructionsLexicales {
  private : elementOf_GGS_tListeInstructionsLexicales * mNextItem ;
    public : GGS_typeInstructionLexicale  attributInstruction ;
  public : elementOf_GGS_tListeInstructionsLexicales (const GGS_typeInstructionLexicale & ) ;

  public : inline elementOf_GGS_tListeInstructionsLexicales * nextObject (void) const { return mNextItem ; }
  private : elementOf_GGS_tListeInstructionsLexicales (const elementOf_GGS_tListeInstructionsLexicales &) ;
  private : void operator = (const elementOf_GGS_tListeInstructionsLexicales &) ;
  public : inline ~elementOf_GGS_tListeInstructionsLexicales (void) {}
  public : void appendForListDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const ;
  friend class GGS_tListeInstructionsLexicales ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@typeListeTestsEtInstructions'               *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_typeListeTestsEtInstructions {
  private : elementOf_GGS_typeListeTestsEtInstructions * mNextItem ;
    public : GGS_typeListeConditionsLexicales  attributListeConditions ;
    public : GGS_tListeInstructionsLexicales  attributListeInstructions ;
  public : elementOf_GGS_typeListeTestsEtInstructions (const GGS_typeListeConditionsLexicales & ,
                                const GGS_tListeInstructionsLexicales & ) ;

  public : inline elementOf_GGS_typeListeTestsEtInstructions * nextObject (void) const { return mNextItem ; }
  private : elementOf_GGS_typeListeTestsEtInstructions (const elementOf_GGS_typeListeTestsEtInstructions &) ;
  private : void operator = (const elementOf_GGS_typeListeTestsEtInstructions &) ;
  public : inline ~elementOf_GGS_typeListeTestsEtInstructions (void) {}
  public : void appendForListDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const ;
  friend class GGS_typeListeTestsEtInstructions ;
} ;

//---------------------------------------------------------------------------*


#include "include_typeArgumentRoutineExterne.h"

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@typeListeArgumentsRoutExterne'              *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_typeListeArgumentsRoutExterne {
  private : elementOf_GGS_typeListeArgumentsRoutExterne * mNextItem ;
    public : GGS_typeArgumentRoutineExterne  attributArgument ;
  public : elementOf_GGS_typeListeArgumentsRoutExterne (const GGS_typeArgumentRoutineExterne & ) ;

  public : inline elementOf_GGS_typeListeArgumentsRoutExterne * nextObject (void) const { return mNextItem ; }
  private : elementOf_GGS_typeListeArgumentsRoutExterne (const elementOf_GGS_typeListeArgumentsRoutExterne &) ;
  private : void operator = (const elementOf_GGS_typeListeArgumentsRoutExterne &) ;
  public : inline ~elementOf_GGS_typeListeArgumentsRoutExterne (void) {}
  public : void appendForListDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const ;
  friend class GGS_typeListeArgumentsRoutExterne ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeArgumentAttribut'                        *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeArgumentAttribut.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeArgumentAttribut'                   *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeArgumentAttribut {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeArgumentAttribut * constructor_new (const GGS_lstring & argument_0,
                                const GGS_AC_galgasType & argument_1 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeArgumentAttribut * constructor_new (const GGS_lstring & argument_0,
                                const GGS_AC_galgasType & argument_1 COMMA_LOCATION_ARGS) {
      return new cPtr_typeArgumentAttribut(argument_0,
                                argument_1 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'typeArgumentCaractere'                        *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeArgumentCaractere.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeArgumentCaractere'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeArgumentCaractere {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeArgumentCaractere * constructor_new (const GGS_lchar & argument_0 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeArgumentCaractere * constructor_new (const GGS_lchar & argument_0 COMMA_LOCATION_ARGS) {
      return new cPtr_typeArgumentCaractere(argument_0 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'typeArgumentCaractereCourant'                    *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeArgumentCaractereCourant.h"

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_typeArgumentCaractereCourant'               *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeArgumentCaractereCourant {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeArgumentCaractereCourant * constructor_new (LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeArgumentCaractereCourant * constructor_new (LOCATION_ARGS) {
      return new cPtr_typeArgumentCaractereCourant(THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeArgumentEntier'                         *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeArgumentEntier.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeArgumentEntier'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeArgumentEntier {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeArgumentEntier * constructor_new (const GGS_luint & argument_0 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeArgumentEntier * constructor_new (const GGS_luint & argument_0 COMMA_LOCATION_ARGS) {
      return new cPtr_typeArgumentEntier(argument_0 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeArgumentRoutine'                         *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeArgumentRoutine.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeArgumentRoutine'                   *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeArgumentRoutine {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeArgumentRoutine * constructor_new (const GGS_lstring & argument_0,
                                const GGS_typeListeArgumentsRoutExterne & argument_1 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeArgumentRoutine * constructor_new (const GGS_lstring & argument_0,
                                const GGS_typeListeArgumentsRoutExterne & argument_1 COMMA_LOCATION_ARGS) {
      return new cPtr_typeArgumentRoutine(argument_0,
                                argument_1 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@typeListeMessagesErreur'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_typeListeMessagesErreur {
  private : elementOf_GGS_typeListeMessagesErreur * mNextItem ;
    public : GGS_luint  mErrorMessageIndex ;
  public : elementOf_GGS_typeListeMessagesErreur (const GGS_luint & ) ;

  public : inline elementOf_GGS_typeListeMessagesErreur * nextObject (void) const { return mNextItem ; }
  private : elementOf_GGS_typeListeMessagesErreur (const elementOf_GGS_typeListeMessagesErreur &) ;
  private : void operator = (const elementOf_GGS_typeListeMessagesErreur &) ;
  public : inline ~elementOf_GGS_typeListeMessagesErreur (void) {}
  public : void appendForListDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const ;
  friend class GGS_typeListeMessagesErreur ;
} ;

//---------------------------------------------------------------------------*


#include "include_typeEmissionParDefaut.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'typeEmissionTerminalParDefaut'                    *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeEmissionTerminalParDefaut.h"

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_typeEmissionTerminalParDefaut'              *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeEmissionTerminalParDefaut {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeEmissionTerminalParDefaut * constructor_new (const GGS_lstring & argument_0 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeEmissionTerminalParDefaut * constructor_new (const GGS_lstring & argument_0 COMMA_LOCATION_ARGS) {
      return new cPtr_typeEmissionTerminalParDefaut(argument_0 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'typeEmissionErreurParDefaut'                     *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeEmissionErreurParDefaut.h"

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeEmissionErreurParDefaut'               *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeEmissionErreurParDefaut {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeEmissionErreurParDefaut * constructor_new (const GGS_luint & argument_0 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeEmissionErreurParDefaut * constructor_new (const GGS_luint & argument_0 COMMA_LOCATION_ARGS) {
      return new cPtr_typeEmissionErreurParDefaut(argument_0 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@typeListeRecherche'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_typeListeRecherche {
  private : elementOf_GGS_typeListeRecherche * mNextItem ;
    public : GGS_lstring  attributNomAttribut ;
    public : GGS_lstring  attributNomTable ;
  public : elementOf_GGS_typeListeRecherche (const GGS_lstring & ,
                                const GGS_lstring & ) ;

  public : inline elementOf_GGS_typeListeRecherche * nextObject (void) const { return mNextItem ; }
  private : elementOf_GGS_typeListeRecherche (const elementOf_GGS_typeListeRecherche &) ;
  private : void operator = (const elementOf_GGS_typeListeRecherche &) ;
  public : inline ~elementOf_GGS_typeListeRecherche (void) {}
  public : void appendForListDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const ;
  friend class GGS_typeListeRecherche ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'typeInstructionActionExterne'                    *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeInstructionActionExterne.h"

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_typeInstructionActionExterne'               *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeInstructionActionExterne {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeInstructionActionExterne * constructor_new (const GGS_lstring & argument_0,
                                const GGS_typeListeArgumentsRoutExterne & argument_1,
                                const GGS_typeListeMessagesErreur & argument_2 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeInstructionActionExterne * constructor_new (const GGS_lstring & argument_0,
                                const GGS_typeListeArgumentsRoutExterne & argument_1,
                                const GGS_typeListeMessagesErreur & argument_2 COMMA_LOCATION_ARGS) {
      return new cPtr_typeInstructionActionExterne(argument_0,
                                argument_1,
                                argument_2 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'typeInstructionRepetitionLexicale'                  *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeInstructionRepetitionLexicale.h"

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_typeInstructionRepetitionLexicale'            *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeInstructionRepetitionLexicale {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeInstructionRepetitionLexicale * constructor_new (const GGS_tListeInstructionsLexicales & argument_0,
                                const GGS_typeListeTestsEtInstructions & argument_1 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeInstructionRepetitionLexicale * constructor_new (const GGS_tListeInstructionsLexicales & argument_0,
                                const GGS_typeListeTestsEtInstructions & argument_1 COMMA_LOCATION_ARGS) {
      return new cPtr_typeInstructionRepetitionLexicale(argument_0,
                                argument_1 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'typeInstructionSiLexical'                      *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeInstructionSiLexical.h"

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeInstructionSiLexical'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeInstructionSiLexical {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeInstructionSiLexical * constructor_new (const GGS_typeListeTestsEtInstructions & argument_0,
                                const GGS_tListeInstructionsLexicales & argument_1 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeInstructionSiLexical * constructor_new (const GGS_typeListeTestsEtInstructions & argument_0,
                                const GGS_tListeInstructionsLexicales & argument_1 COMMA_LOCATION_ARGS) {
      return new cPtr_typeInstructionSiLexical(argument_0,
                                argument_1 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'typeInstructionEmettreSimple'                    *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeInstructionEmettreSimple.h"

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_typeInstructionEmettreSimple'               *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeInstructionEmettreSimple {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeInstructionEmettreSimple * constructor_new (const GGS_lstring & argument_0 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeInstructionEmettreSimple * constructor_new (const GGS_lstring & argument_0 COMMA_LOCATION_ARGS) {
      return new cPtr_typeInstructionEmettreSimple(argument_0 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'typeInstructionEmettre'                       *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeInstructionEmettre.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeInstructionEmettre'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeInstructionEmettre {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeInstructionEmettre * constructor_new (const GGS_typeListeRecherche & argument_0,
                                const GGS_typeEmissionParDefaut & argument_1 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeInstructionEmettre * constructor_new (const GGS_typeListeRecherche & argument_0,
                                const GGS_typeEmissionParDefaut & argument_1 COMMA_LOCATION_ARGS) {
      return new cPtr_typeInstructionEmettre(argument_0,
                                argument_1 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'typeInstructionErreurLexicale'                    *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeInstructionErreurLexicale.h"

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_typeInstructionErreurLexicale'              *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeInstructionErreurLexicale {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeInstructionErreurLexicale * constructor_new (const GGS_luint & argument_0 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeInstructionErreurLexicale * constructor_new (const GGS_luint & argument_0 COMMA_LOCATION_ARGS) {
      return new cPtr_typeInstructionErreurLexicale(argument_0 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*

#endif
