//---------------------------------------------------------------------------*
//                                                                           *
//                        File 'scanner_semantics.h'                         *
//         Generated by version GALGAS_BETA_VERSION (LL(1) grammar)          *
//                    december 10th, 2006, at 20h43'35"                      *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

#ifndef scanner_semantics_DEFINED
#define scanner_semantics_DEFINED

#include <string.h>

//---------------------------------------------------------------------------*

#include "galgas/C_GGS_Object.h"
#include "galgas/AC_galgas_io.h"
#include "galgas/GGS_location.h"
#include "galgas/GGS_lbool.h"
#include "galgas/GGS_lchar.h"
#include "galgas/GGS_lstring.h"
#include "galgas/GGS_ldouble.h"
#include "galgas/GGS_luint.h"
#include "galgas/GGS_lsint.h"
#include "galgas/GGS_luint64.h"
#include "galgas/GGS_lsint64.h"
#include "galgas/GGS_stringset.h"
#include "galgas/AC_galgas_map.h"
#include "galgas/AC_galgas_list.h"
#include "galgas/AC_galgas_sortedlist.h"

//---------------------------------------------------------------------------*

#include "galgas/C_Lexique.h"

// Include imported semantics
#include "common_semantics.h"

//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                          Class Predeclarations                            *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeLexicalAttributesMap ;
class GGS_lexicalTypeMap ;
class GGS_typeTableMessagesErreurs ;
class GGS_M_styles ;
class GGS_typeTableDefinitionTerminaux ;
class GGS_typeTableMotsReserves ;
class GGS_typeTableTablesDeMotsReserves ;
class GGS_typeConditionLexicale ;
class cPtr_typeConditionLexicale ;
class GGS_typeConditionChaine ;
class cPtr_typeConditionChaine ;
class GGS_typeConditionCaractere ;
class cPtr_typeConditionCaractere ;
class GGS_typeConditionIntervalle ;
class cPtr_typeConditionIntervalle ;
class GGS_typeListeConditionsLexicales ;
class GGS_typeInstructionLexicale ;
class cPtr_typeInstructionLexicale ;
class GGS_tListeInstructionsLexicales ;
class GGS_typeListeTestsEtInstructions ;
class GGS_typeArgumentRoutineExterne ;
class cPtr_typeArgumentRoutineExterne ;
class GGS_typeListeArgumentsRoutExterne ;
class GGS_typeArgumentAttribut ;
class cPtr_typeArgumentAttribut ;
class GGS_typeArgumentCaractere ;
class cPtr_typeArgumentCaractere ;
class GGS_typeArgumentCaractereCourant ;
class cPtr_typeArgumentCaractereCourant ;
class GGS_typeArgumentEntier ;
class cPtr_typeArgumentEntier ;
class GGS_typeArgumentRoutine ;
class cPtr_typeArgumentRoutine ;
class GGS_typeListeMessagesErreur ;
class GGS_typeEmissionParDefaut ;
class cPtr_typeEmissionParDefaut ;
class GGS_typeEmissionTerminalParDefaut ;
class cPtr_typeEmissionTerminalParDefaut ;
class GGS_typeEmissionErreurParDefaut ;
class cPtr_typeEmissionErreurParDefaut ;
class GGS_typeListeRecherche ;
class GGS_typeInstructionActionExterne ;
class cPtr_typeInstructionActionExterne ;
class GGS_typeInstructionRepetitionLexicale ;
class cPtr_typeInstructionRepetitionLexicale ;
class GGS_typeInstructionSiLexical ;
class cPtr_typeInstructionSiLexical ;
class GGS_typeInstructionEmettreSimple ;
class cPtr_typeInstructionEmettreSimple ;
class GGS_typeLexicalDropInstruction ;
class cPtr_typeLexicalDropInstruction ;
class GGS_typeInstructionEmettre ;
class cPtr_typeInstructionEmettre ;
class GGS_typeInstructionErreurLexicale ;
class cPtr_typeInstructionErreurLexicale ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     Map '@typeLexicalAttributesMap'                       *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_typeLexicalAttributesMap ;

class GGS_typeLexicalAttributesMap : public AC_galgas_map {
//--- Element Class
  public : typedef elementOf_GGS_typeLexicalAttributesMap element_type ;
//--- Get pointers
  public : inline element_type * rootObject (void) const { return (element_type *) internalRootObject () ; }
  public : inline element_type * firstObject (void) const { return (element_type *) internalFirstObject () ; }
  public : inline element_type * lastObject (void) const { return (element_type *) internalLastObject () ; }
//--- Comparison methods
  public : GGS_bool operator == (const GGS_typeLexicalAttributesMap & inOperand) const ;
  public : GGS_bool operator != (const GGS_typeLexicalAttributesMap & inOperand) const ;
//--- Create a new element
  protected : virtual AC_galgas_map_element * new_element (const GGS_lstring & inKey, void * inInfo) ;
//--- Get object pointer (for method call)
  public : inline GGS_typeLexicalAttributesMap * operator () (UNUSED_LOCATION_ARGS) { return this ; }
  public : inline const GGS_typeLexicalAttributesMap * operator () (UNUSED_LOCATION_ARGS) const { return this ; }
//--- 'emptyMap' constructor
  public : static GGS_typeLexicalAttributesMap constructor_emptyMap (C_Lexique & inLexique COMMA_LOCATION_ARGS) ;
//--- Method used for duplicate a map
  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;
//--- 'insertKey' Insert Modifier
  public : void modifier_insertKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0 COMMA_LOCATION_ARGS) ;
//--- 'searchKey' Search Method
  public : void method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_AC_galgasType   & outParameter0 COMMA_LOCATION_ARGS) const ;
//--- Internal method for inserting an element
  protected : void _insertElement (C_Lexique & inLexique,
                                   const char * inErrorMessage,
                                   const GGS_lstring & inKey,
                                   const GGS_AC_galgasType & inParameter0,
                                   GGS_luint * outIndex
                                   COMMA_LOCATION_ARGS) ;
//--- Internal method for searching for an element
  protected : void _searchElement (C_Lexique & inLexique,
                                   const char * inErrorMessage,
                                   const GGS_lstring & inKey,
                                   GGS_AC_galgasType & outParameter0,
                                   GGS_luint * outIndex
                                   COMMA_LOCATION_ARGS) const ;
  public : GGS_string reader_description (C_Lexique & _inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;
  public : static GGS_typeLexicalAttributesMap constructor_mapWithMapToOverride (C_Lexique & inLexique,
                                            const GGS_typeLexicalAttributesMap & inMapToOverride
                                            COMMA_LOCATION_ARGS) ;
  public : GGS_typeLexicalAttributesMap reader_overriddenMap (C_Lexique & inLexique
                                            COMMA_LOCATION_ARGS) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                          Map '@lexicalTypeMap'                            *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_lexicalTypeMap ;

class GGS_lexicalTypeMap : public AC_galgas_map {
//--- Element Class
  public : typedef elementOf_GGS_lexicalTypeMap element_type ;
//--- Get pointers
  public : inline element_type * rootObject (void) const { return (element_type *) internalRootObject () ; }
  public : inline element_type * firstObject (void) const { return (element_type *) internalFirstObject () ; }
  public : inline element_type * lastObject (void) const { return (element_type *) internalLastObject () ; }
//--- Comparison methods
  public : GGS_bool operator == (const GGS_lexicalTypeMap & inOperand) const ;
  public : GGS_bool operator != (const GGS_lexicalTypeMap & inOperand) const ;
//--- Create a new element
  protected : virtual AC_galgas_map_element * new_element (const GGS_lstring & inKey, void * inInfo) ;
//--- Get object pointer (for method call)
  public : inline GGS_lexicalTypeMap * operator () (UNUSED_LOCATION_ARGS) { return this ; }
  public : inline const GGS_lexicalTypeMap * operator () (UNUSED_LOCATION_ARGS) const { return this ; }
//--- 'emptyMap' constructor
  public : static GGS_lexicalTypeMap constructor_emptyMap (C_Lexique & inLexique COMMA_LOCATION_ARGS) ;
//--- Method used for duplicate a map
  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;
//--- 'insertKey' Insert Modifier
  public : void modifier_insertKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0 COMMA_LOCATION_ARGS) ;
//--- 'searchKey' Search Method
  public : void method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_AC_galgasType   & outParameter0 COMMA_LOCATION_ARGS) const ;
//--- Internal method for inserting an element
  protected : void _insertElement (C_Lexique & inLexique,
                                   const char * inErrorMessage,
                                   const GGS_lstring & inKey,
                                   const GGS_AC_galgasType & inParameter0,
                                   GGS_luint * outIndex
                                   COMMA_LOCATION_ARGS) ;
//--- Internal method for searching for an element
  protected : void _searchElement (C_Lexique & inLexique,
                                   const char * inErrorMessage,
                                   const GGS_lstring & inKey,
                                   GGS_AC_galgasType & outParameter0,
                                   GGS_luint * outIndex
                                   COMMA_LOCATION_ARGS) const ;
  public : GGS_string reader_description (C_Lexique & _inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;
  public : static GGS_lexicalTypeMap constructor_mapWithMapToOverride (C_Lexique & inLexique,
                                            const GGS_lexicalTypeMap & inMapToOverride
                                            COMMA_LOCATION_ARGS) ;
  public : GGS_lexicalTypeMap reader_overriddenMap (C_Lexique & inLexique
                                            COMMA_LOCATION_ARGS) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     Map '@typeTableMessagesErreurs'                       *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_typeTableMessagesErreurs ;

class GGS_typeTableMessagesErreurs : public AC_galgas_map {
//--- Element Class
  public : typedef elementOf_GGS_typeTableMessagesErreurs element_type ;
//--- Get pointers
  public : inline element_type * rootObject (void) const { return (element_type *) internalRootObject () ; }
  public : inline element_type * firstObject (void) const { return (element_type *) internalFirstObject () ; }
  public : inline element_type * lastObject (void) const { return (element_type *) internalLastObject () ; }
//--- Comparison methods
  public : GGS_bool operator == (const GGS_typeTableMessagesErreurs & inOperand) const ;
  public : GGS_bool operator != (const GGS_typeTableMessagesErreurs & inOperand) const ;
//--- Create a new element
  protected : virtual AC_galgas_map_element * new_element (const GGS_lstring & inKey, void * inInfo) ;
//--- Get object pointer (for method call)
  public : inline GGS_typeTableMessagesErreurs * operator () (UNUSED_LOCATION_ARGS) { return this ; }
  public : inline const GGS_typeTableMessagesErreurs * operator () (UNUSED_LOCATION_ARGS) const { return this ; }
//--- 'emptyMap' constructor
  public : static GGS_typeTableMessagesErreurs constructor_emptyMap (C_Lexique & inLexique COMMA_LOCATION_ARGS) ;
//--- Method used for duplicate a map
  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;
//--- 'insertKey' Insert Modifier
  public : void modifier_insertKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lstring &  inParameter0 COMMA_LOCATION_ARGS) ;
//--- 'searchKey' Search Method
  public : void method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lstring   & outParameter0 COMMA_LOCATION_ARGS) const ;
//--- 'searchKeyGetIndex' Search Method
  public : void method_searchKeyGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_lstring   & outParameter0 COMMA_LOCATION_ARGS) const ;
//--- Internal method for inserting an element
  protected : void _insertElement (C_Lexique & inLexique,
                                   const char * inErrorMessage,
                                   const GGS_lstring & inKey,
                                   const GGS_lstring & inParameter0,
                                   GGS_luint * outIndex
                                   COMMA_LOCATION_ARGS) ;
//--- Internal method for searching for an element
  protected : void _searchElement (C_Lexique & inLexique,
                                   const char * inErrorMessage,
                                   const GGS_lstring & inKey,
                                   GGS_lstring & outParameter0,
                                   GGS_luint * outIndex
                                   COMMA_LOCATION_ARGS) const ;
  public : GGS_string reader_description (C_Lexique & _inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;
  public : static GGS_typeTableMessagesErreurs constructor_mapWithMapToOverride (C_Lexique & inLexique,
                                            const GGS_typeTableMessagesErreurs & inMapToOverride
                                            COMMA_LOCATION_ARGS) ;
  public : GGS_typeTableMessagesErreurs reader_overriddenMap (C_Lexique & inLexique
                                            COMMA_LOCATION_ARGS) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                             Map '@M_styles'                               *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_M_styles ;

class GGS_M_styles : public AC_galgas_map {
//--- Element Class
  public : typedef elementOf_GGS_M_styles element_type ;
//--- Get pointers
  public : inline element_type * rootObject (void) const { return (element_type *) internalRootObject () ; }
  public : inline element_type * firstObject (void) const { return (element_type *) internalFirstObject () ; }
  public : inline element_type * lastObject (void) const { return (element_type *) internalLastObject () ; }
//--- Comparison methods
  public : GGS_bool operator == (const GGS_M_styles & inOperand) const ;
  public : GGS_bool operator != (const GGS_M_styles & inOperand) const ;
//--- Create a new element
  protected : virtual AC_galgas_map_element * new_element (const GGS_lstring & inKey, void * inInfo) ;
//--- Get object pointer (for method call)
  public : inline GGS_M_styles * operator () (UNUSED_LOCATION_ARGS) { return this ; }
  public : inline const GGS_M_styles * operator () (UNUSED_LOCATION_ARGS) const { return this ; }
//--- 'emptyMap' constructor
  public : static GGS_M_styles constructor_emptyMap (C_Lexique & inLexique COMMA_LOCATION_ARGS) ;
//--- Method used for duplicate a map
  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;
//--- 'insertKey' Insert Modifier
  public : void modifier_insertKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lstring &  inParameter0 COMMA_LOCATION_ARGS) ;
//--- 'searchKey' Search Method
  public : void method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lstring   & outParameter0 COMMA_LOCATION_ARGS) const ;
//--- 'searchKeyGetIndex' Search Method
  public : void method_searchKeyGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_lstring   & outParameter0 COMMA_LOCATION_ARGS) const ;
//--- Internal method for inserting an element
  protected : void _insertElement (C_Lexique & inLexique,
                                   const char * inErrorMessage,
                                   const GGS_lstring & inKey,
                                   const GGS_lstring & inParameter0,
                                   GGS_luint * outIndex
                                   COMMA_LOCATION_ARGS) ;
//--- Internal method for searching for an element
  protected : void _searchElement (C_Lexique & inLexique,
                                   const char * inErrorMessage,
                                   const GGS_lstring & inKey,
                                   GGS_lstring & outParameter0,
                                   GGS_luint * outIndex
                                   COMMA_LOCATION_ARGS) const ;
  public : GGS_string reader_description (C_Lexique & _inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;
  public : static GGS_M_styles constructor_mapWithMapToOverride (C_Lexique & inLexique,
                                            const GGS_M_styles & inMapToOverride
                                            COMMA_LOCATION_ARGS) ;
  public : GGS_M_styles reader_overriddenMap (C_Lexique & inLexique
                                            COMMA_LOCATION_ARGS) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   Map '@typeTableDefinitionTerminaux'                     *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_typeTableDefinitionTerminaux ;

class GGS_typeTableDefinitionTerminaux : public AC_galgas_map {
//--- Element Class
  public : typedef elementOf_GGS_typeTableDefinitionTerminaux element_type ;
//--- Get pointers
  public : inline element_type * rootObject (void) const { return (element_type *) internalRootObject () ; }
  public : inline element_type * firstObject (void) const { return (element_type *) internalFirstObject () ; }
  public : inline element_type * lastObject (void) const { return (element_type *) internalLastObject () ; }
//--- Comparison methods
  public : GGS_bool operator == (const GGS_typeTableDefinitionTerminaux & inOperand) const ;
  public : GGS_bool operator != (const GGS_typeTableDefinitionTerminaux & inOperand) const ;
//--- Create a new element
  protected : virtual AC_galgas_map_element * new_element (const GGS_lstring & inKey, void * inInfo) ;
//--- Get object pointer (for method call)
  public : inline GGS_typeTableDefinitionTerminaux * operator () (UNUSED_LOCATION_ARGS) { return this ; }
  public : inline const GGS_typeTableDefinitionTerminaux * operator () (UNUSED_LOCATION_ARGS) const { return this ; }
//--- 'emptyMap' constructor
  public : static GGS_typeTableDefinitionTerminaux constructor_emptyMap (C_Lexique & inLexique COMMA_LOCATION_ARGS) ;
//--- Method used for duplicate a map
  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;
//--- 'insertKey' Insert Modifier
  public : void modifier_insertKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_string&  inParameter0,
                                const GGS_typeListeAttributsSemantiques &  inParameter1,
                                const GGS_luint &  inParameter2 COMMA_LOCATION_ARGS) ;
//--- 'searchKey' Search Method
  public : void method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_string  & outParameter0,
                                GGS_typeListeAttributsSemantiques   & outParameter1,
                                GGS_luint   & outParameter2 COMMA_LOCATION_ARGS) const ;
//--- Internal method for inserting an element
  protected : void _insertElement (C_Lexique & inLexique,
                                   const char * inErrorMessage,
                                   const GGS_lstring & inKey,
                                   const GGS_string& inParameter0,
                                   const GGS_typeListeAttributsSemantiques & inParameter1,
                                   const GGS_luint & inParameter2,
                                   GGS_luint * outIndex
                                   COMMA_LOCATION_ARGS) ;
//--- Internal method for searching for an element
  protected : void _searchElement (C_Lexique & inLexique,
                                   const char * inErrorMessage,
                                   const GGS_lstring & inKey,
                                   GGS_string& outParameter0,
                                   GGS_typeListeAttributsSemantiques & outParameter1,
                                   GGS_luint & outParameter2,
                                   GGS_luint * outIndex
                                   COMMA_LOCATION_ARGS) const ;
  public : GGS_string reader_description (C_Lexique & _inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;
  public : static GGS_typeTableDefinitionTerminaux constructor_mapWithMapToOverride (C_Lexique & inLexique,
                                            const GGS_typeTableDefinitionTerminaux & inMapToOverride
                                            COMMA_LOCATION_ARGS) ;
  public : GGS_typeTableDefinitionTerminaux reader_overriddenMap (C_Lexique & inLexique
                                            COMMA_LOCATION_ARGS) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       Map '@typeTableMotsReserves'                        *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_typeTableMotsReserves ;

class GGS_typeTableMotsReserves : public AC_galgas_map {
//--- Element Class
  public : typedef elementOf_GGS_typeTableMotsReserves element_type ;
//--- Get pointers
  public : inline element_type * rootObject (void) const { return (element_type *) internalRootObject () ; }
  public : inline element_type * firstObject (void) const { return (element_type *) internalFirstObject () ; }
  public : inline element_type * lastObject (void) const { return (element_type *) internalLastObject () ; }
//--- Comparison methods
  public : GGS_bool operator == (const GGS_typeTableMotsReserves & inOperand) const ;
  public : GGS_bool operator != (const GGS_typeTableMotsReserves & inOperand) const ;
//--- Create a new element
  protected : virtual AC_galgas_map_element * new_element (const GGS_lstring & inKey, void * inInfo) ;
//--- Get object pointer (for method call)
  public : inline GGS_typeTableMotsReserves * operator () (UNUSED_LOCATION_ARGS) { return this ; }
  public : inline const GGS_typeTableMotsReserves * operator () (UNUSED_LOCATION_ARGS) const { return this ; }
//--- 'emptyMap' constructor
  public : static GGS_typeTableMotsReserves constructor_emptyMap (C_Lexique & inLexique COMMA_LOCATION_ARGS) ;
//--- Method used for duplicate a map
  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;
//--- 'insertKey' Insert Modifier
  public : void modifier_insertKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lstring &  inParameter0 COMMA_LOCATION_ARGS) ;
//--- 'searchKey' Search Method
  public : void method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lstring   & outParameter0 COMMA_LOCATION_ARGS) const ;
//--- Internal method for inserting an element
  protected : void _insertElement (C_Lexique & inLexique,
                                   const char * inErrorMessage,
                                   const GGS_lstring & inKey,
                                   const GGS_lstring & inParameter0,
                                   GGS_luint * outIndex
                                   COMMA_LOCATION_ARGS) ;
//--- Internal method for searching for an element
  protected : void _searchElement (C_Lexique & inLexique,
                                   const char * inErrorMessage,
                                   const GGS_lstring & inKey,
                                   GGS_lstring & outParameter0,
                                   GGS_luint * outIndex
                                   COMMA_LOCATION_ARGS) const ;
  public : GGS_string reader_description (C_Lexique & _inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;
  public : static GGS_typeTableMotsReserves constructor_mapWithMapToOverride (C_Lexique & inLexique,
                                            const GGS_typeTableMotsReserves & inMapToOverride
                                            COMMA_LOCATION_ARGS) ;
  public : GGS_typeTableMotsReserves reader_overriddenMap (C_Lexique & inLexique
                                            COMMA_LOCATION_ARGS) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   Map '@typeTableTablesDeMotsReserves'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_typeTableTablesDeMotsReserves ;

class GGS_typeTableTablesDeMotsReserves : public AC_galgas_map {
//--- Element Class
  public : typedef elementOf_GGS_typeTableTablesDeMotsReserves element_type ;
//--- Get pointers
  public : inline element_type * rootObject (void) const { return (element_type *) internalRootObject () ; }
  public : inline element_type * firstObject (void) const { return (element_type *) internalFirstObject () ; }
  public : inline element_type * lastObject (void) const { return (element_type *) internalLastObject () ; }
//--- Comparison methods
  public : GGS_bool operator == (const GGS_typeTableTablesDeMotsReserves & inOperand) const ;
  public : GGS_bool operator != (const GGS_typeTableTablesDeMotsReserves & inOperand) const ;
//--- Create a new element
  protected : virtual AC_galgas_map_element * new_element (const GGS_lstring & inKey, void * inInfo) ;
//--- Get object pointer (for method call)
  public : inline GGS_typeTableTablesDeMotsReserves * operator () (UNUSED_LOCATION_ARGS) { return this ; }
  public : inline const GGS_typeTableTablesDeMotsReserves * operator () (UNUSED_LOCATION_ARGS) const { return this ; }
//--- 'emptyMap' constructor
  public : static GGS_typeTableTablesDeMotsReserves constructor_emptyMap (C_Lexique & inLexique COMMA_LOCATION_ARGS) ;
//--- Method used for duplicate a map
  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;
//--- 'insertKey' Insert Modifier
  public : void modifier_insertKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_typeTableMotsReserves &  inParameter0 COMMA_LOCATION_ARGS) ;
//--- 'searchKey' Search Method
  public : void method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_typeTableMotsReserves   & outParameter0 COMMA_LOCATION_ARGS) const ;
//--- Internal method for inserting an element
  protected : void _insertElement (C_Lexique & inLexique,
                                   const char * inErrorMessage,
                                   const GGS_lstring & inKey,
                                   const GGS_typeTableMotsReserves & inParameter0,
                                   GGS_luint * outIndex
                                   COMMA_LOCATION_ARGS) ;
//--- Internal method for searching for an element
  protected : void _searchElement (C_Lexique & inLexique,
                                   const char * inErrorMessage,
                                   const GGS_lstring & inKey,
                                   GGS_typeTableMotsReserves & outParameter0,
                                   GGS_luint * outIndex
                                   COMMA_LOCATION_ARGS) const ;
  public : GGS_string reader_description (C_Lexique & _inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;
  public : static GGS_typeTableTablesDeMotsReserves constructor_mapWithMapToOverride (C_Lexique & inLexique,
                                            const GGS_typeTableTablesDeMotsReserves & inMapToOverride
                                            COMMA_LOCATION_ARGS) ;
  public : GGS_typeTableTablesDeMotsReserves reader_overriddenMap (C_Lexique & inLexique
                                            COMMA_LOCATION_ARGS) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeConditionLexicale'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeConditionLexicale {
//--- Pointer to actual instance
  protected : cPtr_typeConditionLexicale * mPointer ;
//--- Default constructor
  public : GGS_typeConditionLexicale (void) ;
//--- Copy constructor
  public : GGS_typeConditionLexicale (const GGS_typeConditionLexicale &) ;
//--- Virtual destructor
  public : virtual ~GGS_typeConditionLexicale (void) ;
//--- Assignment operator
  public : void operator = (const GGS_typeConditionLexicale &) ;
//--- Comparison methods
  public : GGS_bool operator == (const GGS_typeConditionLexicale & inOperand) const ;
  public : GGS_bool operator != (const GGS_typeConditionLexicale & inOperand) const ;
//--- _isBuilt
  public : inline bool _isBuilt (void) const { return mPointer != NULL ; }
//--- isEqualTo
  public : inline bool isEqualTo (const GGS_typeConditionLexicale & _inOperand) const {
    return mPointer == _inOperand.mPointer ;
  }
//--- getPtr
  public : inline cPtr_typeConditionLexicale * getPtr (void) const {
    return mPointer ;
  }
//--- drop
  public : void _drop_operation (void) ;
//--- 'description' reader
  public : GGS_string reader_description (C_Lexique & _inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;
//--- operator ()
//--- Readers
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_typeConditionLexicale * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_typeConditionLexicale * operator () (LOCATION_ARGS) const {
      return mPointer ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeConditionChaine'                   *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeConditionChaine : public GGS_typeConditionLexicale {
//--- Default constructor
  public : GGS_typeConditionChaine (void) ;
//--- Copy constructor
  public : GGS_typeConditionChaine (const GGS_typeConditionChaine &) ;
//--- Virtual destructor
  public : virtual ~GGS_typeConditionChaine (void) ;
//--- 'new' constructor
  public : static GGS_typeConditionChaine constructor_new (C_Lexique & inLexique,
                                const GGS_lstring & argument_0 COMMA_LOCATION_ARGS) ;
//--- Assignment operator
  public : void operator = (const GGS_typeConditionChaine &) ;
//--- Comparison methods
  public : GGS_bool operator == (const GGS_typeConditionChaine & inOperand) const ;
  public : GGS_bool operator != (const GGS_typeConditionChaine & inOperand) const ;
//--- 'description' reader
  public : GGS_string reader_description (C_Lexique & _inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;
//--- operator ()
//--- Readers
  public : GGS_lstring  reader_attributChaine (C_Lexique & inLexique COMMA_LOCATION_ARGS) const ;
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_typeConditionChaine * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_typeConditionChaine * operator () (LOCATION_ARGS) const {
      return (cPtr_typeConditionChaine *) mPointer ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeConditionCaractere'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeConditionCaractere : public GGS_typeConditionLexicale {
//--- Default constructor
  public : GGS_typeConditionCaractere (void) ;
//--- Copy constructor
  public : GGS_typeConditionCaractere (const GGS_typeConditionCaractere &) ;
//--- Virtual destructor
  public : virtual ~GGS_typeConditionCaractere (void) ;
//--- 'new' constructor
  public : static GGS_typeConditionCaractere constructor_new (C_Lexique & inLexique,
                                const GGS_lchar & argument_0 COMMA_LOCATION_ARGS) ;
//--- Assignment operator
  public : void operator = (const GGS_typeConditionCaractere &) ;
//--- Comparison methods
  public : GGS_bool operator == (const GGS_typeConditionCaractere & inOperand) const ;
  public : GGS_bool operator != (const GGS_typeConditionCaractere & inOperand) const ;
//--- 'description' reader
  public : GGS_string reader_description (C_Lexique & _inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;
//--- operator ()
//--- Readers
  public : GGS_lchar  reader_attributCaractere (C_Lexique & inLexique COMMA_LOCATION_ARGS) const ;
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_typeConditionCaractere * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_typeConditionCaractere * operator () (LOCATION_ARGS) const {
      return (cPtr_typeConditionCaractere *) mPointer ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeConditionIntervalle'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeConditionIntervalle : public GGS_typeConditionLexicale {
//--- Default constructor
  public : GGS_typeConditionIntervalle (void) ;
//--- Copy constructor
  public : GGS_typeConditionIntervalle (const GGS_typeConditionIntervalle &) ;
//--- Virtual destructor
  public : virtual ~GGS_typeConditionIntervalle (void) ;
//--- 'new' constructor
  public : static GGS_typeConditionIntervalle constructor_new (C_Lexique & inLexique,
                                const GGS_lchar & argument_0,
                                const GGS_lchar & argument_1 COMMA_LOCATION_ARGS) ;
//--- Assignment operator
  public : void operator = (const GGS_typeConditionIntervalle &) ;
//--- Comparison methods
  public : GGS_bool operator == (const GGS_typeConditionIntervalle & inOperand) const ;
  public : GGS_bool operator != (const GGS_typeConditionIntervalle & inOperand) const ;
//--- 'description' reader
  public : GGS_string reader_description (C_Lexique & _inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;
//--- operator ()
//--- Readers
  public : GGS_lchar  reader_attributBorneInf (C_Lexique & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_lchar  reader_attributBorneSup (C_Lexique & inLexique COMMA_LOCATION_ARGS) const ;
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_typeConditionIntervalle * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_typeConditionIntervalle * operator () (LOCATION_ARGS) const {
      return (cPtr_typeConditionIntervalle *) mPointer ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   list '@typeListeConditionsLexicales'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_typeListeConditionsLexicales ;

class GGS_typeListeConditionsLexicales : public AC_galgas_list {
  public : typedef elementOf_GGS_typeListeConditionsLexicales element_type ;
//--- Default Constructor
  public : GGS_typeListeConditionsLexicales (void) ;
//--- Copy Constructor
  public : GGS_typeListeConditionsLexicales (const GGS_typeListeConditionsLexicales & inSource) ;
//--- Comparison Operators
  public : GGS_bool operator == (const GGS_typeListeConditionsLexicales & inOperand) const ;
  public : GGS_bool operator != (const GGS_typeListeConditionsLexicales & inOperand) const ;
//--- Constructor 'emptyList'
  public : static GGS_typeListeConditionsLexicales constructor_emptyList (C_Lexique & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_typeListeConditionsLexicales constructor_listWithValue (C_Lexique & _inLexique,
                                const GGS_typeConditionLexicale & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operators () used for method call
  public : const GGS_typeListeConditionsLexicales * operator () (UNUSED_LOCATION_ARGS) const { return this ;} 
//--- Method 'first'
  public : void method_first (C_Lexique & _inLexique,
                              GGS_typeConditionLexicale & _out_0
                              COMMA_LOCATION_ARGS) const ;
//--- Method 'last'
  public : void method_last (C_Lexique & _inLexique,
                             GGS_typeConditionLexicale & _out_0
                             COMMA_LOCATION_ARGS) const ;
//--- Modifier 'popLast'
  public : void modifier_popLast (C_Lexique & _inLexique,
                                GGS_typeConditionLexicale & _out_0
                                COMMA_LOCATION_ARGS) ;
//--- Modifier 'popFirst'
  public : void modifier_popFirst (C_Lexique & _inLexique,
                                 GGS_typeConditionLexicale & _out_0
                                 COMMA_LOCATION_ARGS) ;
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_typeConditionLexicale & argument_0) ;
//--- Handling '.' GALGAS operator
  public : GGS_typeListeConditionsLexicales operator + (const GGS_typeListeConditionsLexicales & inOperand) const ;
  public : void modifier_prependValue (C_Lexique & _inLexique,
                                const GGS_typeConditionLexicale & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_typeConditionLexicale & argument_0) ;
  protected : void _internalPrependValues (const GGS_typeConditionLexicale & argument_0) ;
//--- List Insulation
  protected : void _insulateList (void) ;
//--- Reader 'description
  public : GGS_string reader_description (C_Lexique & _inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeInstructionLexicale'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeInstructionLexicale {
//--- Pointer to actual instance
  protected : cPtr_typeInstructionLexicale * mPointer ;
//--- Default constructor
  public : GGS_typeInstructionLexicale (void) ;
//--- Copy constructor
  public : GGS_typeInstructionLexicale (const GGS_typeInstructionLexicale &) ;
//--- Virtual destructor
  public : virtual ~GGS_typeInstructionLexicale (void) ;
//--- Assignment operator
  public : void operator = (const GGS_typeInstructionLexicale &) ;
//--- Comparison methods
  public : GGS_bool operator == (const GGS_typeInstructionLexicale & inOperand) const ;
  public : GGS_bool operator != (const GGS_typeInstructionLexicale & inOperand) const ;
//--- _isBuilt
  public : inline bool _isBuilt (void) const { return mPointer != NULL ; }
//--- isEqualTo
  public : inline bool isEqualTo (const GGS_typeInstructionLexicale & _inOperand) const {
    return mPointer == _inOperand.mPointer ;
  }
//--- getPtr
  public : inline cPtr_typeInstructionLexicale * getPtr (void) const {
    return mPointer ;
  }
//--- drop
  public : void _drop_operation (void) ;
//--- 'description' reader
  public : GGS_string reader_description (C_Lexique & _inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;
//--- operator ()
//--- Readers
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_typeInstructionLexicale * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_typeInstructionLexicale * operator () (LOCATION_ARGS) const {
      return mPointer ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   list '@tListeInstructionsLexicales'                     *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_tListeInstructionsLexicales ;

class GGS_tListeInstructionsLexicales : public AC_galgas_list {
  public : typedef elementOf_GGS_tListeInstructionsLexicales element_type ;
//--- Default Constructor
  public : GGS_tListeInstructionsLexicales (void) ;
//--- Copy Constructor
  public : GGS_tListeInstructionsLexicales (const GGS_tListeInstructionsLexicales & inSource) ;
//--- Comparison Operators
  public : GGS_bool operator == (const GGS_tListeInstructionsLexicales & inOperand) const ;
  public : GGS_bool operator != (const GGS_tListeInstructionsLexicales & inOperand) const ;
//--- Constructor 'emptyList'
  public : static GGS_tListeInstructionsLexicales constructor_emptyList (C_Lexique & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_tListeInstructionsLexicales constructor_listWithValue (C_Lexique & _inLexique,
                                const GGS_typeInstructionLexicale & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operators () used for method call
  public : const GGS_tListeInstructionsLexicales * operator () (UNUSED_LOCATION_ARGS) const { return this ;} 
//--- Method 'first'
  public : void method_first (C_Lexique & _inLexique,
                              GGS_typeInstructionLexicale & _out_0
                              COMMA_LOCATION_ARGS) const ;
//--- Method 'last'
  public : void method_last (C_Lexique & _inLexique,
                             GGS_typeInstructionLexicale & _out_0
                             COMMA_LOCATION_ARGS) const ;
//--- Modifier 'popLast'
  public : void modifier_popLast (C_Lexique & _inLexique,
                                GGS_typeInstructionLexicale & _out_0
                                COMMA_LOCATION_ARGS) ;
//--- Modifier 'popFirst'
  public : void modifier_popFirst (C_Lexique & _inLexique,
                                 GGS_typeInstructionLexicale & _out_0
                                 COMMA_LOCATION_ARGS) ;
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_typeInstructionLexicale & argument_0) ;
//--- Handling '.' GALGAS operator
  public : GGS_tListeInstructionsLexicales operator + (const GGS_tListeInstructionsLexicales & inOperand) const ;
  public : void modifier_prependValue (C_Lexique & _inLexique,
                                const GGS_typeInstructionLexicale & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_typeInstructionLexicale & argument_0) ;
  protected : void _internalPrependValues (const GGS_typeInstructionLexicale & argument_0) ;
//--- List Insulation
  protected : void _insulateList (void) ;
//--- Reader 'description
  public : GGS_string reader_description (C_Lexique & _inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   list '@typeListeTestsEtInstructions'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_typeListeTestsEtInstructions ;

class GGS_typeListeTestsEtInstructions : public AC_galgas_list {
  public : typedef elementOf_GGS_typeListeTestsEtInstructions element_type ;
//--- Default Constructor
  public : GGS_typeListeTestsEtInstructions (void) ;
//--- Copy Constructor
  public : GGS_typeListeTestsEtInstructions (const GGS_typeListeTestsEtInstructions & inSource) ;
//--- Comparison Operators
  public : GGS_bool operator == (const GGS_typeListeTestsEtInstructions & inOperand) const ;
  public : GGS_bool operator != (const GGS_typeListeTestsEtInstructions & inOperand) const ;
//--- Constructor 'emptyList'
  public : static GGS_typeListeTestsEtInstructions constructor_emptyList (C_Lexique & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_typeListeTestsEtInstructions constructor_listWithValue (C_Lexique & _inLexique,
                                const GGS_typeListeConditionsLexicales & argument_0,
                                const GGS_tListeInstructionsLexicales & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operators () used for method call
  public : const GGS_typeListeTestsEtInstructions * operator () (UNUSED_LOCATION_ARGS) const { return this ;} 
//--- Method 'first'
  public : void method_first (C_Lexique & _inLexique,
                              GGS_typeListeConditionsLexicales & _out_0,
                              GGS_tListeInstructionsLexicales & _out_1
                              COMMA_LOCATION_ARGS) const ;
//--- Method 'last'
  public : void method_last (C_Lexique & _inLexique,
                             GGS_typeListeConditionsLexicales & _out_0,
                             GGS_tListeInstructionsLexicales & _out_1
                             COMMA_LOCATION_ARGS) const ;
//--- Modifier 'popLast'
  public : void modifier_popLast (C_Lexique & _inLexique,
                                GGS_typeListeConditionsLexicales & _out_0,
                                GGS_tListeInstructionsLexicales & _out_1
                                COMMA_LOCATION_ARGS) ;
//--- Modifier 'popFirst'
  public : void modifier_popFirst (C_Lexique & _inLexique,
                                 GGS_typeListeConditionsLexicales & _out_0,
                                 GGS_tListeInstructionsLexicales & _out_1
                                 COMMA_LOCATION_ARGS) ;
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_typeListeConditionsLexicales & argument_0,
                                const GGS_tListeInstructionsLexicales & argument_1) ;
//--- Handling '.' GALGAS operator
  public : GGS_typeListeTestsEtInstructions operator + (const GGS_typeListeTestsEtInstructions & inOperand) const ;
  public : void modifier_prependValue (C_Lexique & _inLexique,
                                const GGS_typeListeConditionsLexicales & argument_0,
                                const GGS_tListeInstructionsLexicales & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_typeListeConditionsLexicales & argument_0,
                                const GGS_tListeInstructionsLexicales & argument_1) ;
  protected : void _internalPrependValues (const GGS_typeListeConditionsLexicales & argument_0,
                                const GGS_tListeInstructionsLexicales & argument_1) ;
//--- List Insulation
  protected : void _insulateList (void) ;
//--- Reader 'description
  public : GGS_string reader_description (C_Lexique & _inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeArgumentRoutineExterne'                *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeArgumentRoutineExterne {
//--- Pointer to actual instance
  protected : cPtr_typeArgumentRoutineExterne * mPointer ;
//--- Default constructor
  public : GGS_typeArgumentRoutineExterne (void) ;
//--- Copy constructor
  public : GGS_typeArgumentRoutineExterne (const GGS_typeArgumentRoutineExterne &) ;
//--- Virtual destructor
  public : virtual ~GGS_typeArgumentRoutineExterne (void) ;
//--- Assignment operator
  public : void operator = (const GGS_typeArgumentRoutineExterne &) ;
//--- Comparison methods
  public : GGS_bool operator == (const GGS_typeArgumentRoutineExterne & inOperand) const ;
  public : GGS_bool operator != (const GGS_typeArgumentRoutineExterne & inOperand) const ;
//--- _isBuilt
  public : inline bool _isBuilt (void) const { return mPointer != NULL ; }
//--- isEqualTo
  public : inline bool isEqualTo (const GGS_typeArgumentRoutineExterne & _inOperand) const {
    return mPointer == _inOperand.mPointer ;
  }
//--- getPtr
  public : inline cPtr_typeArgumentRoutineExterne * getPtr (void) const {
    return mPointer ;
  }
//--- drop
  public : void _drop_operation (void) ;
//--- 'description' reader
  public : GGS_string reader_description (C_Lexique & _inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;
//--- operator ()
//--- Readers
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_typeArgumentRoutineExterne * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_typeArgumentRoutineExterne * operator () (LOCATION_ARGS) const {
      return mPointer ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  list '@typeListeArgumentsRoutExterne'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_typeListeArgumentsRoutExterne ;

class GGS_typeListeArgumentsRoutExterne : public AC_galgas_list {
  public : typedef elementOf_GGS_typeListeArgumentsRoutExterne element_type ;
//--- Default Constructor
  public : GGS_typeListeArgumentsRoutExterne (void) ;
//--- Copy Constructor
  public : GGS_typeListeArgumentsRoutExterne (const GGS_typeListeArgumentsRoutExterne & inSource) ;
//--- Comparison Operators
  public : GGS_bool operator == (const GGS_typeListeArgumentsRoutExterne & inOperand) const ;
  public : GGS_bool operator != (const GGS_typeListeArgumentsRoutExterne & inOperand) const ;
//--- Constructor 'emptyList'
  public : static GGS_typeListeArgumentsRoutExterne constructor_emptyList (C_Lexique & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_typeListeArgumentsRoutExterne constructor_listWithValue (C_Lexique & _inLexique,
                                const GGS_typeArgumentRoutineExterne & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operators () used for method call
  public : const GGS_typeListeArgumentsRoutExterne * operator () (UNUSED_LOCATION_ARGS) const { return this ;} 
//--- Method 'first'
  public : void method_first (C_Lexique & _inLexique,
                              GGS_typeArgumentRoutineExterne & _out_0
                              COMMA_LOCATION_ARGS) const ;
//--- Method 'last'
  public : void method_last (C_Lexique & _inLexique,
                             GGS_typeArgumentRoutineExterne & _out_0
                             COMMA_LOCATION_ARGS) const ;
//--- Modifier 'popLast'
  public : void modifier_popLast (C_Lexique & _inLexique,
                                GGS_typeArgumentRoutineExterne & _out_0
                                COMMA_LOCATION_ARGS) ;
//--- Modifier 'popFirst'
  public : void modifier_popFirst (C_Lexique & _inLexique,
                                 GGS_typeArgumentRoutineExterne & _out_0
                                 COMMA_LOCATION_ARGS) ;
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_typeArgumentRoutineExterne & argument_0) ;
//--- Handling '.' GALGAS operator
  public : GGS_typeListeArgumentsRoutExterne operator + (const GGS_typeListeArgumentsRoutExterne & inOperand) const ;
  public : void modifier_prependValue (C_Lexique & _inLexique,
                                const GGS_typeArgumentRoutineExterne & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_typeArgumentRoutineExterne & argument_0) ;
  protected : void _internalPrependValues (const GGS_typeArgumentRoutineExterne & argument_0) ;
//--- List Insulation
  protected : void _insulateList (void) ;
//--- Reader 'description
  public : GGS_string reader_description (C_Lexique & _inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeArgumentAttribut'                   *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeArgumentAttribut : public GGS_typeArgumentRoutineExterne {
//--- Default constructor
  public : GGS_typeArgumentAttribut (void) ;
//--- Copy constructor
  public : GGS_typeArgumentAttribut (const GGS_typeArgumentAttribut &) ;
//--- Virtual destructor
  public : virtual ~GGS_typeArgumentAttribut (void) ;
//--- 'new' constructor
  public : static GGS_typeArgumentAttribut constructor_new (C_Lexique & inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_AC_galgasType & argument_1 COMMA_LOCATION_ARGS) ;
//--- Assignment operator
  public : void operator = (const GGS_typeArgumentAttribut &) ;
//--- Comparison methods
  public : GGS_bool operator == (const GGS_typeArgumentAttribut & inOperand) const ;
  public : GGS_bool operator != (const GGS_typeArgumentAttribut & inOperand) const ;
//--- 'description' reader
  public : GGS_string reader_description (C_Lexique & _inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;
//--- operator ()
//--- Readers
  public : GGS_lstring  reader_attributNom (C_Lexique & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_AC_galgasType  reader_attributTypeAttribut (C_Lexique & inLexique COMMA_LOCATION_ARGS) const ;
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_typeArgumentAttribut * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_typeArgumentAttribut * operator () (LOCATION_ARGS) const {
      return (cPtr_typeArgumentAttribut *) mPointer ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeArgumentCaractere'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeArgumentCaractere : public GGS_typeArgumentRoutineExterne {
//--- Default constructor
  public : GGS_typeArgumentCaractere (void) ;
//--- Copy constructor
  public : GGS_typeArgumentCaractere (const GGS_typeArgumentCaractere &) ;
//--- Virtual destructor
  public : virtual ~GGS_typeArgumentCaractere (void) ;
//--- 'new' constructor
  public : static GGS_typeArgumentCaractere constructor_new (C_Lexique & inLexique,
                                const GGS_lchar & argument_0 COMMA_LOCATION_ARGS) ;
//--- Assignment operator
  public : void operator = (const GGS_typeArgumentCaractere &) ;
//--- Comparison methods
  public : GGS_bool operator == (const GGS_typeArgumentCaractere & inOperand) const ;
  public : GGS_bool operator != (const GGS_typeArgumentCaractere & inOperand) const ;
//--- 'description' reader
  public : GGS_string reader_description (C_Lexique & _inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;
//--- operator ()
//--- Readers
  public : GGS_lchar  reader_attributCaractere (C_Lexique & inLexique COMMA_LOCATION_ARGS) const ;
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_typeArgumentCaractere * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_typeArgumentCaractere * operator () (LOCATION_ARGS) const {
      return (cPtr_typeArgumentCaractere *) mPointer ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_typeArgumentCaractereCourant'               *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeArgumentCaractereCourant : public GGS_typeArgumentRoutineExterne {
//--- Default constructor
  public : GGS_typeArgumentCaractereCourant (void) ;
//--- Copy constructor
  public : GGS_typeArgumentCaractereCourant (const GGS_typeArgumentCaractereCourant &) ;
//--- Virtual destructor
  public : virtual ~GGS_typeArgumentCaractereCourant (void) ;
//--- 'new' constructor
  public : static GGS_typeArgumentCaractereCourant constructor_new (C_Lexique & inLexique COMMA_LOCATION_ARGS) ;
//--- Assignment operator
  public : void operator = (const GGS_typeArgumentCaractereCourant &) ;
//--- Comparison methods
  public : GGS_bool operator == (const GGS_typeArgumentCaractereCourant & inOperand) const ;
  public : GGS_bool operator != (const GGS_typeArgumentCaractereCourant & inOperand) const ;
//--- 'description' reader
  public : GGS_string reader_description (C_Lexique & _inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;
//--- operator ()
//--- Readers
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_typeArgumentCaractereCourant * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_typeArgumentCaractereCourant * operator () (LOCATION_ARGS) const {
      return (cPtr_typeArgumentCaractereCourant *) mPointer ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeArgumentEntier'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeArgumentEntier : public GGS_typeArgumentRoutineExterne {
//--- Default constructor
  public : GGS_typeArgumentEntier (void) ;
//--- Copy constructor
  public : GGS_typeArgumentEntier (const GGS_typeArgumentEntier &) ;
//--- Virtual destructor
  public : virtual ~GGS_typeArgumentEntier (void) ;
//--- 'new' constructor
  public : static GGS_typeArgumentEntier constructor_new (C_Lexique & inLexique,
                                const GGS_luint & argument_0 COMMA_LOCATION_ARGS) ;
//--- Assignment operator
  public : void operator = (const GGS_typeArgumentEntier &) ;
//--- Comparison methods
  public : GGS_bool operator == (const GGS_typeArgumentEntier & inOperand) const ;
  public : GGS_bool operator != (const GGS_typeArgumentEntier & inOperand) const ;
//--- 'description' reader
  public : GGS_string reader_description (C_Lexique & _inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;
//--- operator ()
//--- Readers
  public : GGS_luint  reader_attributValeur (C_Lexique & inLexique COMMA_LOCATION_ARGS) const ;
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_typeArgumentEntier * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_typeArgumentEntier * operator () (LOCATION_ARGS) const {
      return (cPtr_typeArgumentEntier *) mPointer ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeArgumentRoutine'                   *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeArgumentRoutine : public GGS_typeArgumentRoutineExterne {
//--- Default constructor
  public : GGS_typeArgumentRoutine (void) ;
//--- Copy constructor
  public : GGS_typeArgumentRoutine (const GGS_typeArgumentRoutine &) ;
//--- Virtual destructor
  public : virtual ~GGS_typeArgumentRoutine (void) ;
//--- 'new' constructor
  public : static GGS_typeArgumentRoutine constructor_new (C_Lexique & inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_typeListeArgumentsRoutExterne & argument_1 COMMA_LOCATION_ARGS) ;
//--- Assignment operator
  public : void operator = (const GGS_typeArgumentRoutine &) ;
//--- Comparison methods
  public : GGS_bool operator == (const GGS_typeArgumentRoutine & inOperand) const ;
  public : GGS_bool operator != (const GGS_typeArgumentRoutine & inOperand) const ;
//--- 'description' reader
  public : GGS_string reader_description (C_Lexique & _inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;
//--- operator ()
//--- Readers
  public : GGS_lstring  reader_attributNomRoutine (C_Lexique & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_typeListeArgumentsRoutExterne  reader_attributListeArguments (C_Lexique & inLexique COMMA_LOCATION_ARGS) const ;
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_typeArgumentRoutine * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_typeArgumentRoutine * operator () (LOCATION_ARGS) const {
      return (cPtr_typeArgumentRoutine *) mPointer ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     list '@typeListeMessagesErreur'                       *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_typeListeMessagesErreur ;

class GGS_typeListeMessagesErreur : public AC_galgas_list {
  public : typedef elementOf_GGS_typeListeMessagesErreur element_type ;
//--- Default Constructor
  public : GGS_typeListeMessagesErreur (void) ;
//--- Copy Constructor
  public : GGS_typeListeMessagesErreur (const GGS_typeListeMessagesErreur & inSource) ;
//--- Comparison Operators
  public : GGS_bool operator == (const GGS_typeListeMessagesErreur & inOperand) const ;
  public : GGS_bool operator != (const GGS_typeListeMessagesErreur & inOperand) const ;
//--- Constructor 'emptyList'
  public : static GGS_typeListeMessagesErreur constructor_emptyList (C_Lexique & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_typeListeMessagesErreur constructor_listWithValue (C_Lexique & _inLexique,
                                const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operators () used for method call
  public : const GGS_typeListeMessagesErreur * operator () (UNUSED_LOCATION_ARGS) const { return this ;} 
//--- Method 'first'
  public : void method_first (C_Lexique & _inLexique,
                              GGS_luint & _out_0
                              COMMA_LOCATION_ARGS) const ;
//--- Method 'last'
  public : void method_last (C_Lexique & _inLexique,
                             GGS_luint & _out_0
                             COMMA_LOCATION_ARGS) const ;
//--- Modifier 'popLast'
  public : void modifier_popLast (C_Lexique & _inLexique,
                                GGS_luint & _out_0
                                COMMA_LOCATION_ARGS) ;
//--- Modifier 'popFirst'
  public : void modifier_popFirst (C_Lexique & _inLexique,
                                 GGS_luint & _out_0
                                 COMMA_LOCATION_ARGS) ;
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_luint & argument_0) ;
//--- Handling '.' GALGAS operator
  public : GGS_typeListeMessagesErreur operator + (const GGS_typeListeMessagesErreur & inOperand) const ;
  public : void modifier_prependValue (C_Lexique & _inLexique,
                                const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_luint & argument_0) ;
  protected : void _internalPrependValues (const GGS_luint & argument_0) ;
//--- List Insulation
  protected : void _insulateList (void) ;
//--- Reader 'description
  public : GGS_string reader_description (C_Lexique & _inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeEmissionParDefaut'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeEmissionParDefaut {
//--- Pointer to actual instance
  protected : cPtr_typeEmissionParDefaut * mPointer ;
//--- Default constructor
  public : GGS_typeEmissionParDefaut (void) ;
//--- Copy constructor
  public : GGS_typeEmissionParDefaut (const GGS_typeEmissionParDefaut &) ;
//--- Virtual destructor
  public : virtual ~GGS_typeEmissionParDefaut (void) ;
//--- Assignment operator
  public : void operator = (const GGS_typeEmissionParDefaut &) ;
//--- Comparison methods
  public : GGS_bool operator == (const GGS_typeEmissionParDefaut & inOperand) const ;
  public : GGS_bool operator != (const GGS_typeEmissionParDefaut & inOperand) const ;
//--- _isBuilt
  public : inline bool _isBuilt (void) const { return mPointer != NULL ; }
//--- isEqualTo
  public : inline bool isEqualTo (const GGS_typeEmissionParDefaut & _inOperand) const {
    return mPointer == _inOperand.mPointer ;
  }
//--- getPtr
  public : inline cPtr_typeEmissionParDefaut * getPtr (void) const {
    return mPointer ;
  }
//--- drop
  public : void _drop_operation (void) ;
//--- 'description' reader
  public : GGS_string reader_description (C_Lexique & _inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;
//--- operator ()
//--- Readers
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_typeEmissionParDefaut * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_typeEmissionParDefaut * operator () (LOCATION_ARGS) const {
      return mPointer ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_typeEmissionTerminalParDefaut'              *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeEmissionTerminalParDefaut : public GGS_typeEmissionParDefaut {
//--- Default constructor
  public : GGS_typeEmissionTerminalParDefaut (void) ;
//--- Copy constructor
  public : GGS_typeEmissionTerminalParDefaut (const GGS_typeEmissionTerminalParDefaut &) ;
//--- Virtual destructor
  public : virtual ~GGS_typeEmissionTerminalParDefaut (void) ;
//--- 'new' constructor
  public : static GGS_typeEmissionTerminalParDefaut constructor_new (C_Lexique & inLexique,
                                const GGS_lstring & argument_0 COMMA_LOCATION_ARGS) ;
//--- Assignment operator
  public : void operator = (const GGS_typeEmissionTerminalParDefaut &) ;
//--- Comparison methods
  public : GGS_bool operator == (const GGS_typeEmissionTerminalParDefaut & inOperand) const ;
  public : GGS_bool operator != (const GGS_typeEmissionTerminalParDefaut & inOperand) const ;
//--- 'description' reader
  public : GGS_string reader_description (C_Lexique & _inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;
//--- operator ()
//--- Readers
  public : GGS_lstring  reader_attributNomTerminal (C_Lexique & inLexique COMMA_LOCATION_ARGS) const ;
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_typeEmissionTerminalParDefaut * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_typeEmissionTerminalParDefaut * operator () (LOCATION_ARGS) const {
      return (cPtr_typeEmissionTerminalParDefaut *) mPointer ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeEmissionErreurParDefaut'               *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeEmissionErreurParDefaut : public GGS_typeEmissionParDefaut {
//--- Default constructor
  public : GGS_typeEmissionErreurParDefaut (void) ;
//--- Copy constructor
  public : GGS_typeEmissionErreurParDefaut (const GGS_typeEmissionErreurParDefaut &) ;
//--- Virtual destructor
  public : virtual ~GGS_typeEmissionErreurParDefaut (void) ;
//--- 'new' constructor
  public : static GGS_typeEmissionErreurParDefaut constructor_new (C_Lexique & inLexique,
                                const GGS_luint & argument_0 COMMA_LOCATION_ARGS) ;
//--- Assignment operator
  public : void operator = (const GGS_typeEmissionErreurParDefaut &) ;
//--- Comparison methods
  public : GGS_bool operator == (const GGS_typeEmissionErreurParDefaut & inOperand) const ;
  public : GGS_bool operator != (const GGS_typeEmissionErreurParDefaut & inOperand) const ;
//--- 'description' reader
  public : GGS_string reader_description (C_Lexique & _inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;
//--- operator ()
//--- Readers
  public : GGS_luint  reader_mErrorMessageIndex (C_Lexique & inLexique COMMA_LOCATION_ARGS) const ;
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_typeEmissionErreurParDefaut * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_typeEmissionErreurParDefaut * operator () (LOCATION_ARGS) const {
      return (cPtr_typeEmissionErreurParDefaut *) mPointer ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        list '@typeListeRecherche'                         *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_typeListeRecherche ;

class GGS_typeListeRecherche : public AC_galgas_list {
  public : typedef elementOf_GGS_typeListeRecherche element_type ;
//--- Default Constructor
  public : GGS_typeListeRecherche (void) ;
//--- Copy Constructor
  public : GGS_typeListeRecherche (const GGS_typeListeRecherche & inSource) ;
//--- Comparison Operators
  public : GGS_bool operator == (const GGS_typeListeRecherche & inOperand) const ;
  public : GGS_bool operator != (const GGS_typeListeRecherche & inOperand) const ;
//--- Constructor 'emptyList'
  public : static GGS_typeListeRecherche constructor_emptyList (C_Lexique & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_typeListeRecherche constructor_listWithValue (C_Lexique & _inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operators () used for method call
  public : const GGS_typeListeRecherche * operator () (UNUSED_LOCATION_ARGS) const { return this ;} 
//--- Method 'first'
  public : void method_first (C_Lexique & _inLexique,
                              GGS_lstring & _out_0,
                              GGS_lstring & _out_1
                              COMMA_LOCATION_ARGS) const ;
//--- Method 'last'
  public : void method_last (C_Lexique & _inLexique,
                             GGS_lstring & _out_0,
                             GGS_lstring & _out_1
                             COMMA_LOCATION_ARGS) const ;
//--- Modifier 'popLast'
  public : void modifier_popLast (C_Lexique & _inLexique,
                                GGS_lstring & _out_0,
                                GGS_lstring & _out_1
                                COMMA_LOCATION_ARGS) ;
//--- Modifier 'popFirst'
  public : void modifier_popFirst (C_Lexique & _inLexique,
                                 GGS_lstring & _out_0,
                                 GGS_lstring & _out_1
                                 COMMA_LOCATION_ARGS) ;
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) ;
//--- Handling '.' GALGAS operator
  public : GGS_typeListeRecherche operator + (const GGS_typeListeRecherche & inOperand) const ;
  public : void modifier_prependValue (C_Lexique & _inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) ;
  protected : void _internalPrependValues (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) ;
//--- List Insulation
  protected : void _insulateList (void) ;
//--- Reader 'description
  public : GGS_string reader_description (C_Lexique & _inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_typeInstructionActionExterne'               *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeInstructionActionExterne : public GGS_typeInstructionLexicale {
//--- Default constructor
  public : GGS_typeInstructionActionExterne (void) ;
//--- Copy constructor
  public : GGS_typeInstructionActionExterne (const GGS_typeInstructionActionExterne &) ;
//--- Virtual destructor
  public : virtual ~GGS_typeInstructionActionExterne (void) ;
//--- 'new' constructor
  public : static GGS_typeInstructionActionExterne constructor_new (C_Lexique & inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_typeListeArgumentsRoutExterne & argument_1,
                                const GGS_typeListeMessagesErreur & argument_2 COMMA_LOCATION_ARGS) ;
//--- Assignment operator
  public : void operator = (const GGS_typeInstructionActionExterne &) ;
//--- Comparison methods
  public : GGS_bool operator == (const GGS_typeInstructionActionExterne & inOperand) const ;
  public : GGS_bool operator != (const GGS_typeInstructionActionExterne & inOperand) const ;
//--- 'description' reader
  public : GGS_string reader_description (C_Lexique & _inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;
//--- operator ()
//--- Readers
  public : GGS_lstring  reader_attributNomRoutineExterne (C_Lexique & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_typeListeArgumentsRoutExterne  reader_attributListeArguments (C_Lexique & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_typeListeMessagesErreur  reader_attributListeMessageErreur (C_Lexique & inLexique COMMA_LOCATION_ARGS) const ;
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_typeInstructionActionExterne * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_typeInstructionActionExterne * operator () (LOCATION_ARGS) const {
      return (cPtr_typeInstructionActionExterne *) mPointer ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_typeInstructionRepetitionLexicale'            *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeInstructionRepetitionLexicale : public GGS_typeInstructionLexicale {
//--- Default constructor
  public : GGS_typeInstructionRepetitionLexicale (void) ;
//--- Copy constructor
  public : GGS_typeInstructionRepetitionLexicale (const GGS_typeInstructionRepetitionLexicale &) ;
//--- Virtual destructor
  public : virtual ~GGS_typeInstructionRepetitionLexicale (void) ;
//--- 'new' constructor
  public : static GGS_typeInstructionRepetitionLexicale constructor_new (C_Lexique & inLexique,
                                const GGS_tListeInstructionsLexicales & argument_0,
                                const GGS_typeListeTestsEtInstructions & argument_1 COMMA_LOCATION_ARGS) ;
//--- Assignment operator
  public : void operator = (const GGS_typeInstructionRepetitionLexicale &) ;
//--- Comparison methods
  public : GGS_bool operator == (const GGS_typeInstructionRepetitionLexicale & inOperand) const ;
  public : GGS_bool operator != (const GGS_typeInstructionRepetitionLexicale & inOperand) const ;
//--- 'description' reader
  public : GGS_string reader_description (C_Lexique & _inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;
//--- operator ()
//--- Readers
  public : GGS_tListeInstructionsLexicales  reader_attributListeInstructionsDebut (C_Lexique & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_typeListeTestsEtInstructions  reader_attributListeBranches (C_Lexique & inLexique COMMA_LOCATION_ARGS) const ;
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_typeInstructionRepetitionLexicale * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_typeInstructionRepetitionLexicale * operator () (LOCATION_ARGS) const {
      return (cPtr_typeInstructionRepetitionLexicale *) mPointer ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeInstructionSiLexical'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeInstructionSiLexical : public GGS_typeInstructionLexicale {
//--- Default constructor
  public : GGS_typeInstructionSiLexical (void) ;
//--- Copy constructor
  public : GGS_typeInstructionSiLexical (const GGS_typeInstructionSiLexical &) ;
//--- Virtual destructor
  public : virtual ~GGS_typeInstructionSiLexical (void) ;
//--- 'new' constructor
  public : static GGS_typeInstructionSiLexical constructor_new (C_Lexique & inLexique,
                                const GGS_typeListeTestsEtInstructions & argument_0,
                                const GGS_tListeInstructionsLexicales & argument_1 COMMA_LOCATION_ARGS) ;
//--- Assignment operator
  public : void operator = (const GGS_typeInstructionSiLexical &) ;
//--- Comparison methods
  public : GGS_bool operator == (const GGS_typeInstructionSiLexical & inOperand) const ;
  public : GGS_bool operator != (const GGS_typeInstructionSiLexical & inOperand) const ;
//--- 'description' reader
  public : GGS_string reader_description (C_Lexique & _inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;
//--- operator ()
//--- Readers
  public : GGS_typeListeTestsEtInstructions  reader_attributListeBranches (C_Lexique & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_tListeInstructionsLexicales  reader_attributBrancheSinon (C_Lexique & inLexique COMMA_LOCATION_ARGS) const ;
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_typeInstructionSiLexical * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_typeInstructionSiLexical * operator () (LOCATION_ARGS) const {
      return (cPtr_typeInstructionSiLexical *) mPointer ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_typeInstructionEmettreSimple'               *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeInstructionEmettreSimple : public GGS_typeInstructionLexicale {
//--- Default constructor
  public : GGS_typeInstructionEmettreSimple (void) ;
//--- Copy constructor
  public : GGS_typeInstructionEmettreSimple (const GGS_typeInstructionEmettreSimple &) ;
//--- Virtual destructor
  public : virtual ~GGS_typeInstructionEmettreSimple (void) ;
//--- 'new' constructor
  public : static GGS_typeInstructionEmettreSimple constructor_new (C_Lexique & inLexique,
                                const GGS_lstring & argument_0 COMMA_LOCATION_ARGS) ;
//--- Assignment operator
  public : void operator = (const GGS_typeInstructionEmettreSimple &) ;
//--- Comparison methods
  public : GGS_bool operator == (const GGS_typeInstructionEmettreSimple & inOperand) const ;
  public : GGS_bool operator != (const GGS_typeInstructionEmettreSimple & inOperand) const ;
//--- 'description' reader
  public : GGS_string reader_description (C_Lexique & _inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;
//--- operator ()
//--- Readers
  public : GGS_lstring  reader_attributTerminal (C_Lexique & inLexique COMMA_LOCATION_ARGS) const ;
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_typeInstructionEmettreSimple * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_typeInstructionEmettreSimple * operator () (LOCATION_ARGS) const {
      return (cPtr_typeInstructionEmettreSimple *) mPointer ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeLexicalDropInstruction'                *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeLexicalDropInstruction : public GGS_typeInstructionLexicale {
//--- Default constructor
  public : GGS_typeLexicalDropInstruction (void) ;
//--- Copy constructor
  public : GGS_typeLexicalDropInstruction (const GGS_typeLexicalDropInstruction &) ;
//--- Virtual destructor
  public : virtual ~GGS_typeLexicalDropInstruction (void) ;
//--- 'new' constructor
  public : static GGS_typeLexicalDropInstruction constructor_new (C_Lexique & inLexique,
                                const GGS_lstring & argument_0 COMMA_LOCATION_ARGS) ;
//--- Assignment operator
  public : void operator = (const GGS_typeLexicalDropInstruction &) ;
//--- Comparison methods
  public : GGS_bool operator == (const GGS_typeLexicalDropInstruction & inOperand) const ;
  public : GGS_bool operator != (const GGS_typeLexicalDropInstruction & inOperand) const ;
//--- 'description' reader
  public : GGS_string reader_description (C_Lexique & _inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;
//--- operator ()
//--- Readers
  public : GGS_lstring  reader_attributTerminal (C_Lexique & inLexique COMMA_LOCATION_ARGS) const ;
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_typeLexicalDropInstruction * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_typeLexicalDropInstruction * operator () (LOCATION_ARGS) const {
      return (cPtr_typeLexicalDropInstruction *) mPointer ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeInstructionEmettre'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeInstructionEmettre : public GGS_typeInstructionLexicale {
//--- Default constructor
  public : GGS_typeInstructionEmettre (void) ;
//--- Copy constructor
  public : GGS_typeInstructionEmettre (const GGS_typeInstructionEmettre &) ;
//--- Virtual destructor
  public : virtual ~GGS_typeInstructionEmettre (void) ;
//--- 'new' constructor
  public : static GGS_typeInstructionEmettre constructor_new (C_Lexique & inLexique,
                                const GGS_typeListeRecherche & argument_0,
                                const GGS_typeEmissionParDefaut & argument_1 COMMA_LOCATION_ARGS) ;
//--- Assignment operator
  public : void operator = (const GGS_typeInstructionEmettre &) ;
//--- Comparison methods
  public : GGS_bool operator == (const GGS_typeInstructionEmettre & inOperand) const ;
  public : GGS_bool operator != (const GGS_typeInstructionEmettre & inOperand) const ;
//--- 'description' reader
  public : GGS_string reader_description (C_Lexique & _inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;
//--- operator ()
//--- Readers
  public : GGS_typeListeRecherche  reader_attributListeRecherches (C_Lexique & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_typeEmissionParDefaut  reader_attributEmissionParDefaut (C_Lexique & inLexique COMMA_LOCATION_ARGS) const ;
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_typeInstructionEmettre * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_typeInstructionEmettre * operator () (LOCATION_ARGS) const {
      return (cPtr_typeInstructionEmettre *) mPointer ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_typeInstructionErreurLexicale'              *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeInstructionErreurLexicale : public GGS_typeInstructionLexicale {
//--- Default constructor
  public : GGS_typeInstructionErreurLexicale (void) ;
//--- Copy constructor
  public : GGS_typeInstructionErreurLexicale (const GGS_typeInstructionErreurLexicale &) ;
//--- Virtual destructor
  public : virtual ~GGS_typeInstructionErreurLexicale (void) ;
//--- 'new' constructor
  public : static GGS_typeInstructionErreurLexicale constructor_new (C_Lexique & inLexique,
                                const GGS_luint & argument_0 COMMA_LOCATION_ARGS) ;
//--- Assignment operator
  public : void operator = (const GGS_typeInstructionErreurLexicale &) ;
//--- Comparison methods
  public : GGS_bool operator == (const GGS_typeInstructionErreurLexicale & inOperand) const ;
  public : GGS_bool operator != (const GGS_typeInstructionErreurLexicale & inOperand) const ;
//--- 'description' reader
  public : GGS_string reader_description (C_Lexique & _inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;
//--- operator ()
//--- Readers
  public : GGS_luint  reader_mErrorMessageIndex (C_Lexique & inLexique COMMA_LOCATION_ARGS) const ;
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_typeInstructionErreurLexicale * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_typeInstructionErreurLexicale * operator () (LOCATION_ARGS) const {
      return (cPtr_typeInstructionErreurLexicale *) mPointer ;
    }
  #endif
} ;

void routine_appendToLexicalInstructionList (C_Lexique &,
                                GGS_typeListeTestsEtInstructions  &,
                                const GGS_lstring  &,
                                GGS_lstring  & COMMA_LOCATION_ARGS) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of map '@typeLexicalAttributesMap'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class e_typeLexicalAttributesMap {
  public : GGS_AC_galgasType  attributType ;
} ;

//---------------------------------------------------------------------------*

class elementOf_GGS_typeLexicalAttributesMap : public AC_galgas_map_element {
//--- Constructor
  public : elementOf_GGS_typeLexicalAttributesMap (const GGS_lstring & inKey,
                                     const sint32 inIndex,
                                     const e_typeLexicalAttributesMap & inInfo) ;
//--- Get pointers
  public : inline elementOf_GGS_typeLexicalAttributesMap * nextObject (void) const { return (elementOf_GGS_typeLexicalAttributesMap *) mNextItem ; }
  public : inline elementOf_GGS_typeLexicalAttributesMap * infObject (void) const { return (elementOf_GGS_typeLexicalAttributesMap *) mInfPtr ; }
  public : inline elementOf_GGS_typeLexicalAttributesMap * supObject (void) const { return (elementOf_GGS_typeLexicalAttributesMap *) mSupPtr ; }
//--- Comparison
  protected : virtual bool isEqualToMapElement (const AC_galgas_map_element * inOperand) const ;
//--- Data member
  public : e_typeLexicalAttributesMap mInfo ;
//--- Method for 'description' reader
  public : void appendForMapDescription (C_Lexique & _inLexique,
                                         const sint32 inElementIndex,
                                         C_String & ioString,
                                         const sint32 inIndentation
                                         COMMA_LOCATION_ARGS) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     Element of map '@lexicalTypeMap'                      *
//                                                                           *
//---------------------------------------------------------------------------*

class e_lexicalTypeMap {
  public : GGS_AC_galgasType  mAttributType ;
} ;

//---------------------------------------------------------------------------*

class elementOf_GGS_lexicalTypeMap : public AC_galgas_map_element {
//--- Constructor
  public : elementOf_GGS_lexicalTypeMap (const GGS_lstring & inKey,
                                     const sint32 inIndex,
                                     const e_lexicalTypeMap & inInfo) ;
//--- Get pointers
  public : inline elementOf_GGS_lexicalTypeMap * nextObject (void) const { return (elementOf_GGS_lexicalTypeMap *) mNextItem ; }
  public : inline elementOf_GGS_lexicalTypeMap * infObject (void) const { return (elementOf_GGS_lexicalTypeMap *) mInfPtr ; }
  public : inline elementOf_GGS_lexicalTypeMap * supObject (void) const { return (elementOf_GGS_lexicalTypeMap *) mSupPtr ; }
//--- Comparison
  protected : virtual bool isEqualToMapElement (const AC_galgas_map_element * inOperand) const ;
//--- Data member
  public : e_lexicalTypeMap mInfo ;
//--- Method for 'description' reader
  public : void appendForMapDescription (C_Lexique & _inLexique,
                                         const sint32 inElementIndex,
                                         C_String & ioString,
                                         const sint32 inIndentation
                                         COMMA_LOCATION_ARGS) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of map '@typeTableMessagesErreurs'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class e_typeTableMessagesErreurs {
  public : GGS_lstring  mErrorMessage ;
} ;

//---------------------------------------------------------------------------*

class elementOf_GGS_typeTableMessagesErreurs : public AC_galgas_map_element {
//--- Constructor
  public : elementOf_GGS_typeTableMessagesErreurs (const GGS_lstring & inKey,
                                     const sint32 inIndex,
                                     const e_typeTableMessagesErreurs & inInfo) ;
//--- Get pointers
  public : inline elementOf_GGS_typeTableMessagesErreurs * nextObject (void) const { return (elementOf_GGS_typeTableMessagesErreurs *) mNextItem ; }
  public : inline elementOf_GGS_typeTableMessagesErreurs * infObject (void) const { return (elementOf_GGS_typeTableMessagesErreurs *) mInfPtr ; }
  public : inline elementOf_GGS_typeTableMessagesErreurs * supObject (void) const { return (elementOf_GGS_typeTableMessagesErreurs *) mSupPtr ; }
//--- Comparison
  protected : virtual bool isEqualToMapElement (const AC_galgas_map_element * inOperand) const ;
//--- Data member
  public : e_typeTableMessagesErreurs mInfo ;
//--- Method for 'description' reader
  public : void appendForMapDescription (C_Lexique & _inLexique,
                                         const sint32 inElementIndex,
                                         C_String & ioString,
                                         const sint32 inIndentation
                                         COMMA_LOCATION_ARGS) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        Element of map '@M_styles'                         *
//                                                                           *
//---------------------------------------------------------------------------*

class e_M_styles {
  public : GGS_lstring  mTitle ;
} ;

//---------------------------------------------------------------------------*

class elementOf_GGS_M_styles : public AC_galgas_map_element {
//--- Constructor
  public : elementOf_GGS_M_styles (const GGS_lstring & inKey,
                                     const sint32 inIndex,
                                     const e_M_styles & inInfo) ;
//--- Get pointers
  public : inline elementOf_GGS_M_styles * nextObject (void) const { return (elementOf_GGS_M_styles *) mNextItem ; }
  public : inline elementOf_GGS_M_styles * infObject (void) const { return (elementOf_GGS_M_styles *) mInfPtr ; }
  public : inline elementOf_GGS_M_styles * supObject (void) const { return (elementOf_GGS_M_styles *) mSupPtr ; }
//--- Comparison
  protected : virtual bool isEqualToMapElement (const AC_galgas_map_element * inOperand) const ;
//--- Data member
  public : e_M_styles mInfo ;
//--- Method for 'description' reader
  public : void appendForMapDescription (C_Lexique & _inLexique,
                                         const sint32 inElementIndex,
                                         C_String & ioString,
                                         const sint32 inIndentation
                                         COMMA_LOCATION_ARGS) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of map '@typeTableDefinitionTerminaux'               *
//                                                                           *
//---------------------------------------------------------------------------*

class e_typeTableDefinitionTerminaux {
  public : GGS_string mErrorMessage ;
  public : GGS_typeListeAttributsSemantiques  attributListeDesAttributs ;
  public : GGS_luint  mStyleIndex ;
} ;

//---------------------------------------------------------------------------*

class elementOf_GGS_typeTableDefinitionTerminaux : public AC_galgas_map_element {
//--- Constructor
  public : elementOf_GGS_typeTableDefinitionTerminaux (const GGS_lstring & inKey,
                                     const sint32 inIndex,
                                     const e_typeTableDefinitionTerminaux & inInfo) ;
//--- Get pointers
  public : inline elementOf_GGS_typeTableDefinitionTerminaux * nextObject (void) const { return (elementOf_GGS_typeTableDefinitionTerminaux *) mNextItem ; }
  public : inline elementOf_GGS_typeTableDefinitionTerminaux * infObject (void) const { return (elementOf_GGS_typeTableDefinitionTerminaux *) mInfPtr ; }
  public : inline elementOf_GGS_typeTableDefinitionTerminaux * supObject (void) const { return (elementOf_GGS_typeTableDefinitionTerminaux *) mSupPtr ; }
//--- Comparison
  protected : virtual bool isEqualToMapElement (const AC_galgas_map_element * inOperand) const ;
//--- Data member
  public : e_typeTableDefinitionTerminaux mInfo ;
//--- Method for 'description' reader
  public : void appendForMapDescription (C_Lexique & _inLexique,
                                         const sint32 inElementIndex,
                                         C_String & ioString,
                                         const sint32 inIndentation
                                         COMMA_LOCATION_ARGS) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of map '@typeTableMotsReserves'                   *
//                                                                           *
//---------------------------------------------------------------------------*

class e_typeTableMotsReserves {
  public : GGS_lstring  attributNomTerminal ;
} ;

//---------------------------------------------------------------------------*

class elementOf_GGS_typeTableMotsReserves : public AC_galgas_map_element {
//--- Constructor
  public : elementOf_GGS_typeTableMotsReserves (const GGS_lstring & inKey,
                                     const sint32 inIndex,
                                     const e_typeTableMotsReserves & inInfo) ;
//--- Get pointers
  public : inline elementOf_GGS_typeTableMotsReserves * nextObject (void) const { return (elementOf_GGS_typeTableMotsReserves *) mNextItem ; }
  public : inline elementOf_GGS_typeTableMotsReserves * infObject (void) const { return (elementOf_GGS_typeTableMotsReserves *) mInfPtr ; }
  public : inline elementOf_GGS_typeTableMotsReserves * supObject (void) const { return (elementOf_GGS_typeTableMotsReserves *) mSupPtr ; }
//--- Comparison
  protected : virtual bool isEqualToMapElement (const AC_galgas_map_element * inOperand) const ;
//--- Data member
  public : e_typeTableMotsReserves mInfo ;
//--- Method for 'description' reader
  public : void appendForMapDescription (C_Lexique & _inLexique,
                                         const sint32 inElementIndex,
                                         C_String & ioString,
                                         const sint32 inIndentation
                                         COMMA_LOCATION_ARGS) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of map '@typeTableTablesDeMotsReserves'               *
//                                                                           *
//---------------------------------------------------------------------------*

class e_typeTableTablesDeMotsReserves {
  public : GGS_typeTableMotsReserves  attributSimpleTable ;
} ;

//---------------------------------------------------------------------------*

class elementOf_GGS_typeTableTablesDeMotsReserves : public AC_galgas_map_element {
//--- Constructor
  public : elementOf_GGS_typeTableTablesDeMotsReserves (const GGS_lstring & inKey,
                                     const sint32 inIndex,
                                     const e_typeTableTablesDeMotsReserves & inInfo) ;
//--- Get pointers
  public : inline elementOf_GGS_typeTableTablesDeMotsReserves * nextObject (void) const { return (elementOf_GGS_typeTableTablesDeMotsReserves *) mNextItem ; }
  public : inline elementOf_GGS_typeTableTablesDeMotsReserves * infObject (void) const { return (elementOf_GGS_typeTableTablesDeMotsReserves *) mInfPtr ; }
  public : inline elementOf_GGS_typeTableTablesDeMotsReserves * supObject (void) const { return (elementOf_GGS_typeTableTablesDeMotsReserves *) mSupPtr ; }
//--- Comparison
  protected : virtual bool isEqualToMapElement (const AC_galgas_map_element * inOperand) const ;
//--- Data member
  public : e_typeTableTablesDeMotsReserves mInfo ;
//--- Method for 'description' reader
  public : void appendForMapDescription (C_Lexique & _inLexique,
                                         const sint32 inElementIndex,
                                         C_String & ioString,
                                         const sint32 inIndentation
                                         COMMA_LOCATION_ARGS) const ;
} ;

//---------------------------------------------------------------------------*

#include "include_typeConditionLexicale.h"

//---------------------------------------------------------------------------*

#include "include_typeConditionChaine.h"

//---------------------------------------------------------------------------*

#include "include_typeConditionCaractere.h"

//---------------------------------------------------------------------------*

#include "include_typeConditionIntervalle.h"

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@typeListeConditionsLexicales'               *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_typeListeConditionsLexicales : public AC_galgas_list::cListElement {
//--- Attributes
  public : GGS_typeConditionLexicale  attributCondition ;
//--- Constructor
  public : elementOf_GGS_typeListeConditionsLexicales (const GGS_typeConditionLexicale & ) ;

//--- Access to next
  public : inline elementOf_GGS_typeListeConditionsLexicales * nextObject (void) const { return (elementOf_GGS_typeListeConditionsLexicales *) internalNextItem () ; }
//--- Access to previous
  public : inline elementOf_GGS_typeListeConditionsLexicales * previousObject (void) const { return (elementOf_GGS_typeListeConditionsLexicales *) internalPreviousItem () ; }
//--- Element comparison
  protected : bool isEqualToElement (const cListElement * inOperand) const ;
//--- Method used for description
  public : virtual void appendForListDescription (C_Lexique & _inLexique,
                                                  C_String & ioString,
                                                  const sint32 inIndentation
                                                  COMMA_LOCATION_ARGS) const ;
  friend class GGS_typeListeConditionsLexicales ;
} ;

//---------------------------------------------------------------------------*

#include "include_typeInstructionLexicale.h"

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@tListeInstructionsLexicales'               *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_tListeInstructionsLexicales : public AC_galgas_list::cListElement {
//--- Attributes
  public : GGS_typeInstructionLexicale  attributInstruction ;
//--- Constructor
  public : elementOf_GGS_tListeInstructionsLexicales (const GGS_typeInstructionLexicale & ) ;

//--- Access to next
  public : inline elementOf_GGS_tListeInstructionsLexicales * nextObject (void) const { return (elementOf_GGS_tListeInstructionsLexicales *) internalNextItem () ; }
//--- Access to previous
  public : inline elementOf_GGS_tListeInstructionsLexicales * previousObject (void) const { return (elementOf_GGS_tListeInstructionsLexicales *) internalPreviousItem () ; }
//--- Element comparison
  protected : bool isEqualToElement (const cListElement * inOperand) const ;
//--- Method used for description
  public : virtual void appendForListDescription (C_Lexique & _inLexique,
                                                  C_String & ioString,
                                                  const sint32 inIndentation
                                                  COMMA_LOCATION_ARGS) const ;
  friend class GGS_tListeInstructionsLexicales ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@typeListeTestsEtInstructions'               *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_typeListeTestsEtInstructions : public AC_galgas_list::cListElement {
//--- Attributes
  public : GGS_typeListeConditionsLexicales  attributListeConditions ;
  public : GGS_tListeInstructionsLexicales  attributListeInstructions ;
//--- Constructor
  public : elementOf_GGS_typeListeTestsEtInstructions (const GGS_typeListeConditionsLexicales & ,
                                const GGS_tListeInstructionsLexicales & ) ;

//--- Access to next
  public : inline elementOf_GGS_typeListeTestsEtInstructions * nextObject (void) const { return (elementOf_GGS_typeListeTestsEtInstructions *) internalNextItem () ; }
//--- Access to previous
  public : inline elementOf_GGS_typeListeTestsEtInstructions * previousObject (void) const { return (elementOf_GGS_typeListeTestsEtInstructions *) internalPreviousItem () ; }
//--- Element comparison
  protected : bool isEqualToElement (const cListElement * inOperand) const ;
//--- Method used for description
  public : virtual void appendForListDescription (C_Lexique & _inLexique,
                                                  C_String & ioString,
                                                  const sint32 inIndentation
                                                  COMMA_LOCATION_ARGS) const ;
  friend class GGS_typeListeTestsEtInstructions ;
} ;

//---------------------------------------------------------------------------*

#include "include_typeArgumentRoutineExterne.h"

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@typeListeArgumentsRoutExterne'              *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_typeListeArgumentsRoutExterne : public AC_galgas_list::cListElement {
//--- Attributes
  public : GGS_typeArgumentRoutineExterne  attributArgument ;
//--- Constructor
  public : elementOf_GGS_typeListeArgumentsRoutExterne (const GGS_typeArgumentRoutineExterne & ) ;

//--- Access to next
  public : inline elementOf_GGS_typeListeArgumentsRoutExterne * nextObject (void) const { return (elementOf_GGS_typeListeArgumentsRoutExterne *) internalNextItem () ; }
//--- Access to previous
  public : inline elementOf_GGS_typeListeArgumentsRoutExterne * previousObject (void) const { return (elementOf_GGS_typeListeArgumentsRoutExterne *) internalPreviousItem () ; }
//--- Element comparison
  protected : bool isEqualToElement (const cListElement * inOperand) const ;
//--- Method used for description
  public : virtual void appendForListDescription (C_Lexique & _inLexique,
                                                  C_String & ioString,
                                                  const sint32 inIndentation
                                                  COMMA_LOCATION_ARGS) const ;
  friend class GGS_typeListeArgumentsRoutExterne ;
} ;

//---------------------------------------------------------------------------*

#include "include_typeArgumentAttribut.h"

//---------------------------------------------------------------------------*

#include "include_typeArgumentCaractere.h"

//---------------------------------------------------------------------------*

#include "include_typeArgumentCaractereCourant.h"

//---------------------------------------------------------------------------*

#include "include_typeArgumentEntier.h"

//---------------------------------------------------------------------------*

#include "include_typeArgumentRoutine.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@typeListeMessagesErreur'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_typeListeMessagesErreur : public AC_galgas_list::cListElement {
//--- Attributes
  public : GGS_luint  mErrorMessageIndex ;
//--- Constructor
  public : elementOf_GGS_typeListeMessagesErreur (const GGS_luint & ) ;

//--- Access to next
  public : inline elementOf_GGS_typeListeMessagesErreur * nextObject (void) const { return (elementOf_GGS_typeListeMessagesErreur *) internalNextItem () ; }
//--- Access to previous
  public : inline elementOf_GGS_typeListeMessagesErreur * previousObject (void) const { return (elementOf_GGS_typeListeMessagesErreur *) internalPreviousItem () ; }
//--- Element comparison
  protected : bool isEqualToElement (const cListElement * inOperand) const ;
//--- Method used for description
  public : virtual void appendForListDescription (C_Lexique & _inLexique,
                                                  C_String & ioString,
                                                  const sint32 inIndentation
                                                  COMMA_LOCATION_ARGS) const ;
  friend class GGS_typeListeMessagesErreur ;
} ;

//---------------------------------------------------------------------------*

#include "include_typeEmissionParDefaut.h"

//---------------------------------------------------------------------------*

#include "include_typeEmissionTerminalParDefaut.h"

//---------------------------------------------------------------------------*

#include "include_typeEmissionErreurParDefaut.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@typeListeRecherche'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_typeListeRecherche : public AC_galgas_list::cListElement {
//--- Attributes
  public : GGS_lstring  attributNomAttribut ;
  public : GGS_lstring  attributNomTable ;
//--- Constructor
  public : elementOf_GGS_typeListeRecherche (const GGS_lstring & ,
                                const GGS_lstring & ) ;

//--- Access to next
  public : inline elementOf_GGS_typeListeRecherche * nextObject (void) const { return (elementOf_GGS_typeListeRecherche *) internalNextItem () ; }
//--- Access to previous
  public : inline elementOf_GGS_typeListeRecherche * previousObject (void) const { return (elementOf_GGS_typeListeRecherche *) internalPreviousItem () ; }
//--- Element comparison
  protected : bool isEqualToElement (const cListElement * inOperand) const ;
//--- Method used for description
  public : virtual void appendForListDescription (C_Lexique & _inLexique,
                                                  C_String & ioString,
                                                  const sint32 inIndentation
                                                  COMMA_LOCATION_ARGS) const ;
  friend class GGS_typeListeRecherche ;
} ;

//---------------------------------------------------------------------------*

#include "include_typeInstructionActionExterne.h"

//---------------------------------------------------------------------------*

#include "include_typeInstructionRepetitionLexicale.h"

//---------------------------------------------------------------------------*

#include "include_typeInstructionSiLexical.h"

//---------------------------------------------------------------------------*

#include "include_typeInstructionEmettreSimple.h"

//---------------------------------------------------------------------------*

#include "include_typeLexicalDropInstruction.h"

//---------------------------------------------------------------------------*

#include "include_typeInstructionEmettre.h"

//---------------------------------------------------------------------------*

#include "include_typeInstructionErreurLexicale.h"

//---------------------------------------------------------------------------*

#endif
