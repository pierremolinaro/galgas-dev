//---------------------------------------------------------------------------*//                                                                           *//                        File 'scanner_semantics.h'                         *//               Generated by version 0.14.1 (LL(1) grammar)                 *//                       june 6th, 2005, at 18h19'23"                        *//                                                                           *// This program is free software; you can redistribute it and/or modify it   *// under the terms of the GNU General Public License as published by the     *// Free Software Foundation.                                                 *//                                                                           *// This program is distributed in the hope it will be useful, but WITHOUT    *// ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or     *// FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for  *// more details.                                                             *//                                                                           *//---------------------------------------------------------------------------*//--- START OF USER ZONE 1//--- END OF USER ZONE 1#ifndef scanner_semantics_DEFINED#define scanner_semantics_DEFINED#include <string.h>// Include predefined semantics types definition *#include "galgas/C_GGS_Object.h"#include "galgas/AC_galgas_io.h"#include "galgas/GGS_location.h"#include "galgas/GGS_lbool.h"#include "galgas/GGS_lchar.h"#include "galgas/GGS_lstring.h"#include "galgas/GGS_ldouble.h"#include "galgas/GGS_luint.h"#include "galgas/GGS_lsint.h"#include "galgas/AC_galgas_map.h"// Include scanner definition *#include "galgas/C_Lexique.h"// Include imported semantics *#include "common_semantics.h"//--- START OF USER ZONE 2//--- END OF USER ZONE 2//---------------------------------------------------------------------------*//                                                                           *//             DECLARATIONS FOR MAP 'typeLexicalAttributesMap'               *//                                                                           *//---------------------------------------------------------------------------*class e_typeLexicalAttributesMap {  public : GGS_AC_galgasType  attributType ;} ;//---------------------------------------------------------------------------*class GGS_typeLexicalAttributesMap : public AC_galgas_map {//------------------------ Internal class for an element  public : class element_type : public AC_galgas_map_element {  //--- Constructor    public : element_type (const GGS_lstring & inKey,                           const sint32 inIndex,                           const e_typeLexicalAttributesMap & inInfo) ;  //--- Method for key compare    public : virtual sint32 compareKeys (void * inKey) const ;  //--- Method for getting key as C_String    public : virtual C_String stringForKey (void) const ;  //--- Get pointers    public : inline element_type * nextObject (void) const { return (element_type *) mNextItem ; }    public : inline element_type * infObject (void) const { return (element_type *) mInfPtr ; }    public : inline element_type * supObject (void) const { return (element_type *) mSupPtr ; }  //--- Data members    public : const GGS_lstring mKey ;    public : e_typeLexicalAttributesMap mInfo ;  } ;//--- Get pointers  public : inline element_type * rootObject (void) const { return (element_type *) mRoot ; }  public : inline element_type * firstObject (void) const { return (element_type *) mFirstItem ; }  public : inline element_type * lastObject (void) const { return (element_type *) mLastItem ; }//--- Create a new element  protected : virtual AC_galgas_map_element * new_element (void * inKey, void * inInfo) ;//--- 'empty' constructor  public : static GGS_typeLexicalAttributesMap constructor_empty (void) ;//--- 'hasKey' reader  public : GGS_bool reader_hasKey (const GGS_lstring & inKey) const ;//--- Method used for duplicate a map  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;//--- Insert an element  public : void insertElement (C_Lexique & inLexique,                               const char * inErrorMessagesArray [],                               const GGS_lstring & inKey,                               const GGS_AC_galgasType & inParameter0,                               GGS_luint * outIndex) ;//--- Search for an element  public : void searchElement (C_Lexique & inLexique,                               const char * inErrorMessagesArray [],                               const GGS_lstring & inKey,                               GGS_AC_galgasType * outParameter0,                               GGS_luint * outIndex) ;} ;//---------------------------------------------------------------------------*void searchKey_typeLexicalAttributesMap (C_Lexique & inLexique,                                GGS_typeLexicalAttributesMap & ioMap,                                const GGS_lstring & inKey,                                GGS_AC_galgasType   * outParameter0,                                GGS_luint * outIndex) ;//---------------------------------------------------------------------------*void insertKey_typeLexicalAttributesMap (C_Lexique & inLexique,                                GGS_typeLexicalAttributesMap & ioMap,                                const GGS_lstring & inKey,                                const GGS_AC_galgasType &  inParameter0,                                GGS_luint * outIndex) ;//---------------------------------------------------------------------------*//                                                                           *//                  DECLARATIONS FOR MAP 'lexicalTypeMap'                    *//                                                                           *//---------------------------------------------------------------------------*class e_lexicalTypeMap {  public : GGS_AC_galgasType  mAttributType ;} ;//---------------------------------------------------------------------------*class GGS_lexicalTypeMap : public AC_galgas_map {//------------------------ Internal class for an element  public : class element_type : public AC_galgas_map_element {  //--- Constructor    public : element_type (const GGS_lstring & inKey,                           const sint32 inIndex,                           const e_lexicalTypeMap & inInfo) ;  //--- Method for key compare    public : virtual sint32 compareKeys (void * inKey) const ;  //--- Method for getting key as C_String    public : virtual C_String stringForKey (void) const ;  //--- Get pointers    public : inline element_type * nextObject (void) const { return (element_type *) mNextItem ; }    public : inline element_type * infObject (void) const { return (element_type *) mInfPtr ; }    public : inline element_type * supObject (void) const { return (element_type *) mSupPtr ; }  //--- Data members    public : const GGS_lstring mKey ;    public : e_lexicalTypeMap mInfo ;  } ;//--- Get pointers  public : inline element_type * rootObject (void) const { return (element_type *) mRoot ; }  public : inline element_type * firstObject (void) const { return (element_type *) mFirstItem ; }  public : inline element_type * lastObject (void) const { return (element_type *) mLastItem ; }//--- Create a new element  protected : virtual AC_galgas_map_element * new_element (void * inKey, void * inInfo) ;//--- 'empty' constructor  public : static GGS_lexicalTypeMap constructor_empty (void) ;//--- 'hasKey' reader  public : GGS_bool reader_hasKey (const GGS_lstring & inKey) const ;//--- Method used for duplicate a map  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;//--- Insert an element  public : void insertElement (C_Lexique & inLexique,                               const char * inErrorMessagesArray [],                               const GGS_lstring & inKey,                               const GGS_AC_galgasType & inParameter0,                               GGS_luint * outIndex) ;//--- Search for an element  public : void searchElement (C_Lexique & inLexique,                               const char * inErrorMessagesArray [],                               const GGS_lstring & inKey,                               GGS_AC_galgasType * outParameter0,                               GGS_luint * outIndex) ;} ;//---------------------------------------------------------------------------*void searchKey_lexicalTypeMap (C_Lexique & inLexique,                                GGS_lexicalTypeMap & ioMap,                                const GGS_lstring & inKey,                                GGS_AC_galgasType   * outParameter0,                                GGS_luint * outIndex) ;//---------------------------------------------------------------------------*void insertKey_lexicalTypeMap (C_Lexique & inLexique,                                GGS_lexicalTypeMap & ioMap,                                const GGS_lstring & inKey,                                const GGS_AC_galgasType &  inParameter0,                                GGS_luint * outIndex) ;//---------------------------------------------------------------------------*//                                                                           *//             DECLARATIONS FOR MAP 'typeTableMessagesErreurs'               *//                                                                           *//---------------------------------------------------------------------------*class e_typeTableMessagesErreurs {  public : GGS_lstring  mErrorMessage ;} ;//---------------------------------------------------------------------------*class GGS_typeTableMessagesErreurs : public AC_galgas_map {//------------------------ Internal class for an element  public : class element_type : public AC_galgas_map_element {  //--- Constructor    public : element_type (const GGS_lstring & inKey,                           const sint32 inIndex,                           const e_typeTableMessagesErreurs & inInfo) ;  //--- Method for key compare    public : virtual sint32 compareKeys (void * inKey) const ;  //--- Method for getting key as C_String    public : virtual C_String stringForKey (void) const ;  //--- Get pointers    public : inline element_type * nextObject (void) const { return (element_type *) mNextItem ; }    public : inline element_type * infObject (void) const { return (element_type *) mInfPtr ; }    public : inline element_type * supObject (void) const { return (element_type *) mSupPtr ; }  //--- Data members    public : const GGS_lstring mKey ;    public : e_typeTableMessagesErreurs mInfo ;  } ;//--- Get pointers  public : inline element_type * rootObject (void) const { return (element_type *) mRoot ; }  public : inline element_type * firstObject (void) const { return (element_type *) mFirstItem ; }  public : inline element_type * lastObject (void) const { return (element_type *) mLastItem ; }//--- Create a new element  protected : virtual AC_galgas_map_element * new_element (void * inKey, void * inInfo) ;//--- 'empty' constructor  public : static GGS_typeTableMessagesErreurs constructor_empty (void) ;//--- 'hasKey' reader  public : GGS_bool reader_hasKey (const GGS_lstring & inKey) const ;//--- Method used for duplicate a map  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;//--- Insert an element  public : void insertElement (C_Lexique & inLexique,                               const char * inErrorMessagesArray [],                               const GGS_lstring & inKey,                               const GGS_lstring & inParameter0,                               GGS_luint * outIndex) ;//--- Search for an element  public : void searchElement (C_Lexique & inLexique,                               const char * inErrorMessagesArray [],                               const GGS_lstring & inKey,                               GGS_lstring * outParameter0,                               GGS_luint * outIndex) ;} ;//---------------------------------------------------------------------------*void searchKey_typeTableMessagesErreurs (C_Lexique & inLexique,                                GGS_typeTableMessagesErreurs & ioMap,                                const GGS_lstring & inKey,                                GGS_lstring   * outParameter0,                                GGS_luint * outIndex) ;//---------------------------------------------------------------------------*void insertKey_typeTableMessagesErreurs (C_Lexique & inLexique,                                GGS_typeTableMessagesErreurs & ioMap,                                const GGS_lstring & inKey,                                const GGS_lstring &  inParameter0,                                GGS_luint * outIndex) ;//---------------------------------------------------------------------------*//                                                                           *//                     DECLARATIONS FOR MAP 'M_styles'                       *//                                                                           *//---------------------------------------------------------------------------*class e_M_styles {  public : GGS_lstring  mTitle ;} ;//---------------------------------------------------------------------------*class GGS_M_styles : public AC_galgas_map {//------------------------ Internal class for an element  public : class element_type : public AC_galgas_map_element {  //--- Constructor    public : element_type (const GGS_lstring & inKey,                           const sint32 inIndex,                           const e_M_styles & inInfo) ;  //--- Method for key compare    public : virtual sint32 compareKeys (void * inKey) const ;  //--- Method for getting key as C_String    public : virtual C_String stringForKey (void) const ;  //--- Get pointers    public : inline element_type * nextObject (void) const { return (element_type *) mNextItem ; }    public : inline element_type * infObject (void) const { return (element_type *) mInfPtr ; }    public : inline element_type * supObject (void) const { return (element_type *) mSupPtr ; }  //--- Data members    public : const GGS_lstring mKey ;    public : e_M_styles mInfo ;  } ;//--- Get pointers  public : inline element_type * rootObject (void) const { return (element_type *) mRoot ; }  public : inline element_type * firstObject (void) const { return (element_type *) mFirstItem ; }  public : inline element_type * lastObject (void) const { return (element_type *) mLastItem ; }//--- Create a new element  protected : virtual AC_galgas_map_element * new_element (void * inKey, void * inInfo) ;//--- 'empty' constructor  public : static GGS_M_styles constructor_empty (void) ;//--- 'hasKey' reader  public : GGS_bool reader_hasKey (const GGS_lstring & inKey) const ;//--- Method used for duplicate a map  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;//--- Insert an element  public : void insertElement (C_Lexique & inLexique,                               const char * inErrorMessagesArray [],                               const GGS_lstring & inKey,                               const GGS_lstring & inParameter0,                               GGS_luint * outIndex) ;//--- Search for an element  public : void searchElement (C_Lexique & inLexique,                               const char * inErrorMessagesArray [],                               const GGS_lstring & inKey,                               GGS_lstring * outParameter0,                               GGS_luint * outIndex) ;} ;//---------------------------------------------------------------------------*void searchKey_M_styles (C_Lexique & inLexique,                                GGS_M_styles & ioMap,                                const GGS_lstring & inKey,                                GGS_lstring   * outParameter0,                                GGS_luint * outIndex) ;//---------------------------------------------------------------------------*void insertKey_M_styles (C_Lexique & inLexique,                                GGS_M_styles & ioMap,                                const GGS_lstring & inKey,                                const GGS_lstring &  inParameter0,                                GGS_luint * outIndex) ;//---------------------------------------------------------------------------*//                                                                           *//           DECLARATIONS FOR MAP 'typeTableDefinitionTerminaux'             *//                                                                           *//---------------------------------------------------------------------------*class e_typeTableDefinitionTerminaux {  public : GGS_string mErrorMessage ;  public : GGS_typeListeAttributsSemantiques  attributListeDesAttributs ;  public : GGS_luint  mStyleIndex ;} ;//---------------------------------------------------------------------------*class GGS_typeTableDefinitionTerminaux : public AC_galgas_map {//------------------------ Internal class for an element  public : class element_type : public AC_galgas_map_element {  //--- Constructor    public : element_type (const GGS_lstring & inKey,                           const sint32 inIndex,                           const e_typeTableDefinitionTerminaux & inInfo) ;  //--- Method for key compare    public : virtual sint32 compareKeys (void * inKey) const ;  //--- Method for getting key as C_String    public : virtual C_String stringForKey (void) const ;  //--- Get pointers    public : inline element_type * nextObject (void) const { return (element_type *) mNextItem ; }    public : inline element_type * infObject (void) const { return (element_type *) mInfPtr ; }    public : inline element_type * supObject (void) const { return (element_type *) mSupPtr ; }  //--- Data members    public : const GGS_lstring mKey ;    public : e_typeTableDefinitionTerminaux mInfo ;  } ;//--- Get pointers  public : inline element_type * rootObject (void) const { return (element_type *) mRoot ; }  public : inline element_type * firstObject (void) const { return (element_type *) mFirstItem ; }  public : inline element_type * lastObject (void) const { return (element_type *) mLastItem ; }//--- Create a new element  protected : virtual AC_galgas_map_element * new_element (void * inKey, void * inInfo) ;//--- 'empty' constructor  public : static GGS_typeTableDefinitionTerminaux constructor_empty (void) ;//--- 'hasKey' reader  public : GGS_bool reader_hasKey (const GGS_lstring & inKey) const ;//--- Method used for duplicate a map  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;//--- Insert an element  public : void insertElement (C_Lexique & inLexique,                               const char * inErrorMessagesArray [],                               const GGS_lstring & inKey,                               const GGS_string& inParameter0,                               const GGS_typeListeAttributsSemantiques & inParameter1,                               const GGS_luint & inParameter2,                               GGS_luint * outIndex) ;//--- Search for an element  public : void searchElement (C_Lexique & inLexique,                               const char * inErrorMessagesArray [],                               const GGS_lstring & inKey,                               GGS_string* outParameter0,                               GGS_typeListeAttributsSemantiques * outParameter1,                               GGS_luint * outParameter2,                               GGS_luint * outIndex) ;} ;//---------------------------------------------------------------------------*void searchKey_typeTableDefinitionTerminaux (C_Lexique & inLexique,                                GGS_typeTableDefinitionTerminaux & ioMap,                                const GGS_lstring & inKey,                                GGS_string  * outParameter0,                                GGS_typeListeAttributsSemantiques   * outParameter1,                                GGS_luint   * outParameter2,                                GGS_luint * outIndex) ;//---------------------------------------------------------------------------*void insertKey_typeTableDefinitionTerminaux (C_Lexique & inLexique,                                GGS_typeTableDefinitionTerminaux & ioMap,                                const GGS_lstring & inKey,                                const GGS_string&  inParameter0,                                const GGS_typeListeAttributsSemantiques &  inParameter1,                                const GGS_luint &  inParameter2,                                GGS_luint * outIndex) ;//---------------------------------------------------------------------------*//                                                                           *//               DECLARATIONS FOR MAP 'typeTableMotsReserves'                *//                                                                           *//---------------------------------------------------------------------------*class e_typeTableMotsReserves {  public : GGS_lstring  attributNomTerminal ;} ;//---------------------------------------------------------------------------*class GGS_typeTableMotsReserves : public AC_galgas_map {//------------------------ Internal class for an element  public : class element_type : public AC_galgas_map_element {  //--- Constructor    public : element_type (const GGS_lstring & inKey,                           const sint32 inIndex,                           const e_typeTableMotsReserves & inInfo) ;  //--- Method for key compare    public : virtual sint32 compareKeys (void * inKey) const ;  //--- Method for getting key as C_String    public : virtual C_String stringForKey (void) const ;  //--- Get pointers    public : inline element_type * nextObject (void) const { return (element_type *) mNextItem ; }    public : inline element_type * infObject (void) const { return (element_type *) mInfPtr ; }    public : inline element_type * supObject (void) const { return (element_type *) mSupPtr ; }  //--- Data members    public : const GGS_lstring mKey ;    public : e_typeTableMotsReserves mInfo ;  } ;//--- Get pointers  public : inline element_type * rootObject (void) const { return (element_type *) mRoot ; }  public : inline element_type * firstObject (void) const { return (element_type *) mFirstItem ; }  public : inline element_type * lastObject (void) const { return (element_type *) mLastItem ; }//--- Create a new element  protected : virtual AC_galgas_map_element * new_element (void * inKey, void * inInfo) ;//--- 'empty' constructor  public : static GGS_typeTableMotsReserves constructor_empty (void) ;//--- 'hasKey' reader  public : GGS_bool reader_hasKey (const GGS_lstring & inKey) const ;//--- Method used for duplicate a map  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;//--- Insert an element  public : void insertElement (C_Lexique & inLexique,                               const char * inErrorMessagesArray [],                               const GGS_lstring & inKey,                               const GGS_lstring & inParameter0,                               GGS_luint * outIndex) ;//--- Search for an element  public : void searchElement (C_Lexique & inLexique,                               const char * inErrorMessagesArray [],                               const GGS_lstring & inKey,                               GGS_lstring * outParameter0,                               GGS_luint * outIndex) ;} ;//---------------------------------------------------------------------------*void searchKey_typeTableMotsReserves (C_Lexique & inLexique,                                GGS_typeTableMotsReserves & ioMap,                                const GGS_lstring & inKey,                                GGS_lstring   * outParameter0,                                GGS_luint * outIndex) ;//---------------------------------------------------------------------------*void insertKey_typeTableMotsReserves (C_Lexique & inLexique,                                GGS_typeTableMotsReserves & ioMap,                                const GGS_lstring & inKey,                                const GGS_lstring &  inParameter0,                                GGS_luint * outIndex) ;//---------------------------------------------------------------------------*//                                                                           *//           DECLARATIONS FOR MAP 'typeTableTablesDeMotsReserves'            *//                                                                           *//---------------------------------------------------------------------------*class e_typeTableTablesDeMotsReserves {  public : GGS_typeTableMotsReserves  attributSimpleTable ;} ;//---------------------------------------------------------------------------*class GGS_typeTableTablesDeMotsReserves : public AC_galgas_map {//------------------------ Internal class for an element  public : class element_type : public AC_galgas_map_element {  //--- Constructor    public : element_type (const GGS_lstring & inKey,                           const sint32 inIndex,                           const e_typeTableTablesDeMotsReserves & inInfo) ;  //--- Method for key compare    public : virtual sint32 compareKeys (void * inKey) const ;  //--- Method for getting key as C_String    public : virtual C_String stringForKey (void) const ;  //--- Get pointers    public : inline element_type * nextObject (void) const { return (element_type *) mNextItem ; }    public : inline element_type * infObject (void) const { return (element_type *) mInfPtr ; }    public : inline element_type * supObject (void) const { return (element_type *) mSupPtr ; }  //--- Data members    public : const GGS_lstring mKey ;    public : e_typeTableTablesDeMotsReserves mInfo ;  } ;//--- Get pointers  public : inline element_type * rootObject (void) const { return (element_type *) mRoot ; }  public : inline element_type * firstObject (void) const { return (element_type *) mFirstItem ; }  public : inline element_type * lastObject (void) const { return (element_type *) mLastItem ; }//--- Create a new element  protected : virtual AC_galgas_map_element * new_element (void * inKey, void * inInfo) ;//--- 'empty' constructor  public : static GGS_typeTableTablesDeMotsReserves constructor_empty (void) ;//--- 'hasKey' reader  public : GGS_bool reader_hasKey (const GGS_lstring & inKey) const ;//--- Method used for duplicate a map  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;//--- Insert an element  public : void insertElement (C_Lexique & inLexique,                               const char * inErrorMessagesArray [],                               const GGS_lstring & inKey,                               const GGS_typeTableMotsReserves & inParameter0,                               GGS_luint * outIndex) ;//--- Search for an element  public : void searchElement (C_Lexique & inLexique,                               const char * inErrorMessagesArray [],                               const GGS_lstring & inKey,                               GGS_typeTableMotsReserves * outParameter0,                               GGS_luint * outIndex) ;} ;//---------------------------------------------------------------------------*void searchKey_typeTableTablesDeMotsReserves (C_Lexique & inLexique,                                GGS_typeTableTablesDeMotsReserves & ioMap,                                const GGS_lstring & inKey,                                GGS_typeTableMotsReserves   * outParameter0,                                GGS_luint * outIndex) ;//---------------------------------------------------------------------------*void insertKey_typeTableTablesDeMotsReserves (C_Lexique & inLexique,                                GGS_typeTableTablesDeMotsReserves & ioMap,                                const GGS_lstring & inKey,                                const GGS_typeTableMotsReserves &  inParameter0,                                GGS_luint * outIndex) ;class cPtr_typeConditionLexicale ;//---------------------------------------------------------------------------*//                                                                           *//                 GALGAS class 'GGS_typeConditionLexicale'                  *//                                                                           *//---------------------------------------------------------------------------*class GGS_typeConditionLexicale {  protected : cPtr_typeConditionLexicale * mPointer ;  public : GGS_typeConditionLexicale (void) ;  public : GGS_typeConditionLexicale (const GGS_typeConditionLexicale &) ;  public : virtual ~GGS_typeConditionLexicale (void) ;  public : void operator = (const GGS_typeConditionLexicale &) ;  public : bool isBuilt (void) const ;  public : inline bool isEqualTo (const GGS_typeConditionLexicale & operand_) const {    return mPointer == operand_.mPointer ;  }  public : void operator = (cPtr_typeConditionLexicale * inSource) ;  public : GGS_typeConditionLexicale (cPtr_typeConditionLexicale * inSource) ;  public : inline cPtr_typeConditionLexicale * getPtr (void) const {    return mPointer ;  }  public : void drop_operation (void) ;  public : cPtr_typeConditionLexicale * operator () (void) const ;} ;//---------------------------------------------------------------------------*//                                                                           *//                class list 'typeListeConditionsLexicales'                  *//                                                                           *//---------------------------------------------------------------------------*class GGS_typeListeConditionsLexicales {  public : class element_type {    private : element_type * mNextItem ;    public : GGS_typeConditionLexicale  attributCondition ;    public : element_type (const GGS_typeConditionLexicale & ) ;    public : inline element_type * nextObject (void) const { return mNextItem ; }    private : element_type (const element_type &) ;    private : void operator = (const element_type &) ;    public : ~element_type (void) {}    friend class GGS_typeListeConditionsLexicales ;  } ;  private : element_type * mFirstItem ;  private : element_type * mLastItem ;  private : element_type * mCurrentItemPtr ;  private : sint32 mCurrentItemIndex ;  private : sint32 mListLength ;  public : inline sint32 count (void) const {    return mListLength ;  }  private : sint32 * mCountReference ;  public : GGS_typeListeConditionsLexicales (void) ; // Default Constructor  public : GGS_typeListeConditionsLexicales (const GGS_typeListeConditionsLexicales &) ; // Copy constructor  public : void operator = (const GGS_typeListeConditionsLexicales &) ; // Assignment operator//--- Virtual destructor  public : virtual ~GGS_typeListeConditionsLexicales (void) ;//--- Constructor 'new'  public : static GGS_typeListeConditionsLexicales constructor_empty (void) ;//--- Get first item  public : inline element_type * firstObject (void) const { return mFirstItem ; }  public : void addAssign_operation (const GGS_typeConditionLexicale & argument_0) ;  protected : void internalAppendItem (const GGS_typeConditionLexicale & argument_0) ;  public : void insulateList (void) ;  public : void emptyList (void) ;  public : inline bool isBuilt (void) const {    return mCountReference != NULL ;  }  public : void drop_operation (void) ;  public : inline GGS_uint reader_length (void)  const {    return GGS_uint (mCountReference != NULL, (uint32) mListLength) ;  }} ;class cPtr_typeInstructionLexicale ;//---------------------------------------------------------------------------*//                                                                           *//                GALGAS class 'GGS_typeInstructionLexicale'                 *//                                                                           *//---------------------------------------------------------------------------*class GGS_typeInstructionLexicale {  protected : cPtr_typeInstructionLexicale * mPointer ;  public : GGS_typeInstructionLexicale (void) ;  public : GGS_typeInstructionLexicale (const GGS_typeInstructionLexicale &) ;  public : virtual ~GGS_typeInstructionLexicale (void) ;  public : void operator = (const GGS_typeInstructionLexicale &) ;  public : bool isBuilt (void) const ;  public : inline bool isEqualTo (const GGS_typeInstructionLexicale & operand_) const {    return mPointer == operand_.mPointer ;  }  public : void operator = (cPtr_typeInstructionLexicale * inSource) ;  public : GGS_typeInstructionLexicale (cPtr_typeInstructionLexicale * inSource) ;  public : inline cPtr_typeInstructionLexicale * getPtr (void) const {    return mPointer ;  }  public : void drop_operation (void) ;  public : cPtr_typeInstructionLexicale * operator () (void) const ;} ;//---------------------------------------------------------------------------*//                                                                           *//                 class list 'tListeInstructionsLexicales'                  *//                                                                           *//---------------------------------------------------------------------------*class GGS_tListeInstructionsLexicales {  public : class element_type {    private : element_type * mNextItem ;    public : GGS_typeInstructionLexicale  attributInstruction ;    public : element_type (const GGS_typeInstructionLexicale & ) ;    public : inline element_type * nextObject (void) const { return mNextItem ; }    private : element_type (const element_type &) ;    private : void operator = (const element_type &) ;    public : ~element_type (void) {}    friend class GGS_tListeInstructionsLexicales ;  } ;  private : element_type * mFirstItem ;  private : element_type * mLastItem ;  private : element_type * mCurrentItemPtr ;  private : sint32 mCurrentItemIndex ;  private : sint32 mListLength ;  public : inline sint32 count (void) const {    return mListLength ;  }  private : sint32 * mCountReference ;  public : GGS_tListeInstructionsLexicales (void) ; // Default Constructor  public : GGS_tListeInstructionsLexicales (const GGS_tListeInstructionsLexicales &) ; // Copy constructor  public : void operator = (const GGS_tListeInstructionsLexicales &) ; // Assignment operator//--- Virtual destructor  public : virtual ~GGS_tListeInstructionsLexicales (void) ;//--- Constructor 'new'  public : static GGS_tListeInstructionsLexicales constructor_empty (void) ;//--- Get first item  public : inline element_type * firstObject (void) const { return mFirstItem ; }  public : void addAssign_operation (const GGS_typeInstructionLexicale & argument_0) ;  protected : void internalAppendItem (const GGS_typeInstructionLexicale & argument_0) ;  public : void insulateList (void) ;  public : void emptyList (void) ;  public : inline bool isBuilt (void) const {    return mCountReference != NULL ;  }  public : void drop_operation (void) ;  public : inline GGS_uint reader_length (void)  const {    return GGS_uint (mCountReference != NULL, (uint32) mListLength) ;  }} ;//---------------------------------------------------------------------------*//                                                                           *//                class list 'typeListeTestsEtInstructions'                  *//                                                                           *//---------------------------------------------------------------------------*class GGS_typeListeTestsEtInstructions {  public : class element_type {    private : element_type * mNextItem ;    public : GGS_typeListeConditionsLexicales  attributListeConditions ;    public : GGS_tListeInstructionsLexicales  attributListeInstructions ;    public : element_type (const GGS_typeListeConditionsLexicales & ,                                const GGS_tListeInstructionsLexicales & ) ;    public : inline element_type * nextObject (void) const { return mNextItem ; }    private : element_type (const element_type &) ;    private : void operator = (const element_type &) ;    public : ~element_type (void) {}    friend class GGS_typeListeTestsEtInstructions ;  } ;  private : element_type * mFirstItem ;  private : element_type * mLastItem ;  private : element_type * mCurrentItemPtr ;  private : sint32 mCurrentItemIndex ;  private : sint32 mListLength ;  public : inline sint32 count (void) const {    return mListLength ;  }  private : sint32 * mCountReference ;  public : GGS_typeListeTestsEtInstructions (void) ; // Default Constructor  public : GGS_typeListeTestsEtInstructions (const GGS_typeListeTestsEtInstructions &) ; // Copy constructor  public : void operator = (const GGS_typeListeTestsEtInstructions &) ; // Assignment operator//--- Virtual destructor  public : virtual ~GGS_typeListeTestsEtInstructions (void) ;//--- Constructor 'new'  public : static GGS_typeListeTestsEtInstructions constructor_empty (void) ;//--- Get first item  public : inline element_type * firstObject (void) const { return mFirstItem ; }  public : void addAssign_operation (const GGS_typeListeConditionsLexicales & argument_0,                                const GGS_tListeInstructionsLexicales & argument_1) ;  protected : void internalAppendItem (const GGS_typeListeConditionsLexicales & argument_0,                                const GGS_tListeInstructionsLexicales & argument_1) ;  public : void insulateList (void) ;  public : void emptyList (void) ;  public : inline bool isBuilt (void) const {    return mCountReference != NULL ;  }  public : void drop_operation (void) ;  public : inline GGS_uint reader_length (void)  const {    return GGS_uint (mCountReference != NULL, (uint32) mListLength) ;  }} ;class cPtr_typeArgumentRoutineExterne ;//---------------------------------------------------------------------------*//                                                                           *//              GALGAS class 'GGS_typeArgumentRoutineExterne'                *//                                                                           *//---------------------------------------------------------------------------*class GGS_typeArgumentRoutineExterne {  protected : cPtr_typeArgumentRoutineExterne * mPointer ;  public : GGS_typeArgumentRoutineExterne (void) ;  public : GGS_typeArgumentRoutineExterne (const GGS_typeArgumentRoutineExterne &) ;  public : virtual ~GGS_typeArgumentRoutineExterne (void) ;  public : void operator = (const GGS_typeArgumentRoutineExterne &) ;  public : bool isBuilt (void) const ;  public : inline bool isEqualTo (const GGS_typeArgumentRoutineExterne & operand_) const {    return mPointer == operand_.mPointer ;  }  public : void operator = (cPtr_typeArgumentRoutineExterne * inSource) ;  public : GGS_typeArgumentRoutineExterne (cPtr_typeArgumentRoutineExterne * inSource) ;  public : inline cPtr_typeArgumentRoutineExterne * getPtr (void) const {    return mPointer ;  }  public : void drop_operation (void) ;  public : cPtr_typeArgumentRoutineExterne * operator () (void) const ;} ;//---------------------------------------------------------------------------*//                                                                           *//                class list 'typeListeArgumentsRoutExterne'                 *//                                                                           *//---------------------------------------------------------------------------*class GGS_typeListeArgumentsRoutExterne {  public : class element_type {    private : element_type * mNextItem ;    public : GGS_typeArgumentRoutineExterne  attributArgument ;    public : element_type (const GGS_typeArgumentRoutineExterne & ) ;    public : inline element_type * nextObject (void) const { return mNextItem ; }    private : element_type (const element_type &) ;    private : void operator = (const element_type &) ;    public : ~element_type (void) {}    friend class GGS_typeListeArgumentsRoutExterne ;  } ;  private : element_type * mFirstItem ;  private : element_type * mLastItem ;  private : element_type * mCurrentItemPtr ;  private : sint32 mCurrentItemIndex ;  private : sint32 mListLength ;  public : inline sint32 count (void) const {    return mListLength ;  }  private : sint32 * mCountReference ;  public : GGS_typeListeArgumentsRoutExterne (void) ; // Default Constructor  public : GGS_typeListeArgumentsRoutExterne (const GGS_typeListeArgumentsRoutExterne &) ; // Copy constructor  public : void operator = (const GGS_typeListeArgumentsRoutExterne &) ; // Assignment operator//--- Virtual destructor  public : virtual ~GGS_typeListeArgumentsRoutExterne (void) ;//--- Constructor 'new'  public : static GGS_typeListeArgumentsRoutExterne constructor_empty (void) ;//--- Get first item  public : inline element_type * firstObject (void) const { return mFirstItem ; }  public : void addAssign_operation (const GGS_typeArgumentRoutineExterne & argument_0) ;  protected : void internalAppendItem (const GGS_typeArgumentRoutineExterne & argument_0) ;  public : void insulateList (void) ;  public : void emptyList (void) ;  public : inline bool isBuilt (void) const {    return mCountReference != NULL ;  }  public : void drop_operation (void) ;  public : inline GGS_uint reader_length (void)  const {    return GGS_uint (mCountReference != NULL, (uint32) mListLength) ;  }} ;//---------------------------------------------------------------------------*//                                                                           *//                   class list 'typeListeMessagesErreur'                    *//                                                                           *//---------------------------------------------------------------------------*class GGS_typeListeMessagesErreur {  public : class element_type {    private : element_type * mNextItem ;    public : GGS_luint  mErrorMessageIndex ;    public : element_type (const GGS_luint & ) ;    public : inline element_type * nextObject (void) const { return mNextItem ; }    private : element_type (const element_type &) ;    private : void operator = (const element_type &) ;    public : ~element_type (void) {}    friend class GGS_typeListeMessagesErreur ;  } ;  private : element_type * mFirstItem ;  private : element_type * mLastItem ;  private : element_type * mCurrentItemPtr ;  private : sint32 mCurrentItemIndex ;  private : sint32 mListLength ;  public : inline sint32 count (void) const {    return mListLength ;  }  private : sint32 * mCountReference ;  public : GGS_typeListeMessagesErreur (void) ; // Default Constructor  public : GGS_typeListeMessagesErreur (const GGS_typeListeMessagesErreur &) ; // Copy constructor  public : void operator = (const GGS_typeListeMessagesErreur &) ; // Assignment operator//--- Virtual destructor  public : virtual ~GGS_typeListeMessagesErreur (void) ;//--- Constructor 'new'  public : static GGS_typeListeMessagesErreur constructor_empty (void) ;//--- Get first item  public : inline element_type * firstObject (void) const { return mFirstItem ; }  public : void addAssign_operation (const GGS_luint & argument_0) ;  protected : void internalAppendItem (const GGS_luint & argument_0) ;  public : void insulateList (void) ;  public : void emptyList (void) ;  public : inline bool isBuilt (void) const {    return mCountReference != NULL ;  }  public : void drop_operation (void) ;  public : inline GGS_uint reader_length (void)  const {    return GGS_uint (mCountReference != NULL, (uint32) mListLength) ;  }} ;class cPtr_typeEmissionParDefaut ;//---------------------------------------------------------------------------*//                                                                           *//                 GALGAS class 'GGS_typeEmissionParDefaut'                  *//                                                                           *//---------------------------------------------------------------------------*class GGS_typeEmissionParDefaut {  protected : cPtr_typeEmissionParDefaut * mPointer ;  public : GGS_typeEmissionParDefaut (void) ;  public : GGS_typeEmissionParDefaut (const GGS_typeEmissionParDefaut &) ;  public : virtual ~GGS_typeEmissionParDefaut (void) ;  public : void operator = (const GGS_typeEmissionParDefaut &) ;  public : bool isBuilt (void) const ;  public : inline bool isEqualTo (const GGS_typeEmissionParDefaut & operand_) const {    return mPointer == operand_.mPointer ;  }  public : void operator = (cPtr_typeEmissionParDefaut * inSource) ;  public : GGS_typeEmissionParDefaut (cPtr_typeEmissionParDefaut * inSource) ;  public : inline cPtr_typeEmissionParDefaut * getPtr (void) const {    return mPointer ;  }  public : void drop_operation (void) ;  public : cPtr_typeEmissionParDefaut * operator () (void) const ;} ;//---------------------------------------------------------------------------*//                                                                           *//                     class list 'typeListeRecherche'                       *//                                                                           *//---------------------------------------------------------------------------*class GGS_typeListeRecherche {  public : class element_type {    private : element_type * mNextItem ;    public : GGS_lstring  attributNomAttribut ;    public : GGS_lstring  attributNomTable ;    public : element_type (const GGS_lstring & ,                                const GGS_lstring & ) ;    public : inline element_type * nextObject (void) const { return mNextItem ; }    private : element_type (const element_type &) ;    private : void operator = (const element_type &) ;    public : ~element_type (void) {}    friend class GGS_typeListeRecherche ;  } ;  private : element_type * mFirstItem ;  private : element_type * mLastItem ;  private : element_type * mCurrentItemPtr ;  private : sint32 mCurrentItemIndex ;  private : sint32 mListLength ;  public : inline sint32 count (void) const {    return mListLength ;  }  private : sint32 * mCountReference ;  public : GGS_typeListeRecherche (void) ; // Default Constructor  public : GGS_typeListeRecherche (const GGS_typeListeRecherche &) ; // Copy constructor  public : void operator = (const GGS_typeListeRecherche &) ; // Assignment operator//--- Virtual destructor  public : virtual ~GGS_typeListeRecherche (void) ;//--- Constructor 'new'  public : static GGS_typeListeRecherche constructor_empty (void) ;//--- Get first item  public : inline element_type * firstObject (void) const { return mFirstItem ; }  public : void addAssign_operation (const GGS_lstring & argument_0,                                const GGS_lstring & argument_1) ;  protected : void internalAppendItem (const GGS_lstring & argument_0,                                const GGS_lstring & argument_1) ;  public : void insulateList (void) ;  public : void emptyList (void) ;  public : inline bool isBuilt (void) const {    return mCountReference != NULL ;  }  public : void drop_operation (void) ;  public : inline GGS_uint reader_length (void)  const {    return GGS_uint (mCountReference != NULL, (uint32) mListLength) ;  }} ;class cPtr_typeInclusion ;//---------------------------------------------------------------------------*//                                                                           *//                     GALGAS class 'GGS_typeInclusion'                      *//                                                                           *//---------------------------------------------------------------------------*class GGS_typeInclusion {  protected : cPtr_typeInclusion * mPointer ;  public : GGS_typeInclusion (void) ;  public : GGS_typeInclusion (const GGS_typeInclusion &) ;  public : virtual ~GGS_typeInclusion (void) ;  public : void operator = (const GGS_typeInclusion &) ;  public : bool isBuilt (void) const ;  public : inline bool isEqualTo (const GGS_typeInclusion & operand_) const {    return mPointer == operand_.mPointer ;  }  public : void operator = (cPtr_typeInclusion * inSource) ;  public : GGS_typeInclusion (cPtr_typeInclusion * inSource) ;  public : inline cPtr_typeInclusion * getPtr (void) const {    return mPointer ;  }  public : void drop_operation (void) ;  public : cPtr_typeInclusion * operator () (void) const ;} ;//---------------------------------------------------------------------------*//                                                                           *//                     class list 'typeListeInclusions'                      *//                                                                           *//---------------------------------------------------------------------------*class GGS_typeListeInclusions {  public : class element_type {    private : element_type * mNextItem ;    public : GGS_typeInclusion  attributInclusion ;    public : element_type (const GGS_typeInclusion & ) ;    public : inline element_type * nextObject (void) const { return mNextItem ; }    private : element_type (const element_type &) ;    private : void operator = (const element_type &) ;    public : ~element_type (void) {}    friend class GGS_typeListeInclusions ;  } ;  private : element_type * mFirstItem ;  private : element_type * mLastItem ;  private : element_type * mCurrentItemPtr ;  private : sint32 mCurrentItemIndex ;  private : sint32 mListLength ;  public : inline sint32 count (void) const {    return mListLength ;  }  private : sint32 * mCountReference ;  public : GGS_typeListeInclusions (void) ; // Default Constructor  public : GGS_typeListeInclusions (const GGS_typeListeInclusions &) ; // Copy constructor  public : void operator = (const GGS_typeListeInclusions &) ; // Assignment operator//--- Virtual destructor  public : virtual ~GGS_typeListeInclusions (void) ;//--- Constructor 'new'  public : static GGS_typeListeInclusions constructor_empty (void) ;//--- Get first item  public : inline element_type * firstObject (void) const { return mFirstItem ; }  public : void addAssign_operation (const GGS_typeInclusion & argument_0) ;  protected : void internalAppendItem (const GGS_typeInclusion & argument_0) ;  public : void insulateList (void) ;  public : void emptyList (void) ;  public : inline bool isBuilt (void) const {    return mCountReference != NULL ;  }  public : void drop_operation (void) ;  public : inline GGS_uint reader_length (void)  const {    return GGS_uint (mCountReference != NULL, (uint32) mListLength) ;  }} ;void routine_appendToLexicalInstructionList (C_Lexique &,                                GGS_typeListeTestsEtInstructions  &,                                const GGS_lstring  &,                                GGS_lstring  &) ;#include "include_typeConditionLexicale.h"//---------------------------------------------------------------------------*//                                                                           *//                       class 'typeConditionChaine'                         *//                                                                           *//---------------------------------------------------------------------------*#define macro_typeConditionChaine#define macroInheritFrom_typeConditionChaineclass cPtr_typeConditionChaine : public cPtr_typeConditionLexicale {  private : typedef cPtr_typeConditionLexicale inherited ;  macroInheritFrom_typeConditionLexicale  macro_typeConditionChaine  public : cPtr_typeConditionChaine (const GGS_lstring & ) ;  public : GGS_lstring  attributChaine ;  public : virtual bool isBuilt (void) const ;} ;//---------------------------------------------------------------------------*//                                                                           *//                  GALGAS class 'GGS_typeConditionChaine'                   *//                                                                           *//---------------------------------------------------------------------------*class GGS_typeConditionChaine {  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE    public : static cPtr_typeConditionChaine * constructor_new (const GGS_lstring & argument_0) ;  #else    public : inline static cPtr_typeConditionChaine * constructor_new (const GGS_lstring & argument_0) {      return new cPtr_typeConditionChaine(argument_0) ;    }  #endif} ;//---------------------------------------------------------------------------*//                                                                           *//                      class 'typeConditionCaractere'                       *//                                                                           *//---------------------------------------------------------------------------*#define macro_typeConditionCaractere#define macroInheritFrom_typeConditionCaractereclass cPtr_typeConditionCaractere : public cPtr_typeConditionLexicale {  private : typedef cPtr_typeConditionLexicale inherited ;  macroInheritFrom_typeConditionLexicale  macro_typeConditionCaractere  public : cPtr_typeConditionCaractere (const GGS_lchar & ) ;  public : GGS_lchar  attributCaractere ;  public : virtual bool isBuilt (void) const ;} ;//---------------------------------------------------------------------------*//                                                                           *//                GALGAS class 'GGS_typeConditionCaractere'                  *//                                                                           *//---------------------------------------------------------------------------*class GGS_typeConditionCaractere {  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE    public : static cPtr_typeConditionCaractere * constructor_new (const GGS_lchar & argument_0) ;  #else    public : inline static cPtr_typeConditionCaractere * constructor_new (const GGS_lchar & argument_0) {      return new cPtr_typeConditionCaractere(argument_0) ;    }  #endif} ;//---------------------------------------------------------------------------*//                                                                           *//                     class 'typeConditionIntervalle'                       *//                                                                           *//---------------------------------------------------------------------------*#define macro_typeConditionIntervalle#define macroInheritFrom_typeConditionIntervalleclass cPtr_typeConditionIntervalle : public cPtr_typeConditionLexicale {  private : typedef cPtr_typeConditionLexicale inherited ;  macroInheritFrom_typeConditionLexicale  macro_typeConditionIntervalle  public : cPtr_typeConditionIntervalle (const GGS_lchar & ,                                const GGS_lchar & ) ;  public : GGS_lchar  attributBorneInf ;  public : GGS_lchar  attributBorneSup ;  public : virtual bool isBuilt (void) const ;} ;//---------------------------------------------------------------------------*//                                                                           *//                GALGAS class 'GGS_typeConditionIntervalle'                 *//                                                                           *//---------------------------------------------------------------------------*class GGS_typeConditionIntervalle {  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE    public : static cPtr_typeConditionIntervalle * constructor_new (const GGS_lchar & argument_0,                                const GGS_lchar & argument_1) ;  #else    public : inline static cPtr_typeConditionIntervalle * constructor_new (const GGS_lchar & argument_0,                                const GGS_lchar & argument_1) {      return new cPtr_typeConditionIntervalle(argument_0,                                argument_1) ;    }  #endif} ;#include "include_typeInstructionLexicale.h"#include "include_typeArgumentRoutineExterne.h"//---------------------------------------------------------------------------*//                                                                           *//                       class 'typeArgumentAttribut'                        *//                                                                           *//---------------------------------------------------------------------------*#define macro_typeArgumentAttribut#define macroInheritFrom_typeArgumentAttributclass cPtr_typeArgumentAttribut : public cPtr_typeArgumentRoutineExterne {  private : typedef cPtr_typeArgumentRoutineExterne inherited ;  macroInheritFrom_typeArgumentRoutineExterne  macro_typeArgumentAttribut  public : cPtr_typeArgumentAttribut (const GGS_lstring & ,                                const GGS_AC_galgasType & ) ;  public : GGS_lstring  attributNom ;  public : GGS_AC_galgasType  attributTypeAttribut ;  public : virtual bool isBuilt (void) const ;} ;//---------------------------------------------------------------------------*//                                                                           *//                 GALGAS class 'GGS_typeArgumentAttribut'                   *//                                                                           *//---------------------------------------------------------------------------*class GGS_typeArgumentAttribut {  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE    public : static cPtr_typeArgumentAttribut * constructor_new (const GGS_lstring & argument_0,                                const GGS_AC_galgasType & argument_1) ;  #else    public : inline static cPtr_typeArgumentAttribut * constructor_new (const GGS_lstring & argument_0,                                const GGS_AC_galgasType & argument_1) {      return new cPtr_typeArgumentAttribut(argument_0,                                argument_1) ;    }  #endif} ;//---------------------------------------------------------------------------*//                                                                           *//                      class 'typeArgumentCaractere'                        *//                                                                           *//---------------------------------------------------------------------------*#define macro_typeArgumentCaractere#define macroInheritFrom_typeArgumentCaractereclass cPtr_typeArgumentCaractere : public cPtr_typeArgumentRoutineExterne {  private : typedef cPtr_typeArgumentRoutineExterne inherited ;  macroInheritFrom_typeArgumentRoutineExterne  macro_typeArgumentCaractere  public : cPtr_typeArgumentCaractere (const GGS_lchar & ) ;  public : GGS_lchar  attributCaractere ;  public : virtual bool isBuilt (void) const ;} ;//---------------------------------------------------------------------------*//                                                                           *//                 GALGAS class 'GGS_typeArgumentCaractere'                  *//                                                                           *//---------------------------------------------------------------------------*class GGS_typeArgumentCaractere {  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE    public : static cPtr_typeArgumentCaractere * constructor_new (const GGS_lchar & argument_0) ;  #else    public : inline static cPtr_typeArgumentCaractere * constructor_new (const GGS_lchar & argument_0) {      return new cPtr_typeArgumentCaractere(argument_0) ;    }  #endif} ;//---------------------------------------------------------------------------*//                                                                           *//                   class 'typeArgumentCaractereCourant'                    *//                                                                           *//---------------------------------------------------------------------------*#define macro_typeArgumentCaractereCourant#define macroInheritFrom_typeArgumentCaractereCourantclass cPtr_typeArgumentCaractereCourant : public cPtr_typeArgumentRoutineExterne {  private : typedef cPtr_typeArgumentRoutineExterne inherited ;  macroInheritFrom_typeArgumentRoutineExterne  macro_typeArgumentCaractereCourant  public : virtual bool isBuilt (void) const ;} ;//---------------------------------------------------------------------------*//                                                                           *//             GALGAS class 'GGS_typeArgumentCaractereCourant'               *//                                                                           *//---------------------------------------------------------------------------*class GGS_typeArgumentCaractereCourant {  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE    public : static cPtr_typeArgumentCaractereCourant * constructor_new () ;  #else    public : inline static cPtr_typeArgumentCaractereCourant * constructor_new () {      return new cPtr_typeArgumentCaractereCourant() ;    }  #endif} ;//---------------------------------------------------------------------------*//                                                                           *//                        class 'typeArgumentEntier'                         *//                                                                           *//---------------------------------------------------------------------------*#define macro_typeArgumentEntier#define macroInheritFrom_typeArgumentEntierclass cPtr_typeArgumentEntier : public cPtr_typeArgumentRoutineExterne {  private : typedef cPtr_typeArgumentRoutineExterne inherited ;  macroInheritFrom_typeArgumentRoutineExterne  macro_typeArgumentEntier  public : cPtr_typeArgumentEntier (const GGS_luint & ) ;  public : GGS_luint  attributValeur ;  public : virtual bool isBuilt (void) const ;} ;//---------------------------------------------------------------------------*//                                                                           *//                  GALGAS class 'GGS_typeArgumentEntier'                    *//                                                                           *//---------------------------------------------------------------------------*class GGS_typeArgumentEntier {  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE    public : static cPtr_typeArgumentEntier * constructor_new (const GGS_luint & argument_0) ;  #else    public : inline static cPtr_typeArgumentEntier * constructor_new (const GGS_luint & argument_0) {      return new cPtr_typeArgumentEntier(argument_0) ;    }  #endif} ;//---------------------------------------------------------------------------*//                                                                           *//                       class 'typeArgumentRoutine'                         *//                                                                           *//---------------------------------------------------------------------------*#define macro_typeArgumentRoutine#define macroInheritFrom_typeArgumentRoutineclass cPtr_typeArgumentRoutine : public cPtr_typeArgumentRoutineExterne {  private : typedef cPtr_typeArgumentRoutineExterne inherited ;  macroInheritFrom_typeArgumentRoutineExterne  macro_typeArgumentRoutine  public : cPtr_typeArgumentRoutine (const GGS_lstring & ,                                const GGS_typeListeArgumentsRoutExterne & ) ;  public : GGS_lstring  attributNomRoutine ;  public : GGS_typeListeArgumentsRoutExterne  attributListeArguments ;  public : virtual bool isBuilt (void) const ;} ;//---------------------------------------------------------------------------*//                                                                           *//                  GALGAS class 'GGS_typeArgumentRoutine'                   *//                                                                           *//---------------------------------------------------------------------------*class GGS_typeArgumentRoutine {  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE    public : static cPtr_typeArgumentRoutine * constructor_new (const GGS_lstring & argument_0,                                const GGS_typeListeArgumentsRoutExterne & argument_1) ;  #else    public : inline static cPtr_typeArgumentRoutine * constructor_new (const GGS_lstring & argument_0,                                const GGS_typeListeArgumentsRoutExterne & argument_1) {      return new cPtr_typeArgumentRoutine(argument_0,                                argument_1) ;    }  #endif} ;#include "include_typeEmissionParDefaut.h"//---------------------------------------------------------------------------*//                                                                           *//                  class 'typeEmissionTerminalParDefaut'                    *//                                                                           *//---------------------------------------------------------------------------*#define macro_typeEmissionTerminalParDefaut#define macroInheritFrom_typeEmissionTerminalParDefautclass cPtr_typeEmissionTerminalParDefaut : public cPtr_typeEmissionParDefaut {  private : typedef cPtr_typeEmissionParDefaut inherited ;  macroInheritFrom_typeEmissionParDefaut  macro_typeEmissionTerminalParDefaut  public : cPtr_typeEmissionTerminalParDefaut (const GGS_lstring & ) ;  public : GGS_lstring  attributNomTerminal ;  public : virtual bool isBuilt (void) const ;} ;//---------------------------------------------------------------------------*//                                                                           *//             GALGAS class 'GGS_typeEmissionTerminalParDefaut'              *//                                                                           *//---------------------------------------------------------------------------*class GGS_typeEmissionTerminalParDefaut {  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE    public : static cPtr_typeEmissionTerminalParDefaut * constructor_new (const GGS_lstring & argument_0) ;  #else    public : inline static cPtr_typeEmissionTerminalParDefaut * constructor_new (const GGS_lstring & argument_0) {      return new cPtr_typeEmissionTerminalParDefaut(argument_0) ;    }  #endif} ;//---------------------------------------------------------------------------*//                                                                           *//                   class 'typeEmissionErreurParDefaut'                     *//                                                                           *//---------------------------------------------------------------------------*#define macro_typeEmissionErreurParDefaut#define macroInheritFrom_typeEmissionErreurParDefautclass cPtr_typeEmissionErreurParDefaut : public cPtr_typeEmissionParDefaut {  private : typedef cPtr_typeEmissionParDefaut inherited ;  macroInheritFrom_typeEmissionParDefaut  macro_typeEmissionErreurParDefaut  public : cPtr_typeEmissionErreurParDefaut (const GGS_luint & ) ;  public : GGS_luint  mErrorMessageIndex ;  public : virtual bool isBuilt (void) const ;} ;//---------------------------------------------------------------------------*//                                                                           *//              GALGAS class 'GGS_typeEmissionErreurParDefaut'               *//                                                                           *//---------------------------------------------------------------------------*class GGS_typeEmissionErreurParDefaut {  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE    public : static cPtr_typeEmissionErreurParDefaut * constructor_new (const GGS_luint & argument_0) ;  #else    public : inline static cPtr_typeEmissionErreurParDefaut * constructor_new (const GGS_luint & argument_0) {      return new cPtr_typeEmissionErreurParDefaut(argument_0) ;    }  #endif} ;//---------------------------------------------------------------------------*//                                                                           *//                   class 'typeInstructionActionExterne'                    *//                                                                           *//---------------------------------------------------------------------------*#define macro_typeInstructionActionExterne#define macroInheritFrom_typeInstructionActionExterneclass cPtr_typeInstructionActionExterne : public cPtr_typeInstructionLexicale {  private : typedef cPtr_typeInstructionLexicale inherited ;  macroInheritFrom_typeInstructionLexicale  macro_typeInstructionActionExterne  public : cPtr_typeInstructionActionExterne (const GGS_lstring & ,                                const GGS_typeListeArgumentsRoutExterne & ,                                const GGS_typeListeMessagesErreur & ) ;  public : GGS_lstring  attributNomRoutineExterne ;  public : GGS_typeListeArgumentsRoutExterne  attributListeArguments ;  public : GGS_typeListeMessagesErreur  attributListeMessageErreur ;  public : virtual bool isBuilt (void) const ;} ;//---------------------------------------------------------------------------*//                                                                           *//             GALGAS class 'GGS_typeInstructionActionExterne'               *//                                                                           *//---------------------------------------------------------------------------*class GGS_typeInstructionActionExterne {  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE    public : static cPtr_typeInstructionActionExterne * constructor_new (const GGS_lstring & argument_0,                                const GGS_typeListeArgumentsRoutExterne & argument_1,                                const GGS_typeListeMessagesErreur & argument_2) ;  #else    public : inline static cPtr_typeInstructionActionExterne * constructor_new (const GGS_lstring & argument_0,                                const GGS_typeListeArgumentsRoutExterne & argument_1,                                const GGS_typeListeMessagesErreur & argument_2) {      return new cPtr_typeInstructionActionExterne(argument_0,                                argument_1,                                argument_2) ;    }  #endif} ;//---------------------------------------------------------------------------*//                                                                           *//                class 'typeInstructionRepetitionLexicale'                  *//                                                                           *//---------------------------------------------------------------------------*#define macro_typeInstructionRepetitionLexicale#define macroInheritFrom_typeInstructionRepetitionLexicaleclass cPtr_typeInstructionRepetitionLexicale : public cPtr_typeInstructionLexicale {  private : typedef cPtr_typeInstructionLexicale inherited ;  macroInheritFrom_typeInstructionLexicale  macro_typeInstructionRepetitionLexicale  public : cPtr_typeInstructionRepetitionLexicale (const GGS_tListeInstructionsLexicales & ,                                const GGS_typeListeTestsEtInstructions & ) ;  public : GGS_tListeInstructionsLexicales  attributListeInstructionsDebut ;  public : GGS_typeListeTestsEtInstructions  attributListeBranches ;  public : virtual bool isBuilt (void) const ;} ;//---------------------------------------------------------------------------*//                                                                           *//           GALGAS class 'GGS_typeInstructionRepetitionLexicale'            *//                                                                           *//---------------------------------------------------------------------------*class GGS_typeInstructionRepetitionLexicale {  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE    public : static cPtr_typeInstructionRepetitionLexicale * constructor_new (const GGS_tListeInstructionsLexicales & argument_0,                                const GGS_typeListeTestsEtInstructions & argument_1) ;  #else    public : inline static cPtr_typeInstructionRepetitionLexicale * constructor_new (const GGS_tListeInstructionsLexicales & argument_0,                                const GGS_typeListeTestsEtInstructions & argument_1) {      return new cPtr_typeInstructionRepetitionLexicale(argument_0,                                argument_1) ;    }  #endif} ;//---------------------------------------------------------------------------*//                                                                           *//                     class 'typeInstructionSiLexical'                      *//                                                                           *//---------------------------------------------------------------------------*#define macro_typeInstructionSiLexical#define macroInheritFrom_typeInstructionSiLexicalclass cPtr_typeInstructionSiLexical : public cPtr_typeInstructionLexicale {  private : typedef cPtr_typeInstructionLexicale inherited ;  macroInheritFrom_typeInstructionLexicale  macro_typeInstructionSiLexical  public : cPtr_typeInstructionSiLexical (const GGS_typeListeTestsEtInstructions & ,                                const GGS_tListeInstructionsLexicales & ) ;  public : GGS_typeListeTestsEtInstructions  attributListeBranches ;  public : GGS_tListeInstructionsLexicales  attributBrancheSinon ;  public : virtual bool isBuilt (void) const ;} ;//---------------------------------------------------------------------------*//                                                                           *//               GALGAS class 'GGS_typeInstructionSiLexical'                 *//                                                                           *//---------------------------------------------------------------------------*class GGS_typeInstructionSiLexical {  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE    public : static cPtr_typeInstructionSiLexical * constructor_new (const GGS_typeListeTestsEtInstructions & argument_0,                                const GGS_tListeInstructionsLexicales & argument_1) ;  #else    public : inline static cPtr_typeInstructionSiLexical * constructor_new (const GGS_typeListeTestsEtInstructions & argument_0,                                const GGS_tListeInstructionsLexicales & argument_1) {      return new cPtr_typeInstructionSiLexical(argument_0,                                argument_1) ;    }  #endif} ;//---------------------------------------------------------------------------*//                                                                           *//                   class 'typeInstructionEmettreSimple'                    *//                                                                           *//---------------------------------------------------------------------------*#define macro_typeInstructionEmettreSimple#define macroInheritFrom_typeInstructionEmettreSimpleclass cPtr_typeInstructionEmettreSimple : public cPtr_typeInstructionLexicale {  private : typedef cPtr_typeInstructionLexicale inherited ;  macroInheritFrom_typeInstructionLexicale  macro_typeInstructionEmettreSimple  public : cPtr_typeInstructionEmettreSimple (const GGS_lstring & ) ;  public : GGS_lstring  attributTerminal ;  public : virtual bool isBuilt (void) const ;} ;//---------------------------------------------------------------------------*//                                                                           *//             GALGAS class 'GGS_typeInstructionEmettreSimple'               *//                                                                           *//---------------------------------------------------------------------------*class GGS_typeInstructionEmettreSimple {  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE    public : static cPtr_typeInstructionEmettreSimple * constructor_new (const GGS_lstring & argument_0) ;  #else    public : inline static cPtr_typeInstructionEmettreSimple * constructor_new (const GGS_lstring & argument_0) {      return new cPtr_typeInstructionEmettreSimple(argument_0) ;    }  #endif} ;//---------------------------------------------------------------------------*//                                                                           *//                      class 'typeInstructionEmettre'                       *//                                                                           *//---------------------------------------------------------------------------*#define macro_typeInstructionEmettre#define macroInheritFrom_typeInstructionEmettreclass cPtr_typeInstructionEmettre : public cPtr_typeInstructionLexicale {  private : typedef cPtr_typeInstructionLexicale inherited ;  macroInheritFrom_typeInstructionLexicale  macro_typeInstructionEmettre  public : cPtr_typeInstructionEmettre (const GGS_typeListeRecherche & ,                                const GGS_typeEmissionParDefaut & ) ;  public : GGS_typeListeRecherche  attributListeRecherches ;  public : GGS_typeEmissionParDefaut  attributEmissionParDefaut ;  public : virtual bool isBuilt (void) const ;} ;//---------------------------------------------------------------------------*//                                                                           *//                GALGAS class 'GGS_typeInstructionEmettre'                  *//                                                                           *//---------------------------------------------------------------------------*class GGS_typeInstructionEmettre {  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE    public : static cPtr_typeInstructionEmettre * constructor_new (const GGS_typeListeRecherche & argument_0,                                const GGS_typeEmissionParDefaut & argument_1) ;  #else    public : inline static cPtr_typeInstructionEmettre * constructor_new (const GGS_typeListeRecherche & argument_0,                                const GGS_typeEmissionParDefaut & argument_1) {      return new cPtr_typeInstructionEmettre(argument_0,                                argument_1) ;    }  #endif} ;//---------------------------------------------------------------------------*//                                                                           *//                  class 'typeInstructionErreurLexicale'                    *//                                                                           *//---------------------------------------------------------------------------*#define macro_typeInstructionErreurLexicale#define macroInheritFrom_typeInstructionErreurLexicaleclass cPtr_typeInstructionErreurLexicale : public cPtr_typeInstructionLexicale {  private : typedef cPtr_typeInstructionLexicale inherited ;  macroInheritFrom_typeInstructionLexicale  macro_typeInstructionErreurLexicale  public : cPtr_typeInstructionErreurLexicale (const GGS_luint & ) ;  public : GGS_luint  mErrorMessageIndex ;  public : virtual bool isBuilt (void) const ;} ;//---------------------------------------------------------------------------*//                                                                           *//             GALGAS class 'GGS_typeInstructionErreurLexicale'              *//                                                                           *//---------------------------------------------------------------------------*class GGS_typeInstructionErreurLexicale {  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE    public : static cPtr_typeInstructionErreurLexicale * constructor_new (const GGS_luint & argument_0) ;  #else    public : inline static cPtr_typeInstructionErreurLexicale * constructor_new (const GGS_luint & argument_0) {      return new cPtr_typeInstructionErreurLexicale(argument_0) ;    }  #endif} ;#include "include_typeInclusion.h"//---------------------------------------------------------------------------*//                                                                           *//                     class 'typeInclusionUtilisateur'                      *//                                                                           *//---------------------------------------------------------------------------*#define macro_typeInclusionUtilisateur#define macroInheritFrom_typeInclusionUtilisateurclass cPtr_typeInclusionUtilisateur : public cPtr_typeInclusion {  private : typedef cPtr_typeInclusion inherited ;  macroInheritFrom_typeInclusion  macro_typeInclusionUtilisateur  public : cPtr_typeInclusionUtilisateur (const GGS_lstring & ) ;  public : GGS_lstring  attributNomFichierInclus ;  public : virtual bool isBuilt (void) const ;} ;//---------------------------------------------------------------------------*//                                                                           *//               GALGAS class 'GGS_typeInclusionUtilisateur'                 *//                                                                           *//---------------------------------------------------------------------------*class GGS_typeInclusionUtilisateur {  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE    public : static cPtr_typeInclusionUtilisateur * constructor_new (const GGS_lstring & argument_0) ;  #else    public : inline static cPtr_typeInclusionUtilisateur * constructor_new (const GGS_lstring & argument_0) {      return new cPtr_typeInclusionUtilisateur(argument_0) ;    }  #endif} ;//---------------------------------------------------------------------------*//                                                                           *//                       class 'typeInclusionSysteme'                        *//                                                                           *//---------------------------------------------------------------------------*#define macro_typeInclusionSysteme#define macroInheritFrom_typeInclusionSystemeclass cPtr_typeInclusionSysteme : public cPtr_typeInclusion {  private : typedef cPtr_typeInclusion inherited ;  macroInheritFrom_typeInclusion  macro_typeInclusionSysteme  public : cPtr_typeInclusionSysteme (const GGS_lstring & ) ;  public : GGS_lstring  attributNomFichierInclus ;  public : virtual bool isBuilt (void) const ;} ;//---------------------------------------------------------------------------*//                                                                           *//                 GALGAS class 'GGS_typeInclusionSysteme'                   *//                                                                           *//---------------------------------------------------------------------------*class GGS_typeInclusionSysteme {  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE    public : static cPtr_typeInclusionSysteme * constructor_new (const GGS_lstring & argument_0) ;  #else    public : inline static cPtr_typeInclusionSysteme * constructor_new (const GGS_lstring & argument_0) {      return new cPtr_typeInclusionSysteme(argument_0) ;    }  #endif} ;//---------------------------------------------------------------------------*#endif