//---------------------------------------------------------------------------*
//                                                                           *
//                        File 'grammar_semantics.h'                         *
//               Generated by version 0.14.1 (LL(1) grammar)                 *
//                     february 2nd, 2005, at 19h33'46"                      *
//                                                                           *
// This program is free software; you can redistribute it and/or modify it   *
// under the terms of the GNU General Public License as published by the     *
// Free Software Foundation.                                                 *
//                                                                           *
// This program is distributed in the hope it will be useful, but WITHOUT    *
// ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or     *
// FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for  *
// more details.                                                             *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

#ifndef grammar_semantics_DEFINED
#define grammar_semantics_DEFINED

#include <string.h>

// Include predefined semantics types definition *
#include "memory/C_reference_count.h"
#include "galgas/AC_galgas_io.h"
#include "galgas/GGS_location.h"
#include "galgas/GGS_lbool.h"
#include "galgas/GGS_lchar.h"
#include "galgas/GGS_lstring.h"
#include "galgas/GGS_ldfloat.h"
#include "galgas/GGS_luint.h"
#include "galgas/GGS_lsint.h"
#include "galgas/AC_galgas_map.h"
// Include scanner definition *
#include "galgas/C_lexique.h"
// Include imported semantics *
#include "common_semantics.h"


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                  class list 'typeListeAttributsAxiome'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeListeAttributsAxiome {
  public : class element_type {
    private : element_type * mNextItem ;
    public : GGS_lstring  aAttributAxiome ;
    public : element_type (const GGS_lstring & ) ;

    public : inline element_type * getNextItem (void) const { return mNextItem ; }
    private : element_type (const element_type &) ;
    private : void operator = (const element_type &) ;
    public : ~element_type (void) {}
    friend class GGS_typeListeAttributsAxiome ;
  } ;

  private : element_type * mFirstItem ;
  private : element_type * mLastItem ;
  private : element_type * mCurrentItemPtr ;
  private : sint32 mCurrentItemIndex ;
  private : sint32 mListLength ;
  public : inline sint32 getCount (void) const {
    return mListLength ;
  }
  private : sint32 * mCountReference ;
  public : GGS_typeListeAttributsAxiome (void) ; // Default Constructor
  public : GGS_typeListeAttributsAxiome (const GGS_typeListeAttributsAxiome &) ; // Copy constructor
  public : void operator = (const GGS_typeListeAttributsAxiome &) ; // Assignment operator
//--- Virtual destructor
  public : virtual ~GGS_typeListeAttributsAxiome (void) ;

//--- Constructor 'new'
  public : static GGS_typeListeAttributsAxiome constructor_empty (void) ;
//--- Get first item
  public : inline element_type * getFirstItem (void) const { return mFirstItem ; }
  public : void addAssign_operation (const GGS_lstring & argument_0) ;
  protected : void internalAppendItem (const GGS_lstring & argument_0) ;
  public : void insulateList (void) ;
  public : void emptyList (void) ;
  public : inline bool isBuilt (void) const {
    return mCountReference != NULL ;
  }
  public : void drop_operation (void) ;
  public : inline GGS_uint reader_length (void)  const {
    return GGS_uint (mCountReference != NULL, (uint32) mListLength) ;
  }
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class list 'typeListeChaines'                        *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeListeChaines {
  public : class element_type {
    private : element_type * mNextItem ;
    public : GGS_lstring  attributChaine ;
    public : element_type (const GGS_lstring & ) ;

    public : inline element_type * getNextItem (void) const { return mNextItem ; }
    private : element_type (const element_type &) ;
    private : void operator = (const element_type &) ;
    public : ~element_type (void) {}
    friend class GGS_typeListeChaines ;
  } ;

  private : element_type * mFirstItem ;
  private : element_type * mLastItem ;
  private : element_type * mCurrentItemPtr ;
  private : sint32 mCurrentItemIndex ;
  private : sint32 mListLength ;
  public : inline sint32 getCount (void) const {
    return mListLength ;
  }
  private : sint32 * mCountReference ;
  public : GGS_typeListeChaines (void) ; // Default Constructor
  public : GGS_typeListeChaines (const GGS_typeListeChaines &) ; // Copy constructor
  public : void operator = (const GGS_typeListeChaines &) ; // Assignment operator
//--- Virtual destructor
  public : virtual ~GGS_typeListeChaines (void) ;

//--- Constructor 'new'
  public : static GGS_typeListeChaines constructor_empty (void) ;
//--- Get first item
  public : inline element_type * getFirstItem (void) const { return mFirstItem ; }
  public : void addAssign_operation (const GGS_lstring & argument_0) ;
  protected : void internalAppendItem (const GGS_lstring & argument_0) ;
  public : void insulateList (void) ;
  public : void emptyList (void) ;
  public : inline bool isBuilt (void) const {
    return mCountReference != NULL ;
  }
  public : void drop_operation (void) ;
  public : inline GGS_uint reader_length (void)  const {
    return GGS_uint (mCountReference != NULL, (uint32) mListLength) ;
  }
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                class list 'L_grammarDescriptorForProgram'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_L_grammarDescriptorForProgram {
  public : class element_type {
    private : element_type * mNextItem ;
    public : GGS_lstring  mGrammarName ;
    public : GGS_L_signature_ForGrammarComponent  mStartSymbolSignature ;
    public : GGS_typeListeAttributsAxiome  mStartSymbolAttributesList ;
    public : GGS_bool mIncludeHeader ;
    public : GGS_lstring  mLexiqueClassName ;
    public : element_type (const GGS_lstring & ,
                                const GGS_L_signature_ForGrammarComponent & ,
                                const GGS_typeListeAttributsAxiome & ,
                                const GGS_bool& ,
                                const GGS_lstring & ) ;

    public : inline element_type * getNextItem (void) const { return mNextItem ; }
    private : element_type (const element_type &) ;
    private : void operator = (const element_type &) ;
    public : ~element_type (void) {}
    friend class GGS_L_grammarDescriptorForProgram ;
  } ;

  private : element_type * mFirstItem ;
  private : element_type * mLastItem ;
  private : element_type * mCurrentItemPtr ;
  private : sint32 mCurrentItemIndex ;
  private : sint32 mListLength ;
  public : inline sint32 getCount (void) const {
    return mListLength ;
  }
  private : sint32 * mCountReference ;
  public : GGS_L_grammarDescriptorForProgram (void) ; // Default Constructor
  public : GGS_L_grammarDescriptorForProgram (const GGS_L_grammarDescriptorForProgram &) ; // Copy constructor
  public : void operator = (const GGS_L_grammarDescriptorForProgram &) ; // Assignment operator
//--- Virtual destructor
  public : virtual ~GGS_L_grammarDescriptorForProgram (void) ;

//--- Constructor 'new'
  public : static GGS_L_grammarDescriptorForProgram constructor_empty (void) ;
//--- Get first item
  public : inline element_type * getFirstItem (void) const { return mFirstItem ; }
  public : void addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_L_signature_ForGrammarComponent & argument_1,
                                const GGS_typeListeAttributsAxiome & argument_2,
                                const GGS_bool& argument_3,
                                const GGS_lstring & argument_4) ;
  protected : void internalAppendItem (const GGS_lstring & argument_0,
                                const GGS_L_signature_ForGrammarComponent & argument_1,
                                const GGS_typeListeAttributsAxiome & argument_2,
                                const GGS_bool& argument_3,
                                const GGS_lstring & argument_4) ;
  public : void insulateList (void) ;
  public : void emptyList (void) ;
  public : inline bool isBuilt (void) const {
    return mCountReference != NULL ;
  }
  public : void drop_operation (void) ;
  public : inline GGS_uint reader_length (void)  const {
    return GGS_uint (mCountReference != NULL, (uint32) mListLength) ;
  }
} ;

//---------------------------------------------------------------------------*

#endif
