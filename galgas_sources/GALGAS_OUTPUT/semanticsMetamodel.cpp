//---------------------------------------------------------------------------*
//                                                                           *
//                      File 'semanticsMetamodel.cpp'                        *
//         Generated by version GALGAS_BETA_VERSION (LL(1) grammar)          *
//                       may 17th, 2007, at 20h23'49"                        *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

#include "semanticsMetamodel.h"
#include "utilities/MF_MemoryControl.h"

//---------------------------------------------------------------------------*

#include <typeinfo>

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "semanticsMetamodel.gMetamodel", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif

//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                           Metamodel Management                            *
//                                                                           *
//---------------------------------------------------------------------------*

static C_MetamodelManager gMetamodelManager ;

//---------------------------------------------------------------------------*

uint32 _metamodel_index_for_semanticsMetamodel (void) {
  return gMetamodelManager.mMetamodelIndex ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@semanticsComponentRootList'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_semanticsComponentRoot::
cPtr_semanticsComponentRoot (const GGS_lstring & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_semanticDeclarationList & argument_2
                                COMMA_LOCATION_ARGS) :
C_GGS_MetamodelEntity (THERE),
mSemanticsComponentName (argument_0),
mImportedComponentFileNameList (argument_1),
mSemanticDeclarationList (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_semanticsComponentRoot::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_semanticsComponentRoot * _p = dynamic_cast <const cPtr_semanticsComponentRoot *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mSemanticsComponentName._operator_isEqual (_p->mSemanticsComponentName).boolValue ()
         && mImportedComponentFileNameList._operator_isEqual (_p->mImportedComponentFileNameList).boolValue ()
         && mSemanticDeclarationList._operator_isEqual (_p->mSemanticDeclarationList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_semanticsComponentRoot::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @semanticsComponentRoot" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSemanticsComponentName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mImportedComponentFileNameList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSemanticDeclarationList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_semanticsComponentRoot::_metamodelIndex (void) const {
  return gMetamodelManager.mMetamodelIndex ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_semanticsComponentRoot::_metamodelClassID (void) const {
  return 0 ;
}

//---------------------------------------------------------------------------*

cPtr_semanticsComponentRoot * cPtr_semanticsComponentRoot::
_cloneObject (void) const {
  cPtr_semanticsComponentRoot * _p = NULL ;
  macroMyNew (_p, cPtr_semanticsComponentRoot (mSemanticsComponentName, mImportedComponentFileNameList, mSemanticDeclarationList COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@semanticsComponentRootList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_semanticsComponentRootList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstringlist & argument_1,
                    const GGS_semanticDeclarationList & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticsComponentRootList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstringlist & argument_1,
                    const GGS_semanticDeclarationList & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticsComponentRootList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_semanticDeclarationList & argument_2) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

GGS_semanticsComponentRootList GGS_semanticsComponentRootList::
_operator_concat (const GGS_semanticsComponentRootList & inOperand) const {
  GGS_semanticsComponentRootList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_semanticsComponentRoot * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mSemanticsComponentName ;
          GGS_lstringlist  p_1 = p->mImportedComponentFileNameList ;
          GGS_semanticDeclarationList  p_2 = p->mSemanticDeclarationList ;
          result._internalAppendValues (p_0, p_1, p_2) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_semanticsComponentRootList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstringlist & argument_1,
                     const GGS_semanticDeclarationList & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticsComponentRootList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mSemanticsComponentName,
                                _p->mImportedComponentFileNameList,
                                _p->mSemanticDeclarationList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_semanticsComponentRootList  GGS_semanticsComponentRootList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_semanticsComponentRootList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticsComponentRootList  GGS_semanticsComponentRootList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_lstringlist & argument_1,
                           const GGS_semanticDeclarationList & argument_2
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_semanticsComponentRootList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_semanticsComponentRootList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@semanticsComponentRootList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticsComponentRootList::
_addModel (const GGS_semanticsComponentRoot & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticsComponentRootList::
method_first (C_Compiler & _inLexique,
              GGS_lstring & _out_0,
              GGS_lstringlist & _out_1,
              GGS_semanticDeclarationList & _out_2
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mSemanticsComponentName ;
    _out_1 = _p->mImportedComponentFileNameList ;
    _out_2 = _p->mSemanticDeclarationList ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticsComponentRootList::
method_last (C_Compiler & _inLexique,
             GGS_lstring & _out_0,
             GGS_lstringlist & _out_1,
             GGS_semanticDeclarationList & _out_2
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mSemanticsComponentName ;
    _out_1 = _p->mImportedComponentFileNameList ;
    _out_2 = _p->mSemanticDeclarationList ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticsComponentRootList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstringlist & _out_1,
                 GGS_semanticDeclarationList & _out_2
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mSemanticsComponentName ;
    _out_1 = _p->mImportedComponentFileNameList ;
    _out_2 = _p->mSemanticDeclarationList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticsComponentRootList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lstring & _out_0,
                GGS_lstringlist & _out_1,
                GGS_semanticDeclarationList & _out_2
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mSemanticsComponentName ;
    _out_1 = _p->mImportedComponentFileNameList ;
    _out_2 = _p->mSemanticDeclarationList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_semanticsComponentRoot'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_semanticsComponentRoot GGS_semanticsComponentRoot::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstringlist & argument_1,
                 const GGS_semanticDeclarationList & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_semanticsComponentRoot result ;
  macroMyNew (result.mPointer, cPtr_semanticsComponentRoot (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_semanticsComponentRoot::
reader_mSemanticsComponentName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_semanticsComponentRoot *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_semanticsComponentRoot *) mPointer)->mSemanticsComponentName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_semanticsComponentRoot::
reader_mImportedComponentFileNameList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_semanticsComponentRoot *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_semanticsComponentRoot *) mPointer)->mImportedComponentFileNameList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationList  GGS_semanticsComponentRoot::
reader_mSemanticDeclarationList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticDeclarationList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_semanticsComponentRoot *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_semanticsComponentRoot *) mPointer)->mSemanticDeclarationList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_semanticsComponentRoot::actualTypeName (void) const {
 return "semanticsComponentRoot" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_semanticsComponentRoot * GGS_semanticsComponentRoot::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_semanticsComponentRoot *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@semanticDeclarationList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_semanticDeclaration::
cPtr_semanticDeclaration (LOCATION_ARGS) :
C_GGS_MetamodelEntity (THERE) {
}

//---------------------------------------------------------------------------*

bool cPtr_semanticDeclaration::
isEqualToObject (const cListElement * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

void cPtr_semanticDeclaration::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "-> instance of @semanticDeclaration" ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_semanticDeclaration::_metamodelIndex (void) const {
  return gMetamodelManager.mMetamodelIndex ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_semanticDeclaration::_metamodelClassID (void) const {
  return 1 ;
}

//---------------------------------------------------------------------------*

cPtr_semanticDeclaration * cPtr_semanticDeclaration::
_cloneObject (void) const {
  cPtr_semanticDeclaration * _p = NULL ;
  macroMyNew (_p, cPtr_semanticDeclaration (HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@semanticDeclarationList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_semanticDeclarationList::
_internalAppendValues () {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationList::
_internalPrependValues () {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationList::
_addAssign_operation () {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues () ;
  }
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationList GGS_semanticDeclarationList::
_operator_concat (const GGS_semanticDeclarationList & inOperand) const {
  GGS_semanticDeclarationList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_semanticDeclaration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          result._internalAppendValues () ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationList::
modifier_prependValue (C_Compiler & /* inLexique */
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues () ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationList  GGS_semanticDeclarationList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_semanticDeclarationList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationList  GGS_semanticDeclarationList::
constructor_listWithValue (C_Compiler & /* _inLexique */
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_semanticDeclarationList result ;
  result._alloc () ;
  result._addAssign_operation () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_semanticDeclarationList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@semanticDeclarationList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationList::
_addModel (const GGS_semanticDeclaration & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationList::
method_first (C_Compiler & _inLexique
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
  }else{
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationList::
method_last (C_Compiler & _inLexique
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
  }else{
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationList::
modifier_popFirst (C_Compiler & _inLexique
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationList::
modifier_popLast (C_Compiler & _inLexique
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_semanticDeclaration'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const char * GGS_semanticDeclaration::actualTypeName (void) const {
 return "semanticDeclaration" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_semanticDeclaration * GGS_semanticDeclaration::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_semanticDeclaration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@structuredTypeAttributeList'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_structuredTypeAttribute::
cPtr_structuredTypeAttribute (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
C_GGS_MetamodelEntity (THERE),
mAttributeTypeName (argument_0),
mAttributeName (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_structuredTypeAttribute::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_structuredTypeAttribute * _p = dynamic_cast <const cPtr_structuredTypeAttribute *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mAttributeTypeName._operator_isEqual (_p->mAttributeTypeName).boolValue ()
         && mAttributeName._operator_isEqual (_p->mAttributeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_structuredTypeAttribute::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @structuredTypeAttribute" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAttributeTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAttributeName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_structuredTypeAttribute::_metamodelIndex (void) const {
  return gMetamodelManager.mMetamodelIndex ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_structuredTypeAttribute::_metamodelClassID (void) const {
  return 2 ;
}

//---------------------------------------------------------------------------*

cPtr_structuredTypeAttribute * cPtr_structuredTypeAttribute::
_cloneObject (void) const {
  cPtr_structuredTypeAttribute * _p = NULL ;
  macroMyNew (_p, cPtr_structuredTypeAttribute (mAttributeTypeName, mAttributeName COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@structuredTypeAttributeList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_structuredTypeAttributeList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_structuredTypeAttributeList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_structuredTypeAttributeList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

GGS_structuredTypeAttributeList GGS_structuredTypeAttributeList::
_operator_concat (const GGS_structuredTypeAttributeList & inOperand) const {
  GGS_structuredTypeAttributeList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_structuredTypeAttribute * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mAttributeTypeName ;
          GGS_lstring  p_1 = p->mAttributeName ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_structuredTypeAttributeList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_structuredTypeAttributeList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mAttributeTypeName,
                                _p->mAttributeName) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_structuredTypeAttributeList  GGS_structuredTypeAttributeList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_structuredTypeAttributeList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_structuredTypeAttributeList  GGS_structuredTypeAttributeList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_lstring & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_structuredTypeAttributeList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_structuredTypeAttributeList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@structuredTypeAttributeList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_structuredTypeAttributeList::
_addModel (const GGS_structuredTypeAttribute & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_structuredTypeAttributeList::
method_first (C_Compiler & _inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mAttributeTypeName ;
    _out_1 = _p->mAttributeName ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_structuredTypeAttributeList::
method_last (C_Compiler & _inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mAttributeTypeName ;
    _out_1 = _p->mAttributeName ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_structuredTypeAttributeList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mAttributeTypeName ;
    _out_1 = _p->mAttributeName ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_structuredTypeAttributeList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mAttributeTypeName ;
    _out_1 = _p->mAttributeName ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_structuredTypeAttribute'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_structuredTypeAttribute GGS_structuredTypeAttribute::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_structuredTypeAttribute result ;
  macroMyNew (result.mPointer, cPtr_structuredTypeAttribute (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_structuredTypeAttribute::
reader_mAttributeTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_structuredTypeAttribute *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_structuredTypeAttribute *) mPointer)->mAttributeTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_structuredTypeAttribute::
reader_mAttributeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_structuredTypeAttribute *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_structuredTypeAttribute *) mPointer)->mAttributeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_structuredTypeAttribute::actualTypeName (void) const {
 return "structuredTypeAttribute" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_structuredTypeAttribute * GGS_structuredTypeAttribute::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_structuredTypeAttribute *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@formalParametersList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_formalParameters::
cPtr_formalParameters (const GGS_formalParameterList & argument_0
                                COMMA_LOCATION_ARGS) :
C_GGS_MetamodelEntity (THERE),
mFormalParameterList (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_formalParameters::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_formalParameters * _p = dynamic_cast <const cPtr_formalParameters *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mFormalParameterList._operator_isEqual (_p->mFormalParameterList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_formalParameters::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @formalParameters" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFormalParameterList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_formalParameters::_metamodelIndex (void) const {
  return gMetamodelManager.mMetamodelIndex ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_formalParameters::_metamodelClassID (void) const {
  return 3 ;
}

//---------------------------------------------------------------------------*

cPtr_formalParameters * cPtr_formalParameters::
_cloneObject (void) const {
  cPtr_formalParameters * _p = NULL ;
  macroMyNew (_p, cPtr_formalParameters (mFormalParameterList COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@formalParametersList'                        *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_formalParametersList::
_internalAppendValues (const GGS_formalParameterList & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_formalParametersList::
_internalPrependValues (const GGS_formalParameterList & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_formalParametersList::
_addAssign_operation (const GGS_formalParameterList & argument_0) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

GGS_formalParametersList GGS_formalParametersList::
_operator_concat (const GGS_formalParametersList & inOperand) const {
  GGS_formalParametersList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_formalParameters * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_formalParameterList  p_0 = p->mFormalParameterList ;
          result._internalAppendValues (p_0) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_formalParametersList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_formalParameterList & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_formalParametersList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mFormalParameterList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_formalParametersList  GGS_formalParametersList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_formalParametersList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParametersList  GGS_formalParametersList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_formalParameterList & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_formalParametersList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_formalParametersList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@formalParametersList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_formalParametersList::
_addModel (const GGS_formalParameters & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_formalParametersList::
method_first (C_Compiler & _inLexique,
              GGS_formalParameterList & _out_0
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mFormalParameterList ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_formalParametersList::
method_last (C_Compiler & _inLexique,
             GGS_formalParameterList & _out_0
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mFormalParameterList ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_formalParametersList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_formalParameterList & _out_0
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mFormalParameterList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_formalParametersList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_formalParameterList & _out_0
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mFormalParameterList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_formalParameters'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_formalParameters GGS_formalParameters::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_formalParameterList & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_formalParameters result ;
  macroMyNew (result.mPointer, cPtr_formalParameters (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameterList  GGS_formalParameters::
reader_mFormalParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_formalParameterList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_formalParameters *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_formalParameters *) mPointer)->mFormalParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_formalParameters::actualTypeName (void) const {
 return "formalParameters" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_formalParameters * GGS_formalParameters::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_formalParameters *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@formalParameterList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_formalParameter::
cPtr_formalParameter (const GGS_formalArgumentPassingMode& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_bool& argument_3
                                COMMA_LOCATION_ARGS) :
C_GGS_MetamodelEntity (THERE),
mFormalParameterPassingMode (argument_0),
mFormalParameterTypeName (argument_1),
mFormalParameterName (argument_2),
mIsUnused (argument_3) {
}

//---------------------------------------------------------------------------*

bool cPtr_formalParameter::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_formalParameter * _p = dynamic_cast <const cPtr_formalParameter *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mFormalParameterPassingMode._operator_isEqual (_p->mFormalParameterPassingMode).boolValue ()
         && mFormalParameterTypeName._operator_isEqual (_p->mFormalParameterTypeName).boolValue ()
         && mFormalParameterName._operator_isEqual (_p->mFormalParameterName).boolValue ()
         && mIsUnused._operator_isEqual (_p->mIsUnused).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_formalParameter::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @formalParameter" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFormalParameterPassingMode.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFormalParameterTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFormalParameterName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mIsUnused.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_formalParameter::_metamodelIndex (void) const {
  return gMetamodelManager.mMetamodelIndex ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_formalParameter::_metamodelClassID (void) const {
  return 4 ;
}

//---------------------------------------------------------------------------*

cPtr_formalParameter * cPtr_formalParameter::
_cloneObject (void) const {
  cPtr_formalParameter * _p = NULL ;
  macroMyNew (_p, cPtr_formalParameter (mFormalParameterPassingMode, mFormalParameterTypeName, mFormalParameterName, mIsUnused COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@formalParameterList'                         *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_formalParameterList::
_internalAppendValues (const GGS_formalArgumentPassingMode& argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_bool& argument_3) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_formalParameterList::
_internalPrependValues (const GGS_formalArgumentPassingMode& argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_bool& argument_3) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_formalParameterList::
_addAssign_operation (const GGS_formalArgumentPassingMode& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_bool& argument_3) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3) ;
  }
}

//---------------------------------------------------------------------------*

GGS_formalParameterList GGS_formalParameterList::
_operator_concat (const GGS_formalParameterList & inOperand) const {
  GGS_formalParameterList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_formalParameter * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_formalArgumentPassingMode p_0 = p->mFormalParameterPassingMode ;
          GGS_lstring  p_1 = p->mFormalParameterTypeName ;
          GGS_lstring  p_2 = p->mFormalParameterName ;
          GGS_bool p_3 = p->mIsUnused ;
          result._internalAppendValues (p_0, p_1, p_2, p_3) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_formalParameterList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_formalArgumentPassingMode& argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_lstring & argument_2,
                     const GGS_bool& argument_3
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_formalParameterList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mFormalParameterPassingMode,
                                _p->mFormalParameterTypeName,
                                _p->mFormalParameterName,
                                _p->mIsUnused) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_formalParameterList  GGS_formalParameterList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_formalParameterList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameterList  GGS_formalParameterList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_formalArgumentPassingMode& argument_0,
                           const GGS_lstring & argument_1,
                           const GGS_lstring & argument_2,
                           const GGS_bool& argument_3
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_formalParameterList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2, argument_3) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_formalParameterList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@formalParameterList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_formalParameterList::
_addModel (const GGS_formalParameter & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_formalParameterList::
method_first (C_Compiler & _inLexique,
              GGS_formalArgumentPassingMode& _out_0,
              GGS_lstring & _out_1,
              GGS_lstring & _out_2,
              GGS_bool& _out_3
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mFormalParameterPassingMode ;
    _out_1 = _p->mFormalParameterTypeName ;
    _out_2 = _p->mFormalParameterName ;
    _out_3 = _p->mIsUnused ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_formalParameterList::
method_last (C_Compiler & _inLexique,
             GGS_formalArgumentPassingMode& _out_0,
             GGS_lstring & _out_1,
             GGS_lstring & _out_2,
             GGS_bool& _out_3
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mFormalParameterPassingMode ;
    _out_1 = _p->mFormalParameterTypeName ;
    _out_2 = _p->mFormalParameterName ;
    _out_3 = _p->mIsUnused ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_formalParameterList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_formalArgumentPassingMode& _out_0,
                 GGS_lstring & _out_1,
                 GGS_lstring & _out_2,
                 GGS_bool& _out_3
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mFormalParameterPassingMode ;
    _out_1 = _p->mFormalParameterTypeName ;
    _out_2 = _p->mFormalParameterName ;
    _out_3 = _p->mIsUnused ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_formalParameterList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_formalArgumentPassingMode& _out_0,
                GGS_lstring & _out_1,
                GGS_lstring & _out_2,
                GGS_bool& _out_3
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mFormalParameterPassingMode ;
    _out_1 = _p->mFormalParameterTypeName ;
    _out_2 = _p->mFormalParameterName ;
    _out_3 = _p->mIsUnused ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_formalParameter'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_formalParameter GGS_formalParameter::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_formalArgumentPassingMode& argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_bool& argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_formalParameter result ;
  macroMyNew (result.mPointer, cPtr_formalParameter (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalArgumentPassingMode GGS_formalParameter::
reader_mFormalParameterPassingMode (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_formalArgumentPassingMode  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_formalParameter *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_formalParameter *) mPointer)->mFormalParameterPassingMode ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_formalParameter::
reader_mFormalParameterTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_formalParameter *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_formalParameter *) mPointer)->mFormalParameterTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_formalParameter::
reader_mFormalParameterName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_formalParameter *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_formalParameter *) mPointer)->mFormalParameterName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_formalParameter::
reader_mIsUnused (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_formalParameter *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_formalParameter *) mPointer)->mIsUnused ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_formalParameter::actualTypeName (void) const {
 return "formalParameter" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_formalParameter * GGS_formalParameter::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_formalParameter *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@mapDeclarationList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_mapDeclaration::
cPtr_mapDeclaration (const GGS_lstring & argument_0,
                                const GGS_structuredTypeAttributeList & argument_1,
                                const GGS_mapMethodList & argument_2,
                                const GGS_mapMethodList & argument_3,
                                const GGS_mapMethodList & argument_4
                                COMMA_LOCATION_ARGS) :
cPtr_semanticDeclaration (THERE),
mMapTypeName (argument_0),
mAttributeList (argument_1),
mInsertMethodList (argument_2),
mSearchMethodList (argument_3),
mRemoveMethodList (argument_4) {
}

//---------------------------------------------------------------------------*

bool cPtr_mapDeclaration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_mapDeclaration * _p = dynamic_cast <const cPtr_mapDeclaration *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mMapTypeName._operator_isEqual (_p->mMapTypeName).boolValue ()
         && mAttributeList._operator_isEqual (_p->mAttributeList).boolValue ()
         && mInsertMethodList._operator_isEqual (_p->mInsertMethodList).boolValue ()
         && mSearchMethodList._operator_isEqual (_p->mSearchMethodList).boolValue ()
         && mRemoveMethodList._operator_isEqual (_p->mRemoveMethodList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_mapDeclaration::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @mapDeclaration" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMapTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAttributeList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInsertMethodList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSearchMethodList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRemoveMethodList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_mapDeclaration::_metamodelIndex (void) const {
  return gMetamodelManager.mMetamodelIndex ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_mapDeclaration::_metamodelClassID (void) const {
  return 5 ;
}

//---------------------------------------------------------------------------*

cPtr_mapDeclaration * cPtr_mapDeclaration::
_cloneObject (void) const {
  cPtr_mapDeclaration * _p = NULL ;
  macroMyNew (_p, cPtr_mapDeclaration (mMapTypeName, mAttributeList, mInsertMethodList, mSearchMethodList, mRemoveMethodList COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        List '@mapDeclarationList'                         *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_mapDeclarationList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_structuredTypeAttributeList & argument_1,
                    const GGS_mapMethodList & argument_2,
                    const GGS_mapMethodList & argument_3,
                    const GGS_mapMethodList & argument_4) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_mapDeclarationList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_structuredTypeAttributeList & argument_1,
                    const GGS_mapMethodList & argument_2,
                    const GGS_mapMethodList & argument_3,
                    const GGS_mapMethodList & argument_4) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_mapDeclarationList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_structuredTypeAttributeList & argument_1,
                                const GGS_mapMethodList & argument_2,
                                const GGS_mapMethodList & argument_3,
                                const GGS_mapMethodList & argument_4) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4) ;
  }
}

//---------------------------------------------------------------------------*

GGS_mapDeclarationList GGS_mapDeclarationList::
_operator_concat (const GGS_mapDeclarationList & inOperand) const {
  GGS_mapDeclarationList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_mapDeclaration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mMapTypeName ;
          GGS_structuredTypeAttributeList  p_1 = p->mAttributeList ;
          GGS_mapMethodList  p_2 = p->mInsertMethodList ;
          GGS_mapMethodList  p_3 = p->mSearchMethodList ;
          GGS_mapMethodList  p_4 = p->mRemoveMethodList ;
          result._internalAppendValues (p_0, p_1, p_2, p_3, p_4) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_mapDeclarationList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_structuredTypeAttributeList & argument_1,
                     const GGS_mapMethodList & argument_2,
                     const GGS_mapMethodList & argument_3,
                     const GGS_mapMethodList & argument_4
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapDeclarationList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mMapTypeName,
                                _p->mAttributeList,
                                _p->mInsertMethodList,
                                _p->mSearchMethodList,
                                _p->mRemoveMethodList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_mapDeclarationList  GGS_mapDeclarationList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_mapDeclarationList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapDeclarationList  GGS_mapDeclarationList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_structuredTypeAttributeList & argument_1,
                           const GGS_mapMethodList & argument_2,
                           const GGS_mapMethodList & argument_3,
                           const GGS_mapMethodList & argument_4
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_mapDeclarationList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2, argument_3, argument_4) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_mapDeclarationList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@mapDeclarationList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_mapDeclarationList::
_addModel (const GGS_mapDeclaration & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapDeclarationList::
method_first (C_Compiler & _inLexique,
              GGS_lstring & _out_0,
              GGS_structuredTypeAttributeList & _out_1,
              GGS_mapMethodList & _out_2,
              GGS_mapMethodList & _out_3,
              GGS_mapMethodList & _out_4
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMapTypeName ;
    _out_1 = _p->mAttributeList ;
    _out_2 = _p->mInsertMethodList ;
    _out_3 = _p->mSearchMethodList ;
    _out_4 = _p->mRemoveMethodList ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
    _out_4._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapDeclarationList::
method_last (C_Compiler & _inLexique,
             GGS_lstring & _out_0,
             GGS_structuredTypeAttributeList & _out_1,
             GGS_mapMethodList & _out_2,
             GGS_mapMethodList & _out_3,
             GGS_mapMethodList & _out_4
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMapTypeName ;
    _out_1 = _p->mAttributeList ;
    _out_2 = _p->mInsertMethodList ;
    _out_3 = _p->mSearchMethodList ;
    _out_4 = _p->mRemoveMethodList ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
    _out_4._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapDeclarationList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_structuredTypeAttributeList & _out_1,
                 GGS_mapMethodList & _out_2,
                 GGS_mapMethodList & _out_3,
                 GGS_mapMethodList & _out_4
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMapTypeName ;
    _out_1 = _p->mAttributeList ;
    _out_2 = _p->mInsertMethodList ;
    _out_3 = _p->mSearchMethodList ;
    _out_4 = _p->mRemoveMethodList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
    _out_4._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapDeclarationList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lstring & _out_0,
                GGS_structuredTypeAttributeList & _out_1,
                GGS_mapMethodList & _out_2,
                GGS_mapMethodList & _out_3,
                GGS_mapMethodList & _out_4
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMapTypeName ;
    _out_1 = _p->mAttributeList ;
    _out_2 = _p->mInsertMethodList ;
    _out_3 = _p->mSearchMethodList ;
    _out_4 = _p->mRemoveMethodList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
    _out_4._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_mapDeclaration'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_mapDeclaration GGS_mapDeclaration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_structuredTypeAttributeList & argument_1,
                 const GGS_mapMethodList & argument_2,
                 const GGS_mapMethodList & argument_3,
                 const GGS_mapMethodList & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_mapDeclaration result ;
  macroMyNew (result.mPointer, cPtr_mapDeclaration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapDeclaration::
reader_mMapTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapDeclaration *) mPointer)->mMapTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_structuredTypeAttributeList  GGS_mapDeclaration::
reader_mAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_structuredTypeAttributeList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapDeclaration *) mPointer)->mAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapMethodList  GGS_mapDeclaration::
reader_mInsertMethodList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_mapMethodList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapDeclaration *) mPointer)->mInsertMethodList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapMethodList  GGS_mapDeclaration::
reader_mSearchMethodList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_mapMethodList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapDeclaration *) mPointer)->mSearchMethodList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapMethodList  GGS_mapDeclaration::
reader_mRemoveMethodList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_mapMethodList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapDeclaration *) mPointer)->mRemoveMethodList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_mapDeclaration::actualTypeName (void) const {
 return "mapDeclaration" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_mapDeclaration * GGS_mapDeclaration::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_mapDeclaration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                     Element of list '@mapMethodList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_mapMethod::
cPtr_mapMethod (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
C_GGS_MetamodelEntity (THERE),
mMethodName (argument_0),
mErrorMessage (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_mapMethod::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_mapMethod * _p = dynamic_cast <const cPtr_mapMethod *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mMethodName._operator_isEqual (_p->mMethodName).boolValue ()
         && mErrorMessage._operator_isEqual (_p->mErrorMessage).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_mapMethod::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @mapMethod" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMethodName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mErrorMessage.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_mapMethod::_metamodelIndex (void) const {
  return gMetamodelManager.mMetamodelIndex ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_mapMethod::_metamodelClassID (void) const {
  return 6 ;
}

//---------------------------------------------------------------------------*

cPtr_mapMethod * cPtr_mapMethod::
_cloneObject (void) const {
  cPtr_mapMethod * _p = NULL ;
  macroMyNew (_p, cPtr_mapMethod (mMethodName, mErrorMessage COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          List '@mapMethodList'                            *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_mapMethodList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_mapMethodList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_mapMethodList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

GGS_mapMethodList GGS_mapMethodList::
_operator_concat (const GGS_mapMethodList & inOperand) const {
  GGS_mapMethodList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_mapMethod * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mMethodName ;
          GGS_lstring  p_1 = p->mErrorMessage ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_mapMethodList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapMethodList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mMethodName,
                                _p->mErrorMessage) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_mapMethodList  GGS_mapMethodList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_mapMethodList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapMethodList  GGS_mapMethodList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_lstring & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_mapMethodList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_mapMethodList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@mapMethodList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_mapMethodList::
_addModel (const GGS_mapMethod & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapMethodList::
method_first (C_Compiler & _inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMethodName ;
    _out_1 = _p->mErrorMessage ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapMethodList::
method_last (C_Compiler & _inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMethodName ;
    _out_1 = _p->mErrorMessage ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapMethodList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMethodName ;
    _out_1 = _p->mErrorMessage ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapMethodList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMethodName ;
    _out_1 = _p->mErrorMessage ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_mapMethod'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_mapMethod GGS_mapMethod::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_mapMethod result ;
  macroMyNew (result.mPointer, cPtr_mapMethod (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapMethod::
reader_mMethodName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapMethod *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapMethod *) mPointer)->mMethodName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapMethod::
reader_mErrorMessage (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapMethod *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapMethod *) mPointer)->mErrorMessage ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_mapMethod::actualTypeName (void) const {
 return "mapMethod" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_mapMethod * GGS_mapMethod::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_mapMethod *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@classDeclarationList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_classDeclaration::
cPtr_classDeclaration (const GGS_bool& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_structuredTypeAttributeList & argument_3,
                                const GGS_abstractMethodDefinitionList & argument_4,
                                const GGS_overridenMethodDefinitionList & argument_5,
                                const GGS_classMessageDefinitionList & argument_6
                                COMMA_LOCATION_ARGS) :
cPtr_semanticDeclaration (THERE),
mIsAbstract (argument_0),
mClassTypeName (argument_1),
mSuperClassName (argument_2),
mAttributeList (argument_3),
mAbstractMethodList (argument_4),
mOverridenMethodList (argument_5),
mMessageList (argument_6) {
}

//---------------------------------------------------------------------------*

bool cPtr_classDeclaration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_classDeclaration * _p = dynamic_cast <const cPtr_classDeclaration *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mIsAbstract._operator_isEqual (_p->mIsAbstract).boolValue ()
         && mClassTypeName._operator_isEqual (_p->mClassTypeName).boolValue ()
         && mSuperClassName._operator_isEqual (_p->mSuperClassName).boolValue ()
         && mAttributeList._operator_isEqual (_p->mAttributeList).boolValue ()
         && mAbstractMethodList._operator_isEqual (_p->mAbstractMethodList).boolValue ()
         && mOverridenMethodList._operator_isEqual (_p->mOverridenMethodList).boolValue ()
         && mMessageList._operator_isEqual (_p->mMessageList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_classDeclaration::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @classDeclaration" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mIsAbstract.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mClassTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSuperClassName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAttributeList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAbstractMethodList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOverridenMethodList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMessageList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_classDeclaration::_metamodelIndex (void) const {
  return gMetamodelManager.mMetamodelIndex ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_classDeclaration::_metamodelClassID (void) const {
  return 7 ;
}

//---------------------------------------------------------------------------*

cPtr_classDeclaration * cPtr_classDeclaration::
_cloneObject (void) const {
  cPtr_classDeclaration * _p = NULL ;
  macroMyNew (_p, cPtr_classDeclaration (mIsAbstract, mClassTypeName, mSuperClassName, mAttributeList, mAbstractMethodList, mOverridenMethodList, mMessageList COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@classDeclarationList'                        *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_classDeclarationList::
_internalAppendValues (const GGS_bool& argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_structuredTypeAttributeList & argument_3,
                    const GGS_abstractMethodDefinitionList & argument_4,
                    const GGS_overridenMethodDefinitionList & argument_5,
                    const GGS_classMessageDefinitionList & argument_6) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_classDeclarationList::
_internalPrependValues (const GGS_bool& argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_structuredTypeAttributeList & argument_3,
                    const GGS_abstractMethodDefinitionList & argument_4,
                    const GGS_overridenMethodDefinitionList & argument_5,
                    const GGS_classMessageDefinitionList & argument_6) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_classDeclarationList::
_addAssign_operation (const GGS_bool& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_structuredTypeAttributeList & argument_3,
                                const GGS_abstractMethodDefinitionList & argument_4,
                                const GGS_overridenMethodDefinitionList & argument_5,
                                const GGS_classMessageDefinitionList & argument_6) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6) ;
  }
}

//---------------------------------------------------------------------------*

GGS_classDeclarationList GGS_classDeclarationList::
_operator_concat (const GGS_classDeclarationList & inOperand) const {
  GGS_classDeclarationList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_classDeclaration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_bool p_0 = p->mIsAbstract ;
          GGS_lstring  p_1 = p->mClassTypeName ;
          GGS_lstring  p_2 = p->mSuperClassName ;
          GGS_structuredTypeAttributeList  p_3 = p->mAttributeList ;
          GGS_abstractMethodDefinitionList  p_4 = p->mAbstractMethodList ;
          GGS_overridenMethodDefinitionList  p_5 = p->mOverridenMethodList ;
          GGS_classMessageDefinitionList  p_6 = p->mMessageList ;
          result._internalAppendValues (p_0, p_1, p_2, p_3, p_4, p_5, p_6) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_classDeclarationList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_bool& argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_lstring & argument_2,
                     const GGS_structuredTypeAttributeList & argument_3,
                     const GGS_abstractMethodDefinitionList & argument_4,
                     const GGS_overridenMethodDefinitionList & argument_5,
                     const GGS_classMessageDefinitionList & argument_6
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_classDeclarationList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mIsAbstract,
                                _p->mClassTypeName,
                                _p->mSuperClassName,
                                _p->mAttributeList,
                                _p->mAbstractMethodList,
                                _p->mOverridenMethodList,
                                _p->mMessageList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_classDeclarationList  GGS_classDeclarationList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_classDeclarationList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_classDeclarationList  GGS_classDeclarationList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_bool& argument_0,
                           const GGS_lstring & argument_1,
                           const GGS_lstring & argument_2,
                           const GGS_structuredTypeAttributeList & argument_3,
                           const GGS_abstractMethodDefinitionList & argument_4,
                           const GGS_overridenMethodDefinitionList & argument_5,
                           const GGS_classMessageDefinitionList & argument_6
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_classDeclarationList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2, argument_3, argument_4, argument_5, argument_6) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_classDeclarationList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@classDeclarationList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_classDeclarationList::
_addModel (const GGS_classDeclaration & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_classDeclarationList::
method_first (C_Compiler & _inLexique,
              GGS_bool& _out_0,
              GGS_lstring & _out_1,
              GGS_lstring & _out_2,
              GGS_structuredTypeAttributeList & _out_3,
              GGS_abstractMethodDefinitionList & _out_4,
              GGS_overridenMethodDefinitionList & _out_5,
              GGS_classMessageDefinitionList & _out_6
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mIsAbstract ;
    _out_1 = _p->mClassTypeName ;
    _out_2 = _p->mSuperClassName ;
    _out_3 = _p->mAttributeList ;
    _out_4 = _p->mAbstractMethodList ;
    _out_5 = _p->mOverridenMethodList ;
    _out_6 = _p->mMessageList ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
    _out_4._drop_operation () ;
    _out_5._drop_operation () ;
    _out_6._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_classDeclarationList::
method_last (C_Compiler & _inLexique,
             GGS_bool& _out_0,
             GGS_lstring & _out_1,
             GGS_lstring & _out_2,
             GGS_structuredTypeAttributeList & _out_3,
             GGS_abstractMethodDefinitionList & _out_4,
             GGS_overridenMethodDefinitionList & _out_5,
             GGS_classMessageDefinitionList & _out_6
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mIsAbstract ;
    _out_1 = _p->mClassTypeName ;
    _out_2 = _p->mSuperClassName ;
    _out_3 = _p->mAttributeList ;
    _out_4 = _p->mAbstractMethodList ;
    _out_5 = _p->mOverridenMethodList ;
    _out_6 = _p->mMessageList ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
    _out_4._drop_operation () ;
    _out_5._drop_operation () ;
    _out_6._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_classDeclarationList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_bool& _out_0,
                 GGS_lstring & _out_1,
                 GGS_lstring & _out_2,
                 GGS_structuredTypeAttributeList & _out_3,
                 GGS_abstractMethodDefinitionList & _out_4,
                 GGS_overridenMethodDefinitionList & _out_5,
                 GGS_classMessageDefinitionList & _out_6
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mIsAbstract ;
    _out_1 = _p->mClassTypeName ;
    _out_2 = _p->mSuperClassName ;
    _out_3 = _p->mAttributeList ;
    _out_4 = _p->mAbstractMethodList ;
    _out_5 = _p->mOverridenMethodList ;
    _out_6 = _p->mMessageList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
    _out_4._drop_operation () ;
    _out_5._drop_operation () ;
    _out_6._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_classDeclarationList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_bool& _out_0,
                GGS_lstring & _out_1,
                GGS_lstring & _out_2,
                GGS_structuredTypeAttributeList & _out_3,
                GGS_abstractMethodDefinitionList & _out_4,
                GGS_overridenMethodDefinitionList & _out_5,
                GGS_classMessageDefinitionList & _out_6
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mIsAbstract ;
    _out_1 = _p->mClassTypeName ;
    _out_2 = _p->mSuperClassName ;
    _out_3 = _p->mAttributeList ;
    _out_4 = _p->mAbstractMethodList ;
    _out_5 = _p->mOverridenMethodList ;
    _out_6 = _p->mMessageList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
    _out_4._drop_operation () ;
    _out_5._drop_operation () ;
    _out_6._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_classDeclaration'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_classDeclaration GGS_classDeclaration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_bool& argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_structuredTypeAttributeList & argument_3,
                 const GGS_abstractMethodDefinitionList & argument_4,
                 const GGS_overridenMethodDefinitionList & argument_5,
                 const GGS_classMessageDefinitionList & argument_6
                                COMMA_LOCATION_ARGS) {
  GGS_classDeclaration result ;
  macroMyNew (result.mPointer, cPtr_classDeclaration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_classDeclaration::
reader_mIsAbstract (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classDeclaration *) mPointer)->mIsAbstract ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_classDeclaration::
reader_mClassTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classDeclaration *) mPointer)->mClassTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_classDeclaration::
reader_mSuperClassName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classDeclaration *) mPointer)->mSuperClassName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_structuredTypeAttributeList  GGS_classDeclaration::
reader_mAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_structuredTypeAttributeList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classDeclaration *) mPointer)->mAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_abstractMethodDefinitionList  GGS_classDeclaration::
reader_mAbstractMethodList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_abstractMethodDefinitionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classDeclaration *) mPointer)->mAbstractMethodList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_overridenMethodDefinitionList  GGS_classDeclaration::
reader_mOverridenMethodList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_overridenMethodDefinitionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classDeclaration *) mPointer)->mOverridenMethodList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_classMessageDefinitionList  GGS_classDeclaration::
reader_mMessageList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_classMessageDefinitionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classDeclaration *) mPointer)->mMessageList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_classDeclaration::actualTypeName (void) const {
 return "classDeclaration" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_classDeclaration * GGS_classDeclaration::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_classDeclaration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@abstractMethodDefinitionList'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_abstractMethodDefinition::
cPtr_abstractMethodDefinition (const GGS_lstring & argument_0,
                                const GGS_formalParameters & argument_1
                                COMMA_LOCATION_ARGS) :
C_GGS_MetamodelEntity (THERE),
mMethodName (argument_0),
mSignature (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_abstractMethodDefinition::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_abstractMethodDefinition * _p = dynamic_cast <const cPtr_abstractMethodDefinition *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mMethodName._operator_isEqual (_p->mMethodName).boolValue ()
         && mSignature._operator_isEqual (_p->mSignature).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_abstractMethodDefinition::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @abstractMethodDefinition" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMethodName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSignature.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_abstractMethodDefinition::_metamodelIndex (void) const {
  return gMetamodelManager.mMetamodelIndex ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_abstractMethodDefinition::_metamodelClassID (void) const {
  return 8 ;
}

//---------------------------------------------------------------------------*

cPtr_abstractMethodDefinition * cPtr_abstractMethodDefinition::
_cloneObject (void) const {
  cPtr_abstractMethodDefinition * _p = NULL ;
  macroMyNew (_p, cPtr_abstractMethodDefinition (mMethodName, mSignature COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@abstractMethodDefinitionList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_formalParameters & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_formalParameters & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_formalParameters & argument_1) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

GGS_abstractMethodDefinitionList GGS_abstractMethodDefinitionList::
_operator_concat (const GGS_abstractMethodDefinitionList & inOperand) const {
  GGS_abstractMethodDefinitionList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_abstractMethodDefinition * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mMethodName ;
          GGS_formalParameters  p_1 = p->mSignature ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_formalParameters & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mMethodName,
                                _p->mSignature) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_abstractMethodDefinitionList  GGS_abstractMethodDefinitionList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_abstractMethodDefinitionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_abstractMethodDefinitionList  GGS_abstractMethodDefinitionList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_formalParameters & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_abstractMethodDefinitionList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_abstractMethodDefinitionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@abstractMethodDefinitionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionList::
_addModel (const GGS_abstractMethodDefinition & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionList::
method_first (C_Compiler & _inLexique,
              GGS_lstring & _out_0,
              GGS_formalParameters & _out_1
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMethodName ;
    _out_1 = _p->mSignature ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionList::
method_last (C_Compiler & _inLexique,
             GGS_lstring & _out_0,
             GGS_formalParameters & _out_1
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMethodName ;
    _out_1 = _p->mSignature ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_formalParameters & _out_1
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMethodName ;
    _out_1 = _p->mSignature ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lstring & _out_0,
                GGS_formalParameters & _out_1
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMethodName ;
    _out_1 = _p->mSignature ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_abstractMethodDefinition'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_abstractMethodDefinition GGS_abstractMethodDefinition::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_formalParameters & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_abstractMethodDefinition result ;
  macroMyNew (result.mPointer, cPtr_abstractMethodDefinition (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_abstractMethodDefinition::
reader_mMethodName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_abstractMethodDefinition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_abstractMethodDefinition *) mPointer)->mMethodName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameters  GGS_abstractMethodDefinition::
reader_mSignature (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_formalParameters   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_abstractMethodDefinition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_abstractMethodDefinition *) mPointer)->mSignature ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_abstractMethodDefinition::actualTypeName (void) const {
 return "abstractMethodDefinition" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_abstractMethodDefinition * GGS_abstractMethodDefinition::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_abstractMethodDefinition *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@overridenMethodDefinitionList'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_overridenMethodDefinition::
cPtr_overridenMethodDefinition (const GGS_lstring & argument_0,
                                const GGS_formalParameters & argument_1,
                                const GGS_semanticInstructions & argument_2
                                COMMA_LOCATION_ARGS) :
C_GGS_MetamodelEntity (THERE),
mMethodName (argument_0),
mSignature (argument_1),
mInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_overridenMethodDefinition::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_overridenMethodDefinition * _p = dynamic_cast <const cPtr_overridenMethodDefinition *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mMethodName._operator_isEqual (_p->mMethodName).boolValue ()
         && mSignature._operator_isEqual (_p->mSignature).boolValue ()
         && mInstructionList._operator_isEqual (_p->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_overridenMethodDefinition::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @overridenMethodDefinition" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMethodName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSignature.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_overridenMethodDefinition::_metamodelIndex (void) const {
  return gMetamodelManager.mMetamodelIndex ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_overridenMethodDefinition::_metamodelClassID (void) const {
  return 9 ;
}

//---------------------------------------------------------------------------*

cPtr_overridenMethodDefinition * cPtr_overridenMethodDefinition::
_cloneObject (void) const {
  cPtr_overridenMethodDefinition * _p = NULL ;
  macroMyNew (_p, cPtr_overridenMethodDefinition (mMethodName, mSignature, mInstructionList COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@overridenMethodDefinitionList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_overridenMethodDefinitionList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_formalParameters & argument_1,
                    const GGS_semanticInstructions & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_overridenMethodDefinitionList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_formalParameters & argument_1,
                    const GGS_semanticInstructions & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_overridenMethodDefinitionList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_formalParameters & argument_1,
                                const GGS_semanticInstructions & argument_2) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

GGS_overridenMethodDefinitionList GGS_overridenMethodDefinitionList::
_operator_concat (const GGS_overridenMethodDefinitionList & inOperand) const {
  GGS_overridenMethodDefinitionList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_overridenMethodDefinition * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mMethodName ;
          GGS_formalParameters  p_1 = p->mSignature ;
          GGS_semanticInstructions  p_2 = p->mInstructionList ;
          result._internalAppendValues (p_0, p_1, p_2) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_overridenMethodDefinitionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_formalParameters & argument_1,
                     const GGS_semanticInstructions & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_overridenMethodDefinitionList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mMethodName,
                                _p->mSignature,
                                _p->mInstructionList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_overridenMethodDefinitionList  GGS_overridenMethodDefinitionList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_overridenMethodDefinitionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_overridenMethodDefinitionList  GGS_overridenMethodDefinitionList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_formalParameters & argument_1,
                           const GGS_semanticInstructions & argument_2
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_overridenMethodDefinitionList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_overridenMethodDefinitionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@overridenMethodDefinitionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_overridenMethodDefinitionList::
_addModel (const GGS_overridenMethodDefinition & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_overridenMethodDefinitionList::
method_first (C_Compiler & _inLexique,
              GGS_lstring & _out_0,
              GGS_formalParameters & _out_1,
              GGS_semanticInstructions & _out_2
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMethodName ;
    _out_1 = _p->mSignature ;
    _out_2 = _p->mInstructionList ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_overridenMethodDefinitionList::
method_last (C_Compiler & _inLexique,
             GGS_lstring & _out_0,
             GGS_formalParameters & _out_1,
             GGS_semanticInstructions & _out_2
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMethodName ;
    _out_1 = _p->mSignature ;
    _out_2 = _p->mInstructionList ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_overridenMethodDefinitionList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_formalParameters & _out_1,
                 GGS_semanticInstructions & _out_2
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMethodName ;
    _out_1 = _p->mSignature ;
    _out_2 = _p->mInstructionList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_overridenMethodDefinitionList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lstring & _out_0,
                GGS_formalParameters & _out_1,
                GGS_semanticInstructions & _out_2
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMethodName ;
    _out_1 = _p->mSignature ;
    _out_2 = _p->mInstructionList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_overridenMethodDefinition'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_overridenMethodDefinition GGS_overridenMethodDefinition::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_formalParameters & argument_1,
                 const GGS_semanticInstructions & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_overridenMethodDefinition result ;
  macroMyNew (result.mPointer, cPtr_overridenMethodDefinition (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_overridenMethodDefinition::
reader_mMethodName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_overridenMethodDefinition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_overridenMethodDefinition *) mPointer)->mMethodName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameters  GGS_overridenMethodDefinition::
reader_mSignature (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_formalParameters   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_overridenMethodDefinition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_overridenMethodDefinition *) mPointer)->mSignature ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructions  GGS_overridenMethodDefinition::
reader_mInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructions   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_overridenMethodDefinition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_overridenMethodDefinition *) mPointer)->mInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_overridenMethodDefinition::actualTypeName (void) const {
 return "overridenMethodDefinition" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_overridenMethodDefinition * GGS_overridenMethodDefinition::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_overridenMethodDefinition *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@classMessageDefinitionList'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_classMessageDefinition::
cPtr_classMessageDefinition (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
C_GGS_MetamodelEntity (THERE),
mMessageName (argument_0),
mMessageValue (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_classMessageDefinition::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_classMessageDefinition * _p = dynamic_cast <const cPtr_classMessageDefinition *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mMessageName._operator_isEqual (_p->mMessageName).boolValue ()
         && mMessageValue._operator_isEqual (_p->mMessageValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_classMessageDefinition::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @classMessageDefinition" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMessageName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMessageValue.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_classMessageDefinition::_metamodelIndex (void) const {
  return gMetamodelManager.mMetamodelIndex ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_classMessageDefinition::_metamodelClassID (void) const {
  return 10 ;
}

//---------------------------------------------------------------------------*

cPtr_classMessageDefinition * cPtr_classMessageDefinition::
_cloneObject (void) const {
  cPtr_classMessageDefinition * _p = NULL ;
  macroMyNew (_p, cPtr_classMessageDefinition (mMessageName, mMessageValue COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@classMessageDefinitionList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_classMessageDefinitionList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_classMessageDefinitionList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_classMessageDefinitionList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

GGS_classMessageDefinitionList GGS_classMessageDefinitionList::
_operator_concat (const GGS_classMessageDefinitionList & inOperand) const {
  GGS_classMessageDefinitionList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_classMessageDefinition * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mMessageName ;
          GGS_lstring  p_1 = p->mMessageValue ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_classMessageDefinitionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_classMessageDefinitionList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mMessageName,
                                _p->mMessageValue) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_classMessageDefinitionList  GGS_classMessageDefinitionList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_classMessageDefinitionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_classMessageDefinitionList  GGS_classMessageDefinitionList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_lstring & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_classMessageDefinitionList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_classMessageDefinitionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@classMessageDefinitionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_classMessageDefinitionList::
_addModel (const GGS_classMessageDefinition & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_classMessageDefinitionList::
method_first (C_Compiler & _inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMessageName ;
    _out_1 = _p->mMessageValue ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_classMessageDefinitionList::
method_last (C_Compiler & _inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMessageName ;
    _out_1 = _p->mMessageValue ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_classMessageDefinitionList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMessageName ;
    _out_1 = _p->mMessageValue ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_classMessageDefinitionList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMessageName ;
    _out_1 = _p->mMessageValue ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_classMessageDefinition'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_classMessageDefinition GGS_classMessageDefinition::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_classMessageDefinition result ;
  macroMyNew (result.mPointer, cPtr_classMessageDefinition (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_classMessageDefinition::
reader_mMessageName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classMessageDefinition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classMessageDefinition *) mPointer)->mMessageName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_classMessageDefinition::
reader_mMessageValue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classMessageDefinition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classMessageDefinition *) mPointer)->mMessageValue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_classMessageDefinition::actualTypeName (void) const {
 return "classMessageDefinition" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_classMessageDefinition * GGS_classMessageDefinition::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_classMessageDefinition *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@listDeclarationList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_listDeclaration::
cPtr_listDeclaration (const GGS_lstring & argument_0,
                                const GGS_structuredTypeAttributeList & argument_1
                                COMMA_LOCATION_ARGS) :
cPtr_semanticDeclaration (THERE),
mListTypeName (argument_0),
mAttributeList (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_listDeclaration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_listDeclaration * _p = dynamic_cast <const cPtr_listDeclaration *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mListTypeName._operator_isEqual (_p->mListTypeName).boolValue ()
         && mAttributeList._operator_isEqual (_p->mAttributeList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_listDeclaration::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @listDeclaration" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mListTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAttributeList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_listDeclaration::_metamodelIndex (void) const {
  return gMetamodelManager.mMetamodelIndex ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_listDeclaration::_metamodelClassID (void) const {
  return 11 ;
}

//---------------------------------------------------------------------------*

cPtr_listDeclaration * cPtr_listDeclaration::
_cloneObject (void) const {
  cPtr_listDeclaration * _p = NULL ;
  macroMyNew (_p, cPtr_listDeclaration (mListTypeName, mAttributeList COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@listDeclarationList'                         *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_listDeclarationList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_structuredTypeAttributeList & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_listDeclarationList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_structuredTypeAttributeList & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_listDeclarationList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_structuredTypeAttributeList & argument_1) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

GGS_listDeclarationList GGS_listDeclarationList::
_operator_concat (const GGS_listDeclarationList & inOperand) const {
  GGS_listDeclarationList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_listDeclaration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mListTypeName ;
          GGS_structuredTypeAttributeList  p_1 = p->mAttributeList ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_listDeclarationList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_structuredTypeAttributeList & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_listDeclarationList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mListTypeName,
                                _p->mAttributeList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_listDeclarationList  GGS_listDeclarationList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_listDeclarationList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_listDeclarationList  GGS_listDeclarationList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_structuredTypeAttributeList & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_listDeclarationList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_listDeclarationList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@listDeclarationList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_listDeclarationList::
_addModel (const GGS_listDeclaration & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_listDeclarationList::
method_first (C_Compiler & _inLexique,
              GGS_lstring & _out_0,
              GGS_structuredTypeAttributeList & _out_1
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mListTypeName ;
    _out_1 = _p->mAttributeList ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_listDeclarationList::
method_last (C_Compiler & _inLexique,
             GGS_lstring & _out_0,
             GGS_structuredTypeAttributeList & _out_1
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mListTypeName ;
    _out_1 = _p->mAttributeList ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_listDeclarationList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_structuredTypeAttributeList & _out_1
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mListTypeName ;
    _out_1 = _p->mAttributeList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_listDeclarationList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lstring & _out_0,
                GGS_structuredTypeAttributeList & _out_1
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mListTypeName ;
    _out_1 = _p->mAttributeList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_listDeclaration'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_listDeclaration GGS_listDeclaration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_structuredTypeAttributeList & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_listDeclaration result ;
  macroMyNew (result.mPointer, cPtr_listDeclaration (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_listDeclaration::
reader_mListTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_listDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_listDeclaration *) mPointer)->mListTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_structuredTypeAttributeList  GGS_listDeclaration::
reader_mAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_structuredTypeAttributeList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_listDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_listDeclaration *) mPointer)->mAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_listDeclaration::actualTypeName (void) const {
 return "listDeclaration" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_listDeclaration * GGS_listDeclaration::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_listDeclaration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@enumDeclarationList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_enumDeclaration::
cPtr_enumDeclaration (const GGS_lstring & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_enumMessageList & argument_2
                                COMMA_LOCATION_ARGS) :
cPtr_semanticDeclaration (THERE),
mEnumTypeName (argument_0),
mConstantList (argument_1),
mEnumMessageList (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_enumDeclaration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_enumDeclaration * _p = dynamic_cast <const cPtr_enumDeclaration *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mEnumTypeName._operator_isEqual (_p->mEnumTypeName).boolValue ()
         && mConstantList._operator_isEqual (_p->mConstantList).boolValue ()
         && mEnumMessageList._operator_isEqual (_p->mEnumMessageList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_enumDeclaration::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @enumDeclaration" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEnumTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mConstantList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEnumMessageList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_enumDeclaration::_metamodelIndex (void) const {
  return gMetamodelManager.mMetamodelIndex ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_enumDeclaration::_metamodelClassID (void) const {
  return 12 ;
}

//---------------------------------------------------------------------------*

cPtr_enumDeclaration * cPtr_enumDeclaration::
_cloneObject (void) const {
  cPtr_enumDeclaration * _p = NULL ;
  macroMyNew (_p, cPtr_enumDeclaration (mEnumTypeName, mConstantList, mEnumMessageList COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@enumDeclarationList'                         *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_enumDeclarationList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstringlist & argument_1,
                    const GGS_enumMessageList & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_enumDeclarationList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstringlist & argument_1,
                    const GGS_enumMessageList & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_enumDeclarationList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_enumMessageList & argument_2) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

GGS_enumDeclarationList GGS_enumDeclarationList::
_operator_concat (const GGS_enumDeclarationList & inOperand) const {
  GGS_enumDeclarationList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_enumDeclaration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mEnumTypeName ;
          GGS_lstringlist  p_1 = p->mConstantList ;
          GGS_enumMessageList  p_2 = p->mEnumMessageList ;
          result._internalAppendValues (p_0, p_1, p_2) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumDeclarationList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstringlist & argument_1,
                     const GGS_enumMessageList & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumDeclarationList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mEnumTypeName,
                                _p->mConstantList,
                                _p->mEnumMessageList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_enumDeclarationList  GGS_enumDeclarationList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_enumDeclarationList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumDeclarationList  GGS_enumDeclarationList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_lstringlist & argument_1,
                           const GGS_enumMessageList & argument_2
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_enumDeclarationList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_enumDeclarationList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@enumDeclarationList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_enumDeclarationList::
_addModel (const GGS_enumDeclaration & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumDeclarationList::
method_first (C_Compiler & _inLexique,
              GGS_lstring & _out_0,
              GGS_lstringlist & _out_1,
              GGS_enumMessageList & _out_2
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mEnumTypeName ;
    _out_1 = _p->mConstantList ;
    _out_2 = _p->mEnumMessageList ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumDeclarationList::
method_last (C_Compiler & _inLexique,
             GGS_lstring & _out_0,
             GGS_lstringlist & _out_1,
             GGS_enumMessageList & _out_2
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mEnumTypeName ;
    _out_1 = _p->mConstantList ;
    _out_2 = _p->mEnumMessageList ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumDeclarationList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstringlist & _out_1,
                 GGS_enumMessageList & _out_2
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mEnumTypeName ;
    _out_1 = _p->mConstantList ;
    _out_2 = _p->mEnumMessageList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumDeclarationList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lstring & _out_0,
                GGS_lstringlist & _out_1,
                GGS_enumMessageList & _out_2
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mEnumTypeName ;
    _out_1 = _p->mConstantList ;
    _out_2 = _p->mEnumMessageList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_enumDeclaration'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_enumDeclaration GGS_enumDeclaration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstringlist & argument_1,
                 const GGS_enumMessageList & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_enumDeclaration result ;
  macroMyNew (result.mPointer, cPtr_enumDeclaration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_enumDeclaration::
reader_mEnumTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumDeclaration *) mPointer)->mEnumTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_enumDeclaration::
reader_mConstantList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumDeclaration *) mPointer)->mConstantList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMessageList  GGS_enumDeclaration::
reader_mEnumMessageList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_enumMessageList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumDeclaration *) mPointer)->mEnumMessageList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_enumDeclaration::actualTypeName (void) const {
 return "enumDeclaration" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_enumDeclaration * GGS_enumDeclaration::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_enumDeclaration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                    Element of list '@enumMessageList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_enumMessage::
cPtr_enumMessage (const GGS_lstring & argument_0,
                                const GGS_enumMessageAssociationList & argument_1
                                COMMA_LOCATION_ARGS) :
C_GGS_MetamodelEntity (THERE),
mEnumMessageName (argument_0),
mMessageAssociationList (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_enumMessage::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_enumMessage * _p = dynamic_cast <const cPtr_enumMessage *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mEnumMessageName._operator_isEqual (_p->mEnumMessageName).boolValue ()
         && mMessageAssociationList._operator_isEqual (_p->mMessageAssociationList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_enumMessage::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @enumMessage" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEnumMessageName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMessageAssociationList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_enumMessage::_metamodelIndex (void) const {
  return gMetamodelManager.mMetamodelIndex ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_enumMessage::_metamodelClassID (void) const {
  return 13 ;
}

//---------------------------------------------------------------------------*

cPtr_enumMessage * cPtr_enumMessage::
_cloneObject (void) const {
  cPtr_enumMessage * _p = NULL ;
  macroMyNew (_p, cPtr_enumMessage (mEnumMessageName, mMessageAssociationList COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         List '@enumMessageList'                           *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_enumMessageList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_enumMessageAssociationList & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_enumMessageAssociationList & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_enumMessageAssociationList & argument_1) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

GGS_enumMessageList GGS_enumMessageList::
_operator_concat (const GGS_enumMessageList & inOperand) const {
  GGS_enumMessageList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_enumMessage * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mEnumMessageName ;
          GGS_enumMessageAssociationList  p_1 = p->mMessageAssociationList ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_enumMessageAssociationList & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mEnumMessageName,
                                _p->mMessageAssociationList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_enumMessageList  GGS_enumMessageList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_enumMessageList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMessageList  GGS_enumMessageList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_enumMessageAssociationList & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_enumMessageList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_enumMessageList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@enumMessageList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageList::
_addModel (const GGS_enumMessage & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageList::
method_first (C_Compiler & _inLexique,
              GGS_lstring & _out_0,
              GGS_enumMessageAssociationList & _out_1
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mEnumMessageName ;
    _out_1 = _p->mMessageAssociationList ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageList::
method_last (C_Compiler & _inLexique,
             GGS_lstring & _out_0,
             GGS_enumMessageAssociationList & _out_1
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mEnumMessageName ;
    _out_1 = _p->mMessageAssociationList ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_enumMessageAssociationList & _out_1
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mEnumMessageName ;
    _out_1 = _p->mMessageAssociationList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lstring & _out_0,
                GGS_enumMessageAssociationList & _out_1
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mEnumMessageName ;
    _out_1 = _p->mMessageAssociationList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_enumMessage'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_enumMessage GGS_enumMessage::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_enumMessageAssociationList & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_enumMessage result ;
  macroMyNew (result.mPointer, cPtr_enumMessage (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_enumMessage::
reader_mEnumMessageName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumMessage *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumMessage *) mPointer)->mEnumMessageName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMessageAssociationList  GGS_enumMessage::
reader_mMessageAssociationList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_enumMessageAssociationList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumMessage *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumMessage *) mPointer)->mMessageAssociationList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_enumMessage::actualTypeName (void) const {
 return "enumMessage" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_enumMessage * GGS_enumMessage::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_enumMessage *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@enumMessageAssociationList'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_enumMessageAssociation::
cPtr_enumMessageAssociation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
C_GGS_MetamodelEntity (THERE),
mConstantName (argument_0),
mMessage (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_enumMessageAssociation::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_enumMessageAssociation * _p = dynamic_cast <const cPtr_enumMessageAssociation *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mConstantName._operator_isEqual (_p->mConstantName).boolValue ()
         && mMessage._operator_isEqual (_p->mMessage).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_enumMessageAssociation::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @enumMessageAssociation" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mConstantName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMessage.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_enumMessageAssociation::_metamodelIndex (void) const {
  return gMetamodelManager.mMetamodelIndex ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_enumMessageAssociation::_metamodelClassID (void) const {
  return 14 ;
}

//---------------------------------------------------------------------------*

cPtr_enumMessageAssociation * cPtr_enumMessageAssociation::
_cloneObject (void) const {
  cPtr_enumMessageAssociation * _p = NULL ;
  macroMyNew (_p, cPtr_enumMessageAssociation (mConstantName, mMessage COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@enumMessageAssociationList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

GGS_enumMessageAssociationList GGS_enumMessageAssociationList::
_operator_concat (const GGS_enumMessageAssociationList & inOperand) const {
  GGS_enumMessageAssociationList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_enumMessageAssociation * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mConstantName ;
          GGS_lstring  p_1 = p->mMessage ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mConstantName,
                                _p->mMessage) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_enumMessageAssociationList  GGS_enumMessageAssociationList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_enumMessageAssociationList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMessageAssociationList  GGS_enumMessageAssociationList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_lstring & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_enumMessageAssociationList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_enumMessageAssociationList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@enumMessageAssociationList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationList::
_addModel (const GGS_enumMessageAssociation & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationList::
method_first (C_Compiler & _inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mConstantName ;
    _out_1 = _p->mMessage ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationList::
method_last (C_Compiler & _inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mConstantName ;
    _out_1 = _p->mMessage ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mConstantName ;
    _out_1 = _p->mMessage ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mConstantName ;
    _out_1 = _p->mMessage ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_enumMessageAssociation'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_enumMessageAssociation GGS_enumMessageAssociation::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_enumMessageAssociation result ;
  macroMyNew (result.mPointer, cPtr_enumMessageAssociation (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_enumMessageAssociation::
reader_mConstantName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumMessageAssociation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumMessageAssociation *) mPointer)->mConstantName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_enumMessageAssociation::
reader_mMessage (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumMessageAssociation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumMessageAssociation *) mPointer)->mMessage ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_enumMessageAssociation::actualTypeName (void) const {
 return "enumMessageAssociation" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_enumMessageAssociation * GGS_enumMessageAssociation::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_enumMessageAssociation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@routineDeclarationList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_routineDeclaration::
cPtr_routineDeclaration (const GGS_lstring & argument_0,
                                const GGS_formalParameters & argument_1,
                                const GGS_semanticInstructions & argument_2
                                COMMA_LOCATION_ARGS) :
cPtr_semanticDeclaration (THERE),
mRoutineName (argument_0),
mFormalParameters (argument_1),
mRoutineInstructions (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_routineDeclaration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_routineDeclaration * _p = dynamic_cast <const cPtr_routineDeclaration *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mRoutineName._operator_isEqual (_p->mRoutineName).boolValue ()
         && mFormalParameters._operator_isEqual (_p->mFormalParameters).boolValue ()
         && mRoutineInstructions._operator_isEqual (_p->mRoutineInstructions).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_routineDeclaration::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @routineDeclaration" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRoutineName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFormalParameters.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRoutineInstructions.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_routineDeclaration::_metamodelIndex (void) const {
  return gMetamodelManager.mMetamodelIndex ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_routineDeclaration::_metamodelClassID (void) const {
  return 15 ;
}

//---------------------------------------------------------------------------*

cPtr_routineDeclaration * cPtr_routineDeclaration::
_cloneObject (void) const {
  cPtr_routineDeclaration * _p = NULL ;
  macroMyNew (_p, cPtr_routineDeclaration (mRoutineName, mFormalParameters, mRoutineInstructions COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@routineDeclarationList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_routineDeclarationList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_formalParameters & argument_1,
                    const GGS_semanticInstructions & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_routineDeclarationList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_formalParameters & argument_1,
                    const GGS_semanticInstructions & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_routineDeclarationList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_formalParameters & argument_1,
                                const GGS_semanticInstructions & argument_2) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

GGS_routineDeclarationList GGS_routineDeclarationList::
_operator_concat (const GGS_routineDeclarationList & inOperand) const {
  GGS_routineDeclarationList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_routineDeclaration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mRoutineName ;
          GGS_formalParameters  p_1 = p->mFormalParameters ;
          GGS_semanticInstructions  p_2 = p->mRoutineInstructions ;
          result._internalAppendValues (p_0, p_1, p_2) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_routineDeclarationList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_formalParameters & argument_1,
                     const GGS_semanticInstructions & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_routineDeclarationList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mRoutineName,
                                _p->mFormalParameters,
                                _p->mRoutineInstructions) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_routineDeclarationList  GGS_routineDeclarationList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_routineDeclarationList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_routineDeclarationList  GGS_routineDeclarationList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_formalParameters & argument_1,
                           const GGS_semanticInstructions & argument_2
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_routineDeclarationList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_routineDeclarationList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@routineDeclarationList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_routineDeclarationList::
_addModel (const GGS_routineDeclaration & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_routineDeclarationList::
method_first (C_Compiler & _inLexique,
              GGS_lstring & _out_0,
              GGS_formalParameters & _out_1,
              GGS_semanticInstructions & _out_2
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mRoutineName ;
    _out_1 = _p->mFormalParameters ;
    _out_2 = _p->mRoutineInstructions ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_routineDeclarationList::
method_last (C_Compiler & _inLexique,
             GGS_lstring & _out_0,
             GGS_formalParameters & _out_1,
             GGS_semanticInstructions & _out_2
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mRoutineName ;
    _out_1 = _p->mFormalParameters ;
    _out_2 = _p->mRoutineInstructions ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_routineDeclarationList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_formalParameters & _out_1,
                 GGS_semanticInstructions & _out_2
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mRoutineName ;
    _out_1 = _p->mFormalParameters ;
    _out_2 = _p->mRoutineInstructions ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_routineDeclarationList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lstring & _out_0,
                GGS_formalParameters & _out_1,
                GGS_semanticInstructions & _out_2
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mRoutineName ;
    _out_1 = _p->mFormalParameters ;
    _out_2 = _p->mRoutineInstructions ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_routineDeclaration'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_routineDeclaration GGS_routineDeclaration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_formalParameters & argument_1,
                 const GGS_semanticInstructions & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_routineDeclaration result ;
  macroMyNew (result.mPointer, cPtr_routineDeclaration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_routineDeclaration::
reader_mRoutineName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_routineDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_routineDeclaration *) mPointer)->mRoutineName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameters  GGS_routineDeclaration::
reader_mFormalParameters (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_formalParameters   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_routineDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_routineDeclaration *) mPointer)->mFormalParameters ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructions  GGS_routineDeclaration::
reader_mRoutineInstructions (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructions   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_routineDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_routineDeclaration *) mPointer)->mRoutineInstructions ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_routineDeclaration::actualTypeName (void) const {
 return "routineDeclaration" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_routineDeclaration * GGS_routineDeclaration::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_routineDeclaration *) mPointer ;
  }
#endif

