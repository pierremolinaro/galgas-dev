//---------------------------------------------------------------------------*
//                                                                           *
//                      File 'semanticsMetamodel.cpp'                        *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                        june 7th, 2008, at 13h4'3"                         *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

#include "semanticsMetamodel.h"
#include "utilities/MF_MemoryControl.h"

//---------------------------------------------------------------------------*

#include <typeinfo>

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "semanticsMetamodel.gMetamodel", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif

//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                           Metamodel Management                            *
//                                                                           *
//---------------------------------------------------------------------------*

static C_MetamodelManager gMetamodelManager ("semanticsMetamodel", 25) ;

//---------------------------------------------------------------------------*

sint32 _metamodel_index_for_semanticsMetamodel (void) {
  return gMetamodelManager.mMetamodelComponentIndex ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@semanticsComponentRoot'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_semanticsComponentRoot::
cPtr_semanticsComponentRoot (const GGS_lstring & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS__list_semanticDeclaration & argument_2
                                COMMA_LOCATION_ARGS) :
cPtr_entity (THERE),
mSemanticsComponentName (argument_0),
mImportedComponentFileNameList (argument_1),
mSemanticDeclarationList (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_semanticsComponentRoot::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_semanticsComponentRoot * _p = dynamic_cast <const cPtr_semanticsComponentRoot *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mSemanticsComponentName._operator_isEqual (_p->mSemanticsComponentName).boolValue ()
         && mImportedComponentFileNameList._operator_isEqual (_p->mImportedComponentFileNameList).boolValue ()
         && mSemanticDeclarationList._operator_isEqual (_p->mSemanticDeclarationList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_semanticsComponentRoot::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @semanticsComponentRoot" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSemanticsComponentName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mImportedComponentFileNameList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSemanticDeclarationList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_semanticsComponentRoot::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_semanticsComponentRoot::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_semanticsComponentRoot::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 0 ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_semanticsComponentRoot::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "semanticsComponentRoot" ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_semanticsComponentRoot * cPtr_semanticsComponentRoot::
_cloneObject (void) const {
  cPtr_semanticsComponentRoot * _p = NULL ;
  macroMyNew (_p, cPtr_semanticsComponentRoot (mSemanticsComponentName, mImportedComponentFileNameList, mSemanticDeclarationList COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@_list_semanticsComponentRoot'                    *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_semanticsComponentRoot::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstringlist & argument_1,
                    const GGS__list_semanticDeclaration & argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_semanticsComponentRoot::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstringlist & argument_1,
                    const GGS__list_semanticDeclaration & argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_semanticsComponentRoot::
_addAssign_operation (const GGS_semanticsComponentRoot & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_semanticsComponentRoot GGS__list_semanticsComponentRoot::
_operator_concat (const GGS__list_semanticsComponentRoot & inOperand) const {
  GGS__list_semanticsComponentRoot result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_semanticsComponentRoot::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_semanticsComponentRoot & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_semanticsComponentRoot::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mSemanticsComponentName,
                                _p->mImportedComponentFileNameList,
                                _p->mSemanticDeclarationList) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_semanticsComponentRoot  GGS__list_semanticsComponentRoot::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_semanticsComponentRoot result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_semanticsComponentRoot  GGS__list_semanticsComponentRoot::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_semanticsComponentRoot & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_semanticsComponentRoot result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_semanticsComponentRoot::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_semanticsComponentRoot", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_semanticsComponentRoot::
_addModel (const GGS_semanticsComponentRoot & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_semanticsComponentRoot::
method_first (C_Compiler & _inLexique,
              GGS_semanticsComponentRoot & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_semanticsComponentRoot::constructor_new (_inLexique,
       _p->mSemanticsComponentName,
       _p->mImportedComponentFileNameList,
       _p->mSemanticDeclarationList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_semanticsComponentRoot::
method_last (C_Compiler & _inLexique,
             GGS_semanticsComponentRoot & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_semanticsComponentRoot::constructor_new (_inLexique,
       _p->mSemanticsComponentName,
       _p->mImportedComponentFileNameList,
       _p->mSemanticDeclarationList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_semanticsComponentRoot::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_semanticsComponentRoot & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_semanticsComponentRoot::constructor_new (_inLexique,
       _p->mSemanticsComponentName,
       _p->mImportedComponentFileNameList,
       _p->mSemanticDeclarationList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_semanticsComponentRoot::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_semanticsComponentRoot & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_semanticsComponentRoot::constructor_new (_inLexique,
       _p->mSemanticsComponentName,
       _p->mImportedComponentFileNameList,
       _p->mSemanticDeclarationList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS entity '@semanticsComponentRoot'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_semanticsComponentRoot GGS_semanticsComponentRoot::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstringlist & argument_1,
                 const GGS__list_semanticDeclaration & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_semanticsComponentRoot result ;
  macroMyNew (result.mPointer, cPtr_semanticsComponentRoot (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_semanticsComponentRoot::
reader_mSemanticsComponentName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_semanticsComponentRoot *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_semanticsComponentRoot *) mPointer)->mSemanticsComponentName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_semanticsComponentRoot::
reader_mImportedComponentFileNameList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_semanticsComponentRoot *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_semanticsComponentRoot *) mPointer)->mImportedComponentFileNameList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_semanticDeclaration  GGS_semanticsComponentRoot::
reader_mSemanticDeclarationList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_semanticDeclaration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_semanticsComponentRoot *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_semanticsComponentRoot *) mPointer)->mSemanticDeclarationList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_semanticsComponentRoot::actualTypeName (void) const {
 return "semanticsComponentRoot" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_semanticsComponentRoot * GGS_semanticsComponentRoot::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_semanticsComponentRoot *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@attributeInCollection'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_attributeInCollection::
cPtr_attributeInCollection (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
cPtr_entity (THERE),
mAttributeTypeName (argument_0),
mAttributeName (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_attributeInCollection::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_attributeInCollection * _p = dynamic_cast <const cPtr_attributeInCollection *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mAttributeTypeName._operator_isEqual (_p->mAttributeTypeName).boolValue ()
         && mAttributeName._operator_isEqual (_p->mAttributeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_attributeInCollection::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @attributeInCollection" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAttributeTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAttributeName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_attributeInCollection::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_attributeInCollection::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_attributeInCollection::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 1 ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_attributeInCollection::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "attributeInCollection" ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_attributeInCollection * cPtr_attributeInCollection::
_cloneObject (void) const {
  cPtr_attributeInCollection * _p = NULL ;
  macroMyNew (_p, cPtr_attributeInCollection (mAttributeTypeName, mAttributeName COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@_list_attributeInCollection'                     *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_attributeInCollection::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_attributeInCollection::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_attributeInCollection::
_addAssign_operation (const GGS_attributeInCollection & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_attributeInCollection GGS__list_attributeInCollection::
_operator_concat (const GGS__list_attributeInCollection & inOperand) const {
  GGS__list_attributeInCollection result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_attributeInCollection::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_attributeInCollection & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_attributeInCollection::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mAttributeTypeName,
                                _p->mAttributeName) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_attributeInCollection  GGS__list_attributeInCollection::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_attributeInCollection result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_attributeInCollection  GGS__list_attributeInCollection::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_attributeInCollection & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_attributeInCollection result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_attributeInCollection::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_attributeInCollection", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_attributeInCollection::
_addModel (const GGS_attributeInCollection & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_attributeInCollection::
method_first (C_Compiler & _inLexique,
              GGS_attributeInCollection & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_attributeInCollection::constructor_new (_inLexique,
       _p->mAttributeTypeName,
       _p->mAttributeName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_attributeInCollection::
method_last (C_Compiler & _inLexique,
             GGS_attributeInCollection & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_attributeInCollection::constructor_new (_inLexique,
       _p->mAttributeTypeName,
       _p->mAttributeName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_attributeInCollection::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_attributeInCollection & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_attributeInCollection::constructor_new (_inLexique,
       _p->mAttributeTypeName,
       _p->mAttributeName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_attributeInCollection::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_attributeInCollection & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_attributeInCollection::constructor_new (_inLexique,
       _p->mAttributeTypeName,
       _p->mAttributeName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS entity '@attributeInCollection'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_attributeInCollection GGS_attributeInCollection::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_attributeInCollection result ;
  macroMyNew (result.mPointer, cPtr_attributeInCollection (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_attributeInCollection::
reader_mAttributeTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_attributeInCollection *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_attributeInCollection *) mPointer)->mAttributeTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_attributeInCollection::
reader_mAttributeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_attributeInCollection *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_attributeInCollection *) mPointer)->mAttributeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_attributeInCollection::actualTypeName (void) const {
 return "attributeInCollection" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_attributeInCollection * GGS_attributeInCollection::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_attributeInCollection *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                    Element of list '@mapDeclaration'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_mapDeclaration::
cPtr_mapDeclaration (const GGS_lstring & argument_0,
                                const GGS__list_attributeInCollection & argument_1,
                                const GGS__list_mapMethod & argument_2,
                                const GGS__list_mapMethod & argument_3,
                                const GGS__list_mapMethod & argument_4
                                COMMA_LOCATION_ARGS) :
cPtr_semanticDeclaration (THERE),
mMapTypeName (argument_0),
mAttributeList (argument_1),
mInsertMethodList (argument_2),
mSearchMethodList (argument_3),
mRemoveMethodList (argument_4) {
}

//---------------------------------------------------------------------------*

bool cPtr_mapDeclaration::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_mapDeclaration * _p = dynamic_cast <const cPtr_mapDeclaration *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mMapTypeName._operator_isEqual (_p->mMapTypeName).boolValue ()
         && mAttributeList._operator_isEqual (_p->mAttributeList).boolValue ()
         && mInsertMethodList._operator_isEqual (_p->mInsertMethodList).boolValue ()
         && mSearchMethodList._operator_isEqual (_p->mSearchMethodList).boolValue ()
         && mRemoveMethodList._operator_isEqual (_p->mRemoveMethodList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_mapDeclaration::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @mapDeclaration" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMapTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAttributeList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInsertMethodList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSearchMethodList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRemoveMethodList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_mapDeclaration::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticDeclaration::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_mapDeclaration::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticDeclaration::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_mapDeclaration::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 2 ;
  if (inLevel > 0) {
    result = cPtr_semanticDeclaration::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_mapDeclaration::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "mapDeclaration" ;
  if (inLevel > 0) {
    result = cPtr_semanticDeclaration::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_mapDeclaration * cPtr_mapDeclaration::
_cloneObject (void) const {
  cPtr_mapDeclaration * _p = NULL ;
  macroMyNew (_p, cPtr_mapDeclaration (mMapTypeName, mAttributeList, mInsertMethodList, mSearchMethodList, mRemoveMethodList COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@_list_mapDeclaration'                        *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_mapDeclaration::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS__list_attributeInCollection & argument_1,
                    const GGS__list_mapMethod & argument_2,
                    const GGS__list_mapMethod & argument_3,
                    const GGS__list_mapMethod & argument_4) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_mapDeclaration::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS__list_attributeInCollection & argument_1,
                    const GGS__list_mapMethod & argument_2,
                    const GGS__list_mapMethod & argument_3,
                    const GGS__list_mapMethod & argument_4) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_mapDeclaration::
_addAssign_operation (const GGS_mapDeclaration & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_mapDeclaration GGS__list_mapDeclaration::
_operator_concat (const GGS__list_mapDeclaration & inOperand) const {
  GGS__list_mapDeclaration result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_mapDeclaration::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_mapDeclaration & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_mapDeclaration::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mMapTypeName,
                                _p->mAttributeList,
                                _p->mInsertMethodList,
                                _p->mSearchMethodList,
                                _p->mRemoveMethodList) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_mapDeclaration  GGS__list_mapDeclaration::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_mapDeclaration result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_mapDeclaration  GGS__list_mapDeclaration::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_mapDeclaration & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_mapDeclaration result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_mapDeclaration::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_mapDeclaration", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_mapDeclaration::
_addModel (const GGS_mapDeclaration & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_mapDeclaration::
method_first (C_Compiler & _inLexique,
              GGS_mapDeclaration & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_mapDeclaration::constructor_new (_inLexique,
       _p->mMapTypeName,
       _p->mAttributeList,
       _p->mInsertMethodList,
       _p->mSearchMethodList,
       _p->mRemoveMethodList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_mapDeclaration::
method_last (C_Compiler & _inLexique,
             GGS_mapDeclaration & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_mapDeclaration::constructor_new (_inLexique,
       _p->mMapTypeName,
       _p->mAttributeList,
       _p->mInsertMethodList,
       _p->mSearchMethodList,
       _p->mRemoveMethodList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_mapDeclaration::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_mapDeclaration & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_mapDeclaration::constructor_new (_inLexique,
       _p->mMapTypeName,
       _p->mAttributeList,
       _p->mInsertMethodList,
       _p->mSearchMethodList,
       _p->mRemoveMethodList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_mapDeclaration::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_mapDeclaration & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_mapDeclaration::constructor_new (_inLexique,
       _p->mMapTypeName,
       _p->mAttributeList,
       _p->mInsertMethodList,
       _p->mSearchMethodList,
       _p->mRemoveMethodList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS entity '@mapDeclaration'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_mapDeclaration GGS_mapDeclaration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS__list_attributeInCollection & argument_1,
                 const GGS__list_mapMethod & argument_2,
                 const GGS__list_mapMethod & argument_3,
                 const GGS__list_mapMethod & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_mapDeclaration result ;
  macroMyNew (result.mPointer, cPtr_mapDeclaration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapDeclaration::
reader_mMapTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapDeclaration *) mPointer)->mMapTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_attributeInCollection  GGS_mapDeclaration::
reader_mAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_attributeInCollection   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapDeclaration *) mPointer)->mAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_mapMethod  GGS_mapDeclaration::
reader_mInsertMethodList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_mapMethod   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapDeclaration *) mPointer)->mInsertMethodList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_mapMethod  GGS_mapDeclaration::
reader_mSearchMethodList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_mapMethod   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapDeclaration *) mPointer)->mSearchMethodList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_mapMethod  GGS_mapDeclaration::
reader_mRemoveMethodList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_mapMethod   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapDeclaration *) mPointer)->mRemoveMethodList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_mapDeclaration::actualTypeName (void) const {
 return "mapDeclaration" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_mapDeclaration * GGS_mapDeclaration::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_mapDeclaration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                       Element of list '@mapMethod'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_mapMethod::
cPtr_mapMethod (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3
                                COMMA_LOCATION_ARGS) :
cPtr_entity (THERE),
mMethodName (argument_0),
mGetIDMethodName (argument_1),
mErrorMessage (argument_2),
mShadowErrorMessage (argument_3) {
}

//---------------------------------------------------------------------------*

bool cPtr_mapMethod::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_mapMethod * _p = dynamic_cast <const cPtr_mapMethod *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mMethodName._operator_isEqual (_p->mMethodName).boolValue ()
         && mGetIDMethodName._operator_isEqual (_p->mGetIDMethodName).boolValue ()
         && mErrorMessage._operator_isEqual (_p->mErrorMessage).boolValue ()
         && mShadowErrorMessage._operator_isEqual (_p->mShadowErrorMessage).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_mapMethod::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @mapMethod" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMethodName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mGetIDMethodName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mErrorMessage.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mShadowErrorMessage.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_mapMethod::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_mapMethod::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_mapMethod::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 3 ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_mapMethod::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "mapMethod" ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_mapMethod * cPtr_mapMethod::
_cloneObject (void) const {
  cPtr_mapMethod * _p = NULL ;
  macroMyNew (_p, cPtr_mapMethod (mMethodName, mGetIDMethodName, mErrorMessage, mShadowErrorMessage COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                         List '@_list_mapMethod'                           *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_mapMethod::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_lstring & argument_3) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_mapMethod::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_lstring & argument_3) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_mapMethod::
_addAssign_operation (const GGS_mapMethod & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_mapMethod GGS__list_mapMethod::
_operator_concat (const GGS__list_mapMethod & inOperand) const {
  GGS__list_mapMethod result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_mapMethod::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_mapMethod & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_mapMethod::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mMethodName,
                                _p->mGetIDMethodName,
                                _p->mErrorMessage,
                                _p->mShadowErrorMessage) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_mapMethod  GGS__list_mapMethod::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_mapMethod result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_mapMethod  GGS__list_mapMethod::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_mapMethod & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_mapMethod result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_mapMethod::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_mapMethod", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_mapMethod::
_addModel (const GGS_mapMethod & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_mapMethod::
method_first (C_Compiler & _inLexique,
              GGS_mapMethod & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_mapMethod::constructor_new (_inLexique,
       _p->mMethodName,
       _p->mGetIDMethodName,
       _p->mErrorMessage,
       _p->mShadowErrorMessage) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_mapMethod::
method_last (C_Compiler & _inLexique,
             GGS_mapMethod & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_mapMethod::constructor_new (_inLexique,
       _p->mMethodName,
       _p->mGetIDMethodName,
       _p->mErrorMessage,
       _p->mShadowErrorMessage) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_mapMethod::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_mapMethod & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_mapMethod::constructor_new (_inLexique,
       _p->mMethodName,
       _p->mGetIDMethodName,
       _p->mErrorMessage,
       _p->mShadowErrorMessage) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_mapMethod::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_mapMethod & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_mapMethod::constructor_new (_inLexique,
       _p->mMethodName,
       _p->mGetIDMethodName,
       _p->mErrorMessage,
       _p->mShadowErrorMessage) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                        GALGAS entity '@mapMethod'                         *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_mapMethod GGS_mapMethod::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_lstring & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_mapMethod result ;
  macroMyNew (result.mPointer, cPtr_mapMethod (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapMethod::
reader_mMethodName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapMethod *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapMethod *) mPointer)->mMethodName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapMethod::
reader_mGetIDMethodName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapMethod *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapMethod *) mPointer)->mGetIDMethodName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapMethod::
reader_mErrorMessage (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapMethod *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapMethod *) mPointer)->mErrorMessage ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapMethod::
reader_mShadowErrorMessage (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapMethod *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapMethod *) mPointer)->mShadowErrorMessage ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_mapMethod::actualTypeName (void) const {
 return "mapMethod" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_mapMethod * GGS_mapMethod::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_mapMethod *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@mapindexDeclaration'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_mapindexDeclaration::
cPtr_mapindexDeclaration (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3
                                COMMA_LOCATION_ARGS) :
cPtr_semanticDeclaration (THERE),
mMapIndexName (argument_0),
mMapTypeName (argument_1),
mSearchMethodName (argument_2),
mSearchMethodErrorMessage (argument_3) {
}

//---------------------------------------------------------------------------*

bool cPtr_mapindexDeclaration::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_mapindexDeclaration * _p = dynamic_cast <const cPtr_mapindexDeclaration *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mMapIndexName._operator_isEqual (_p->mMapIndexName).boolValue ()
         && mMapTypeName._operator_isEqual (_p->mMapTypeName).boolValue ()
         && mSearchMethodName._operator_isEqual (_p->mSearchMethodName).boolValue ()
         && mSearchMethodErrorMessage._operator_isEqual (_p->mSearchMethodErrorMessage).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_mapindexDeclaration::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @mapindexDeclaration" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMapIndexName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMapTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSearchMethodName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSearchMethodErrorMessage.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_mapindexDeclaration::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticDeclaration::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_mapindexDeclaration::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticDeclaration::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_mapindexDeclaration::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 4 ;
  if (inLevel > 0) {
    result = cPtr_semanticDeclaration::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_mapindexDeclaration::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "mapindexDeclaration" ;
  if (inLevel > 0) {
    result = cPtr_semanticDeclaration::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_mapindexDeclaration * cPtr_mapindexDeclaration::
_cloneObject (void) const {
  cPtr_mapindexDeclaration * _p = NULL ;
  macroMyNew (_p, cPtr_mapindexDeclaration (mMapIndexName, mMapTypeName, mSearchMethodName, mSearchMethodErrorMessage COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@_list_mapindexDeclaration'                      *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_mapindexDeclaration::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_lstring & argument_3) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_mapindexDeclaration::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_lstring & argument_3) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_mapindexDeclaration::
_addAssign_operation (const GGS_mapindexDeclaration & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_mapindexDeclaration GGS__list_mapindexDeclaration::
_operator_concat (const GGS__list_mapindexDeclaration & inOperand) const {
  GGS__list_mapindexDeclaration result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_mapindexDeclaration::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_mapindexDeclaration & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_mapindexDeclaration::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mMapIndexName,
                                _p->mMapTypeName,
                                _p->mSearchMethodName,
                                _p->mSearchMethodErrorMessage) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_mapindexDeclaration  GGS__list_mapindexDeclaration::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_mapindexDeclaration result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_mapindexDeclaration  GGS__list_mapindexDeclaration::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_mapindexDeclaration & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_mapindexDeclaration result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_mapindexDeclaration::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_mapindexDeclaration", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_mapindexDeclaration::
_addModel (const GGS_mapindexDeclaration & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_mapindexDeclaration::
method_first (C_Compiler & _inLexique,
              GGS_mapindexDeclaration & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_mapindexDeclaration::constructor_new (_inLexique,
       _p->mMapIndexName,
       _p->mMapTypeName,
       _p->mSearchMethodName,
       _p->mSearchMethodErrorMessage) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_mapindexDeclaration::
method_last (C_Compiler & _inLexique,
             GGS_mapindexDeclaration & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_mapindexDeclaration::constructor_new (_inLexique,
       _p->mMapIndexName,
       _p->mMapTypeName,
       _p->mSearchMethodName,
       _p->mSearchMethodErrorMessage) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_mapindexDeclaration::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_mapindexDeclaration & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_mapindexDeclaration::constructor_new (_inLexique,
       _p->mMapIndexName,
       _p->mMapTypeName,
       _p->mSearchMethodName,
       _p->mSearchMethodErrorMessage) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_mapindexDeclaration::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_mapindexDeclaration & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_mapindexDeclaration::constructor_new (_inLexique,
       _p->mMapIndexName,
       _p->mMapTypeName,
       _p->mSearchMethodName,
       _p->mSearchMethodErrorMessage) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS entity '@mapindexDeclaration'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_mapindexDeclaration GGS_mapindexDeclaration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_lstring & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_mapindexDeclaration result ;
  macroMyNew (result.mPointer, cPtr_mapindexDeclaration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapindexDeclaration::
reader_mMapIndexName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapindexDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapindexDeclaration *) mPointer)->mMapIndexName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapindexDeclaration::
reader_mMapTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapindexDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapindexDeclaration *) mPointer)->mMapTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapindexDeclaration::
reader_mSearchMethodName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapindexDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapindexDeclaration *) mPointer)->mSearchMethodName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapindexDeclaration::
reader_mSearchMethodErrorMessage (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapindexDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapindexDeclaration *) mPointer)->mSearchMethodErrorMessage ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_mapindexDeclaration::actualTypeName (void) const {
 return "mapindexDeclaration" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_mapindexDeclaration * GGS_mapindexDeclaration::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_mapindexDeclaration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                   Element of list '@classDeclaration'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_classDeclaration::
cPtr_classDeclaration (const GGS_bool& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS__list_attributeInCollection & argument_3,
                                const GGS__list_abstractMethodDefinition & argument_4,
                                const GGS__list_overridenMethodDefinition & argument_5,
                                const GGS__list_methodDefinition & argument_6,
                                const GGS__list_classMessageDefinition & argument_7,
                                const GGS_string& argument_8
                                COMMA_LOCATION_ARGS) :
cPtr_semanticDeclaration (THERE),
mIsAbstract (argument_0),
mClassTypeName (argument_1),
mSuperClassName (argument_2),
mAttributeList (argument_3),
mAbstractMethodList (argument_4),
mOverridenMethodList (argument_5),
mMethodList (argument_6),
mMessageList (argument_7),
mClassMessage (argument_8) {
}

//---------------------------------------------------------------------------*

bool cPtr_classDeclaration::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_classDeclaration * _p = dynamic_cast <const cPtr_classDeclaration *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mIsAbstract._operator_isEqual (_p->mIsAbstract).boolValue ()
         && mClassTypeName._operator_isEqual (_p->mClassTypeName).boolValue ()
         && mSuperClassName._operator_isEqual (_p->mSuperClassName).boolValue ()
         && mAttributeList._operator_isEqual (_p->mAttributeList).boolValue ()
         && mAbstractMethodList._operator_isEqual (_p->mAbstractMethodList).boolValue ()
         && mOverridenMethodList._operator_isEqual (_p->mOverridenMethodList).boolValue ()
         && mMethodList._operator_isEqual (_p->mMethodList).boolValue ()
         && mMessageList._operator_isEqual (_p->mMessageList).boolValue ()
         && mClassMessage._operator_isEqual (_p->mClassMessage).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_classDeclaration::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @classDeclaration" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mIsAbstract.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mClassTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSuperClassName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAttributeList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAbstractMethodList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOverridenMethodList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMethodList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMessageList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mClassMessage.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_classDeclaration::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticDeclaration::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_classDeclaration::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticDeclaration::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_classDeclaration::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 5 ;
  if (inLevel > 0) {
    result = cPtr_semanticDeclaration::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_classDeclaration::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "classDeclaration" ;
  if (inLevel > 0) {
    result = cPtr_semanticDeclaration::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_classDeclaration * cPtr_classDeclaration::
_cloneObject (void) const {
  cPtr_classDeclaration * _p = NULL ;
  macroMyNew (_p, cPtr_classDeclaration (mIsAbstract, mClassTypeName, mSuperClassName, mAttributeList, mAbstractMethodList, mOverridenMethodList, mMethodList, mMessageList, mClassMessage COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@_list_classDeclaration'                       *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_classDeclaration::
_internalAppendValues (const GGS_bool& argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS__list_attributeInCollection & argument_3,
                    const GGS__list_abstractMethodDefinition & argument_4,
                    const GGS__list_overridenMethodDefinition & argument_5,
                    const GGS__list_methodDefinition & argument_6,
                    const GGS__list_classMessageDefinition & argument_7,
                    const GGS_string& argument_8) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7,
                                argument_8
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_classDeclaration::
_internalPrependValues (const GGS_bool& argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS__list_attributeInCollection & argument_3,
                    const GGS__list_abstractMethodDefinition & argument_4,
                    const GGS__list_overridenMethodDefinition & argument_5,
                    const GGS__list_methodDefinition & argument_6,
                    const GGS__list_classMessageDefinition & argument_7,
                    const GGS_string& argument_8) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7,
                                argument_8
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_classDeclaration::
_addAssign_operation (const GGS_classDeclaration & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_classDeclaration GGS__list_classDeclaration::
_operator_concat (const GGS__list_classDeclaration & inOperand) const {
  GGS__list_classDeclaration result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_classDeclaration::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_classDeclaration & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_classDeclaration::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mIsAbstract,
                                _p->mClassTypeName,
                                _p->mSuperClassName,
                                _p->mAttributeList,
                                _p->mAbstractMethodList,
                                _p->mOverridenMethodList,
                                _p->mMethodList,
                                _p->mMessageList,
                                _p->mClassMessage) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_classDeclaration  GGS__list_classDeclaration::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_classDeclaration result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_classDeclaration  GGS__list_classDeclaration::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_classDeclaration & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_classDeclaration result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_classDeclaration::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_classDeclaration", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_classDeclaration::
_addModel (const GGS_classDeclaration & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_classDeclaration::
method_first (C_Compiler & _inLexique,
              GGS_classDeclaration & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_classDeclaration::constructor_new (_inLexique,
       _p->mIsAbstract,
       _p->mClassTypeName,
       _p->mSuperClassName,
       _p->mAttributeList,
       _p->mAbstractMethodList,
       _p->mOverridenMethodList,
       _p->mMethodList,
       _p->mMessageList,
       _p->mClassMessage) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_classDeclaration::
method_last (C_Compiler & _inLexique,
             GGS_classDeclaration & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_classDeclaration::constructor_new (_inLexique,
       _p->mIsAbstract,
       _p->mClassTypeName,
       _p->mSuperClassName,
       _p->mAttributeList,
       _p->mAbstractMethodList,
       _p->mOverridenMethodList,
       _p->mMethodList,
       _p->mMessageList,
       _p->mClassMessage) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_classDeclaration::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_classDeclaration & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_classDeclaration::constructor_new (_inLexique,
       _p->mIsAbstract,
       _p->mClassTypeName,
       _p->mSuperClassName,
       _p->mAttributeList,
       _p->mAbstractMethodList,
       _p->mOverridenMethodList,
       _p->mMethodList,
       _p->mMessageList,
       _p->mClassMessage) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_classDeclaration::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_classDeclaration & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_classDeclaration::constructor_new (_inLexique,
       _p->mIsAbstract,
       _p->mClassTypeName,
       _p->mSuperClassName,
       _p->mAttributeList,
       _p->mAbstractMethodList,
       _p->mOverridenMethodList,
       _p->mMethodList,
       _p->mMessageList,
       _p->mClassMessage) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS entity '@classDeclaration'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_classDeclaration GGS_classDeclaration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_bool& argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS__list_attributeInCollection & argument_3,
                 const GGS__list_abstractMethodDefinition & argument_4,
                 const GGS__list_overridenMethodDefinition & argument_5,
                 const GGS__list_methodDefinition & argument_6,
                 const GGS__list_classMessageDefinition & argument_7,
                 const GGS_string& argument_8
                                COMMA_LOCATION_ARGS) {
  GGS_classDeclaration result ;
  macroMyNew (result.mPointer, cPtr_classDeclaration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7,
                                argument_8 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_classDeclaration::
reader_mIsAbstract (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classDeclaration *) mPointer)->mIsAbstract ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_classDeclaration::
reader_mClassTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classDeclaration *) mPointer)->mClassTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_classDeclaration::
reader_mSuperClassName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classDeclaration *) mPointer)->mSuperClassName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_attributeInCollection  GGS_classDeclaration::
reader_mAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_attributeInCollection   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classDeclaration *) mPointer)->mAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_abstractMethodDefinition  GGS_classDeclaration::
reader_mAbstractMethodList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_abstractMethodDefinition   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classDeclaration *) mPointer)->mAbstractMethodList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_overridenMethodDefinition  GGS_classDeclaration::
reader_mOverridenMethodList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_overridenMethodDefinition   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classDeclaration *) mPointer)->mOverridenMethodList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_methodDefinition  GGS_classDeclaration::
reader_mMethodList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_methodDefinition   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classDeclaration *) mPointer)->mMethodList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_classMessageDefinition  GGS_classDeclaration::
reader_mMessageList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_classMessageDefinition   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classDeclaration *) mPointer)->mMessageList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_classDeclaration::
reader_mClassMessage (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classDeclaration *) mPointer)->mClassMessage ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_classDeclaration::actualTypeName (void) const {
 return "classDeclaration" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_classDeclaration * GGS_classDeclaration::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_classDeclaration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@abstractMethodDefinition'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_abstractMethodDefinition::
cPtr_abstractMethodDefinition (const GGS_lstring & argument_0,
                                const GGS_formalParameters & argument_1
                                COMMA_LOCATION_ARGS) :
cPtr_entity (THERE),
mMethodName (argument_0),
mSignature (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_abstractMethodDefinition::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_abstractMethodDefinition * _p = dynamic_cast <const cPtr_abstractMethodDefinition *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mMethodName._operator_isEqual (_p->mMethodName).boolValue ()
         && mSignature._operator_isEqual (_p->mSignature).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_abstractMethodDefinition::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @abstractMethodDefinition" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMethodName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSignature.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_abstractMethodDefinition::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_abstractMethodDefinition::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_abstractMethodDefinition::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 6 ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_abstractMethodDefinition::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "abstractMethodDefinition" ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_abstractMethodDefinition * cPtr_abstractMethodDefinition::
_cloneObject (void) const {
  cPtr_abstractMethodDefinition * _p = NULL ;
  macroMyNew (_p, cPtr_abstractMethodDefinition (mMethodName, mSignature COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@_list_abstractMethodDefinition'                   *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_abstractMethodDefinition::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_formalParameters & argument_1) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_abstractMethodDefinition::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_formalParameters & argument_1) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_abstractMethodDefinition::
_addAssign_operation (const GGS_abstractMethodDefinition & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_abstractMethodDefinition GGS__list_abstractMethodDefinition::
_operator_concat (const GGS__list_abstractMethodDefinition & inOperand) const {
  GGS__list_abstractMethodDefinition result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_abstractMethodDefinition::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_abstractMethodDefinition & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_abstractMethodDefinition::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mMethodName,
                                _p->mSignature) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_abstractMethodDefinition  GGS__list_abstractMethodDefinition::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_abstractMethodDefinition result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_abstractMethodDefinition  GGS__list_abstractMethodDefinition::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_abstractMethodDefinition & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_abstractMethodDefinition result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_abstractMethodDefinition::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_abstractMethodDefinition", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_abstractMethodDefinition::
_addModel (const GGS_abstractMethodDefinition & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_abstractMethodDefinition::
method_first (C_Compiler & _inLexique,
              GGS_abstractMethodDefinition & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_abstractMethodDefinition::constructor_new (_inLexique,
       _p->mMethodName,
       _p->mSignature) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_abstractMethodDefinition::
method_last (C_Compiler & _inLexique,
             GGS_abstractMethodDefinition & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_abstractMethodDefinition::constructor_new (_inLexique,
       _p->mMethodName,
       _p->mSignature) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_abstractMethodDefinition::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_abstractMethodDefinition & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_abstractMethodDefinition::constructor_new (_inLexique,
       _p->mMethodName,
       _p->mSignature) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_abstractMethodDefinition::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_abstractMethodDefinition & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_abstractMethodDefinition::constructor_new (_inLexique,
       _p->mMethodName,
       _p->mSignature) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS entity '@abstractMethodDefinition'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_abstractMethodDefinition GGS_abstractMethodDefinition::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_formalParameters & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_abstractMethodDefinition result ;
  macroMyNew (result.mPointer, cPtr_abstractMethodDefinition (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_abstractMethodDefinition::
reader_mMethodName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_abstractMethodDefinition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_abstractMethodDefinition *) mPointer)->mMethodName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameters  GGS_abstractMethodDefinition::
reader_mSignature (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_formalParameters   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_abstractMethodDefinition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_abstractMethodDefinition *) mPointer)->mSignature ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_abstractMethodDefinition::actualTypeName (void) const {
 return "abstractMethodDefinition" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_abstractMethodDefinition * GGS_abstractMethodDefinition::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_abstractMethodDefinition *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@overridenMethodDefinition'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_overridenMethodDefinition::
cPtr_overridenMethodDefinition (const GGS_lstring & argument_0,
                                const GGS_formalParameters & argument_1,
                                const GGS_semanticInstructions & argument_2
                                COMMA_LOCATION_ARGS) :
cPtr_entity (THERE),
mMethodName (argument_0),
mSignature (argument_1),
mInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_overridenMethodDefinition::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_overridenMethodDefinition * _p = dynamic_cast <const cPtr_overridenMethodDefinition *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mMethodName._operator_isEqual (_p->mMethodName).boolValue ()
         && mSignature._operator_isEqual (_p->mSignature).boolValue ()
         && mInstructionList._operator_isEqual (_p->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_overridenMethodDefinition::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @overridenMethodDefinition" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMethodName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSignature.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_overridenMethodDefinition::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_overridenMethodDefinition::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_overridenMethodDefinition::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 7 ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_overridenMethodDefinition::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "overridenMethodDefinition" ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_overridenMethodDefinition * cPtr_overridenMethodDefinition::
_cloneObject (void) const {
  cPtr_overridenMethodDefinition * _p = NULL ;
  macroMyNew (_p, cPtr_overridenMethodDefinition (mMethodName, mSignature, mInstructionList COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                 List '@_list_overridenMethodDefinition'                   *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_overridenMethodDefinition::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_formalParameters & argument_1,
                    const GGS_semanticInstructions & argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_overridenMethodDefinition::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_formalParameters & argument_1,
                    const GGS_semanticInstructions & argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_overridenMethodDefinition::
_addAssign_operation (const GGS_overridenMethodDefinition & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_overridenMethodDefinition GGS__list_overridenMethodDefinition::
_operator_concat (const GGS__list_overridenMethodDefinition & inOperand) const {
  GGS__list_overridenMethodDefinition result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_overridenMethodDefinition::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_overridenMethodDefinition & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_overridenMethodDefinition::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mMethodName,
                                _p->mSignature,
                                _p->mInstructionList) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_overridenMethodDefinition  GGS__list_overridenMethodDefinition::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_overridenMethodDefinition result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_overridenMethodDefinition  GGS__list_overridenMethodDefinition::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_overridenMethodDefinition & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_overridenMethodDefinition result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_overridenMethodDefinition::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_overridenMethodDefinition", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_overridenMethodDefinition::
_addModel (const GGS_overridenMethodDefinition & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_overridenMethodDefinition::
method_first (C_Compiler & _inLexique,
              GGS_overridenMethodDefinition & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_overridenMethodDefinition::constructor_new (_inLexique,
       _p->mMethodName,
       _p->mSignature,
       _p->mInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_overridenMethodDefinition::
method_last (C_Compiler & _inLexique,
             GGS_overridenMethodDefinition & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_overridenMethodDefinition::constructor_new (_inLexique,
       _p->mMethodName,
       _p->mSignature,
       _p->mInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_overridenMethodDefinition::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_overridenMethodDefinition & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_overridenMethodDefinition::constructor_new (_inLexique,
       _p->mMethodName,
       _p->mSignature,
       _p->mInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_overridenMethodDefinition::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_overridenMethodDefinition & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_overridenMethodDefinition::constructor_new (_inLexique,
       _p->mMethodName,
       _p->mSignature,
       _p->mInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS entity '@overridenMethodDefinition'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_overridenMethodDefinition GGS_overridenMethodDefinition::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_formalParameters & argument_1,
                 const GGS_semanticInstructions & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_overridenMethodDefinition result ;
  macroMyNew (result.mPointer, cPtr_overridenMethodDefinition (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_overridenMethodDefinition::
reader_mMethodName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_overridenMethodDefinition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_overridenMethodDefinition *) mPointer)->mMethodName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameters  GGS_overridenMethodDefinition::
reader_mSignature (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_formalParameters   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_overridenMethodDefinition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_overridenMethodDefinition *) mPointer)->mSignature ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructions  GGS_overridenMethodDefinition::
reader_mInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructions   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_overridenMethodDefinition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_overridenMethodDefinition *) mPointer)->mInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_overridenMethodDefinition::actualTypeName (void) const {
 return "overridenMethodDefinition" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_overridenMethodDefinition * GGS_overridenMethodDefinition::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_overridenMethodDefinition *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                   Element of list '@methodDefinition'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_methodDefinition::
cPtr_methodDefinition (const GGS_lstring & argument_0,
                                const GGS_formalParameters & argument_1,
                                const GGS_semanticInstructions & argument_2
                                COMMA_LOCATION_ARGS) :
cPtr_entity (THERE),
mMethodName (argument_0),
mSignature (argument_1),
mInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_methodDefinition::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_methodDefinition * _p = dynamic_cast <const cPtr_methodDefinition *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mMethodName._operator_isEqual (_p->mMethodName).boolValue ()
         && mSignature._operator_isEqual (_p->mSignature).boolValue ()
         && mInstructionList._operator_isEqual (_p->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_methodDefinition::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @methodDefinition" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMethodName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSignature.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_methodDefinition::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_methodDefinition::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_methodDefinition::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 8 ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_methodDefinition::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "methodDefinition" ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_methodDefinition * cPtr_methodDefinition::
_cloneObject (void) const {
  cPtr_methodDefinition * _p = NULL ;
  macroMyNew (_p, cPtr_methodDefinition (mMethodName, mSignature, mInstructionList COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@_list_methodDefinition'                       *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_methodDefinition::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_formalParameters & argument_1,
                    const GGS_semanticInstructions & argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_methodDefinition::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_formalParameters & argument_1,
                    const GGS_semanticInstructions & argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_methodDefinition::
_addAssign_operation (const GGS_methodDefinition & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_methodDefinition GGS__list_methodDefinition::
_operator_concat (const GGS__list_methodDefinition & inOperand) const {
  GGS__list_methodDefinition result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_methodDefinition::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_methodDefinition & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_methodDefinition::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mMethodName,
                                _p->mSignature,
                                _p->mInstructionList) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_methodDefinition  GGS__list_methodDefinition::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_methodDefinition result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_methodDefinition  GGS__list_methodDefinition::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_methodDefinition & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_methodDefinition result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_methodDefinition::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_methodDefinition", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_methodDefinition::
_addModel (const GGS_methodDefinition & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_methodDefinition::
method_first (C_Compiler & _inLexique,
              GGS_methodDefinition & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_methodDefinition::constructor_new (_inLexique,
       _p->mMethodName,
       _p->mSignature,
       _p->mInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_methodDefinition::
method_last (C_Compiler & _inLexique,
             GGS_methodDefinition & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_methodDefinition::constructor_new (_inLexique,
       _p->mMethodName,
       _p->mSignature,
       _p->mInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_methodDefinition::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_methodDefinition & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_methodDefinition::constructor_new (_inLexique,
       _p->mMethodName,
       _p->mSignature,
       _p->mInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_methodDefinition::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_methodDefinition & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_methodDefinition::constructor_new (_inLexique,
       _p->mMethodName,
       _p->mSignature,
       _p->mInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS entity '@methodDefinition'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_methodDefinition GGS_methodDefinition::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_formalParameters & argument_1,
                 const GGS_semanticInstructions & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_methodDefinition result ;
  macroMyNew (result.mPointer, cPtr_methodDefinition (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_methodDefinition::
reader_mMethodName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_methodDefinition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_methodDefinition *) mPointer)->mMethodName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameters  GGS_methodDefinition::
reader_mSignature (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_formalParameters   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_methodDefinition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_methodDefinition *) mPointer)->mSignature ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructions  GGS_methodDefinition::
reader_mInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructions   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_methodDefinition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_methodDefinition *) mPointer)->mInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_methodDefinition::actualTypeName (void) const {
 return "methodDefinition" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_methodDefinition * GGS_methodDefinition::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_methodDefinition *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@classMessageDefinition'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_classMessageDefinition::
cPtr_classMessageDefinition (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
cPtr_entity (THERE),
mMessageName (argument_0),
mMessageValue (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_classMessageDefinition::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_classMessageDefinition * _p = dynamic_cast <const cPtr_classMessageDefinition *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mMessageName._operator_isEqual (_p->mMessageName).boolValue ()
         && mMessageValue._operator_isEqual (_p->mMessageValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_classMessageDefinition::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @classMessageDefinition" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMessageName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMessageValue.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_classMessageDefinition::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_classMessageDefinition::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_classMessageDefinition::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 9 ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_classMessageDefinition::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "classMessageDefinition" ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_classMessageDefinition * cPtr_classMessageDefinition::
_cloneObject (void) const {
  cPtr_classMessageDefinition * _p = NULL ;
  macroMyNew (_p, cPtr_classMessageDefinition (mMessageName, mMessageValue COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@_list_classMessageDefinition'                    *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_classMessageDefinition::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_classMessageDefinition::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_classMessageDefinition::
_addAssign_operation (const GGS_classMessageDefinition & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_classMessageDefinition GGS__list_classMessageDefinition::
_operator_concat (const GGS__list_classMessageDefinition & inOperand) const {
  GGS__list_classMessageDefinition result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_classMessageDefinition::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_classMessageDefinition & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_classMessageDefinition::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mMessageName,
                                _p->mMessageValue) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_classMessageDefinition  GGS__list_classMessageDefinition::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_classMessageDefinition result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_classMessageDefinition  GGS__list_classMessageDefinition::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_classMessageDefinition & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_classMessageDefinition result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_classMessageDefinition::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_classMessageDefinition", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_classMessageDefinition::
_addModel (const GGS_classMessageDefinition & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_classMessageDefinition::
method_first (C_Compiler & _inLexique,
              GGS_classMessageDefinition & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_classMessageDefinition::constructor_new (_inLexique,
       _p->mMessageName,
       _p->mMessageValue) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_classMessageDefinition::
method_last (C_Compiler & _inLexique,
             GGS_classMessageDefinition & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_classMessageDefinition::constructor_new (_inLexique,
       _p->mMessageName,
       _p->mMessageValue) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_classMessageDefinition::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_classMessageDefinition & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_classMessageDefinition::constructor_new (_inLexique,
       _p->mMessageName,
       _p->mMessageValue) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_classMessageDefinition::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_classMessageDefinition & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_classMessageDefinition::constructor_new (_inLexique,
       _p->mMessageName,
       _p->mMessageValue) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS entity '@classMessageDefinition'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_classMessageDefinition GGS_classMessageDefinition::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_classMessageDefinition result ;
  macroMyNew (result.mPointer, cPtr_classMessageDefinition (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_classMessageDefinition::
reader_mMessageName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classMessageDefinition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classMessageDefinition *) mPointer)->mMessageName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_classMessageDefinition::
reader_mMessageValue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classMessageDefinition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classMessageDefinition *) mPointer)->mMessageValue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_classMessageDefinition::actualTypeName (void) const {
 return "classMessageDefinition" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_classMessageDefinition * GGS_classMessageDefinition::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_classMessageDefinition *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                    Element of list '@listDeclaration'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_listDeclaration::
cPtr_listDeclaration (const GGS_lstring & argument_0,
                                const GGS__list_attributeInCollection & argument_1
                                COMMA_LOCATION_ARGS) :
cPtr_semanticDeclaration (THERE),
mListTypeName (argument_0),
mAttributeList (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_listDeclaration::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_listDeclaration * _p = dynamic_cast <const cPtr_listDeclaration *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mListTypeName._operator_isEqual (_p->mListTypeName).boolValue ()
         && mAttributeList._operator_isEqual (_p->mAttributeList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_listDeclaration::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @listDeclaration" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mListTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAttributeList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_listDeclaration::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticDeclaration::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_listDeclaration::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticDeclaration::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_listDeclaration::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 10 ;
  if (inLevel > 0) {
    result = cPtr_semanticDeclaration::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_listDeclaration::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "listDeclaration" ;
  if (inLevel > 0) {
    result = cPtr_semanticDeclaration::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_listDeclaration * cPtr_listDeclaration::
_cloneObject (void) const {
  cPtr_listDeclaration * _p = NULL ;
  macroMyNew (_p, cPtr_listDeclaration (mListTypeName, mAttributeList COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@_list_listDeclaration'                        *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_listDeclaration::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS__list_attributeInCollection & argument_1) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_listDeclaration::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS__list_attributeInCollection & argument_1) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_listDeclaration::
_addAssign_operation (const GGS_listDeclaration & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_listDeclaration GGS__list_listDeclaration::
_operator_concat (const GGS__list_listDeclaration & inOperand) const {
  GGS__list_listDeclaration result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_listDeclaration::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_listDeclaration & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_listDeclaration::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mListTypeName,
                                _p->mAttributeList) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_listDeclaration  GGS__list_listDeclaration::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_listDeclaration result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_listDeclaration  GGS__list_listDeclaration::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_listDeclaration & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_listDeclaration result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_listDeclaration::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_listDeclaration", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_listDeclaration::
_addModel (const GGS_listDeclaration & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_listDeclaration::
method_first (C_Compiler & _inLexique,
              GGS_listDeclaration & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_listDeclaration::constructor_new (_inLexique,
       _p->mListTypeName,
       _p->mAttributeList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_listDeclaration::
method_last (C_Compiler & _inLexique,
             GGS_listDeclaration & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_listDeclaration::constructor_new (_inLexique,
       _p->mListTypeName,
       _p->mAttributeList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_listDeclaration::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_listDeclaration & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_listDeclaration::constructor_new (_inLexique,
       _p->mListTypeName,
       _p->mAttributeList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_listDeclaration::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_listDeclaration & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_listDeclaration::constructor_new (_inLexique,
       _p->mListTypeName,
       _p->mAttributeList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS entity '@listDeclaration'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_listDeclaration GGS_listDeclaration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS__list_attributeInCollection & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_listDeclaration result ;
  macroMyNew (result.mPointer, cPtr_listDeclaration (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_listDeclaration::
reader_mListTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_listDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_listDeclaration *) mPointer)->mListTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_attributeInCollection  GGS_listDeclaration::
reader_mAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_attributeInCollection   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_listDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_listDeclaration *) mPointer)->mAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_listDeclaration::actualTypeName (void) const {
 return "listDeclaration" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_listDeclaration * GGS_listDeclaration::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_listDeclaration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@sortedListSortDescriptor'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_sortedListSortDescriptor::
cPtr_sortedListSortDescriptor (const GGS_lstring & argument_0,
                                const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS) :
cPtr_entity (THERE),
mSortedAttributeName (argument_0),
mAscending (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_sortedListSortDescriptor::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_sortedListSortDescriptor * _p = dynamic_cast <const cPtr_sortedListSortDescriptor *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mSortedAttributeName._operator_isEqual (_p->mSortedAttributeName).boolValue ()
         && mAscending._operator_isEqual (_p->mAscending).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_sortedListSortDescriptor::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @sortedListSortDescriptor" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSortedAttributeName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAscending.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_sortedListSortDescriptor::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_sortedListSortDescriptor::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_sortedListSortDescriptor::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 11 ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_sortedListSortDescriptor::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "sortedListSortDescriptor" ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_sortedListSortDescriptor * cPtr_sortedListSortDescriptor::
_cloneObject (void) const {
  cPtr_sortedListSortDescriptor * _p = NULL ;
  macroMyNew (_p, cPtr_sortedListSortDescriptor (mSortedAttributeName, mAscending COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@_list_sortedListSortDescriptor'                   *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_sortedListSortDescriptor::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_bool& argument_1) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_sortedListSortDescriptor::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_bool& argument_1) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_sortedListSortDescriptor::
_addAssign_operation (const GGS_sortedListSortDescriptor & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_sortedListSortDescriptor GGS__list_sortedListSortDescriptor::
_operator_concat (const GGS__list_sortedListSortDescriptor & inOperand) const {
  GGS__list_sortedListSortDescriptor result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_sortedListSortDescriptor::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_sortedListSortDescriptor & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_sortedListSortDescriptor::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mSortedAttributeName,
                                _p->mAscending) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_sortedListSortDescriptor  GGS__list_sortedListSortDescriptor::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_sortedListSortDescriptor result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_sortedListSortDescriptor  GGS__list_sortedListSortDescriptor::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_sortedListSortDescriptor & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_sortedListSortDescriptor result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_sortedListSortDescriptor::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_sortedListSortDescriptor", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_sortedListSortDescriptor::
_addModel (const GGS_sortedListSortDescriptor & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_sortedListSortDescriptor::
method_first (C_Compiler & _inLexique,
              GGS_sortedListSortDescriptor & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_sortedListSortDescriptor::constructor_new (_inLexique,
       _p->mSortedAttributeName,
       _p->mAscending) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_sortedListSortDescriptor::
method_last (C_Compiler & _inLexique,
             GGS_sortedListSortDescriptor & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_sortedListSortDescriptor::constructor_new (_inLexique,
       _p->mSortedAttributeName,
       _p->mAscending) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_sortedListSortDescriptor::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_sortedListSortDescriptor & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_sortedListSortDescriptor::constructor_new (_inLexique,
       _p->mSortedAttributeName,
       _p->mAscending) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_sortedListSortDescriptor::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_sortedListSortDescriptor & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_sortedListSortDescriptor::constructor_new (_inLexique,
       _p->mSortedAttributeName,
       _p->mAscending) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS entity '@sortedListSortDescriptor'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_sortedListSortDescriptor GGS_sortedListSortDescriptor::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_sortedListSortDescriptor result ;
  macroMyNew (result.mPointer, cPtr_sortedListSortDescriptor (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_sortedListSortDescriptor::
reader_mSortedAttributeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sortedListSortDescriptor *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sortedListSortDescriptor *) mPointer)->mSortedAttributeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_sortedListSortDescriptor::
reader_mAscending (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sortedListSortDescriptor *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sortedListSortDescriptor *) mPointer)->mAscending ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_sortedListSortDescriptor::actualTypeName (void) const {
 return "sortedListSortDescriptor" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_sortedListSortDescriptor * GGS_sortedListSortDescriptor::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_sortedListSortDescriptor *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@sortedListDeclaration'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_sortedListDeclaration::
cPtr_sortedListDeclaration (const GGS_lstring & argument_0,
                                const GGS__list_attributeInCollection & argument_1,
                                const GGS__list_sortedListSortDescriptor & argument_2
                                COMMA_LOCATION_ARGS) :
cPtr_semanticDeclaration (THERE),
mSortedListTypeName (argument_0),
mAttributeList (argument_1),
mSortDescriptorList (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_sortedListDeclaration::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_sortedListDeclaration * _p = dynamic_cast <const cPtr_sortedListDeclaration *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mSortedListTypeName._operator_isEqual (_p->mSortedListTypeName).boolValue ()
         && mAttributeList._operator_isEqual (_p->mAttributeList).boolValue ()
         && mSortDescriptorList._operator_isEqual (_p->mSortDescriptorList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_sortedListDeclaration::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @sortedListDeclaration" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSortedListTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAttributeList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSortDescriptorList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_sortedListDeclaration::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticDeclaration::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_sortedListDeclaration::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticDeclaration::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_sortedListDeclaration::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 12 ;
  if (inLevel > 0) {
    result = cPtr_semanticDeclaration::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_sortedListDeclaration::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "sortedListDeclaration" ;
  if (inLevel > 0) {
    result = cPtr_semanticDeclaration::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_sortedListDeclaration * cPtr_sortedListDeclaration::
_cloneObject (void) const {
  cPtr_sortedListDeclaration * _p = NULL ;
  macroMyNew (_p, cPtr_sortedListDeclaration (mSortedListTypeName, mAttributeList, mSortDescriptorList COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@_list_sortedListDeclaration'                     *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_sortedListDeclaration::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS__list_attributeInCollection & argument_1,
                    const GGS__list_sortedListSortDescriptor & argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_sortedListDeclaration::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS__list_attributeInCollection & argument_1,
                    const GGS__list_sortedListSortDescriptor & argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_sortedListDeclaration::
_addAssign_operation (const GGS_sortedListDeclaration & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_sortedListDeclaration GGS__list_sortedListDeclaration::
_operator_concat (const GGS__list_sortedListDeclaration & inOperand) const {
  GGS__list_sortedListDeclaration result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_sortedListDeclaration::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_sortedListDeclaration & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_sortedListDeclaration::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mSortedListTypeName,
                                _p->mAttributeList,
                                _p->mSortDescriptorList) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_sortedListDeclaration  GGS__list_sortedListDeclaration::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_sortedListDeclaration result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_sortedListDeclaration  GGS__list_sortedListDeclaration::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_sortedListDeclaration & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_sortedListDeclaration result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_sortedListDeclaration::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_sortedListDeclaration", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_sortedListDeclaration::
_addModel (const GGS_sortedListDeclaration & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_sortedListDeclaration::
method_first (C_Compiler & _inLexique,
              GGS_sortedListDeclaration & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_sortedListDeclaration::constructor_new (_inLexique,
       _p->mSortedListTypeName,
       _p->mAttributeList,
       _p->mSortDescriptorList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_sortedListDeclaration::
method_last (C_Compiler & _inLexique,
             GGS_sortedListDeclaration & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_sortedListDeclaration::constructor_new (_inLexique,
       _p->mSortedListTypeName,
       _p->mAttributeList,
       _p->mSortDescriptorList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_sortedListDeclaration::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_sortedListDeclaration & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_sortedListDeclaration::constructor_new (_inLexique,
       _p->mSortedListTypeName,
       _p->mAttributeList,
       _p->mSortDescriptorList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_sortedListDeclaration::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_sortedListDeclaration & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_sortedListDeclaration::constructor_new (_inLexique,
       _p->mSortedListTypeName,
       _p->mAttributeList,
       _p->mSortDescriptorList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS entity '@sortedListDeclaration'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_sortedListDeclaration GGS_sortedListDeclaration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS__list_attributeInCollection & argument_1,
                 const GGS__list_sortedListSortDescriptor & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_sortedListDeclaration result ;
  macroMyNew (result.mPointer, cPtr_sortedListDeclaration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_sortedListDeclaration::
reader_mSortedListTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sortedListDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sortedListDeclaration *) mPointer)->mSortedListTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_attributeInCollection  GGS_sortedListDeclaration::
reader_mAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_attributeInCollection   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sortedListDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sortedListDeclaration *) mPointer)->mAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_sortedListSortDescriptor  GGS_sortedListDeclaration::
reader_mSortDescriptorList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_sortedListSortDescriptor   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sortedListDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sortedListDeclaration *) mPointer)->mSortDescriptorList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_sortedListDeclaration::actualTypeName (void) const {
 return "sortedListDeclaration" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_sortedListDeclaration * GGS_sortedListDeclaration::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_sortedListDeclaration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                    Element of list '@enumDeclaration'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_enumDeclaration::
cPtr_enumDeclaration (const GGS_lstring & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_lstringlist & argument_2,
                                const GGS__list_enumMessage & argument_3,
                                const GGS__list_enumModifier & argument_4,
                                const GGS__list_enumMethod & argument_5
                                COMMA_LOCATION_ARGS) :
cPtr_semanticDeclaration (THERE),
mEnumTypeName (argument_0),
mConstructorConstantList (argument_1),
mConstantList (argument_2),
mEnumMessageList (argument_3),
mEnumModifierList (argument_4),
mEnumMethodList (argument_5) {
}

//---------------------------------------------------------------------------*

bool cPtr_enumDeclaration::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_enumDeclaration * _p = dynamic_cast <const cPtr_enumDeclaration *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mEnumTypeName._operator_isEqual (_p->mEnumTypeName).boolValue ()
         && mConstructorConstantList._operator_isEqual (_p->mConstructorConstantList).boolValue ()
         && mConstantList._operator_isEqual (_p->mConstantList).boolValue ()
         && mEnumMessageList._operator_isEqual (_p->mEnumMessageList).boolValue ()
         && mEnumModifierList._operator_isEqual (_p->mEnumModifierList).boolValue ()
         && mEnumMethodList._operator_isEqual (_p->mEnumMethodList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_enumDeclaration::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @enumDeclaration" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEnumTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mConstructorConstantList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mConstantList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEnumMessageList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEnumModifierList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEnumMethodList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_enumDeclaration::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticDeclaration::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_enumDeclaration::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticDeclaration::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_enumDeclaration::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 13 ;
  if (inLevel > 0) {
    result = cPtr_semanticDeclaration::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_enumDeclaration::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "enumDeclaration" ;
  if (inLevel > 0) {
    result = cPtr_semanticDeclaration::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_enumDeclaration * cPtr_enumDeclaration::
_cloneObject (void) const {
  cPtr_enumDeclaration * _p = NULL ;
  macroMyNew (_p, cPtr_enumDeclaration (mEnumTypeName, mConstructorConstantList, mConstantList, mEnumMessageList, mEnumModifierList, mEnumMethodList COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@_list_enumDeclaration'                        *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_enumDeclaration::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstringlist & argument_1,
                    const GGS_lstringlist & argument_2,
                    const GGS__list_enumMessage & argument_3,
                    const GGS__list_enumModifier & argument_4,
                    const GGS__list_enumMethod & argument_5) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_enumDeclaration::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstringlist & argument_1,
                    const GGS_lstringlist & argument_2,
                    const GGS__list_enumMessage & argument_3,
                    const GGS__list_enumModifier & argument_4,
                    const GGS__list_enumMethod & argument_5) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_enumDeclaration::
_addAssign_operation (const GGS_enumDeclaration & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_enumDeclaration GGS__list_enumDeclaration::
_operator_concat (const GGS__list_enumDeclaration & inOperand) const {
  GGS__list_enumDeclaration result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_enumDeclaration::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_enumDeclaration & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_enumDeclaration::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mEnumTypeName,
                                _p->mConstructorConstantList,
                                _p->mConstantList,
                                _p->mEnumMessageList,
                                _p->mEnumModifierList,
                                _p->mEnumMethodList) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_enumDeclaration  GGS__list_enumDeclaration::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_enumDeclaration result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_enumDeclaration  GGS__list_enumDeclaration::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_enumDeclaration & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_enumDeclaration result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_enumDeclaration::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_enumDeclaration", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_enumDeclaration::
_addModel (const GGS_enumDeclaration & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_enumDeclaration::
method_first (C_Compiler & _inLexique,
              GGS_enumDeclaration & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_enumDeclaration::constructor_new (_inLexique,
       _p->mEnumTypeName,
       _p->mConstructorConstantList,
       _p->mConstantList,
       _p->mEnumMessageList,
       _p->mEnumModifierList,
       _p->mEnumMethodList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_enumDeclaration::
method_last (C_Compiler & _inLexique,
             GGS_enumDeclaration & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_enumDeclaration::constructor_new (_inLexique,
       _p->mEnumTypeName,
       _p->mConstructorConstantList,
       _p->mConstantList,
       _p->mEnumMessageList,
       _p->mEnumModifierList,
       _p->mEnumMethodList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_enumDeclaration::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_enumDeclaration & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_enumDeclaration::constructor_new (_inLexique,
       _p->mEnumTypeName,
       _p->mConstructorConstantList,
       _p->mConstantList,
       _p->mEnumMessageList,
       _p->mEnumModifierList,
       _p->mEnumMethodList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_enumDeclaration::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_enumDeclaration & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_enumDeclaration::constructor_new (_inLexique,
       _p->mEnumTypeName,
       _p->mConstructorConstantList,
       _p->mConstantList,
       _p->mEnumMessageList,
       _p->mEnumModifierList,
       _p->mEnumMethodList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS entity '@enumDeclaration'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_enumDeclaration GGS_enumDeclaration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstringlist & argument_1,
                 const GGS_lstringlist & argument_2,
                 const GGS__list_enumMessage & argument_3,
                 const GGS__list_enumModifier & argument_4,
                 const GGS__list_enumMethod & argument_5
                                COMMA_LOCATION_ARGS) {
  GGS_enumDeclaration result ;
  macroMyNew (result.mPointer, cPtr_enumDeclaration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_enumDeclaration::
reader_mEnumTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumDeclaration *) mPointer)->mEnumTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_enumDeclaration::
reader_mConstructorConstantList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumDeclaration *) mPointer)->mConstructorConstantList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_enumDeclaration::
reader_mConstantList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumDeclaration *) mPointer)->mConstantList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_enumMessage  GGS_enumDeclaration::
reader_mEnumMessageList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_enumMessage   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumDeclaration *) mPointer)->mEnumMessageList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_enumModifier  GGS_enumDeclaration::
reader_mEnumModifierList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_enumModifier   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumDeclaration *) mPointer)->mEnumModifierList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_enumMethod  GGS_enumDeclaration::
reader_mEnumMethodList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_enumMethod   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumDeclaration *) mPointer)->mEnumMethodList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_enumDeclaration::actualTypeName (void) const {
 return "enumDeclaration" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_enumDeclaration * GGS_enumDeclaration::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_enumDeclaration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                      Element of list '@enumMessage'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_enumMessage::
cPtr_enumMessage (const GGS_lstring & argument_0,
                                const GGS__list_enumMessageAssociation & argument_1
                                COMMA_LOCATION_ARGS) :
cPtr_entity (THERE),
mEnumMessageName (argument_0),
mMessageAssociationList (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_enumMessage::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_enumMessage * _p = dynamic_cast <const cPtr_enumMessage *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mEnumMessageName._operator_isEqual (_p->mEnumMessageName).boolValue ()
         && mMessageAssociationList._operator_isEqual (_p->mMessageAssociationList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_enumMessage::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @enumMessage" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEnumMessageName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMessageAssociationList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_enumMessage::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_enumMessage::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_enumMessage::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 14 ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_enumMessage::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "enumMessage" ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_enumMessage * cPtr_enumMessage::
_cloneObject (void) const {
  cPtr_enumMessage * _p = NULL ;
  macroMyNew (_p, cPtr_enumMessage (mEnumMessageName, mMessageAssociationList COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                        List '@_list_enumMessage'                          *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_enumMessage::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS__list_enumMessageAssociation & argument_1) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_enumMessage::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS__list_enumMessageAssociation & argument_1) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_enumMessage::
_addAssign_operation (const GGS_enumMessage & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_enumMessage GGS__list_enumMessage::
_operator_concat (const GGS__list_enumMessage & inOperand) const {
  GGS__list_enumMessage result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_enumMessage::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_enumMessage & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_enumMessage::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mEnumMessageName,
                                _p->mMessageAssociationList) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_enumMessage  GGS__list_enumMessage::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_enumMessage result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_enumMessage  GGS__list_enumMessage::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_enumMessage & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_enumMessage result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_enumMessage::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_enumMessage", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_enumMessage::
_addModel (const GGS_enumMessage & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_enumMessage::
method_first (C_Compiler & _inLexique,
              GGS_enumMessage & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_enumMessage::constructor_new (_inLexique,
       _p->mEnumMessageName,
       _p->mMessageAssociationList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_enumMessage::
method_last (C_Compiler & _inLexique,
             GGS_enumMessage & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_enumMessage::constructor_new (_inLexique,
       _p->mEnumMessageName,
       _p->mMessageAssociationList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_enumMessage::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_enumMessage & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_enumMessage::constructor_new (_inLexique,
       _p->mEnumMessageName,
       _p->mMessageAssociationList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_enumMessage::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_enumMessage & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_enumMessage::constructor_new (_inLexique,
       _p->mEnumMessageName,
       _p->mMessageAssociationList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS entity '@enumMessage'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_enumMessage GGS_enumMessage::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS__list_enumMessageAssociation & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_enumMessage result ;
  macroMyNew (result.mPointer, cPtr_enumMessage (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_enumMessage::
reader_mEnumMessageName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumMessage *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumMessage *) mPointer)->mEnumMessageName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_enumMessageAssociation  GGS_enumMessage::
reader_mMessageAssociationList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_enumMessageAssociation   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumMessage *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumMessage *) mPointer)->mMessageAssociationList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_enumMessage::actualTypeName (void) const {
 return "enumMessage" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_enumMessage * GGS_enumMessage::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_enumMessage *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@enumMessageAssociation'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_enumMessageAssociation::
cPtr_enumMessageAssociation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
cPtr_entity (THERE),
mConstantName (argument_0),
mMessage (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_enumMessageAssociation::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_enumMessageAssociation * _p = dynamic_cast <const cPtr_enumMessageAssociation *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mConstantName._operator_isEqual (_p->mConstantName).boolValue ()
         && mMessage._operator_isEqual (_p->mMessage).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_enumMessageAssociation::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @enumMessageAssociation" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mConstantName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMessage.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_enumMessageAssociation::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_enumMessageAssociation::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_enumMessageAssociation::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 15 ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_enumMessageAssociation::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "enumMessageAssociation" ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_enumMessageAssociation * cPtr_enumMessageAssociation::
_cloneObject (void) const {
  cPtr_enumMessageAssociation * _p = NULL ;
  macroMyNew (_p, cPtr_enumMessageAssociation (mConstantName, mMessage COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@_list_enumMessageAssociation'                    *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_enumMessageAssociation::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_enumMessageAssociation::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_enumMessageAssociation::
_addAssign_operation (const GGS_enumMessageAssociation & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_enumMessageAssociation GGS__list_enumMessageAssociation::
_operator_concat (const GGS__list_enumMessageAssociation & inOperand) const {
  GGS__list_enumMessageAssociation result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_enumMessageAssociation::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_enumMessageAssociation & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_enumMessageAssociation::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mConstantName,
                                _p->mMessage) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_enumMessageAssociation  GGS__list_enumMessageAssociation::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_enumMessageAssociation result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_enumMessageAssociation  GGS__list_enumMessageAssociation::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_enumMessageAssociation & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_enumMessageAssociation result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_enumMessageAssociation::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_enumMessageAssociation", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_enumMessageAssociation::
_addModel (const GGS_enumMessageAssociation & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_enumMessageAssociation::
method_first (C_Compiler & _inLexique,
              GGS_enumMessageAssociation & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_enumMessageAssociation::constructor_new (_inLexique,
       _p->mConstantName,
       _p->mMessage) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_enumMessageAssociation::
method_last (C_Compiler & _inLexique,
             GGS_enumMessageAssociation & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_enumMessageAssociation::constructor_new (_inLexique,
       _p->mConstantName,
       _p->mMessage) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_enumMessageAssociation::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_enumMessageAssociation & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_enumMessageAssociation::constructor_new (_inLexique,
       _p->mConstantName,
       _p->mMessage) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_enumMessageAssociation::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_enumMessageAssociation & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_enumMessageAssociation::constructor_new (_inLexique,
       _p->mConstantName,
       _p->mMessage) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS entity '@enumMessageAssociation'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_enumMessageAssociation GGS_enumMessageAssociation::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_enumMessageAssociation result ;
  macroMyNew (result.mPointer, cPtr_enumMessageAssociation (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_enumMessageAssociation::
reader_mConstantName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumMessageAssociation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumMessageAssociation *) mPointer)->mConstantName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_enumMessageAssociation::
reader_mMessage (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumMessageAssociation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumMessageAssociation *) mPointer)->mMessage ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_enumMessageAssociation::actualTypeName (void) const {
 return "enumMessageAssociation" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_enumMessageAssociation * GGS_enumMessageAssociation::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_enumMessageAssociation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                     Element of list '@enumModifier'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_enumModifier::
cPtr_enumModifier (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS__list_enumModifierCase & argument_2
                                COMMA_LOCATION_ARGS) :
cPtr_entity (THERE),
mModifierName (argument_0),
mLocationFormalArgumentName (argument_1),
mEnumModifierCaseList (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_enumModifier::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_enumModifier * _p = dynamic_cast <const cPtr_enumModifier *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mModifierName._operator_isEqual (_p->mModifierName).boolValue ()
         && mLocationFormalArgumentName._operator_isEqual (_p->mLocationFormalArgumentName).boolValue ()
         && mEnumModifierCaseList._operator_isEqual (_p->mEnumModifierCaseList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_enumModifier::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @enumModifier" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mModifierName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLocationFormalArgumentName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEnumModifierCaseList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_enumModifier::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_enumModifier::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_enumModifier::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 16 ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_enumModifier::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "enumModifier" ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_enumModifier * cPtr_enumModifier::
_cloneObject (void) const {
  cPtr_enumModifier * _p = NULL ;
  macroMyNew (_p, cPtr_enumModifier (mModifierName, mLocationFormalArgumentName, mEnumModifierCaseList COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                        List '@_list_enumModifier'                         *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_enumModifier::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS__list_enumModifierCase & argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_enumModifier::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS__list_enumModifierCase & argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_enumModifier::
_addAssign_operation (const GGS_enumModifier & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_enumModifier GGS__list_enumModifier::
_operator_concat (const GGS__list_enumModifier & inOperand) const {
  GGS__list_enumModifier result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_enumModifier::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_enumModifier & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_enumModifier::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mModifierName,
                                _p->mLocationFormalArgumentName,
                                _p->mEnumModifierCaseList) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_enumModifier  GGS__list_enumModifier::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_enumModifier result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_enumModifier  GGS__list_enumModifier::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_enumModifier & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_enumModifier result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_enumModifier::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_enumModifier", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_enumModifier::
_addModel (const GGS_enumModifier & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_enumModifier::
method_first (C_Compiler & _inLexique,
              GGS_enumModifier & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_enumModifier::constructor_new (_inLexique,
       _p->mModifierName,
       _p->mLocationFormalArgumentName,
       _p->mEnumModifierCaseList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_enumModifier::
method_last (C_Compiler & _inLexique,
             GGS_enumModifier & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_enumModifier::constructor_new (_inLexique,
       _p->mModifierName,
       _p->mLocationFormalArgumentName,
       _p->mEnumModifierCaseList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_enumModifier::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_enumModifier & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_enumModifier::constructor_new (_inLexique,
       _p->mModifierName,
       _p->mLocationFormalArgumentName,
       _p->mEnumModifierCaseList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_enumModifier::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_enumModifier & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_enumModifier::constructor_new (_inLexique,
       _p->mModifierName,
       _p->mLocationFormalArgumentName,
       _p->mEnumModifierCaseList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS entity '@enumModifier'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_enumModifier GGS_enumModifier::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS__list_enumModifierCase & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_enumModifier result ;
  macroMyNew (result.mPointer, cPtr_enumModifier (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_enumModifier::
reader_mModifierName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumModifier *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumModifier *) mPointer)->mModifierName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_enumModifier::
reader_mLocationFormalArgumentName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumModifier *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumModifier *) mPointer)->mLocationFormalArgumentName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_enumModifierCase  GGS_enumModifier::
reader_mEnumModifierCaseList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_enumModifierCase   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumModifier *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumModifier *) mPointer)->mEnumModifierCaseList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_enumModifier::actualTypeName (void) const {
 return "enumModifier" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_enumModifier * GGS_enumModifier::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_enumModifier *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                   Element of list '@enumModifierCase'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_enumModifierCase::
cPtr_enumModifierCase (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_enumCaseMessage & argument_2
                                COMMA_LOCATION_ARGS) :
cPtr_entity (THERE),
mSourceConstantName (argument_0),
mTargetConstantName (argument_1),
mEnumModifierCaseMessage (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_enumModifierCase::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_enumModifierCase * _p = dynamic_cast <const cPtr_enumModifierCase *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mSourceConstantName._operator_isEqual (_p->mSourceConstantName).boolValue ()
         && mTargetConstantName._operator_isEqual (_p->mTargetConstantName).boolValue ()
         && mEnumModifierCaseMessage._operator_isEqual (_p->mEnumModifierCaseMessage).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_enumModifierCase::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @enumModifierCase" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSourceConstantName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTargetConstantName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEnumModifierCaseMessage.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_enumModifierCase::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_enumModifierCase::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_enumModifierCase::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 17 ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_enumModifierCase::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "enumModifierCase" ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_enumModifierCase * cPtr_enumModifierCase::
_cloneObject (void) const {
  cPtr_enumModifierCase * _p = NULL ;
  macroMyNew (_p, cPtr_enumModifierCase (mSourceConstantName, mTargetConstantName, mEnumModifierCaseMessage COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@_list_enumModifierCase'                       *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_enumModifierCase::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_enumCaseMessage & argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_enumModifierCase::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_enumCaseMessage & argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_enumModifierCase::
_addAssign_operation (const GGS_enumModifierCase & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_enumModifierCase GGS__list_enumModifierCase::
_operator_concat (const GGS__list_enumModifierCase & inOperand) const {
  GGS__list_enumModifierCase result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_enumModifierCase::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_enumModifierCase & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_enumModifierCase::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mSourceConstantName,
                                _p->mTargetConstantName,
                                _p->mEnumModifierCaseMessage) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_enumModifierCase  GGS__list_enumModifierCase::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_enumModifierCase result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_enumModifierCase  GGS__list_enumModifierCase::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_enumModifierCase & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_enumModifierCase result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_enumModifierCase::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_enumModifierCase", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_enumModifierCase::
_addModel (const GGS_enumModifierCase & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_enumModifierCase::
method_first (C_Compiler & _inLexique,
              GGS_enumModifierCase & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_enumModifierCase::constructor_new (_inLexique,
       _p->mSourceConstantName,
       _p->mTargetConstantName,
       _p->mEnumModifierCaseMessage) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_enumModifierCase::
method_last (C_Compiler & _inLexique,
             GGS_enumModifierCase & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_enumModifierCase::constructor_new (_inLexique,
       _p->mSourceConstantName,
       _p->mTargetConstantName,
       _p->mEnumModifierCaseMessage) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_enumModifierCase::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_enumModifierCase & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_enumModifierCase::constructor_new (_inLexique,
       _p->mSourceConstantName,
       _p->mTargetConstantName,
       _p->mEnumModifierCaseMessage) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_enumModifierCase::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_enumModifierCase & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_enumModifierCase::constructor_new (_inLexique,
       _p->mSourceConstantName,
       _p->mTargetConstantName,
       _p->mEnumModifierCaseMessage) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS entity '@enumModifierCase'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_enumModifierCase GGS_enumModifierCase::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_enumCaseMessage & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_enumModifierCase result ;
  macroMyNew (result.mPointer, cPtr_enumModifierCase (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_enumModifierCase::
reader_mSourceConstantName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumModifierCase *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumModifierCase *) mPointer)->mSourceConstantName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_enumModifierCase::
reader_mTargetConstantName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumModifierCase *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumModifierCase *) mPointer)->mTargetConstantName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumCaseMessage  GGS_enumModifierCase::
reader_mEnumModifierCaseMessage (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_enumCaseMessage   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumModifierCase *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumModifierCase *) mPointer)->mEnumModifierCaseMessage ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_enumModifierCase::actualTypeName (void) const {
 return "enumModifierCase" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_enumModifierCase * GGS_enumModifierCase::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_enumModifierCase *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                    Element of list '@enumCaseMessage'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_enumCaseMessage::
cPtr_enumCaseMessage (LOCATION_ARGS) :
cPtr_entity (THERE) {
}

//---------------------------------------------------------------------------*

bool cPtr_enumCaseMessage::
isEqualToObject (const cPtr_entity * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

void cPtr_enumCaseMessage::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "-> instance of @enumCaseMessage" ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_enumCaseMessage::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_enumCaseMessage::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_enumCaseMessage::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 18 ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_enumCaseMessage::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "enumCaseMessage" ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_enumCaseMessage * cPtr_enumCaseMessage::
_cloneObject (void) const {
  cPtr_enumCaseMessage * _p = NULL ;
  macroMyNew (_p, cPtr_enumCaseMessage (HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@_list_enumCaseMessage'                        *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_enumCaseMessage::
_internalAppendValues () {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_enumCaseMessage::
_internalPrependValues () {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_enumCaseMessage::
_addAssign_operation (const GGS_enumCaseMessage & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_enumCaseMessage GGS__list_enumCaseMessage::
_operator_concat (const GGS__list_enumCaseMessage & inOperand) const {
  GGS__list_enumCaseMessage result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_enumCaseMessage::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_enumCaseMessage & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_enumCaseMessage::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues () ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_enumCaseMessage  GGS__list_enumCaseMessage::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_enumCaseMessage result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_enumCaseMessage  GGS__list_enumCaseMessage::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_enumCaseMessage & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_enumCaseMessage result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_enumCaseMessage::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_enumCaseMessage", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_enumCaseMessage::
_addModel (const GGS_enumCaseMessage & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_enumCaseMessage::
method_first (C_Compiler & _inLexique,
              GGS_enumCaseMessage & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_enumCaseMessage::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_enumCaseMessage::
method_last (C_Compiler & _inLexique,
             GGS_enumCaseMessage & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_enumCaseMessage::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_enumCaseMessage::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_enumCaseMessage & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_enumCaseMessage::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_enumCaseMessage::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_enumCaseMessage & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_enumCaseMessage::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS entity '@enumCaseMessage'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_enumCaseMessage GGS_enumCaseMessage::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_enumCaseMessage result ;
  macroMyNew (result.mPointer, cPtr_enumCaseMessage (THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_enumCaseMessage::actualTypeName (void) const {
 return "enumCaseMessage" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_enumCaseMessage * GGS_enumCaseMessage::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_enumCaseMessage *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@enumCaseErrorMessage'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_enumCaseErrorMessage::
cPtr_enumCaseErrorMessage (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
cPtr_enumCaseMessage (THERE),
mLocationParameterName (argument_0),
mMessage (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_enumCaseErrorMessage::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_enumCaseErrorMessage * _p = dynamic_cast <const cPtr_enumCaseErrorMessage *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mLocationParameterName._operator_isEqual (_p->mLocationParameterName).boolValue ()
         && mMessage._operator_isEqual (_p->mMessage).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_enumCaseErrorMessage::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @enumCaseErrorMessage" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLocationParameterName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMessage.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_enumCaseErrorMessage::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_enumCaseMessage::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_enumCaseErrorMessage::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_enumCaseMessage::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_enumCaseErrorMessage::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 19 ;
  if (inLevel > 0) {
    result = cPtr_enumCaseMessage::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_enumCaseErrorMessage::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "enumCaseErrorMessage" ;
  if (inLevel > 0) {
    result = cPtr_enumCaseMessage::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_enumCaseErrorMessage * cPtr_enumCaseErrorMessage::
_cloneObject (void) const {
  cPtr_enumCaseErrorMessage * _p = NULL ;
  macroMyNew (_p, cPtr_enumCaseErrorMessage (mLocationParameterName, mMessage COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@_list_enumCaseErrorMessage'                     *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_enumCaseErrorMessage::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_enumCaseErrorMessage::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_enumCaseErrorMessage::
_addAssign_operation (const GGS_enumCaseErrorMessage & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_enumCaseErrorMessage GGS__list_enumCaseErrorMessage::
_operator_concat (const GGS__list_enumCaseErrorMessage & inOperand) const {
  GGS__list_enumCaseErrorMessage result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_enumCaseErrorMessage::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_enumCaseErrorMessage & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_enumCaseErrorMessage::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mLocationParameterName,
                                _p->mMessage) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_enumCaseErrorMessage  GGS__list_enumCaseErrorMessage::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_enumCaseErrorMessage result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_enumCaseErrorMessage  GGS__list_enumCaseErrorMessage::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_enumCaseErrorMessage & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_enumCaseErrorMessage result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_enumCaseErrorMessage::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_enumCaseErrorMessage", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_enumCaseErrorMessage::
_addModel (const GGS_enumCaseErrorMessage & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_enumCaseErrorMessage::
method_first (C_Compiler & _inLexique,
              GGS_enumCaseErrorMessage & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_enumCaseErrorMessage::constructor_new (_inLexique,
       _p->mLocationParameterName,
       _p->mMessage) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_enumCaseErrorMessage::
method_last (C_Compiler & _inLexique,
             GGS_enumCaseErrorMessage & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_enumCaseErrorMessage::constructor_new (_inLexique,
       _p->mLocationParameterName,
       _p->mMessage) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_enumCaseErrorMessage::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_enumCaseErrorMessage & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_enumCaseErrorMessage::constructor_new (_inLexique,
       _p->mLocationParameterName,
       _p->mMessage) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_enumCaseErrorMessage::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_enumCaseErrorMessage & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_enumCaseErrorMessage::constructor_new (_inLexique,
       _p->mLocationParameterName,
       _p->mMessage) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS entity '@enumCaseErrorMessage'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_enumCaseErrorMessage GGS_enumCaseErrorMessage::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_enumCaseErrorMessage result ;
  macroMyNew (result.mPointer, cPtr_enumCaseErrorMessage (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_enumCaseErrorMessage::
reader_mLocationParameterName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumCaseErrorMessage *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumCaseErrorMessage *) mPointer)->mLocationParameterName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_enumCaseErrorMessage::
reader_mMessage (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumCaseErrorMessage *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumCaseErrorMessage *) mPointer)->mMessage ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_enumCaseErrorMessage::actualTypeName (void) const {
 return "enumCaseErrorMessage" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_enumCaseErrorMessage * GGS_enumCaseErrorMessage::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_enumCaseErrorMessage *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@enumCaseWarningMessage'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_enumCaseWarningMessage::
cPtr_enumCaseWarningMessage (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
cPtr_enumCaseMessage (THERE),
mLocationParameterName (argument_0),
mMessage (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_enumCaseWarningMessage::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_enumCaseWarningMessage * _p = dynamic_cast <const cPtr_enumCaseWarningMessage *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mLocationParameterName._operator_isEqual (_p->mLocationParameterName).boolValue ()
         && mMessage._operator_isEqual (_p->mMessage).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_enumCaseWarningMessage::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @enumCaseWarningMessage" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLocationParameterName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMessage.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_enumCaseWarningMessage::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_enumCaseMessage::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_enumCaseWarningMessage::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_enumCaseMessage::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_enumCaseWarningMessage::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 20 ;
  if (inLevel > 0) {
    result = cPtr_enumCaseMessage::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_enumCaseWarningMessage::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "enumCaseWarningMessage" ;
  if (inLevel > 0) {
    result = cPtr_enumCaseMessage::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_enumCaseWarningMessage * cPtr_enumCaseWarningMessage::
_cloneObject (void) const {
  cPtr_enumCaseWarningMessage * _p = NULL ;
  macroMyNew (_p, cPtr_enumCaseWarningMessage (mLocationParameterName, mMessage COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@_list_enumCaseWarningMessage'                    *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_enumCaseWarningMessage::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_enumCaseWarningMessage::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_enumCaseWarningMessage::
_addAssign_operation (const GGS_enumCaseWarningMessage & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_enumCaseWarningMessage GGS__list_enumCaseWarningMessage::
_operator_concat (const GGS__list_enumCaseWarningMessage & inOperand) const {
  GGS__list_enumCaseWarningMessage result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_enumCaseWarningMessage::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_enumCaseWarningMessage & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_enumCaseWarningMessage::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mLocationParameterName,
                                _p->mMessage) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_enumCaseWarningMessage  GGS__list_enumCaseWarningMessage::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_enumCaseWarningMessage result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_enumCaseWarningMessage  GGS__list_enumCaseWarningMessage::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_enumCaseWarningMessage & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_enumCaseWarningMessage result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_enumCaseWarningMessage::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_enumCaseWarningMessage", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_enumCaseWarningMessage::
_addModel (const GGS_enumCaseWarningMessage & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_enumCaseWarningMessage::
method_first (C_Compiler & _inLexique,
              GGS_enumCaseWarningMessage & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_enumCaseWarningMessage::constructor_new (_inLexique,
       _p->mLocationParameterName,
       _p->mMessage) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_enumCaseWarningMessage::
method_last (C_Compiler & _inLexique,
             GGS_enumCaseWarningMessage & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_enumCaseWarningMessage::constructor_new (_inLexique,
       _p->mLocationParameterName,
       _p->mMessage) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_enumCaseWarningMessage::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_enumCaseWarningMessage & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_enumCaseWarningMessage::constructor_new (_inLexique,
       _p->mLocationParameterName,
       _p->mMessage) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_enumCaseWarningMessage::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_enumCaseWarningMessage & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_enumCaseWarningMessage::constructor_new (_inLexique,
       _p->mLocationParameterName,
       _p->mMessage) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS entity '@enumCaseWarningMessage'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_enumCaseWarningMessage GGS_enumCaseWarningMessage::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_enumCaseWarningMessage result ;
  macroMyNew (result.mPointer, cPtr_enumCaseWarningMessage (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_enumCaseWarningMessage::
reader_mLocationParameterName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumCaseWarningMessage *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumCaseWarningMessage *) mPointer)->mLocationParameterName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_enumCaseWarningMessage::
reader_mMessage (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumCaseWarningMessage *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumCaseWarningMessage *) mPointer)->mMessage ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_enumCaseWarningMessage::actualTypeName (void) const {
 return "enumCaseWarningMessage" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_enumCaseWarningMessage * GGS_enumCaseWarningMessage::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_enumCaseWarningMessage *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                      Element of list '@enumMethod'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_enumMethod::
cPtr_enumMethod (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS__list_enumMethodCase & argument_2
                                COMMA_LOCATION_ARGS) :
cPtr_entity (THERE),
mMethodName (argument_0),
mLocationFormalArgumentName (argument_1),
mEnumMethodCaseList (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_enumMethod::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_enumMethod * _p = dynamic_cast <const cPtr_enumMethod *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mMethodName._operator_isEqual (_p->mMethodName).boolValue ()
         && mLocationFormalArgumentName._operator_isEqual (_p->mLocationFormalArgumentName).boolValue ()
         && mEnumMethodCaseList._operator_isEqual (_p->mEnumMethodCaseList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_enumMethod::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @enumMethod" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMethodName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLocationFormalArgumentName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEnumMethodCaseList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_enumMethod::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_enumMethod::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_enumMethod::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 21 ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_enumMethod::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "enumMethod" ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_enumMethod * cPtr_enumMethod::
_cloneObject (void) const {
  cPtr_enumMethod * _p = NULL ;
  macroMyNew (_p, cPtr_enumMethod (mMethodName, mLocationFormalArgumentName, mEnumMethodCaseList COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                         List '@_list_enumMethod'                          *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_enumMethod::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS__list_enumMethodCase & argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_enumMethod::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS__list_enumMethodCase & argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_enumMethod::
_addAssign_operation (const GGS_enumMethod & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_enumMethod GGS__list_enumMethod::
_operator_concat (const GGS__list_enumMethod & inOperand) const {
  GGS__list_enumMethod result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_enumMethod::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_enumMethod & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_enumMethod::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mMethodName,
                                _p->mLocationFormalArgumentName,
                                _p->mEnumMethodCaseList) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_enumMethod  GGS__list_enumMethod::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_enumMethod result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_enumMethod  GGS__list_enumMethod::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_enumMethod & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_enumMethod result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_enumMethod::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_enumMethod", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_enumMethod::
_addModel (const GGS_enumMethod & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_enumMethod::
method_first (C_Compiler & _inLexique,
              GGS_enumMethod & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_enumMethod::constructor_new (_inLexique,
       _p->mMethodName,
       _p->mLocationFormalArgumentName,
       _p->mEnumMethodCaseList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_enumMethod::
method_last (C_Compiler & _inLexique,
             GGS_enumMethod & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_enumMethod::constructor_new (_inLexique,
       _p->mMethodName,
       _p->mLocationFormalArgumentName,
       _p->mEnumMethodCaseList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_enumMethod::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_enumMethod & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_enumMethod::constructor_new (_inLexique,
       _p->mMethodName,
       _p->mLocationFormalArgumentName,
       _p->mEnumMethodCaseList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_enumMethod::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_enumMethod & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_enumMethod::constructor_new (_inLexique,
       _p->mMethodName,
       _p->mLocationFormalArgumentName,
       _p->mEnumMethodCaseList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS entity '@enumMethod'                         *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_enumMethod GGS_enumMethod::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS__list_enumMethodCase & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_enumMethod result ;
  macroMyNew (result.mPointer, cPtr_enumMethod (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_enumMethod::
reader_mMethodName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumMethod *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumMethod *) mPointer)->mMethodName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_enumMethod::
reader_mLocationFormalArgumentName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumMethod *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumMethod *) mPointer)->mLocationFormalArgumentName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_enumMethodCase  GGS_enumMethod::
reader_mEnumMethodCaseList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_enumMethodCase   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumMethod *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumMethod *) mPointer)->mEnumMethodCaseList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_enumMethod::actualTypeName (void) const {
 return "enumMethod" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_enumMethod * GGS_enumMethod::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_enumMethod *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                    Element of list '@enumMethodCase'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_enumMethodCase::
cPtr_enumMethodCase (const GGS_lstring & argument_0,
                                const GGS_enumCaseMessage & argument_1
                                COMMA_LOCATION_ARGS) :
cPtr_entity (THERE),
mConstantName (argument_0),
mEnumMethodCaseMessage (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_enumMethodCase::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_enumMethodCase * _p = dynamic_cast <const cPtr_enumMethodCase *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mConstantName._operator_isEqual (_p->mConstantName).boolValue ()
         && mEnumMethodCaseMessage._operator_isEqual (_p->mEnumMethodCaseMessage).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_enumMethodCase::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @enumMethodCase" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mConstantName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEnumMethodCaseMessage.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_enumMethodCase::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_enumMethodCase::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_enumMethodCase::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 22 ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_enumMethodCase::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "enumMethodCase" ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_enumMethodCase * cPtr_enumMethodCase::
_cloneObject (void) const {
  cPtr_enumMethodCase * _p = NULL ;
  macroMyNew (_p, cPtr_enumMethodCase (mConstantName, mEnumMethodCaseMessage COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@_list_enumMethodCase'                        *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_enumMethodCase::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_enumCaseMessage & argument_1) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_enumMethodCase::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_enumCaseMessage & argument_1) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_enumMethodCase::
_addAssign_operation (const GGS_enumMethodCase & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_enumMethodCase GGS__list_enumMethodCase::
_operator_concat (const GGS__list_enumMethodCase & inOperand) const {
  GGS__list_enumMethodCase result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_enumMethodCase::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_enumMethodCase & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_enumMethodCase::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mConstantName,
                                _p->mEnumMethodCaseMessage) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_enumMethodCase  GGS__list_enumMethodCase::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_enumMethodCase result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_enumMethodCase  GGS__list_enumMethodCase::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_enumMethodCase & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_enumMethodCase result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_enumMethodCase::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_enumMethodCase", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_enumMethodCase::
_addModel (const GGS_enumMethodCase & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_enumMethodCase::
method_first (C_Compiler & _inLexique,
              GGS_enumMethodCase & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_enumMethodCase::constructor_new (_inLexique,
       _p->mConstantName,
       _p->mEnumMethodCaseMessage) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_enumMethodCase::
method_last (C_Compiler & _inLexique,
             GGS_enumMethodCase & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_enumMethodCase::constructor_new (_inLexique,
       _p->mConstantName,
       _p->mEnumMethodCaseMessage) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_enumMethodCase::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_enumMethodCase & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_enumMethodCase::constructor_new (_inLexique,
       _p->mConstantName,
       _p->mEnumMethodCaseMessage) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_enumMethodCase::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_enumMethodCase & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_enumMethodCase::constructor_new (_inLexique,
       _p->mConstantName,
       _p->mEnumMethodCaseMessage) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS entity '@enumMethodCase'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_enumMethodCase GGS_enumMethodCase::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_enumCaseMessage & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_enumMethodCase result ;
  macroMyNew (result.mPointer, cPtr_enumMethodCase (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_enumMethodCase::
reader_mConstantName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumMethodCase *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumMethodCase *) mPointer)->mConstantName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumCaseMessage  GGS_enumMethodCase::
reader_mEnumMethodCaseMessage (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_enumCaseMessage   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumMethodCase *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumMethodCase *) mPointer)->mEnumMethodCaseMessage ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_enumMethodCase::actualTypeName (void) const {
 return "enumMethodCase" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_enumMethodCase * GGS_enumMethodCase::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_enumMethodCase *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@filewrapperDeclaration'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_filewrapperDeclaration::
cPtr_filewrapperDeclaration (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstringlist & argument_2,
                                const GGS__list_filewrapperTemplate & argument_3
                                COMMA_LOCATION_ARGS) :
cPtr_semanticDeclaration (THERE),
mFilewrapperName (argument_0),
mFilewrapperPath (argument_1),
mFilewrapperExtensionList (argument_2),
mFilewrapperTemplateList (argument_3) {
}

//---------------------------------------------------------------------------*

bool cPtr_filewrapperDeclaration::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_filewrapperDeclaration * _p = dynamic_cast <const cPtr_filewrapperDeclaration *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mFilewrapperName._operator_isEqual (_p->mFilewrapperName).boolValue ()
         && mFilewrapperPath._operator_isEqual (_p->mFilewrapperPath).boolValue ()
         && mFilewrapperExtensionList._operator_isEqual (_p->mFilewrapperExtensionList).boolValue ()
         && mFilewrapperTemplateList._operator_isEqual (_p->mFilewrapperTemplateList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_filewrapperDeclaration::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @filewrapperDeclaration" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFilewrapperName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFilewrapperPath.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFilewrapperExtensionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFilewrapperTemplateList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_filewrapperDeclaration::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticDeclaration::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_filewrapperDeclaration::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticDeclaration::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_filewrapperDeclaration::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 23 ;
  if (inLevel > 0) {
    result = cPtr_semanticDeclaration::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_filewrapperDeclaration::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "filewrapperDeclaration" ;
  if (inLevel > 0) {
    result = cPtr_semanticDeclaration::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_filewrapperDeclaration * cPtr_filewrapperDeclaration::
_cloneObject (void) const {
  cPtr_filewrapperDeclaration * _p = NULL ;
  macroMyNew (_p, cPtr_filewrapperDeclaration (mFilewrapperName, mFilewrapperPath, mFilewrapperExtensionList, mFilewrapperTemplateList COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@_list_filewrapperDeclaration'                    *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_filewrapperDeclaration::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstringlist & argument_2,
                    const GGS__list_filewrapperTemplate & argument_3) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_filewrapperDeclaration::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstringlist & argument_2,
                    const GGS__list_filewrapperTemplate & argument_3) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_filewrapperDeclaration::
_addAssign_operation (const GGS_filewrapperDeclaration & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_filewrapperDeclaration GGS__list_filewrapperDeclaration::
_operator_concat (const GGS__list_filewrapperDeclaration & inOperand) const {
  GGS__list_filewrapperDeclaration result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_filewrapperDeclaration::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_filewrapperDeclaration & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_filewrapperDeclaration::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mFilewrapperName,
                                _p->mFilewrapperPath,
                                _p->mFilewrapperExtensionList,
                                _p->mFilewrapperTemplateList) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_filewrapperDeclaration  GGS__list_filewrapperDeclaration::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_filewrapperDeclaration result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_filewrapperDeclaration  GGS__list_filewrapperDeclaration::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_filewrapperDeclaration & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_filewrapperDeclaration result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_filewrapperDeclaration::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_filewrapperDeclaration", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_filewrapperDeclaration::
_addModel (const GGS_filewrapperDeclaration & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_filewrapperDeclaration::
method_first (C_Compiler & _inLexique,
              GGS_filewrapperDeclaration & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_filewrapperDeclaration::constructor_new (_inLexique,
       _p->mFilewrapperName,
       _p->mFilewrapperPath,
       _p->mFilewrapperExtensionList,
       _p->mFilewrapperTemplateList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_filewrapperDeclaration::
method_last (C_Compiler & _inLexique,
             GGS_filewrapperDeclaration & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_filewrapperDeclaration::constructor_new (_inLexique,
       _p->mFilewrapperName,
       _p->mFilewrapperPath,
       _p->mFilewrapperExtensionList,
       _p->mFilewrapperTemplateList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_filewrapperDeclaration::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_filewrapperDeclaration & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_filewrapperDeclaration::constructor_new (_inLexique,
       _p->mFilewrapperName,
       _p->mFilewrapperPath,
       _p->mFilewrapperExtensionList,
       _p->mFilewrapperTemplateList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_filewrapperDeclaration::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_filewrapperDeclaration & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_filewrapperDeclaration::constructor_new (_inLexique,
       _p->mFilewrapperName,
       _p->mFilewrapperPath,
       _p->mFilewrapperExtensionList,
       _p->mFilewrapperTemplateList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS entity '@filewrapperDeclaration'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_filewrapperDeclaration GGS_filewrapperDeclaration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstringlist & argument_2,
                 const GGS__list_filewrapperTemplate & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_filewrapperDeclaration result ;
  macroMyNew (result.mPointer, cPtr_filewrapperDeclaration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_filewrapperDeclaration::
reader_mFilewrapperName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_filewrapperDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_filewrapperDeclaration *) mPointer)->mFilewrapperName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_filewrapperDeclaration::
reader_mFilewrapperPath (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_filewrapperDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_filewrapperDeclaration *) mPointer)->mFilewrapperPath ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_filewrapperDeclaration::
reader_mFilewrapperExtensionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_filewrapperDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_filewrapperDeclaration *) mPointer)->mFilewrapperExtensionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_filewrapperTemplate  GGS_filewrapperDeclaration::
reader_mFilewrapperTemplateList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_filewrapperTemplate   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_filewrapperDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_filewrapperDeclaration *) mPointer)->mFilewrapperTemplateList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_filewrapperDeclaration::actualTypeName (void) const {
 return "filewrapperDeclaration" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_filewrapperDeclaration * GGS_filewrapperDeclaration::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_filewrapperDeclaration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@filewrapperTemplate'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_filewrapperTemplate::
cPtr_filewrapperTemplate (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_formalInputParameterList & argument_2
                                COMMA_LOCATION_ARGS) :
cPtr_entity (THERE),
mFilewrapperTemplateName (argument_0),
mFilewrapperTemplatePath (argument_1),
mFilewrapperTemplateFormalInputParameters (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_filewrapperTemplate::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_filewrapperTemplate * _p = dynamic_cast <const cPtr_filewrapperTemplate *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mFilewrapperTemplateName._operator_isEqual (_p->mFilewrapperTemplateName).boolValue ()
         && mFilewrapperTemplatePath._operator_isEqual (_p->mFilewrapperTemplatePath).boolValue ()
         && mFilewrapperTemplateFormalInputParameters._operator_isEqual (_p->mFilewrapperTemplateFormalInputParameters).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_filewrapperTemplate::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @filewrapperTemplate" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFilewrapperTemplateName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFilewrapperTemplatePath.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFilewrapperTemplateFormalInputParameters.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_filewrapperTemplate::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_filewrapperTemplate::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_filewrapperTemplate::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 24 ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_filewrapperTemplate::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "filewrapperTemplate" ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_filewrapperTemplate * cPtr_filewrapperTemplate::
_cloneObject (void) const {
  cPtr_filewrapperTemplate * _p = NULL ;
  macroMyNew (_p, cPtr_filewrapperTemplate (mFilewrapperTemplateName, mFilewrapperTemplatePath, mFilewrapperTemplateFormalInputParameters COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@_list_filewrapperTemplate'                      *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_filewrapperTemplate::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_formalInputParameterList & argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_filewrapperTemplate::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_formalInputParameterList & argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_filewrapperTemplate::
_addAssign_operation (const GGS_filewrapperTemplate & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_filewrapperTemplate GGS__list_filewrapperTemplate::
_operator_concat (const GGS__list_filewrapperTemplate & inOperand) const {
  GGS__list_filewrapperTemplate result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_filewrapperTemplate::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_filewrapperTemplate & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_filewrapperTemplate::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mFilewrapperTemplateName,
                                _p->mFilewrapperTemplatePath,
                                _p->mFilewrapperTemplateFormalInputParameters) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_filewrapperTemplate  GGS__list_filewrapperTemplate::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_filewrapperTemplate result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_filewrapperTemplate  GGS__list_filewrapperTemplate::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_filewrapperTemplate & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_filewrapperTemplate result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_filewrapperTemplate::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_filewrapperTemplate", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_filewrapperTemplate::
_addModel (const GGS_filewrapperTemplate & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_filewrapperTemplate::
method_first (C_Compiler & _inLexique,
              GGS_filewrapperTemplate & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_filewrapperTemplate::constructor_new (_inLexique,
       _p->mFilewrapperTemplateName,
       _p->mFilewrapperTemplatePath,
       _p->mFilewrapperTemplateFormalInputParameters) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_filewrapperTemplate::
method_last (C_Compiler & _inLexique,
             GGS_filewrapperTemplate & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_filewrapperTemplate::constructor_new (_inLexique,
       _p->mFilewrapperTemplateName,
       _p->mFilewrapperTemplatePath,
       _p->mFilewrapperTemplateFormalInputParameters) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_filewrapperTemplate::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_filewrapperTemplate & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_filewrapperTemplate::constructor_new (_inLexique,
       _p->mFilewrapperTemplateName,
       _p->mFilewrapperTemplatePath,
       _p->mFilewrapperTemplateFormalInputParameters) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_filewrapperTemplate::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_filewrapperTemplate & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_filewrapperTemplate::constructor_new (_inLexique,
       _p->mFilewrapperTemplateName,
       _p->mFilewrapperTemplatePath,
       _p->mFilewrapperTemplateFormalInputParameters) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS entity '@filewrapperTemplate'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_filewrapperTemplate GGS_filewrapperTemplate::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_formalInputParameterList & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_filewrapperTemplate result ;
  macroMyNew (result.mPointer, cPtr_filewrapperTemplate (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_filewrapperTemplate::
reader_mFilewrapperTemplateName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_filewrapperTemplate *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_filewrapperTemplate *) mPointer)->mFilewrapperTemplateName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_filewrapperTemplate::
reader_mFilewrapperTemplatePath (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_filewrapperTemplate *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_filewrapperTemplate *) mPointer)->mFilewrapperTemplatePath ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalInputParameterList  GGS_filewrapperTemplate::
reader_mFilewrapperTemplateFormalInputParameters (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_formalInputParameterList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_filewrapperTemplate *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_filewrapperTemplate *) mPointer)->mFilewrapperTemplateFormalInputParameters ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_filewrapperTemplate::actualTypeName (void) const {
 return "filewrapperTemplate" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_filewrapperTemplate * GGS_filewrapperTemplate::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_filewrapperTemplate *) mPointer ;
  }
#endif

