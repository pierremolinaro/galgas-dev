//---------------------------------------------------------------------------*
//                                                                           *
//                      File 'semanticsMetamodel.cpp'                        *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                      june 18th, 2008, at 16h49'42"                        *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "semanticsMetamodel.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "semanticsMetamodel.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_semanticsComponentRoot'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_semanticsComponentRoot::
cPtr_semanticsComponentRoot (const GGS_lstring & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_semanticDeclarationList & argument_2,
                                const GGS_location & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE),
mSemanticsComponentName (argument_0),
mImportedComponentFileNameList (argument_1),
mSemanticDeclarationList (argument_2),
mEndOfSourceFile (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_semanticsComponentRoot * GGS_semanticsComponentRoot::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_semanticsComponentRoot *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_semanticsComponentRoot *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_semanticsComponentRoot::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_semanticsComponentRoot * _p = dynamic_cast <const cPtr_semanticsComponentRoot *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mSemanticsComponentName._operator_isEqual (_p->mSemanticsComponentName).boolValue ()
         && mImportedComponentFileNameList._operator_isEqual (_p->mImportedComponentFileNameList).boolValue ()
         && mSemanticDeclarationList._operator_isEqual (_p->mSemanticDeclarationList).boolValue ()
         && mEndOfSourceFile._operator_isEqual (_p->mEndOfSourceFile).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_semanticsComponentRoot::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@semanticsComponentRoot:"
           << mSemanticsComponentName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mImportedComponentFileNameList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mSemanticDeclarationList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mEndOfSourceFile.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_semanticsComponentRoot::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_semanticsComponentRoot::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_semanticsComponentRoot (& typeid (cPtr_semanticsComponentRoot), NULL
, "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_semanticsComponentRoot::galgasRTTI (void) const {
  return & gClassInfoFor__semanticsComponentRoot ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_semanticsComponentRoot'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_semanticsComponentRoot::
GGS_semanticsComponentRoot (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_semanticsComponentRoot::
GGS_semanticsComponentRoot (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_semanticsComponentRoot GGS_semanticsComponentRoot::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_semanticsComponentRoot _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_semanticsComponentRoot *> (inPointer) != NULL)
      : (typeid (cPtr_semanticsComponentRoot) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_semanticsComponentRoot (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_semanticsComponentRoot),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_semanticsComponentRoot GGS_semanticsComponentRoot::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstringlist & argument_1,
                 const GGS_semanticDeclarationList & argument_2,
                 const GGS_location & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_semanticsComponentRoot result ;
  macroMyNew (result.mPointer, cPtr_semanticsComponentRoot (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_semanticsComponentRoot::
reader_mSemanticsComponentName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_semanticsComponentRoot *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_semanticsComponentRoot *) mPointer)->mSemanticsComponentName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_semanticsComponentRoot::
reader_mImportedComponentFileNameList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_semanticsComponentRoot *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_semanticsComponentRoot *) mPointer)->mImportedComponentFileNameList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationList  GGS_semanticsComponentRoot::
reader_mSemanticDeclarationList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticDeclarationList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_semanticsComponentRoot *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_semanticsComponentRoot *) mPointer)->mSemanticDeclarationList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_semanticsComponentRoot::
reader_mEndOfSourceFile (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_semanticsComponentRoot *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_semanticsComponentRoot *) mPointer)->mEndOfSourceFile ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_semanticsComponentRoot::actualTypeName (void) const {
  return "semanticsComponentRoot" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_semanticsComponentRoot::_galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__semanticsComponentRoot ("semanticsComponentRoot") ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'e_parsedSemanticsComponentMap'                    *
//                                                                           *
//---------------------------------------------------------------------------*

e_parsedSemanticsComponentMap::e_parsedSemanticsComponentMap (void) :
mRoot () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class map '@parsedSemanticsComponentMap'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_parsedSemanticsComponentMap::
elementOf_GGS_parsedSemanticsComponentMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_parsedSemanticsComponentMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_parsedSemanticsComponentMap::
appendForMapDescription (C_Compiler & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mRoot.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_parsedSemanticsComponentMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_parsedSemanticsComponentMap * _p = dynamic_cast <const elementOf_GGS_parsedSemanticsComponentMap *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mRoot._operator_isEqual (_p->mInfo.mRoot)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_parsedSemanticsComponentMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_parsedSemanticsComponentMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_parsedSemanticsComponentMap * info = (e_parsedSemanticsComponentMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_parsedSemanticsComponentMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_parsedSemanticsComponentMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_parsedSemanticsComponentMap * info = (e_parsedSemanticsComponentMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_parsedSemanticsComponentMap GGS_parsedSemanticsComponentMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_parsedSemanticsComponentMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_parsedSemanticsComponentMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_parsedSemanticsComponentMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->_mRoot,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_parsedSemanticsComponentMap::
_operator_isEqual (const GGS_parsedSemanticsComponentMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_parsedSemanticsComponentMap::
_operator_isNotEqual (const GGS_parsedSemanticsComponentMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_parsedSemanticsComponentMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo,mSharedMapRoot->_mRoot, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_parsedSemanticsComponentMap::
_insertElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_semanticsComponentRoot & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_parsedSemanticsComponentMap info  ;
    info.mRoot = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_parsedSemanticsComponentMap::
_searchElement (C_Compiler & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_semanticsComponentRoot   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mRoot ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_parsedSemanticsComponentMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_semanticsComponentRoot   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '%K' semantics component symbol is not parsed",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_parsedSemanticsComponentMap::
modifier_insertKey (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_semanticsComponentRoot & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '%K' semantics component has already been parsed",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_parsedSemanticsComponentMap GGS_parsedSemanticsComponentMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_parsedSemanticsComponentMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_parsedSemanticsComponentMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_parsedSemanticsComponentMap GGS_parsedSemanticsComponentMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_parsedSemanticsComponentMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_parsedSemanticsComponentMap::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @parsedSemanticsComponentMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Implementation of 'parsedComponentStruct' struct              *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_parsedComponentStruct::GGS_parsedComponentStruct (void) :
mParsedSemanticsComponentMap () {
}

//---------------------------------------------------------------------------*

GGS_parsedComponentStruct::~GGS_parsedComponentStruct (void) {
}

//---------------------------------------------------------------------------*

void GGS_parsedComponentStruct::_drop_operation (void) {
  mParsedSemanticsComponentMap._drop_operation () ;
}

//---------------------------------------------------------------------------*

bool GGS_parsedComponentStruct::_isBuilt (void) const {
  return mParsedSemanticsComponentMap._isBuilt () ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_parsedComponentStruct::
_operator_isEqual (const GGS_parsedComponentStruct & inOperand) const {
  return mParsedSemanticsComponentMap._operator_isEqual (inOperand.mParsedSemanticsComponentMap) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_parsedComponentStruct::
_operator_isNotEqual (const GGS_parsedComponentStruct & inOperand) const {
  return mParsedSemanticsComponentMap._operator_isNotEqual (inOperand.mParsedSemanticsComponentMap) ;
}

//---------------------------------------------------------------------------*

GGS_parsedComponentStruct GGS_parsedComponentStruct::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_parsedSemanticsComponentMap & argument_0
                 COMMA_UNUSED_LOCATION_ARGS) {
  GGS_parsedComponentStruct result ;
  result.mParsedSemanticsComponentMap = argument_0 ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@attributeInCollectionList'                *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_attributeInCollectionList::
elementOf_GGS_attributeInCollectionList (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mAttributeTypeName (argument_0),
mAttributeName (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_attributeInCollectionList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_attributeInCollectionList * _p = dynamic_cast <const elementOf_GGS_attributeInCollectionList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mAttributeTypeName._operator_isEqual (_p->mAttributeTypeName).boolValue ()
         && mAttributeName._operator_isEqual (_p->mAttributeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_attributeInCollectionList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAttributeTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAttributeName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@attributeInCollectionList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_attributeInCollectionList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_attributeInCollectionList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_attributeInCollectionList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_attributeInCollectionList GGS_attributeInCollectionList::
_operator_concat (const GGS_attributeInCollectionList & inOperand) const {
  GGS_attributeInCollectionList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_attributeInCollectionList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mAttributeTypeName ;
          GGS_lstring  p_1 = p->mAttributeName ;
          result._internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_attributeInCollectionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_attributeInCollectionList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mAttributeTypeName,
                                _p->mAttributeName
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_attributeInCollectionList  GGS_attributeInCollectionList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_attributeInCollectionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_attributeInCollectionList  GGS_attributeInCollectionList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_lstring & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_attributeInCollectionList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_attributeInCollectionList::
internalSubListWithRange (GGS_attributeInCollectionList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mAttributeTypeName, _p->mAttributeName) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_attributeInCollectionList GGS_attributeInCollectionList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_attributeInCollectionList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_attributeInCollectionList GGS_attributeInCollectionList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_attributeInCollectionList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_attributeInCollectionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@attributeInCollectionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_attributeInCollectionList::
method_first (C_Compiler & _inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mAttributeTypeName ;
    _out_1 = _p->mAttributeName ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_attributeInCollectionList::
method_last (C_Compiler & _inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mAttributeTypeName ;
    _out_1 = _p->mAttributeName ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_attributeInCollectionList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mAttributeTypeName ;
    _out_1 = _p->mAttributeName ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_attributeInCollectionList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mAttributeTypeName ;
    _out_1 = _p->mAttributeName ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_attributeInCollectionList::
reader_mAttributeTypeNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mAttributeTypeName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_attributeInCollectionList::
reader_mAttributeNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mAttributeName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_attributeInCollectionList::
modifier_setMAttributeTypeNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mAttributeTypeName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_attributeInCollectionList::
modifier_setMAttributeNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mAttributeName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     Element of list '@mapMethodList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_mapMethodList::
elementOf_GGS_mapMethodList (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mMethodName (argument_0),
mGetIDMethodName (argument_1),
mErrorMessage (argument_2),
mShadowErrorMessage (argument_3) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_mapMethodList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_mapMethodList * _p = dynamic_cast <const elementOf_GGS_mapMethodList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mMethodName._operator_isEqual (_p->mMethodName).boolValue ()
         && mGetIDMethodName._operator_isEqual (_p->mGetIDMethodName).boolValue ()
         && mErrorMessage._operator_isEqual (_p->mErrorMessage).boolValue ()
         && mShadowErrorMessage._operator_isEqual (_p->mShadowErrorMessage).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_mapMethodList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMethodName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mGetIDMethodName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mErrorMessage.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mShadowErrorMessage.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          List '@mapMethodList'                            *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_mapMethodList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_lstring & argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_mapMethodList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_lstring & argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_mapMethodList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_mapMethodList GGS_mapMethodList::
_operator_concat (const GGS_mapMethodList & inOperand) const {
  GGS_mapMethodList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_mapMethodList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mMethodName ;
          GGS_lstring  p_1 = p->mGetIDMethodName ;
          GGS_lstring  p_2 = p->mErrorMessage ;
          GGS_lstring  p_3 = p->mShadowErrorMessage ;
          result._internalAppendValues (p_0, p_1, p_2, p_3 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_mapMethodList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_lstring & argument_2,
                     const GGS_lstring & argument_3
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapMethodList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mMethodName,
                                _p->mGetIDMethodName,
                                _p->mErrorMessage,
                                _p->mShadowErrorMessage
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_mapMethodList  GGS_mapMethodList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_mapMethodList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapMethodList  GGS_mapMethodList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_lstring & argument_1,
                           const GGS_lstring & argument_2,
                           const GGS_lstring & argument_3
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_mapMethodList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2, argument_3) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_mapMethodList::
internalSubListWithRange (GGS_mapMethodList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mMethodName, _p->mGetIDMethodName, _p->mErrorMessage, _p->mShadowErrorMessage) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_mapMethodList GGS_mapMethodList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_mapMethodList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapMethodList GGS_mapMethodList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_mapMethodList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_mapMethodList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@mapMethodList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_mapMethodList::
method_first (C_Compiler & _inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1,
              GGS_lstring & _out_2,
              GGS_lstring & _out_3
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMethodName ;
    _out_1 = _p->mGetIDMethodName ;
    _out_2 = _p->mErrorMessage ;
    _out_3 = _p->mShadowErrorMessage ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapMethodList::
method_last (C_Compiler & _inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1,
             GGS_lstring & _out_2,
             GGS_lstring & _out_3
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMethodName ;
    _out_1 = _p->mGetIDMethodName ;
    _out_2 = _p->mErrorMessage ;
    _out_3 = _p->mShadowErrorMessage ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapMethodList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1,
                 GGS_lstring & _out_2,
                 GGS_lstring & _out_3
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMethodName ;
    _out_1 = _p->mGetIDMethodName ;
    _out_2 = _p->mErrorMessage ;
    _out_3 = _p->mShadowErrorMessage ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapMethodList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1,
                GGS_lstring & _out_2,
                GGS_lstring & _out_3
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMethodName ;
    _out_1 = _p->mGetIDMethodName ;
    _out_2 = _p->mErrorMessage ;
    _out_3 = _p->mShadowErrorMessage ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapMethodList::
reader_mMethodNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mMethodName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapMethodList::
reader_mGetIDMethodNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mGetIDMethodName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapMethodList::
reader_mErrorMessageAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mErrorMessage ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapMethodList::
reader_mShadowErrorMessageAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mShadowErrorMessage ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_mapMethodList::
modifier_setMMethodNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mMethodName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_mapMethodList::
modifier_setMGetIDMethodNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mGetIDMethodName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_mapMethodList::
modifier_setMErrorMessageAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mErrorMessage = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_mapMethodList::
modifier_setMShadowErrorMessageAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mShadowErrorMessage = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_mapDeclaration'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_mapDeclaration::
cPtr_mapDeclaration (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_attributeInCollectionList & argument_3,
                                const GGS_mapMethodList & argument_4,
                                const GGS_mapMethodList & argument_5,
                                const GGS_mapMethodList & argument_6
                                COMMA_LOCATION_ARGS)
:cPtr_semanticDeclaration (THERE),
mMapTypeName (argument_0),
mAssociatedEnumTypeName (argument_1),
mAssociatedTerminaisonMethodName (argument_2),
mAttributeList (argument_3),
mInsertMethodList (argument_4),
mSearchMethodList (argument_5),
mRemoveMethodList (argument_6) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_mapDeclaration * GGS_mapDeclaration::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_mapDeclaration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_mapDeclaration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_mapDeclaration * _p = dynamic_cast <const cPtr_mapDeclaration *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mMapTypeName._operator_isEqual (_p->mMapTypeName).boolValue ()
         && mAssociatedEnumTypeName._operator_isEqual (_p->mAssociatedEnumTypeName).boolValue ()
         && mAssociatedTerminaisonMethodName._operator_isEqual (_p->mAssociatedTerminaisonMethodName).boolValue ()
         && mAttributeList._operator_isEqual (_p->mAttributeList).boolValue ()
         && mInsertMethodList._operator_isEqual (_p->mInsertMethodList).boolValue ()
         && mSearchMethodList._operator_isEqual (_p->mSearchMethodList).boolValue ()
         && mRemoveMethodList._operator_isEqual (_p->mRemoveMethodList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_mapDeclaration::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@mapDeclaration:"
           << mMapTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mAssociatedEnumTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mAssociatedTerminaisonMethodName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mAttributeList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mInsertMethodList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mSearchMethodList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRemoveMethodList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_mapDeclaration::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_mapDeclaration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_mapDeclaration (& typeid (cPtr_mapDeclaration), & typeid (cPtr_semanticDeclaration), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_mapDeclaration::galgasRTTI (void) const {
  return & gClassInfoFor__mapDeclaration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_mapDeclaration'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_mapDeclaration::
GGS_mapDeclaration (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_mapDeclaration::
GGS_mapDeclaration (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_mapDeclaration GGS_mapDeclaration::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_mapDeclaration _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_mapDeclaration *> (inPointer) != NULL)
      : (typeid (cPtr_mapDeclaration) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_mapDeclaration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_mapDeclaration),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_mapDeclaration GGS_mapDeclaration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_attributeInCollectionList & argument_3,
                 const GGS_mapMethodList & argument_4,
                 const GGS_mapMethodList & argument_5,
                 const GGS_mapMethodList & argument_6
                                COMMA_LOCATION_ARGS) {
  GGS_mapDeclaration result ;
  macroMyNew (result.mPointer, cPtr_mapDeclaration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapDeclaration::
reader_mMapTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapDeclaration *) mPointer)->mMapTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapDeclaration::
reader_mAssociatedEnumTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapDeclaration *) mPointer)->mAssociatedEnumTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapDeclaration::
reader_mAssociatedTerminaisonMethodName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapDeclaration *) mPointer)->mAssociatedTerminaisonMethodName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_attributeInCollectionList  GGS_mapDeclaration::
reader_mAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_attributeInCollectionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapDeclaration *) mPointer)->mAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapMethodList  GGS_mapDeclaration::
reader_mInsertMethodList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_mapMethodList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapDeclaration *) mPointer)->mInsertMethodList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapMethodList  GGS_mapDeclaration::
reader_mSearchMethodList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_mapMethodList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapDeclaration *) mPointer)->mSearchMethodList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapMethodList  GGS_mapDeclaration::
reader_mRemoveMethodList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_mapMethodList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapDeclaration *) mPointer)->mRemoveMethodList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_mapDeclaration::actualTypeName (void) const {
  return "mapDeclaration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__mapDeclaration ("mapDeclaration", gClassInfoFor__semanticDeclaration) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_mapindexDeclaration'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_mapindexDeclaration::
cPtr_mapindexDeclaration (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticDeclaration (THERE),
mMapIndexTypeName (argument_0),
mMapTypeName (argument_1),
mSearchMethodName (argument_2),
mSearchMethodErrorMessage (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_mapindexDeclaration * GGS_mapindexDeclaration::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapindexDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_mapindexDeclaration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_mapindexDeclaration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_mapindexDeclaration * _p = dynamic_cast <const cPtr_mapindexDeclaration *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mMapIndexTypeName._operator_isEqual (_p->mMapIndexTypeName).boolValue ()
         && mMapTypeName._operator_isEqual (_p->mMapTypeName).boolValue ()
         && mSearchMethodName._operator_isEqual (_p->mSearchMethodName).boolValue ()
         && mSearchMethodErrorMessage._operator_isEqual (_p->mSearchMethodErrorMessage).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_mapindexDeclaration::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@mapindexDeclaration:"
           << mMapIndexTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mMapTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mSearchMethodName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mSearchMethodErrorMessage.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_mapindexDeclaration::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_mapindexDeclaration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_mapindexDeclaration (& typeid (cPtr_mapindexDeclaration), & typeid (cPtr_semanticDeclaration), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_mapindexDeclaration::galgasRTTI (void) const {
  return & gClassInfoFor__mapindexDeclaration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_mapindexDeclaration'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_mapindexDeclaration::
GGS_mapindexDeclaration (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_mapindexDeclaration::
GGS_mapindexDeclaration (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_mapindexDeclaration GGS_mapindexDeclaration::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_mapindexDeclaration _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_mapindexDeclaration *> (inPointer) != NULL)
      : (typeid (cPtr_mapindexDeclaration) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_mapindexDeclaration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_mapindexDeclaration),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_mapindexDeclaration GGS_mapindexDeclaration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_lstring & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_mapindexDeclaration result ;
  macroMyNew (result.mPointer, cPtr_mapindexDeclaration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapindexDeclaration::
reader_mMapIndexTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapindexDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapindexDeclaration *) mPointer)->mMapIndexTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapindexDeclaration::
reader_mMapTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapindexDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapindexDeclaration *) mPointer)->mMapTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapindexDeclaration::
reader_mSearchMethodName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapindexDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapindexDeclaration *) mPointer)->mSearchMethodName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapindexDeclaration::
reader_mSearchMethodErrorMessage (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapindexDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapindexDeclaration *) mPointer)->mSearchMethodErrorMessage ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_mapindexDeclaration::actualTypeName (void) const {
  return "mapindexDeclaration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__mapindexDeclaration ("mapindexDeclaration", gClassInfoFor__semanticDeclaration) ;

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@abstractMethodDefinitionList'               *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_abstractMethodDefinitionList::
elementOf_GGS_abstractMethodDefinitionList (const GGS_lstring & argument_0,
                                const GGS_formalParameterList & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mMethodName (argument_0),
mSignature (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_abstractMethodDefinitionList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_abstractMethodDefinitionList * _p = dynamic_cast <const elementOf_GGS_abstractMethodDefinitionList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mMethodName._operator_isEqual (_p->mMethodName).boolValue ()
         && mSignature._operator_isEqual (_p->mSignature).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_abstractMethodDefinitionList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMethodName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSignature.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@abstractMethodDefinitionList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_formalParameterList & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_formalParameterList & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_formalParameterList & argument_1) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_abstractMethodDefinitionList GGS_abstractMethodDefinitionList::
_operator_concat (const GGS_abstractMethodDefinitionList & inOperand) const {
  GGS_abstractMethodDefinitionList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_abstractMethodDefinitionList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mMethodName ;
          GGS_formalParameterList  p_1 = p->mSignature ;
          result._internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_formalParameterList & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mMethodName,
                                _p->mSignature
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_abstractMethodDefinitionList  GGS_abstractMethodDefinitionList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_abstractMethodDefinitionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_abstractMethodDefinitionList  GGS_abstractMethodDefinitionList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_formalParameterList & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_abstractMethodDefinitionList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionList::
internalSubListWithRange (GGS_abstractMethodDefinitionList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mMethodName, _p->mSignature) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_abstractMethodDefinitionList GGS_abstractMethodDefinitionList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_abstractMethodDefinitionList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_abstractMethodDefinitionList GGS_abstractMethodDefinitionList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_abstractMethodDefinitionList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_abstractMethodDefinitionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@abstractMethodDefinitionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionList::
method_first (C_Compiler & _inLexique,
              GGS_lstring & _out_0,
              GGS_formalParameterList & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMethodName ;
    _out_1 = _p->mSignature ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionList::
method_last (C_Compiler & _inLexique,
             GGS_lstring & _out_0,
             GGS_formalParameterList & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMethodName ;
    _out_1 = _p->mSignature ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_formalParameterList & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMethodName ;
    _out_1 = _p->mSignature ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lstring & _out_0,
                GGS_formalParameterList & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMethodName ;
    _out_1 = _p->mSignature ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_abstractMethodDefinitionList::
reader_mMethodNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mMethodName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameterList  GGS_abstractMethodDefinitionList::
reader_mSignatureAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_formalParameterList  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSignature ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionList::
modifier_setMMethodNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mMethodName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionList::
modifier_setMSignatureAtIndex (C_Compiler & inLexique,
                              const GGS_formalParameterList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSignature = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@overridenMethodDefinitionList'              *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_overridenMethodDefinitionList::
elementOf_GGS_overridenMethodDefinitionList (const GGS_lstring & argument_0,
                                const GGS_formalParameterList & argument_1,
                                const GGS_semanticInstructionList & argument_2
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mMethodName (argument_0),
mSignature (argument_1),
mInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_overridenMethodDefinitionList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_overridenMethodDefinitionList * _p = dynamic_cast <const elementOf_GGS_overridenMethodDefinitionList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mMethodName._operator_isEqual (_p->mMethodName).boolValue ()
         && mSignature._operator_isEqual (_p->mSignature).boolValue ()
         && mInstructionList._operator_isEqual (_p->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_overridenMethodDefinitionList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMethodName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSignature.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@overridenMethodDefinitionList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_overridenMethodDefinitionList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_formalParameterList & argument_1,
                    const GGS_semanticInstructionList & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_overridenMethodDefinitionList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_formalParameterList & argument_1,
                    const GGS_semanticInstructionList & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_overridenMethodDefinitionList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_formalParameterList & argument_1,
                                const GGS_semanticInstructionList & argument_2) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_overridenMethodDefinitionList GGS_overridenMethodDefinitionList::
_operator_concat (const GGS_overridenMethodDefinitionList & inOperand) const {
  GGS_overridenMethodDefinitionList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_overridenMethodDefinitionList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mMethodName ;
          GGS_formalParameterList  p_1 = p->mSignature ;
          GGS_semanticInstructionList  p_2 = p->mInstructionList ;
          result._internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_overridenMethodDefinitionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_formalParameterList & argument_1,
                     const GGS_semanticInstructionList & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_overridenMethodDefinitionList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mMethodName,
                                _p->mSignature,
                                _p->mInstructionList
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_overridenMethodDefinitionList  GGS_overridenMethodDefinitionList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_overridenMethodDefinitionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_overridenMethodDefinitionList  GGS_overridenMethodDefinitionList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_formalParameterList & argument_1,
                           const GGS_semanticInstructionList & argument_2
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_overridenMethodDefinitionList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_overridenMethodDefinitionList::
internalSubListWithRange (GGS_overridenMethodDefinitionList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mMethodName, _p->mSignature, _p->mInstructionList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_overridenMethodDefinitionList GGS_overridenMethodDefinitionList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_overridenMethodDefinitionList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_overridenMethodDefinitionList GGS_overridenMethodDefinitionList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_overridenMethodDefinitionList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_overridenMethodDefinitionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@overridenMethodDefinitionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_overridenMethodDefinitionList::
method_first (C_Compiler & _inLexique,
              GGS_lstring & _out_0,
              GGS_formalParameterList & _out_1,
              GGS_semanticInstructionList & _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMethodName ;
    _out_1 = _p->mSignature ;
    _out_2 = _p->mInstructionList ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_overridenMethodDefinitionList::
method_last (C_Compiler & _inLexique,
             GGS_lstring & _out_0,
             GGS_formalParameterList & _out_1,
             GGS_semanticInstructionList & _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMethodName ;
    _out_1 = _p->mSignature ;
    _out_2 = _p->mInstructionList ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_overridenMethodDefinitionList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_formalParameterList & _out_1,
                 GGS_semanticInstructionList & _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMethodName ;
    _out_1 = _p->mSignature ;
    _out_2 = _p->mInstructionList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_overridenMethodDefinitionList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lstring & _out_0,
                GGS_formalParameterList & _out_1,
                GGS_semanticInstructionList & _out_2
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMethodName ;
    _out_1 = _p->mSignature ;
    _out_2 = _p->mInstructionList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_overridenMethodDefinitionList::
reader_mMethodNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mMethodName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameterList  GGS_overridenMethodDefinitionList::
reader_mSignatureAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_formalParameterList  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSignature ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionList  GGS_overridenMethodDefinitionList::
reader_mInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticInstructionList  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_overridenMethodDefinitionList::
modifier_setMMethodNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mMethodName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_overridenMethodDefinitionList::
modifier_setMSignatureAtIndex (C_Compiler & inLexique,
                              const GGS_formalParameterList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSignature = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_overridenMethodDefinitionList::
modifier_setMInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_semanticInstructionList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@methodDefinitionList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_methodDefinitionList::
elementOf_GGS_methodDefinitionList (const GGS_lstring & argument_0,
                                const GGS_formalParameterList & argument_1,
                                const GGS_semanticInstructionList & argument_2
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mMethodName (argument_0),
mSignature (argument_1),
mInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_methodDefinitionList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_methodDefinitionList * _p = dynamic_cast <const elementOf_GGS_methodDefinitionList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mMethodName._operator_isEqual (_p->mMethodName).boolValue ()
         && mSignature._operator_isEqual (_p->mSignature).boolValue ()
         && mInstructionList._operator_isEqual (_p->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_methodDefinitionList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMethodName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSignature.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@methodDefinitionList'                        *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_methodDefinitionList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_formalParameterList & argument_1,
                    const GGS_semanticInstructionList & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_formalParameterList & argument_1,
                    const GGS_semanticInstructionList & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_formalParameterList & argument_1,
                                const GGS_semanticInstructionList & argument_2) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_methodDefinitionList GGS_methodDefinitionList::
_operator_concat (const GGS_methodDefinitionList & inOperand) const {
  GGS_methodDefinitionList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_methodDefinitionList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mMethodName ;
          GGS_formalParameterList  p_1 = p->mSignature ;
          GGS_semanticInstructionList  p_2 = p->mInstructionList ;
          result._internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_formalParameterList & argument_1,
                     const GGS_semanticInstructionList & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mMethodName,
                                _p->mSignature,
                                _p->mInstructionList
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_methodDefinitionList  GGS_methodDefinitionList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_methodDefinitionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_methodDefinitionList  GGS_methodDefinitionList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_formalParameterList & argument_1,
                           const GGS_semanticInstructionList & argument_2
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_methodDefinitionList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionList::
internalSubListWithRange (GGS_methodDefinitionList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mMethodName, _p->mSignature, _p->mInstructionList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_methodDefinitionList GGS_methodDefinitionList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_methodDefinitionList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_methodDefinitionList GGS_methodDefinitionList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_methodDefinitionList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_methodDefinitionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@methodDefinitionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionList::
method_first (C_Compiler & _inLexique,
              GGS_lstring & _out_0,
              GGS_formalParameterList & _out_1,
              GGS_semanticInstructionList & _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMethodName ;
    _out_1 = _p->mSignature ;
    _out_2 = _p->mInstructionList ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionList::
method_last (C_Compiler & _inLexique,
             GGS_lstring & _out_0,
             GGS_formalParameterList & _out_1,
             GGS_semanticInstructionList & _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMethodName ;
    _out_1 = _p->mSignature ;
    _out_2 = _p->mInstructionList ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_formalParameterList & _out_1,
                 GGS_semanticInstructionList & _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMethodName ;
    _out_1 = _p->mSignature ;
    _out_2 = _p->mInstructionList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lstring & _out_0,
                GGS_formalParameterList & _out_1,
                GGS_semanticInstructionList & _out_2
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMethodName ;
    _out_1 = _p->mSignature ;
    _out_2 = _p->mInstructionList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_methodDefinitionList::
reader_mMethodNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mMethodName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameterList  GGS_methodDefinitionList::
reader_mSignatureAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_formalParameterList  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSignature ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionList  GGS_methodDefinitionList::
reader_mInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticInstructionList  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionList::
modifier_setMMethodNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mMethodName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionList::
modifier_setMSignatureAtIndex (C_Compiler & inLexique,
                              const GGS_formalParameterList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSignature = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionList::
modifier_setMInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_semanticInstructionList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@classMessageDefinitionList'                *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_classMessageDefinitionList::
elementOf_GGS_classMessageDefinitionList (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mMessageName (argument_0),
mMessageValue (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_classMessageDefinitionList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_classMessageDefinitionList * _p = dynamic_cast <const elementOf_GGS_classMessageDefinitionList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mMessageName._operator_isEqual (_p->mMessageName).boolValue ()
         && mMessageValue._operator_isEqual (_p->mMessageValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_classMessageDefinitionList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMessageName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMessageValue.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@classMessageDefinitionList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_classMessageDefinitionList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_classMessageDefinitionList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_classMessageDefinitionList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_classMessageDefinitionList GGS_classMessageDefinitionList::
_operator_concat (const GGS_classMessageDefinitionList & inOperand) const {
  GGS_classMessageDefinitionList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_classMessageDefinitionList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mMessageName ;
          GGS_lstring  p_1 = p->mMessageValue ;
          result._internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_classMessageDefinitionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_classMessageDefinitionList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mMessageName,
                                _p->mMessageValue
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_classMessageDefinitionList  GGS_classMessageDefinitionList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_classMessageDefinitionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_classMessageDefinitionList  GGS_classMessageDefinitionList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_lstring & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_classMessageDefinitionList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_classMessageDefinitionList::
internalSubListWithRange (GGS_classMessageDefinitionList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mMessageName, _p->mMessageValue) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_classMessageDefinitionList GGS_classMessageDefinitionList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_classMessageDefinitionList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_classMessageDefinitionList GGS_classMessageDefinitionList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_classMessageDefinitionList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_classMessageDefinitionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@classMessageDefinitionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_classMessageDefinitionList::
method_first (C_Compiler & _inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMessageName ;
    _out_1 = _p->mMessageValue ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_classMessageDefinitionList::
method_last (C_Compiler & _inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMessageName ;
    _out_1 = _p->mMessageValue ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_classMessageDefinitionList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMessageName ;
    _out_1 = _p->mMessageValue ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_classMessageDefinitionList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMessageName ;
    _out_1 = _p->mMessageValue ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_classMessageDefinitionList::
reader_mMessageNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mMessageName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_classMessageDefinitionList::
reader_mMessageValueAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mMessageValue ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_classMessageDefinitionList::
modifier_setMMessageNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mMessageName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_classMessageDefinitionList::
modifier_setMMessageValueAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mMessageValue = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_classDeclaration'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_classDeclaration::
cPtr_classDeclaration (const GGS_bool& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_attributeInCollectionList & argument_3,
                                const GGS_abstractMethodDefinitionList & argument_4,
                                const GGS_overridenMethodDefinitionList & argument_5,
                                const GGS_methodDefinitionList & argument_6,
                                const GGS_classMessageDefinitionList & argument_7,
                                const GGS_string& argument_8
                                COMMA_LOCATION_ARGS)
:cPtr_semanticDeclaration (THERE),
mIsAbstract (argument_0),
mClassTypeName (argument_1),
mSuperClassName (argument_2),
mAttributeList (argument_3),
mAbstractMethodList (argument_4),
mOverridenMethodList (argument_5),
mMethodList (argument_6),
mMessageList (argument_7),
mClassMessage (argument_8) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_classDeclaration * GGS_classDeclaration::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_classDeclaration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_classDeclaration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_classDeclaration * _p = dynamic_cast <const cPtr_classDeclaration *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mIsAbstract._operator_isEqual (_p->mIsAbstract).boolValue ()
         && mClassTypeName._operator_isEqual (_p->mClassTypeName).boolValue ()
         && mSuperClassName._operator_isEqual (_p->mSuperClassName).boolValue ()
         && mAttributeList._operator_isEqual (_p->mAttributeList).boolValue ()
         && mAbstractMethodList._operator_isEqual (_p->mAbstractMethodList).boolValue ()
         && mOverridenMethodList._operator_isEqual (_p->mOverridenMethodList).boolValue ()
         && mMethodList._operator_isEqual (_p->mMethodList).boolValue ()
         && mMessageList._operator_isEqual (_p->mMessageList).boolValue ()
         && mClassMessage._operator_isEqual (_p->mClassMessage).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_classDeclaration::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@classDeclaration:"
           << mIsAbstract.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mClassTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mSuperClassName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mAttributeList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mAbstractMethodList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mOverridenMethodList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mMethodList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mMessageList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mClassMessage.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_classDeclaration::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_classDeclaration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_classDeclaration (& typeid (cPtr_classDeclaration), & typeid (cPtr_semanticDeclaration), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_classDeclaration::galgasRTTI (void) const {
  return & gClassInfoFor__classDeclaration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_classDeclaration'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_classDeclaration::
GGS_classDeclaration (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_classDeclaration::
GGS_classDeclaration (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_classDeclaration GGS_classDeclaration::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_classDeclaration _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_classDeclaration *> (inPointer) != NULL)
      : (typeid (cPtr_classDeclaration) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_classDeclaration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_classDeclaration),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_classDeclaration GGS_classDeclaration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_bool& argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_attributeInCollectionList & argument_3,
                 const GGS_abstractMethodDefinitionList & argument_4,
                 const GGS_overridenMethodDefinitionList & argument_5,
                 const GGS_methodDefinitionList & argument_6,
                 const GGS_classMessageDefinitionList & argument_7,
                 const GGS_string& argument_8
                                COMMA_LOCATION_ARGS) {
  GGS_classDeclaration result ;
  macroMyNew (result.mPointer, cPtr_classDeclaration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7,
                                argument_8 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_classDeclaration::
reader_mIsAbstract (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classDeclaration *) mPointer)->mIsAbstract ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_classDeclaration::
reader_mClassTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classDeclaration *) mPointer)->mClassTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_classDeclaration::
reader_mSuperClassName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classDeclaration *) mPointer)->mSuperClassName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_attributeInCollectionList  GGS_classDeclaration::
reader_mAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_attributeInCollectionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classDeclaration *) mPointer)->mAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_abstractMethodDefinitionList  GGS_classDeclaration::
reader_mAbstractMethodList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_abstractMethodDefinitionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classDeclaration *) mPointer)->mAbstractMethodList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_overridenMethodDefinitionList  GGS_classDeclaration::
reader_mOverridenMethodList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_overridenMethodDefinitionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classDeclaration *) mPointer)->mOverridenMethodList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_methodDefinitionList  GGS_classDeclaration::
reader_mMethodList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_methodDefinitionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classDeclaration *) mPointer)->mMethodList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_classMessageDefinitionList  GGS_classDeclaration::
reader_mMessageList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_classMessageDefinitionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classDeclaration *) mPointer)->mMessageList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_classDeclaration::
reader_mClassMessage (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classDeclaration *) mPointer)->mClassMessage ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_classDeclaration::actualTypeName (void) const {
  return "classDeclaration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__classDeclaration ("classDeclaration", gClassInfoFor__semanticDeclaration) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_listDeclaration'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_listDeclaration::
cPtr_listDeclaration (const GGS_lstring & argument_0,
                                const GGS_attributeInCollectionList & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticDeclaration (THERE),
mListTypeName (argument_0),
mAttributeList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_listDeclaration * GGS_listDeclaration::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_listDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_listDeclaration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_listDeclaration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_listDeclaration * _p = dynamic_cast <const cPtr_listDeclaration *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mListTypeName._operator_isEqual (_p->mListTypeName).boolValue ()
         && mAttributeList._operator_isEqual (_p->mAttributeList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_listDeclaration::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@listDeclaration:"
           << mListTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mAttributeList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_listDeclaration::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_listDeclaration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_listDeclaration (& typeid (cPtr_listDeclaration), & typeid (cPtr_semanticDeclaration), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_listDeclaration::galgasRTTI (void) const {
  return & gClassInfoFor__listDeclaration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_listDeclaration'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_listDeclaration::
GGS_listDeclaration (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_listDeclaration::
GGS_listDeclaration (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_listDeclaration GGS_listDeclaration::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_listDeclaration _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_listDeclaration *> (inPointer) != NULL)
      : (typeid (cPtr_listDeclaration) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_listDeclaration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_listDeclaration),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_listDeclaration GGS_listDeclaration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_attributeInCollectionList & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_listDeclaration result ;
  macroMyNew (result.mPointer, cPtr_listDeclaration (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_listDeclaration::
reader_mListTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_listDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_listDeclaration *) mPointer)->mListTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_attributeInCollectionList  GGS_listDeclaration::
reader_mAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_attributeInCollectionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_listDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_listDeclaration *) mPointer)->mAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_listDeclaration::actualTypeName (void) const {
  return "listDeclaration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__listDeclaration ("listDeclaration", gClassInfoFor__semanticDeclaration) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_structDeclaration'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_structDeclaration::
cPtr_structDeclaration (const GGS_lstring & argument_0,
                                const GGS_attributeInCollectionList & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticDeclaration (THERE),
mStructTypeName (argument_0),
mAttributeList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_structDeclaration * GGS_structDeclaration::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_structDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_structDeclaration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_structDeclaration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_structDeclaration * _p = dynamic_cast <const cPtr_structDeclaration *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mStructTypeName._operator_isEqual (_p->mStructTypeName).boolValue ()
         && mAttributeList._operator_isEqual (_p->mAttributeList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_structDeclaration::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@structDeclaration:"
           << mStructTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mAttributeList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_structDeclaration::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_structDeclaration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_structDeclaration (& typeid (cPtr_structDeclaration), & typeid (cPtr_semanticDeclaration), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_structDeclaration::galgasRTTI (void) const {
  return & gClassInfoFor__structDeclaration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_structDeclaration'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_structDeclaration::
GGS_structDeclaration (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_structDeclaration::
GGS_structDeclaration (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_structDeclaration GGS_structDeclaration::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_structDeclaration _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_structDeclaration *> (inPointer) != NULL)
      : (typeid (cPtr_structDeclaration) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_structDeclaration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_structDeclaration),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_structDeclaration GGS_structDeclaration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_attributeInCollectionList & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_structDeclaration result ;
  macroMyNew (result.mPointer, cPtr_structDeclaration (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_structDeclaration::
reader_mStructTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_structDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_structDeclaration *) mPointer)->mStructTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_attributeInCollectionList  GGS_structDeclaration::
reader_mAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_attributeInCollectionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_structDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_structDeclaration *) mPointer)->mAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_structDeclaration::actualTypeName (void) const {
  return "structDeclaration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__structDeclaration ("structDeclaration", gClassInfoFor__semanticDeclaration) ;

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@sortedListSortDescriptorList'               *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_sortedListSortDescriptorList::
elementOf_GGS_sortedListSortDescriptorList (const GGS_lstring & argument_0,
                                const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mSortedAttributeName (argument_0),
mAscending (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_sortedListSortDescriptorList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_sortedListSortDescriptorList * _p = dynamic_cast <const elementOf_GGS_sortedListSortDescriptorList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mSortedAttributeName._operator_isEqual (_p->mSortedAttributeName).boolValue ()
         && mAscending._operator_isEqual (_p->mAscending).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_sortedListSortDescriptorList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSortedAttributeName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAscending.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@sortedListSortDescriptorList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_sortedListSortDescriptorList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_bool& argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_sortedListSortDescriptorList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_bool& argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_sortedListSortDescriptorList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_bool& argument_1) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_sortedListSortDescriptorList GGS_sortedListSortDescriptorList::
_operator_concat (const GGS_sortedListSortDescriptorList & inOperand) const {
  GGS_sortedListSortDescriptorList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_sortedListSortDescriptorList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mSortedAttributeName ;
          GGS_bool p_1 = p->mAscending ;
          result._internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_sortedListSortDescriptorList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_bool& argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_sortedListSortDescriptorList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mSortedAttributeName,
                                _p->mAscending
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_sortedListSortDescriptorList  GGS_sortedListSortDescriptorList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_sortedListSortDescriptorList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sortedListSortDescriptorList  GGS_sortedListSortDescriptorList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_bool& argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_sortedListSortDescriptorList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_sortedListSortDescriptorList::
internalSubListWithRange (GGS_sortedListSortDescriptorList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mSortedAttributeName, _p->mAscending) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_sortedListSortDescriptorList GGS_sortedListSortDescriptorList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_sortedListSortDescriptorList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sortedListSortDescriptorList GGS_sortedListSortDescriptorList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_sortedListSortDescriptorList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_sortedListSortDescriptorList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@sortedListSortDescriptorList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_sortedListSortDescriptorList::
method_first (C_Compiler & _inLexique,
              GGS_lstring & _out_0,
              GGS_bool& _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mSortedAttributeName ;
    _out_1 = _p->mAscending ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_sortedListSortDescriptorList::
method_last (C_Compiler & _inLexique,
             GGS_lstring & _out_0,
             GGS_bool& _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mSortedAttributeName ;
    _out_1 = _p->mAscending ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_sortedListSortDescriptorList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_bool& _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mSortedAttributeName ;
    _out_1 = _p->mAscending ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_sortedListSortDescriptorList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lstring & _out_0,
                GGS_bool& _out_1
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mSortedAttributeName ;
    _out_1 = _p->mAscending ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_sortedListSortDescriptorList::
reader_mSortedAttributeNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSortedAttributeName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_sortedListSortDescriptorList::
reader_mAscendingAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mAscending ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_sortedListSortDescriptorList::
modifier_setMSortedAttributeNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSortedAttributeName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_sortedListSortDescriptorList::
modifier_setMAscendingAtIndex (C_Compiler & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mAscending = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_sortedListDeclaration'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_sortedListDeclaration::
cPtr_sortedListDeclaration (const GGS_lstring & argument_0,
                                const GGS_attributeInCollectionList & argument_1,
                                const GGS_sortedListSortDescriptorList & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticDeclaration (THERE),
mSortedListTypeName (argument_0),
mAttributeList (argument_1),
mSortDescriptorList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_sortedListDeclaration * GGS_sortedListDeclaration::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sortedListDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_sortedListDeclaration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_sortedListDeclaration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_sortedListDeclaration * _p = dynamic_cast <const cPtr_sortedListDeclaration *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mSortedListTypeName._operator_isEqual (_p->mSortedListTypeName).boolValue ()
         && mAttributeList._operator_isEqual (_p->mAttributeList).boolValue ()
         && mSortDescriptorList._operator_isEqual (_p->mSortDescriptorList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_sortedListDeclaration::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@sortedListDeclaration:"
           << mSortedListTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mAttributeList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mSortDescriptorList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_sortedListDeclaration::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_sortedListDeclaration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_sortedListDeclaration (& typeid (cPtr_sortedListDeclaration), & typeid (cPtr_semanticDeclaration), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_sortedListDeclaration::galgasRTTI (void) const {
  return & gClassInfoFor__sortedListDeclaration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_sortedListDeclaration'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_sortedListDeclaration::
GGS_sortedListDeclaration (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_sortedListDeclaration::
GGS_sortedListDeclaration (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_sortedListDeclaration GGS_sortedListDeclaration::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_sortedListDeclaration _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_sortedListDeclaration *> (inPointer) != NULL)
      : (typeid (cPtr_sortedListDeclaration) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_sortedListDeclaration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_sortedListDeclaration),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_sortedListDeclaration GGS_sortedListDeclaration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_attributeInCollectionList & argument_1,
                 const GGS_sortedListSortDescriptorList & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_sortedListDeclaration result ;
  macroMyNew (result.mPointer, cPtr_sortedListDeclaration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_sortedListDeclaration::
reader_mSortedListTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sortedListDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sortedListDeclaration *) mPointer)->mSortedListTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_attributeInCollectionList  GGS_sortedListDeclaration::
reader_mAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_attributeInCollectionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sortedListDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sortedListDeclaration *) mPointer)->mAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sortedListSortDescriptorList  GGS_sortedListDeclaration::
reader_mSortDescriptorList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_sortedListSortDescriptorList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sortedListDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sortedListDeclaration *) mPointer)->mSortDescriptorList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_sortedListDeclaration::actualTypeName (void) const {
  return "sortedListDeclaration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__sortedListDeclaration ("sortedListDeclaration", gClassInfoFor__semanticDeclaration) ;

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@enumMessageAssociationList'                *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_enumMessageAssociationList::
elementOf_GGS_enumMessageAssociationList (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mConstantName (argument_0),
mMessage (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_enumMessageAssociationList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_enumMessageAssociationList * _p = dynamic_cast <const elementOf_GGS_enumMessageAssociationList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mConstantName._operator_isEqual (_p->mConstantName).boolValue ()
         && mMessage._operator_isEqual (_p->mMessage).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_enumMessageAssociationList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mConstantName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMessage.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@enumMessageAssociationList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_enumMessageAssociationList GGS_enumMessageAssociationList::
_operator_concat (const GGS_enumMessageAssociationList & inOperand) const {
  GGS_enumMessageAssociationList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_enumMessageAssociationList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mConstantName ;
          GGS_lstring  p_1 = p->mMessage ;
          result._internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mConstantName,
                                _p->mMessage
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_enumMessageAssociationList  GGS_enumMessageAssociationList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_enumMessageAssociationList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMessageAssociationList  GGS_enumMessageAssociationList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_lstring & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_enumMessageAssociationList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationList::
internalSubListWithRange (GGS_enumMessageAssociationList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mConstantName, _p->mMessage) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_enumMessageAssociationList GGS_enumMessageAssociationList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_enumMessageAssociationList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMessageAssociationList GGS_enumMessageAssociationList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_enumMessageAssociationList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_enumMessageAssociationList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@enumMessageAssociationList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationList::
method_first (C_Compiler & _inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mConstantName ;
    _out_1 = _p->mMessage ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationList::
method_last (C_Compiler & _inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mConstantName ;
    _out_1 = _p->mMessage ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mConstantName ;
    _out_1 = _p->mMessage ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mConstantName ;
    _out_1 = _p->mMessage ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_enumMessageAssociationList::
reader_mConstantNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mConstantName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_enumMessageAssociationList::
reader_mMessageAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mMessage ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationList::
modifier_setMConstantNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mConstantName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationList::
modifier_setMMessageAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mMessage = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    Element of list '@enumMessageList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_enumMessageList::
elementOf_GGS_enumMessageList (const GGS_lstring & argument_0,
                                const GGS_enumMessageAssociationList & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mEnumMessageName (argument_0),
mMessageAssociationList (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_enumMessageList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_enumMessageList * _p = dynamic_cast <const elementOf_GGS_enumMessageList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mEnumMessageName._operator_isEqual (_p->mEnumMessageName).boolValue ()
         && mMessageAssociationList._operator_isEqual (_p->mMessageAssociationList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_enumMessageList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEnumMessageName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMessageAssociationList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         List '@enumMessageList'                           *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_enumMessageList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_enumMessageAssociationList & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_enumMessageAssociationList & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_enumMessageAssociationList & argument_1) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_enumMessageList GGS_enumMessageList::
_operator_concat (const GGS_enumMessageList & inOperand) const {
  GGS_enumMessageList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_enumMessageList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mEnumMessageName ;
          GGS_enumMessageAssociationList  p_1 = p->mMessageAssociationList ;
          result._internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_enumMessageAssociationList & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mEnumMessageName,
                                _p->mMessageAssociationList
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_enumMessageList  GGS_enumMessageList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_enumMessageList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMessageList  GGS_enumMessageList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_enumMessageAssociationList & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_enumMessageList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageList::
internalSubListWithRange (GGS_enumMessageList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mEnumMessageName, _p->mMessageAssociationList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_enumMessageList GGS_enumMessageList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_enumMessageList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMessageList GGS_enumMessageList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_enumMessageList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_enumMessageList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@enumMessageList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageList::
method_first (C_Compiler & _inLexique,
              GGS_lstring & _out_0,
              GGS_enumMessageAssociationList & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mEnumMessageName ;
    _out_1 = _p->mMessageAssociationList ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageList::
method_last (C_Compiler & _inLexique,
             GGS_lstring & _out_0,
             GGS_enumMessageAssociationList & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mEnumMessageName ;
    _out_1 = _p->mMessageAssociationList ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_enumMessageAssociationList & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mEnumMessageName ;
    _out_1 = _p->mMessageAssociationList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lstring & _out_0,
                GGS_enumMessageAssociationList & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mEnumMessageName ;
    _out_1 = _p->mMessageAssociationList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_enumMessageList::
reader_mEnumMessageNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mEnumMessageName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMessageAssociationList  GGS_enumMessageList::
reader_mMessageAssociationListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_enumMessageAssociationList  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mMessageAssociationList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageList::
modifier_setMEnumMessageNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mEnumMessageName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageList::
modifier_setMMessageAssociationListAtIndex (C_Compiler & inLexique,
                              const GGS_enumMessageAssociationList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mMessageAssociationList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_enumCaseMessage'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_enumCaseMessage::
cPtr_enumCaseMessage (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_enumCaseMessage * GGS_enumCaseMessage::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumCaseMessage *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_enumCaseMessage *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_enumCaseMessage::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_enumCaseMessage::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@enumCaseMessage:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_enumCaseMessage::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_enumCaseMessage::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_enumCaseMessage (& typeid (cPtr_enumCaseMessage), NULL
, "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_enumCaseMessage::galgasRTTI (void) const {
  return & gClassInfoFor__enumCaseMessage ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_enumCaseMessage'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_enumCaseMessage::
GGS_enumCaseMessage (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_enumCaseMessage::
GGS_enumCaseMessage (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_enumCaseMessage GGS_enumCaseMessage::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_enumCaseMessage _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_enumCaseMessage *> (inPointer) != NULL)
      : (typeid (cPtr_enumCaseMessage) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_enumCaseMessage (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_enumCaseMessage),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_enumCaseMessage * gSingleton_enumCaseMessage = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_enumCaseMessage (void) {
  macroDetachPointer (gSingleton_enumCaseMessage, cPtr_enumCaseMessage) ;
}

//---------------------------------------------------------------------------*

GGS_enumCaseMessage GGS_enumCaseMessage::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_enumCaseMessage result ;
  if (NULL == gSingleton_enumCaseMessage) {
    macroMyNew (gSingleton_enumCaseMessage, cPtr_enumCaseMessage (THERE)) ;
    registerReleaseRoutine (cleanUp_enumCaseMessage) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_enumCaseMessage) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_enumCaseMessage::actualTypeName (void) const {
  return "enumCaseMessage" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_enumCaseMessage::_galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__enumCaseMessage ("enumCaseMessage") ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@enumModifierCaseList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_enumModifierCaseList::
elementOf_GGS_enumModifierCaseList (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_enumCaseMessage & argument_2
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mSourceConstantName (argument_0),
mTargetConstantName (argument_1),
mEnumModifierCaseMessage (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_enumModifierCaseList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_enumModifierCaseList * _p = dynamic_cast <const elementOf_GGS_enumModifierCaseList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mSourceConstantName._operator_isEqual (_p->mSourceConstantName).boolValue ()
         && mTargetConstantName._operator_isEqual (_p->mTargetConstantName).boolValue ()
         && mEnumModifierCaseMessage._operator_isEqual (_p->mEnumModifierCaseMessage).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_enumModifierCaseList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSourceConstantName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTargetConstantName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEnumModifierCaseMessage.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@enumModifierCaseList'                        *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_enumModifierCaseList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_enumCaseMessage & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_enumModifierCaseList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_enumCaseMessage & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_enumModifierCaseList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_enumCaseMessage & argument_2) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_enumModifierCaseList GGS_enumModifierCaseList::
_operator_concat (const GGS_enumModifierCaseList & inOperand) const {
  GGS_enumModifierCaseList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_enumModifierCaseList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mSourceConstantName ;
          GGS_lstring  p_1 = p->mTargetConstantName ;
          GGS_enumCaseMessage  p_2 = p->mEnumModifierCaseMessage ;
          result._internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumModifierCaseList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_enumCaseMessage & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumModifierCaseList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mSourceConstantName,
                                _p->mTargetConstantName,
                                _p->mEnumModifierCaseMessage
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_enumModifierCaseList  GGS_enumModifierCaseList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_enumModifierCaseList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumModifierCaseList  GGS_enumModifierCaseList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_lstring & argument_1,
                           const GGS_enumCaseMessage & argument_2
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_enumModifierCaseList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumModifierCaseList::
internalSubListWithRange (GGS_enumModifierCaseList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mSourceConstantName, _p->mTargetConstantName, _p->mEnumModifierCaseMessage) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_enumModifierCaseList GGS_enumModifierCaseList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_enumModifierCaseList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumModifierCaseList GGS_enumModifierCaseList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_enumModifierCaseList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_enumModifierCaseList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@enumModifierCaseList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_enumModifierCaseList::
method_first (C_Compiler & _inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1,
              GGS_enumCaseMessage & _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mSourceConstantName ;
    _out_1 = _p->mTargetConstantName ;
    _out_2 = _p->mEnumModifierCaseMessage ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumModifierCaseList::
method_last (C_Compiler & _inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1,
             GGS_enumCaseMessage & _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mSourceConstantName ;
    _out_1 = _p->mTargetConstantName ;
    _out_2 = _p->mEnumModifierCaseMessage ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumModifierCaseList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1,
                 GGS_enumCaseMessage & _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mSourceConstantName ;
    _out_1 = _p->mTargetConstantName ;
    _out_2 = _p->mEnumModifierCaseMessage ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumModifierCaseList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1,
                GGS_enumCaseMessage & _out_2
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mSourceConstantName ;
    _out_1 = _p->mTargetConstantName ;
    _out_2 = _p->mEnumModifierCaseMessage ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_enumModifierCaseList::
reader_mSourceConstantNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSourceConstantName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_enumModifierCaseList::
reader_mTargetConstantNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mTargetConstantName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumCaseMessage  GGS_enumModifierCaseList::
reader_mEnumModifierCaseMessageAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_enumCaseMessage  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mEnumModifierCaseMessage ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumModifierCaseList::
modifier_setMSourceConstantNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSourceConstantName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumModifierCaseList::
modifier_setMTargetConstantNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mTargetConstantName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumModifierCaseList::
modifier_setMEnumModifierCaseMessageAtIndex (C_Compiler & inLexique,
                              const GGS_enumCaseMessage  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mEnumModifierCaseMessage = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   Element of list '@enumModifierList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_enumModifierList::
elementOf_GGS_enumModifierList (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_enumModifierCaseList & argument_2
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mModifierName (argument_0),
mLocationFormalArgumentName (argument_1),
mEnumModifierCaseList (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_enumModifierList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_enumModifierList * _p = dynamic_cast <const elementOf_GGS_enumModifierList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mModifierName._operator_isEqual (_p->mModifierName).boolValue ()
         && mLocationFormalArgumentName._operator_isEqual (_p->mLocationFormalArgumentName).boolValue ()
         && mEnumModifierCaseList._operator_isEqual (_p->mEnumModifierCaseList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_enumModifierList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mModifierName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLocationFormalArgumentName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEnumModifierCaseList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         List '@enumModifierList'                          *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_enumModifierList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_enumModifierCaseList & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_enumModifierList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_enumModifierCaseList & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_enumModifierList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_enumModifierCaseList & argument_2) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_enumModifierList GGS_enumModifierList::
_operator_concat (const GGS_enumModifierList & inOperand) const {
  GGS_enumModifierList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_enumModifierList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mModifierName ;
          GGS_lstring  p_1 = p->mLocationFormalArgumentName ;
          GGS_enumModifierCaseList  p_2 = p->mEnumModifierCaseList ;
          result._internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumModifierList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_enumModifierCaseList & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumModifierList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mModifierName,
                                _p->mLocationFormalArgumentName,
                                _p->mEnumModifierCaseList
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_enumModifierList  GGS_enumModifierList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_enumModifierList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumModifierList  GGS_enumModifierList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_lstring & argument_1,
                           const GGS_enumModifierCaseList & argument_2
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_enumModifierList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumModifierList::
internalSubListWithRange (GGS_enumModifierList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mModifierName, _p->mLocationFormalArgumentName, _p->mEnumModifierCaseList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_enumModifierList GGS_enumModifierList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_enumModifierList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumModifierList GGS_enumModifierList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_enumModifierList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_enumModifierList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@enumModifierList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_enumModifierList::
method_first (C_Compiler & _inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1,
              GGS_enumModifierCaseList & _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mModifierName ;
    _out_1 = _p->mLocationFormalArgumentName ;
    _out_2 = _p->mEnumModifierCaseList ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumModifierList::
method_last (C_Compiler & _inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1,
             GGS_enumModifierCaseList & _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mModifierName ;
    _out_1 = _p->mLocationFormalArgumentName ;
    _out_2 = _p->mEnumModifierCaseList ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumModifierList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1,
                 GGS_enumModifierCaseList & _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mModifierName ;
    _out_1 = _p->mLocationFormalArgumentName ;
    _out_2 = _p->mEnumModifierCaseList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumModifierList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1,
                GGS_enumModifierCaseList & _out_2
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mModifierName ;
    _out_1 = _p->mLocationFormalArgumentName ;
    _out_2 = _p->mEnumModifierCaseList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_enumModifierList::
reader_mModifierNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mModifierName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_enumModifierList::
reader_mLocationFormalArgumentNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mLocationFormalArgumentName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumModifierCaseList  GGS_enumModifierList::
reader_mEnumModifierCaseListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_enumModifierCaseList  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mEnumModifierCaseList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumModifierList::
modifier_setMModifierNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mModifierName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumModifierList::
modifier_setMLocationFormalArgumentNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mLocationFormalArgumentName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumModifierList::
modifier_setMEnumModifierCaseListAtIndex (C_Compiler & inLexique,
                              const GGS_enumModifierCaseList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mEnumModifierCaseList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_enumCaseErrorMessage'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_enumCaseErrorMessage::
cPtr_enumCaseErrorMessage (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_enumCaseMessage (THERE),
mLocationParameterName (argument_0),
mMessage (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_enumCaseErrorMessage * GGS_enumCaseErrorMessage::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumCaseErrorMessage *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_enumCaseErrorMessage *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_enumCaseErrorMessage::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_enumCaseErrorMessage * _p = dynamic_cast <const cPtr_enumCaseErrorMessage *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mLocationParameterName._operator_isEqual (_p->mLocationParameterName).boolValue ()
         && mMessage._operator_isEqual (_p->mMessage).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_enumCaseErrorMessage::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@enumCaseErrorMessage:"
           << mLocationParameterName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mMessage.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_enumCaseErrorMessage::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_enumCaseErrorMessage::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_enumCaseErrorMessage (& typeid (cPtr_enumCaseErrorMessage), & typeid (cPtr_enumCaseMessage), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_enumCaseErrorMessage::galgasRTTI (void) const {
  return & gClassInfoFor__enumCaseErrorMessage ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_enumCaseErrorMessage'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_enumCaseErrorMessage::
GGS_enumCaseErrorMessage (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_enumCaseErrorMessage::
GGS_enumCaseErrorMessage (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_enumCaseErrorMessage GGS_enumCaseErrorMessage::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_enumCaseErrorMessage _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_enumCaseErrorMessage *> (inPointer) != NULL)
      : (typeid (cPtr_enumCaseErrorMessage) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_enumCaseErrorMessage (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_enumCaseErrorMessage),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_enumCaseErrorMessage GGS_enumCaseErrorMessage::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_enumCaseErrorMessage result ;
  macroMyNew (result.mPointer, cPtr_enumCaseErrorMessage (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_enumCaseErrorMessage::
reader_mLocationParameterName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumCaseErrorMessage *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumCaseErrorMessage *) mPointer)->mLocationParameterName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_enumCaseErrorMessage::
reader_mMessage (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumCaseErrorMessage *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumCaseErrorMessage *) mPointer)->mMessage ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_enumCaseErrorMessage::actualTypeName (void) const {
  return "enumCaseErrorMessage" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__enumCaseErrorMessage ("enumCaseErrorMessage", gClassInfoFor__enumCaseMessage) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_enumCaseWarningMessage'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_enumCaseWarningMessage::
cPtr_enumCaseWarningMessage (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_enumCaseMessage (THERE),
mLocationParameterName (argument_0),
mMessage (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_enumCaseWarningMessage * GGS_enumCaseWarningMessage::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumCaseWarningMessage *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_enumCaseWarningMessage *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_enumCaseWarningMessage::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_enumCaseWarningMessage * _p = dynamic_cast <const cPtr_enumCaseWarningMessage *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mLocationParameterName._operator_isEqual (_p->mLocationParameterName).boolValue ()
         && mMessage._operator_isEqual (_p->mMessage).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_enumCaseWarningMessage::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@enumCaseWarningMessage:"
           << mLocationParameterName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mMessage.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_enumCaseWarningMessage::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_enumCaseWarningMessage::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_enumCaseWarningMessage (& typeid (cPtr_enumCaseWarningMessage), & typeid (cPtr_enumCaseMessage), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_enumCaseWarningMessage::galgasRTTI (void) const {
  return & gClassInfoFor__enumCaseWarningMessage ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_enumCaseWarningMessage'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_enumCaseWarningMessage::
GGS_enumCaseWarningMessage (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_enumCaseWarningMessage::
GGS_enumCaseWarningMessage (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_enumCaseWarningMessage GGS_enumCaseWarningMessage::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_enumCaseWarningMessage _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_enumCaseWarningMessage *> (inPointer) != NULL)
      : (typeid (cPtr_enumCaseWarningMessage) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_enumCaseWarningMessage (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_enumCaseWarningMessage),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_enumCaseWarningMessage GGS_enumCaseWarningMessage::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_enumCaseWarningMessage result ;
  macroMyNew (result.mPointer, cPtr_enumCaseWarningMessage (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_enumCaseWarningMessage::
reader_mLocationParameterName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumCaseWarningMessage *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumCaseWarningMessage *) mPointer)->mLocationParameterName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_enumCaseWarningMessage::
reader_mMessage (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumCaseWarningMessage *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumCaseWarningMessage *) mPointer)->mMessage ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_enumCaseWarningMessage::actualTypeName (void) const {
  return "enumCaseWarningMessage" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__enumCaseWarningMessage ("enumCaseWarningMessage", gClassInfoFor__enumCaseMessage) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@enumMethodCaseList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_enumMethodCaseList::
elementOf_GGS_enumMethodCaseList (const GGS_lstring & argument_0,
                                const GGS_enumCaseMessage & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mConstantName (argument_0),
mEnumMethodCaseMessage (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_enumMethodCaseList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_enumMethodCaseList * _p = dynamic_cast <const elementOf_GGS_enumMethodCaseList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mConstantName._operator_isEqual (_p->mConstantName).boolValue ()
         && mEnumMethodCaseMessage._operator_isEqual (_p->mEnumMethodCaseMessage).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_enumMethodCaseList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mConstantName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEnumMethodCaseMessage.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        List '@enumMethodCaseList'                         *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_enumMethodCaseList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_enumCaseMessage & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMethodCaseList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_enumCaseMessage & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMethodCaseList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_enumCaseMessage & argument_1) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_enumMethodCaseList GGS_enumMethodCaseList::
_operator_concat (const GGS_enumMethodCaseList & inOperand) const {
  GGS_enumMethodCaseList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_enumMethodCaseList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mConstantName ;
          GGS_enumCaseMessage  p_1 = p->mEnumMethodCaseMessage ;
          result._internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumMethodCaseList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_enumCaseMessage & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMethodCaseList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mConstantName,
                                _p->mEnumMethodCaseMessage
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_enumMethodCaseList  GGS_enumMethodCaseList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_enumMethodCaseList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMethodCaseList  GGS_enumMethodCaseList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_enumCaseMessage & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_enumMethodCaseList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumMethodCaseList::
internalSubListWithRange (GGS_enumMethodCaseList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mConstantName, _p->mEnumMethodCaseMessage) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_enumMethodCaseList GGS_enumMethodCaseList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_enumMethodCaseList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMethodCaseList GGS_enumMethodCaseList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_enumMethodCaseList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_enumMethodCaseList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@enumMethodCaseList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMethodCaseList::
method_first (C_Compiler & _inLexique,
              GGS_lstring & _out_0,
              GGS_enumCaseMessage & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mConstantName ;
    _out_1 = _p->mEnumMethodCaseMessage ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMethodCaseList::
method_last (C_Compiler & _inLexique,
             GGS_lstring & _out_0,
             GGS_enumCaseMessage & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mConstantName ;
    _out_1 = _p->mEnumMethodCaseMessage ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMethodCaseList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_enumCaseMessage & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mConstantName ;
    _out_1 = _p->mEnumMethodCaseMessage ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMethodCaseList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lstring & _out_0,
                GGS_enumCaseMessage & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mConstantName ;
    _out_1 = _p->mEnumMethodCaseMessage ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_enumMethodCaseList::
reader_mConstantNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mConstantName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumCaseMessage  GGS_enumMethodCaseList::
reader_mEnumMethodCaseMessageAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_enumCaseMessage  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mEnumMethodCaseMessage ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumMethodCaseList::
modifier_setMConstantNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mConstantName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMethodCaseList::
modifier_setMEnumMethodCaseMessageAtIndex (C_Compiler & inLexique,
                              const GGS_enumCaseMessage  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mEnumMethodCaseMessage = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    Element of list '@enumMethodList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_enumMethodList::
elementOf_GGS_enumMethodList (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_enumMethodCaseList & argument_2
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mMethodName (argument_0),
mLocationFormalArgumentName (argument_1),
mEnumMethodCaseList (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_enumMethodList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_enumMethodList * _p = dynamic_cast <const elementOf_GGS_enumMethodList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mMethodName._operator_isEqual (_p->mMethodName).boolValue ()
         && mLocationFormalArgumentName._operator_isEqual (_p->mLocationFormalArgumentName).boolValue ()
         && mEnumMethodCaseList._operator_isEqual (_p->mEnumMethodCaseList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_enumMethodList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMethodName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLocationFormalArgumentName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEnumMethodCaseList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          List '@enumMethodList'                           *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_enumMethodList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_enumMethodCaseList & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMethodList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_enumMethodCaseList & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMethodList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_enumMethodCaseList & argument_2) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_enumMethodList GGS_enumMethodList::
_operator_concat (const GGS_enumMethodList & inOperand) const {
  GGS_enumMethodList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_enumMethodList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mMethodName ;
          GGS_lstring  p_1 = p->mLocationFormalArgumentName ;
          GGS_enumMethodCaseList  p_2 = p->mEnumMethodCaseList ;
          result._internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumMethodList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_enumMethodCaseList & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMethodList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mMethodName,
                                _p->mLocationFormalArgumentName,
                                _p->mEnumMethodCaseList
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_enumMethodList  GGS_enumMethodList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_enumMethodList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMethodList  GGS_enumMethodList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_lstring & argument_1,
                           const GGS_enumMethodCaseList & argument_2
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_enumMethodList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumMethodList::
internalSubListWithRange (GGS_enumMethodList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mMethodName, _p->mLocationFormalArgumentName, _p->mEnumMethodCaseList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_enumMethodList GGS_enumMethodList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_enumMethodList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMethodList GGS_enumMethodList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_enumMethodList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_enumMethodList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@enumMethodList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMethodList::
method_first (C_Compiler & _inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1,
              GGS_enumMethodCaseList & _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMethodName ;
    _out_1 = _p->mLocationFormalArgumentName ;
    _out_2 = _p->mEnumMethodCaseList ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMethodList::
method_last (C_Compiler & _inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1,
             GGS_enumMethodCaseList & _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMethodName ;
    _out_1 = _p->mLocationFormalArgumentName ;
    _out_2 = _p->mEnumMethodCaseList ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMethodList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1,
                 GGS_enumMethodCaseList & _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMethodName ;
    _out_1 = _p->mLocationFormalArgumentName ;
    _out_2 = _p->mEnumMethodCaseList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMethodList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1,
                GGS_enumMethodCaseList & _out_2
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMethodName ;
    _out_1 = _p->mLocationFormalArgumentName ;
    _out_2 = _p->mEnumMethodCaseList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_enumMethodList::
reader_mMethodNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mMethodName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_enumMethodList::
reader_mLocationFormalArgumentNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mLocationFormalArgumentName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMethodCaseList  GGS_enumMethodList::
reader_mEnumMethodCaseListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_enumMethodCaseList  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mEnumMethodCaseList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumMethodList::
modifier_setMMethodNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mMethodName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMethodList::
modifier_setMLocationFormalArgumentNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mLocationFormalArgumentName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMethodList::
modifier_setMEnumMethodCaseListAtIndex (C_Compiler & inLexique,
                              const GGS_enumMethodCaseList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mEnumMethodCaseList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@enumOperatorCaseList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_enumOperatorCaseList::
elementOf_GGS_enumOperatorCaseList (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_enumCaseMessage & argument_3
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mLeftConstantName (argument_0),
mRightConstantName (argument_1),
mResultConstantName (argument_2),
mEnumOperatorCaseMessage (argument_3) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_enumOperatorCaseList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_enumOperatorCaseList * _p = dynamic_cast <const elementOf_GGS_enumOperatorCaseList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mLeftConstantName._operator_isEqual (_p->mLeftConstantName).boolValue ()
         && mRightConstantName._operator_isEqual (_p->mRightConstantName).boolValue ()
         && mResultConstantName._operator_isEqual (_p->mResultConstantName).boolValue ()
         && mEnumOperatorCaseMessage._operator_isEqual (_p->mEnumOperatorCaseMessage).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_enumOperatorCaseList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLeftConstantName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRightConstantName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mResultConstantName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEnumOperatorCaseMessage.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@enumOperatorCaseList'                        *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_enumOperatorCaseList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_enumCaseMessage & argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_enumOperatorCaseList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_enumCaseMessage & argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_enumOperatorCaseList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_enumCaseMessage & argument_3) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_enumOperatorCaseList GGS_enumOperatorCaseList::
_operator_concat (const GGS_enumOperatorCaseList & inOperand) const {
  GGS_enumOperatorCaseList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_enumOperatorCaseList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mLeftConstantName ;
          GGS_lstring  p_1 = p->mRightConstantName ;
          GGS_lstring  p_2 = p->mResultConstantName ;
          GGS_enumCaseMessage  p_3 = p->mEnumOperatorCaseMessage ;
          result._internalAppendValues (p_0, p_1, p_2, p_3 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumOperatorCaseList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_lstring & argument_2,
                     const GGS_enumCaseMessage & argument_3
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumOperatorCaseList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mLeftConstantName,
                                _p->mRightConstantName,
                                _p->mResultConstantName,
                                _p->mEnumOperatorCaseMessage
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_enumOperatorCaseList  GGS_enumOperatorCaseList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_enumOperatorCaseList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumOperatorCaseList  GGS_enumOperatorCaseList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_lstring & argument_1,
                           const GGS_lstring & argument_2,
                           const GGS_enumCaseMessage & argument_3
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_enumOperatorCaseList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2, argument_3) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumOperatorCaseList::
internalSubListWithRange (GGS_enumOperatorCaseList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mLeftConstantName, _p->mRightConstantName, _p->mResultConstantName, _p->mEnumOperatorCaseMessage) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_enumOperatorCaseList GGS_enumOperatorCaseList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_enumOperatorCaseList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumOperatorCaseList GGS_enumOperatorCaseList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_enumOperatorCaseList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_enumOperatorCaseList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@enumOperatorCaseList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_enumOperatorCaseList::
method_first (C_Compiler & _inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1,
              GGS_lstring & _out_2,
              GGS_enumCaseMessage & _out_3
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mLeftConstantName ;
    _out_1 = _p->mRightConstantName ;
    _out_2 = _p->mResultConstantName ;
    _out_3 = _p->mEnumOperatorCaseMessage ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumOperatorCaseList::
method_last (C_Compiler & _inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1,
             GGS_lstring & _out_2,
             GGS_enumCaseMessage & _out_3
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mLeftConstantName ;
    _out_1 = _p->mRightConstantName ;
    _out_2 = _p->mResultConstantName ;
    _out_3 = _p->mEnumOperatorCaseMessage ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumOperatorCaseList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1,
                 GGS_lstring & _out_2,
                 GGS_enumCaseMessage & _out_3
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mLeftConstantName ;
    _out_1 = _p->mRightConstantName ;
    _out_2 = _p->mResultConstantName ;
    _out_3 = _p->mEnumOperatorCaseMessage ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumOperatorCaseList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1,
                GGS_lstring & _out_2,
                GGS_enumCaseMessage & _out_3
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mLeftConstantName ;
    _out_1 = _p->mRightConstantName ;
    _out_2 = _p->mResultConstantName ;
    _out_3 = _p->mEnumOperatorCaseMessage ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_enumOperatorCaseList::
reader_mLeftConstantNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mLeftConstantName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_enumOperatorCaseList::
reader_mRightConstantNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mRightConstantName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_enumOperatorCaseList::
reader_mResultConstantNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mResultConstantName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumCaseMessage  GGS_enumOperatorCaseList::
reader_mEnumOperatorCaseMessageAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_enumCaseMessage  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mEnumOperatorCaseMessage ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumOperatorCaseList::
modifier_setMLeftConstantNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mLeftConstantName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumOperatorCaseList::
modifier_setMRightConstantNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mRightConstantName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumOperatorCaseList::
modifier_setMResultConstantNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mResultConstantName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumOperatorCaseList::
modifier_setMEnumOperatorCaseMessageAtIndex (C_Compiler & inLexique,
                              const GGS_enumCaseMessage  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mEnumOperatorCaseMessage = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   Element of list '@enumOperatorList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_enumOperatorList::
elementOf_GGS_enumOperatorList (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_enumOperatorCaseList & argument_2
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mOperatorName (argument_0),
mLocationFormalArgumentName (argument_1),
mEnumOperatorCaseList (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_enumOperatorList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_enumOperatorList * _p = dynamic_cast <const elementOf_GGS_enumOperatorList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mOperatorName._operator_isEqual (_p->mOperatorName).boolValue ()
         && mLocationFormalArgumentName._operator_isEqual (_p->mLocationFormalArgumentName).boolValue ()
         && mEnumOperatorCaseList._operator_isEqual (_p->mEnumOperatorCaseList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_enumOperatorList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOperatorName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLocationFormalArgumentName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEnumOperatorCaseList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         List '@enumOperatorList'                          *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_enumOperatorList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_enumOperatorCaseList & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_enumOperatorList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_enumOperatorCaseList & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_enumOperatorList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_enumOperatorCaseList & argument_2) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_enumOperatorList GGS_enumOperatorList::
_operator_concat (const GGS_enumOperatorList & inOperand) const {
  GGS_enumOperatorList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_enumOperatorList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mOperatorName ;
          GGS_lstring  p_1 = p->mLocationFormalArgumentName ;
          GGS_enumOperatorCaseList  p_2 = p->mEnumOperatorCaseList ;
          result._internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumOperatorList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_enumOperatorCaseList & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumOperatorList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mOperatorName,
                                _p->mLocationFormalArgumentName,
                                _p->mEnumOperatorCaseList
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_enumOperatorList  GGS_enumOperatorList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_enumOperatorList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumOperatorList  GGS_enumOperatorList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_lstring & argument_1,
                           const GGS_enumOperatorCaseList & argument_2
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_enumOperatorList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumOperatorList::
internalSubListWithRange (GGS_enumOperatorList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mOperatorName, _p->mLocationFormalArgumentName, _p->mEnumOperatorCaseList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_enumOperatorList GGS_enumOperatorList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_enumOperatorList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumOperatorList GGS_enumOperatorList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_enumOperatorList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_enumOperatorList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@enumOperatorList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_enumOperatorList::
method_first (C_Compiler & _inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1,
              GGS_enumOperatorCaseList & _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mOperatorName ;
    _out_1 = _p->mLocationFormalArgumentName ;
    _out_2 = _p->mEnumOperatorCaseList ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumOperatorList::
method_last (C_Compiler & _inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1,
             GGS_enumOperatorCaseList & _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mOperatorName ;
    _out_1 = _p->mLocationFormalArgumentName ;
    _out_2 = _p->mEnumOperatorCaseList ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumOperatorList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1,
                 GGS_enumOperatorCaseList & _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mOperatorName ;
    _out_1 = _p->mLocationFormalArgumentName ;
    _out_2 = _p->mEnumOperatorCaseList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumOperatorList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1,
                GGS_enumOperatorCaseList & _out_2
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mOperatorName ;
    _out_1 = _p->mLocationFormalArgumentName ;
    _out_2 = _p->mEnumOperatorCaseList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_enumOperatorList::
reader_mOperatorNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mOperatorName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_enumOperatorList::
reader_mLocationFormalArgumentNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mLocationFormalArgumentName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumOperatorCaseList  GGS_enumOperatorList::
reader_mEnumOperatorCaseListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_enumOperatorCaseList  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mEnumOperatorCaseList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumOperatorList::
modifier_setMOperatorNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mOperatorName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumOperatorList::
modifier_setMLocationFormalArgumentNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mLocationFormalArgumentName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumOperatorList::
modifier_setMEnumOperatorCaseListAtIndex (C_Compiler & inLexique,
                              const GGS_enumOperatorCaseList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mEnumOperatorCaseList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_enumDeclaration'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_enumDeclaration::
cPtr_enumDeclaration (const GGS_lstring & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_lstringlist & argument_2,
                                const GGS_enumMessageList & argument_3,
                                const GGS_enumModifierList & argument_4,
                                const GGS_enumMethodList & argument_5,
                                const GGS_enumOperatorList & argument_6
                                COMMA_LOCATION_ARGS)
:cPtr_semanticDeclaration (THERE),
mEnumTypeName (argument_0),
mConstructorConstantList (argument_1),
mConstantList (argument_2),
mEnumMessageList (argument_3),
mEnumModifierList (argument_4),
mEnumMethodList (argument_5),
mEnumOperatorList (argument_6) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_enumDeclaration * GGS_enumDeclaration::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_enumDeclaration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_enumDeclaration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_enumDeclaration * _p = dynamic_cast <const cPtr_enumDeclaration *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mEnumTypeName._operator_isEqual (_p->mEnumTypeName).boolValue ()
         && mConstructorConstantList._operator_isEqual (_p->mConstructorConstantList).boolValue ()
         && mConstantList._operator_isEqual (_p->mConstantList).boolValue ()
         && mEnumMessageList._operator_isEqual (_p->mEnumMessageList).boolValue ()
         && mEnumModifierList._operator_isEqual (_p->mEnumModifierList).boolValue ()
         && mEnumMethodList._operator_isEqual (_p->mEnumMethodList).boolValue ()
         && mEnumOperatorList._operator_isEqual (_p->mEnumOperatorList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_enumDeclaration::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@enumDeclaration:"
           << mEnumTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mConstructorConstantList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mConstantList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mEnumMessageList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mEnumModifierList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mEnumMethodList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mEnumOperatorList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_enumDeclaration::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_enumDeclaration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_enumDeclaration (& typeid (cPtr_enumDeclaration), & typeid (cPtr_semanticDeclaration), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_enumDeclaration::galgasRTTI (void) const {
  return & gClassInfoFor__enumDeclaration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_enumDeclaration'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_enumDeclaration::
GGS_enumDeclaration (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_enumDeclaration::
GGS_enumDeclaration (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_enumDeclaration GGS_enumDeclaration::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_enumDeclaration _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_enumDeclaration *> (inPointer) != NULL)
      : (typeid (cPtr_enumDeclaration) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_enumDeclaration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_enumDeclaration),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_enumDeclaration GGS_enumDeclaration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstringlist & argument_1,
                 const GGS_lstringlist & argument_2,
                 const GGS_enumMessageList & argument_3,
                 const GGS_enumModifierList & argument_4,
                 const GGS_enumMethodList & argument_5,
                 const GGS_enumOperatorList & argument_6
                                COMMA_LOCATION_ARGS) {
  GGS_enumDeclaration result ;
  macroMyNew (result.mPointer, cPtr_enumDeclaration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_enumDeclaration::
reader_mEnumTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumDeclaration *) mPointer)->mEnumTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_enumDeclaration::
reader_mConstructorConstantList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumDeclaration *) mPointer)->mConstructorConstantList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_enumDeclaration::
reader_mConstantList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumDeclaration *) mPointer)->mConstantList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMessageList  GGS_enumDeclaration::
reader_mEnumMessageList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_enumMessageList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumDeclaration *) mPointer)->mEnumMessageList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumModifierList  GGS_enumDeclaration::
reader_mEnumModifierList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_enumModifierList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumDeclaration *) mPointer)->mEnumModifierList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMethodList  GGS_enumDeclaration::
reader_mEnumMethodList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_enumMethodList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumDeclaration *) mPointer)->mEnumMethodList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumOperatorList  GGS_enumDeclaration::
reader_mEnumOperatorList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_enumOperatorList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumDeclaration *) mPointer)->mEnumOperatorList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_enumDeclaration::actualTypeName (void) const {
  return "enumDeclaration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__enumDeclaration ("enumDeclaration", gClassInfoFor__semanticDeclaration) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@filewrapperTemplateList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_filewrapperTemplateList::
elementOf_GGS_filewrapperTemplateList (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_formalInputParameterList & argument_2
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mFilewrapperTemplateName (argument_0),
mFilewrapperTemplatePath (argument_1),
mFilewrapperTemplateFormalInputParameters (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_filewrapperTemplateList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_filewrapperTemplateList * _p = dynamic_cast <const elementOf_GGS_filewrapperTemplateList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mFilewrapperTemplateName._operator_isEqual (_p->mFilewrapperTemplateName).boolValue ()
         && mFilewrapperTemplatePath._operator_isEqual (_p->mFilewrapperTemplatePath).boolValue ()
         && mFilewrapperTemplateFormalInputParameters._operator_isEqual (_p->mFilewrapperTemplateFormalInputParameters).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_filewrapperTemplateList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFilewrapperTemplateName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFilewrapperTemplatePath.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFilewrapperTemplateFormalInputParameters.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@filewrapperTemplateList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_formalInputParameterList & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_formalInputParameterList & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_formalInputParameterList & argument_2) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateList GGS_filewrapperTemplateList::
_operator_concat (const GGS_filewrapperTemplateList & inOperand) const {
  GGS_filewrapperTemplateList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_filewrapperTemplateList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mFilewrapperTemplateName ;
          GGS_lstring  p_1 = p->mFilewrapperTemplatePath ;
          GGS_formalInputParameterList  p_2 = p->mFilewrapperTemplateFormalInputParameters ;
          result._internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_formalInputParameterList & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mFilewrapperTemplateName,
                                _p->mFilewrapperTemplatePath,
                                _p->mFilewrapperTemplateFormalInputParameters
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateList  GGS_filewrapperTemplateList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_filewrapperTemplateList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateList  GGS_filewrapperTemplateList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_lstring & argument_1,
                           const GGS_formalInputParameterList & argument_2
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_filewrapperTemplateList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateList::
internalSubListWithRange (GGS_filewrapperTemplateList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mFilewrapperTemplateName, _p->mFilewrapperTemplatePath, _p->mFilewrapperTemplateFormalInputParameters) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateList GGS_filewrapperTemplateList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_filewrapperTemplateList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateList GGS_filewrapperTemplateList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_filewrapperTemplateList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_filewrapperTemplateList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@filewrapperTemplateList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateList::
method_first (C_Compiler & _inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1,
              GGS_formalInputParameterList & _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mFilewrapperTemplateName ;
    _out_1 = _p->mFilewrapperTemplatePath ;
    _out_2 = _p->mFilewrapperTemplateFormalInputParameters ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateList::
method_last (C_Compiler & _inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1,
             GGS_formalInputParameterList & _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mFilewrapperTemplateName ;
    _out_1 = _p->mFilewrapperTemplatePath ;
    _out_2 = _p->mFilewrapperTemplateFormalInputParameters ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1,
                 GGS_formalInputParameterList & _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mFilewrapperTemplateName ;
    _out_1 = _p->mFilewrapperTemplatePath ;
    _out_2 = _p->mFilewrapperTemplateFormalInputParameters ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1,
                GGS_formalInputParameterList & _out_2
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mFilewrapperTemplateName ;
    _out_1 = _p->mFilewrapperTemplatePath ;
    _out_2 = _p->mFilewrapperTemplateFormalInputParameters ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_filewrapperTemplateList::
reader_mFilewrapperTemplateNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mFilewrapperTemplateName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_filewrapperTemplateList::
reader_mFilewrapperTemplatePathAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mFilewrapperTemplatePath ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalInputParameterList  GGS_filewrapperTemplateList::
reader_mFilewrapperTemplateFormalInputParametersAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_formalInputParameterList  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mFilewrapperTemplateFormalInputParameters ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateList::
modifier_setMFilewrapperTemplateNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mFilewrapperTemplateName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateList::
modifier_setMFilewrapperTemplatePathAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mFilewrapperTemplatePath = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateList::
modifier_setMFilewrapperTemplateFormalInputParametersAtIndex (C_Compiler & inLexique,
                              const GGS_formalInputParameterList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mFilewrapperTemplateFormalInputParameters = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_filewrapperDeclaration'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_filewrapperDeclaration::
cPtr_filewrapperDeclaration (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstringlist & argument_2,
                                const GGS_filewrapperTemplateList & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticDeclaration (THERE),
mFilewrapperName (argument_0),
mFilewrapperPath (argument_1),
mFilewrapperExtensionList (argument_2),
mFilewrapperTemplateList (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_filewrapperDeclaration * GGS_filewrapperDeclaration::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_filewrapperDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_filewrapperDeclaration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_filewrapperDeclaration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_filewrapperDeclaration * _p = dynamic_cast <const cPtr_filewrapperDeclaration *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mFilewrapperName._operator_isEqual (_p->mFilewrapperName).boolValue ()
         && mFilewrapperPath._operator_isEqual (_p->mFilewrapperPath).boolValue ()
         && mFilewrapperExtensionList._operator_isEqual (_p->mFilewrapperExtensionList).boolValue ()
         && mFilewrapperTemplateList._operator_isEqual (_p->mFilewrapperTemplateList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_filewrapperDeclaration::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@filewrapperDeclaration:"
           << mFilewrapperName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mFilewrapperPath.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mFilewrapperExtensionList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mFilewrapperTemplateList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_filewrapperDeclaration::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_filewrapperDeclaration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_filewrapperDeclaration (& typeid (cPtr_filewrapperDeclaration), & typeid (cPtr_semanticDeclaration), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_filewrapperDeclaration::galgasRTTI (void) const {
  return & gClassInfoFor__filewrapperDeclaration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_filewrapperDeclaration'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_filewrapperDeclaration::
GGS_filewrapperDeclaration (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperDeclaration::
GGS_filewrapperDeclaration (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_filewrapperDeclaration GGS_filewrapperDeclaration::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_filewrapperDeclaration _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_filewrapperDeclaration *> (inPointer) != NULL)
      : (typeid (cPtr_filewrapperDeclaration) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_filewrapperDeclaration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_filewrapperDeclaration),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperDeclaration GGS_filewrapperDeclaration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstringlist & argument_2,
                 const GGS_filewrapperTemplateList & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_filewrapperDeclaration result ;
  macroMyNew (result.mPointer, cPtr_filewrapperDeclaration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_filewrapperDeclaration::
reader_mFilewrapperName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_filewrapperDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_filewrapperDeclaration *) mPointer)->mFilewrapperName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_filewrapperDeclaration::
reader_mFilewrapperPath (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_filewrapperDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_filewrapperDeclaration *) mPointer)->mFilewrapperPath ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_filewrapperDeclaration::
reader_mFilewrapperExtensionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_filewrapperDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_filewrapperDeclaration *) mPointer)->mFilewrapperExtensionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateList  GGS_filewrapperDeclaration::
reader_mFilewrapperTemplateList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_filewrapperTemplateList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_filewrapperDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_filewrapperDeclaration *) mPointer)->mFilewrapperTemplateList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_filewrapperDeclaration::actualTypeName (void) const {
  return "filewrapperDeclaration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__filewrapperDeclaration ("filewrapperDeclaration", gClassInfoFor__semanticDeclaration) ;

//---------------------------------------------------------------------------*
//                                                                           *
//        Class for 'enumCategoryMethodDeclarationKind' Enumeration          *
//                                                                           *
//---------------------------------------------------------------------------*

bool GGS_enumCategoryMethodDeclarationKind::
_isBuilt (void) const {
  return mValue > kNotBuilt ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_enumCategoryMethodDeclarationKind::
_operator_isEqual (const GGS_enumCategoryMethodDeclarationKind inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_enumCategoryMethodDeclarationKind::
_operator_isNotEqual (const GGS_enumCategoryMethodDeclarationKind inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_enumCategoryMethodDeclarationKind::
_operator_infOrEqual (const GGS_enumCategoryMethodDeclarationKind inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_enumCategoryMethodDeclarationKind::
_operator_supOrEqual (const GGS_enumCategoryMethodDeclarationKind inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_enumCategoryMethodDeclarationKind::
_operator_strictInf (const GGS_enumCategoryMethodDeclarationKind inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_enumCategoryMethodDeclarationKind::
_operator_strictSup (const GGS_enumCategoryMethodDeclarationKind inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_enumCategoryMethodDeclarationKind::
reader_description (C_Compiler & /* _inLexique */
                    COMMA_UNUSED_LOCATION_ARGS,
                    const sint32 /* inIndentation */) const {
  C_String s ;
  s << "<enum @enumCategoryMethodDeclarationKind" ;
  switch (mValue) {
  case enum_isAbstract:
    s << " isAbstract>" ;
    break ;
  case enum_isBaseMethod:
    s << " isBaseMethod>" ;
    break ;
  case enum_isOverriding:
    s << " isOverriding>" ;
    break ;
  case kNotBuilt:
    s << " (not built)>" ;
    break ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_categoryMethodDeclaration'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_categoryMethodDeclaration::
cPtr_categoryMethodDeclaration (const GGS_enumCategoryMethodDeclarationKind& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_formalParameterList & argument_3,
                                const GGS_semanticInstructionList & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_semanticDeclaration (THERE),
mKind (argument_0),
mClassName (argument_1),
mMethodName (argument_2),
mFormalParameterList (argument_3),
mRoutineInstructionList (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_categoryMethodDeclaration * GGS_categoryMethodDeclaration::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_categoryMethodDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_categoryMethodDeclaration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_categoryMethodDeclaration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_categoryMethodDeclaration * _p = dynamic_cast <const cPtr_categoryMethodDeclaration *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mKind._operator_isEqual (_p->mKind).boolValue ()
         && mClassName._operator_isEqual (_p->mClassName).boolValue ()
         && mMethodName._operator_isEqual (_p->mMethodName).boolValue ()
         && mFormalParameterList._operator_isEqual (_p->mFormalParameterList).boolValue ()
         && mRoutineInstructionList._operator_isEqual (_p->mRoutineInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_categoryMethodDeclaration::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@categoryMethodDeclaration:"
           << mKind.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mClassName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mMethodName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mFormalParameterList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRoutineInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_categoryMethodDeclaration::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_categoryMethodDeclaration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_categoryMethodDeclaration (& typeid (cPtr_categoryMethodDeclaration), & typeid (cPtr_semanticDeclaration), "") ;
//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_categoryMethodDeclaration::galgasRTTI (void) const {
  return & gClassInfoFor__categoryMethodDeclaration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_categoryMethodDeclaration'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_categoryMethodDeclaration::
GGS_categoryMethodDeclaration (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_categoryMethodDeclaration::
GGS_categoryMethodDeclaration (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_categoryMethodDeclaration GGS_categoryMethodDeclaration::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_categoryMethodDeclaration _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_categoryMethodDeclaration *> (inPointer) != NULL)
      : (typeid (cPtr_categoryMethodDeclaration) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_categoryMethodDeclaration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_categoryMethodDeclaration),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_categoryMethodDeclaration GGS_categoryMethodDeclaration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_enumCategoryMethodDeclarationKind& argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_formalParameterList & argument_3,
                 const GGS_semanticInstructionList & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_categoryMethodDeclaration result ;
  macroMyNew (result.mPointer, cPtr_categoryMethodDeclaration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumCategoryMethodDeclarationKind GGS_categoryMethodDeclaration::
reader_mKind (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_enumCategoryMethodDeclarationKind  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_categoryMethodDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_categoryMethodDeclaration *) mPointer)->mKind ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_categoryMethodDeclaration::
reader_mClassName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_categoryMethodDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_categoryMethodDeclaration *) mPointer)->mClassName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_categoryMethodDeclaration::
reader_mMethodName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_categoryMethodDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_categoryMethodDeclaration *) mPointer)->mMethodName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameterList  GGS_categoryMethodDeclaration::
reader_mFormalParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_formalParameterList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_categoryMethodDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_categoryMethodDeclaration *) mPointer)->mFormalParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionList  GGS_categoryMethodDeclaration::
reader_mRoutineInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_categoryMethodDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_categoryMethodDeclaration *) mPointer)->mRoutineInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_categoryMethodDeclaration::actualTypeName (void) const {
  return "categoryMethodDeclaration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__categoryMethodDeclaration ("categoryMethodDeclaration", gClassInfoFor__semanticDeclaration) ;

//---------------------------------------------------------------------------*

