//---------------------------------------------------------------------------*
//                                                                           *
//                      File 'semanticsMetamodel.cpp'                        *
//         Generated by version GALGAS_BETA_VERSION (LL(1) grammar)          *
//                      june 24th, 2007, at 15h56'11"                        *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

#include "semanticsMetamodel.h"
#include "utilities/MF_MemoryControl.h"

//---------------------------------------------------------------------------*

#include <typeinfo>

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "semanticsMetamodel.gMetamodel", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif

//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                           Metamodel Management                            *
//                                                                           *
//---------------------------------------------------------------------------*

static C_MetamodelManager gMetamodelManager ("semanticsMetamodel", 16) ;

//---------------------------------------------------------------------------*

sint32 _metamodel_index_for_semanticsMetamodel (void) {
  return gMetamodelManager.mMetamodelComponentIndex ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@semanticsComponentRoot'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_semanticsComponentRoot::
cPtr_semanticsComponentRoot (const GGS_lstring & argument_0,
                                const GGS_stringset & argument_1,
                                const GGS_lstringlist & argument_2,
                                const GGS__list_semanticDeclaration & argument_3
                                COMMA_LOCATION_ARGS) :
EX_C_GGS_MetamodelEntity (THERE),
mSemanticsComponentName (argument_0),
mImportedSemanticsComponentSet (argument_1),
mImportedComponentFileNameList (argument_2),
mSemanticDeclarationList (argument_3) {
}

//---------------------------------------------------------------------------*

bool cPtr_semanticsComponentRoot::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_semanticsComponentRoot * _p = dynamic_cast <const cPtr_semanticsComponentRoot *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mSemanticsComponentName._operator_isEqual (_p->mSemanticsComponentName).boolValue ()
         && mImportedSemanticsComponentSet._operator_isEqual (_p->mImportedSemanticsComponentSet).boolValue ()
         && mImportedComponentFileNameList._operator_isEqual (_p->mImportedComponentFileNameList).boolValue ()
         && mSemanticDeclarationList._operator_isEqual (_p->mSemanticDeclarationList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_semanticsComponentRoot::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @semanticsComponentRoot" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSemanticsComponentName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mImportedSemanticsComponentSet.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mImportedComponentFileNameList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSemanticDeclarationList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_semanticsComponentRoot::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_semanticsComponentRoot::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_semanticsComponentRoot::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 0 ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_semanticsComponentRoot::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "semanticsComponentRoot" ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_semanticsComponentRoot * cPtr_semanticsComponentRoot::
_cloneObject (void) const {
  cPtr_semanticsComponentRoot * _p = NULL ;
  macroMyNew (_p, cPtr_semanticsComponentRoot (mSemanticsComponentName, mImportedSemanticsComponentSet, mImportedComponentFileNameList, mSemanticDeclarationList COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@_list_semanticsComponentRoot'                    *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS__list_semanticsComponentRoot::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_stringset & argument_1,
                    const GGS_lstringlist & argument_2,
                    const GGS__list_semanticDeclaration & argument_3) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_semanticsComponentRoot::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_stringset & argument_1,
                    const GGS_lstringlist & argument_2,
                    const GGS__list_semanticDeclaration & argument_3) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_semanticsComponentRoot::
_addAssign_operation (const GGS_semanticsComponentRoot & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_semanticsComponentRoot *) inElement.getPtr ())->mSemanticsComponentName,
                                ((cPtr_semanticsComponentRoot *) inElement.getPtr ())->mImportedSemanticsComponentSet,
                                ((cPtr_semanticsComponentRoot *) inElement.getPtr ())->mImportedComponentFileNameList,
                                ((cPtr_semanticsComponentRoot *) inElement.getPtr ())->mSemanticDeclarationList) ;
  }
}

//---------------------------------------------------------------------------*

GGS__list_semanticsComponentRoot GGS__list_semanticsComponentRoot::
_operator_concat (const GGS__list_semanticsComponentRoot & inOperand) const {
  GGS__list_semanticsComponentRoot result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_semanticsComponentRoot * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mSemanticsComponentName ;
          GGS_stringset  p_1 = p->mImportedSemanticsComponentSet ;
          GGS_lstringlist  p_2 = p->mImportedComponentFileNameList ;
          GGS__list_semanticDeclaration  p_3 = p->mSemanticDeclarationList ;
          result._internalAppendValues (p_0, p_1, p_2, p_3) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_semanticsComponentRoot::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_stringset & argument_1,
                     const GGS_lstringlist & argument_2,
                     const GGS__list_semanticDeclaration & argument_3
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3) ;
  }
}

//---------------------------------------------------------------------------*

void GGS__list_semanticsComponentRoot::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mSemanticsComponentName,
                                _p->mImportedSemanticsComponentSet,
                                _p->mImportedComponentFileNameList,
                                _p->mSemanticDeclarationList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS__list_semanticsComponentRoot  GGS__list_semanticsComponentRoot::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_semanticsComponentRoot result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_semanticsComponentRoot  GGS__list_semanticsComponentRoot::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_stringset & argument_1,
                           const GGS_lstringlist & argument_2,
                           const GGS__list_semanticDeclaration & argument_3
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_semanticsComponentRoot result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1, argument_2, argument_3) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_semanticsComponentRoot::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_semanticsComponentRoot", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS__list_semanticsComponentRoot::
_addModel (const GGS_semanticsComponentRoot & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_semanticsComponentRoot::
method_first (C_Compiler & _inLexique,
              GGS_semanticsComponentRoot & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_semanticsComponentRoot::constructor_new (_inLexique,
       _p->mSemanticsComponentName,
       _p->mImportedSemanticsComponentSet,
       _p->mImportedComponentFileNameList,
       _p->mSemanticDeclarationList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_semanticsComponentRoot::
method_last (C_Compiler & _inLexique,
             GGS_semanticsComponentRoot & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_semanticsComponentRoot::constructor_new (_inLexique,
       _p->mSemanticsComponentName,
       _p->mImportedSemanticsComponentSet,
       _p->mImportedComponentFileNameList,
       _p->mSemanticDeclarationList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_semanticsComponentRoot::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_semanticsComponentRoot & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_semanticsComponentRoot::constructor_new (_inLexique,
       _p->mSemanticsComponentName,
       _p->mImportedSemanticsComponentSet,
       _p->mImportedComponentFileNameList,
       _p->mSemanticDeclarationList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_semanticsComponentRoot::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_semanticsComponentRoot & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_semanticsComponentRoot::constructor_new (_inLexique,
       _p->mSemanticsComponentName,
       _p->mImportedSemanticsComponentSet,
       _p->mImportedComponentFileNameList,
       _p->mSemanticDeclarationList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS entity '@semanticsComponentRoot'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_semanticsComponentRoot GGS_semanticsComponentRoot::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_stringset & argument_1,
                 const GGS_lstringlist & argument_2,
                 const GGS__list_semanticDeclaration & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_semanticsComponentRoot result ;
  macroMyNew (result.mPointer, cPtr_semanticsComponentRoot (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_semanticsComponentRoot::
reader_mSemanticsComponentName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_semanticsComponentRoot *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_semanticsComponentRoot *) mPointer)->mSemanticsComponentName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringset  GGS_semanticsComponentRoot::
reader_mImportedSemanticsComponentSet (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_stringset   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_semanticsComponentRoot *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_semanticsComponentRoot *) mPointer)->mImportedSemanticsComponentSet ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_semanticsComponentRoot::
reader_mImportedComponentFileNameList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_semanticsComponentRoot *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_semanticsComponentRoot *) mPointer)->mImportedComponentFileNameList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_semanticDeclaration  GGS_semanticsComponentRoot::
reader_mSemanticDeclarationList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_semanticDeclaration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_semanticsComponentRoot *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_semanticsComponentRoot *) mPointer)->mSemanticDeclarationList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_semanticsComponentRoot::actualTypeName (void) const {
 return "semanticsComponentRoot" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_semanticsComponentRoot * GGS_semanticsComponentRoot::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_semanticsComponentRoot *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@attributeInCollection'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_attributeInCollection::
cPtr_attributeInCollection (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
EX_C_GGS_MetamodelEntity (THERE),
mAttributeTypeName (argument_0),
mAttributeName (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_attributeInCollection::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_attributeInCollection * _p = dynamic_cast <const cPtr_attributeInCollection *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mAttributeTypeName._operator_isEqual (_p->mAttributeTypeName).boolValue ()
         && mAttributeName._operator_isEqual (_p->mAttributeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_attributeInCollection::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @attributeInCollection" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAttributeTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAttributeName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_attributeInCollection::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_attributeInCollection::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_attributeInCollection::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 1 ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_attributeInCollection::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "attributeInCollection" ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_attributeInCollection * cPtr_attributeInCollection::
_cloneObject (void) const {
  cPtr_attributeInCollection * _p = NULL ;
  macroMyNew (_p, cPtr_attributeInCollection (mAttributeTypeName, mAttributeName COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@_list_attributeInCollection'                     *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS__list_attributeInCollection::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_attributeInCollection::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_attributeInCollection::
_addAssign_operation (const GGS_attributeInCollection & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_attributeInCollection *) inElement.getPtr ())->mAttributeTypeName,
                                ((cPtr_attributeInCollection *) inElement.getPtr ())->mAttributeName) ;
  }
}

//---------------------------------------------------------------------------*

GGS__list_attributeInCollection GGS__list_attributeInCollection::
_operator_concat (const GGS__list_attributeInCollection & inOperand) const {
  GGS__list_attributeInCollection result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_attributeInCollection * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mAttributeTypeName ;
          GGS_lstring  p_1 = p->mAttributeName ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_attributeInCollection::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS__list_attributeInCollection::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mAttributeTypeName,
                                _p->mAttributeName) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS__list_attributeInCollection  GGS__list_attributeInCollection::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_attributeInCollection result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_attributeInCollection  GGS__list_attributeInCollection::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_lstring & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_attributeInCollection result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_attributeInCollection::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_attributeInCollection", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS__list_attributeInCollection::
_addModel (const GGS_attributeInCollection & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_attributeInCollection::
method_first (C_Compiler & _inLexique,
              GGS_attributeInCollection & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_attributeInCollection::constructor_new (_inLexique,
       _p->mAttributeTypeName,
       _p->mAttributeName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_attributeInCollection::
method_last (C_Compiler & _inLexique,
             GGS_attributeInCollection & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_attributeInCollection::constructor_new (_inLexique,
       _p->mAttributeTypeName,
       _p->mAttributeName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_attributeInCollection::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_attributeInCollection & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_attributeInCollection::constructor_new (_inLexique,
       _p->mAttributeTypeName,
       _p->mAttributeName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_attributeInCollection::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_attributeInCollection & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_attributeInCollection::constructor_new (_inLexique,
       _p->mAttributeTypeName,
       _p->mAttributeName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS entity '@attributeInCollection'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_attributeInCollection GGS_attributeInCollection::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_attributeInCollection result ;
  macroMyNew (result.mPointer, cPtr_attributeInCollection (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_attributeInCollection::
reader_mAttributeTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_attributeInCollection *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_attributeInCollection *) mPointer)->mAttributeTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_attributeInCollection::
reader_mAttributeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_attributeInCollection *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_attributeInCollection *) mPointer)->mAttributeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_attributeInCollection::actualTypeName (void) const {
 return "attributeInCollection" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_attributeInCollection * GGS_attributeInCollection::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_attributeInCollection *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                    Element of list '@mapDeclaration'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_mapDeclaration::
cPtr_mapDeclaration (const GGS_lstring & argument_0,
                                const GGS__list_attributeInCollection & argument_1,
                                const GGS__list_mapMethod & argument_2,
                                const GGS__list_mapMethod & argument_3,
                                const GGS__list_mapMethod & argument_4
                                COMMA_LOCATION_ARGS) :
cPtr_semanticDeclaration (THERE),
mMapTypeName (argument_0),
mAttributeList (argument_1),
mInsertMethodList (argument_2),
mSearchMethodList (argument_3),
mRemoveMethodList (argument_4) {
}

//---------------------------------------------------------------------------*

bool cPtr_mapDeclaration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_mapDeclaration * _p = dynamic_cast <const cPtr_mapDeclaration *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mMapTypeName._operator_isEqual (_p->mMapTypeName).boolValue ()
         && mAttributeList._operator_isEqual (_p->mAttributeList).boolValue ()
         && mInsertMethodList._operator_isEqual (_p->mInsertMethodList).boolValue ()
         && mSearchMethodList._operator_isEqual (_p->mSearchMethodList).boolValue ()
         && mRemoveMethodList._operator_isEqual (_p->mRemoveMethodList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_mapDeclaration::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @mapDeclaration" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMapTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAttributeList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInsertMethodList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSearchMethodList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRemoveMethodList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_mapDeclaration::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticDeclaration::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_mapDeclaration::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticDeclaration::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_mapDeclaration::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 2 ;
  if (inLevel > 0) {
    result = cPtr_semanticDeclaration::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_mapDeclaration::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "mapDeclaration" ;
  if (inLevel > 0) {
    result = cPtr_semanticDeclaration::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_mapDeclaration * cPtr_mapDeclaration::
_cloneObject (void) const {
  cPtr_mapDeclaration * _p = NULL ;
  macroMyNew (_p, cPtr_mapDeclaration (mMapTypeName, mAttributeList, mInsertMethodList, mSearchMethodList, mRemoveMethodList COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@_list_mapDeclaration'                        *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS__list_mapDeclaration::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS__list_attributeInCollection & argument_1,
                    const GGS__list_mapMethod & argument_2,
                    const GGS__list_mapMethod & argument_3,
                    const GGS__list_mapMethod & argument_4) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_mapDeclaration::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS__list_attributeInCollection & argument_1,
                    const GGS__list_mapMethod & argument_2,
                    const GGS__list_mapMethod & argument_3,
                    const GGS__list_mapMethod & argument_4) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_mapDeclaration::
_addAssign_operation (const GGS_mapDeclaration & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_mapDeclaration *) inElement.getPtr ())->mMapTypeName,
                                ((cPtr_mapDeclaration *) inElement.getPtr ())->mAttributeList,
                                ((cPtr_mapDeclaration *) inElement.getPtr ())->mInsertMethodList,
                                ((cPtr_mapDeclaration *) inElement.getPtr ())->mSearchMethodList,
                                ((cPtr_mapDeclaration *) inElement.getPtr ())->mRemoveMethodList) ;
  }
}

//---------------------------------------------------------------------------*

GGS__list_mapDeclaration GGS__list_mapDeclaration::
_operator_concat (const GGS__list_mapDeclaration & inOperand) const {
  GGS__list_mapDeclaration result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_mapDeclaration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mMapTypeName ;
          GGS__list_attributeInCollection  p_1 = p->mAttributeList ;
          GGS__list_mapMethod  p_2 = p->mInsertMethodList ;
          GGS__list_mapMethod  p_3 = p->mSearchMethodList ;
          GGS__list_mapMethod  p_4 = p->mRemoveMethodList ;
          result._internalAppendValues (p_0, p_1, p_2, p_3, p_4) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_mapDeclaration::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS__list_attributeInCollection & argument_1,
                     const GGS__list_mapMethod & argument_2,
                     const GGS__list_mapMethod & argument_3,
                     const GGS__list_mapMethod & argument_4
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4) ;
  }
}

//---------------------------------------------------------------------------*

void GGS__list_mapDeclaration::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mMapTypeName,
                                _p->mAttributeList,
                                _p->mInsertMethodList,
                                _p->mSearchMethodList,
                                _p->mRemoveMethodList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS__list_mapDeclaration  GGS__list_mapDeclaration::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_mapDeclaration result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_mapDeclaration  GGS__list_mapDeclaration::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS__list_attributeInCollection & argument_1,
                           const GGS__list_mapMethod & argument_2,
                           const GGS__list_mapMethod & argument_3,
                           const GGS__list_mapMethod & argument_4
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_mapDeclaration result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1, argument_2, argument_3, argument_4) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_mapDeclaration::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_mapDeclaration", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS__list_mapDeclaration::
_addModel (const GGS_mapDeclaration & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_mapDeclaration::
method_first (C_Compiler & _inLexique,
              GGS_mapDeclaration & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_mapDeclaration::constructor_new (_inLexique,
       _p->mMapTypeName,
       _p->mAttributeList,
       _p->mInsertMethodList,
       _p->mSearchMethodList,
       _p->mRemoveMethodList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_mapDeclaration::
method_last (C_Compiler & _inLexique,
             GGS_mapDeclaration & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_mapDeclaration::constructor_new (_inLexique,
       _p->mMapTypeName,
       _p->mAttributeList,
       _p->mInsertMethodList,
       _p->mSearchMethodList,
       _p->mRemoveMethodList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_mapDeclaration::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_mapDeclaration & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_mapDeclaration::constructor_new (_inLexique,
       _p->mMapTypeName,
       _p->mAttributeList,
       _p->mInsertMethodList,
       _p->mSearchMethodList,
       _p->mRemoveMethodList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_mapDeclaration::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_mapDeclaration & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_mapDeclaration::constructor_new (_inLexique,
       _p->mMapTypeName,
       _p->mAttributeList,
       _p->mInsertMethodList,
       _p->mSearchMethodList,
       _p->mRemoveMethodList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS entity '@mapDeclaration'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_mapDeclaration GGS_mapDeclaration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS__list_attributeInCollection & argument_1,
                 const GGS__list_mapMethod & argument_2,
                 const GGS__list_mapMethod & argument_3,
                 const GGS__list_mapMethod & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_mapDeclaration result ;
  macroMyNew (result.mPointer, cPtr_mapDeclaration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapDeclaration::
reader_mMapTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapDeclaration *) mPointer)->mMapTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_attributeInCollection  GGS_mapDeclaration::
reader_mAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_attributeInCollection   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapDeclaration *) mPointer)->mAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_mapMethod  GGS_mapDeclaration::
reader_mInsertMethodList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_mapMethod   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapDeclaration *) mPointer)->mInsertMethodList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_mapMethod  GGS_mapDeclaration::
reader_mSearchMethodList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_mapMethod   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapDeclaration *) mPointer)->mSearchMethodList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_mapMethod  GGS_mapDeclaration::
reader_mRemoveMethodList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_mapMethod   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapDeclaration *) mPointer)->mRemoveMethodList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_mapDeclaration::actualTypeName (void) const {
 return "mapDeclaration" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_mapDeclaration * GGS_mapDeclaration::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_mapDeclaration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                       Element of list '@mapMethod'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_mapMethod::
cPtr_mapMethod (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3
                                COMMA_LOCATION_ARGS) :
EX_C_GGS_MetamodelEntity (THERE),
mMethodName (argument_0),
mGetIDMethodName (argument_1),
mErrorMessage (argument_2),
mShadowErrorMessage (argument_3) {
}

//---------------------------------------------------------------------------*

bool cPtr_mapMethod::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_mapMethod * _p = dynamic_cast <const cPtr_mapMethod *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mMethodName._operator_isEqual (_p->mMethodName).boolValue ()
         && mGetIDMethodName._operator_isEqual (_p->mGetIDMethodName).boolValue ()
         && mErrorMessage._operator_isEqual (_p->mErrorMessage).boolValue ()
         && mShadowErrorMessage._operator_isEqual (_p->mShadowErrorMessage).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_mapMethod::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @mapMethod" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMethodName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mGetIDMethodName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mErrorMessage.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mShadowErrorMessage.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_mapMethod::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_mapMethod::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_mapMethod::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 3 ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_mapMethod::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "mapMethod" ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_mapMethod * cPtr_mapMethod::
_cloneObject (void) const {
  cPtr_mapMethod * _p = NULL ;
  macroMyNew (_p, cPtr_mapMethod (mMethodName, mGetIDMethodName, mErrorMessage, mShadowErrorMessage COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         List '@_list_mapMethod'                           *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS__list_mapMethod::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_lstring & argument_3) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_mapMethod::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_lstring & argument_3) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_mapMethod::
_addAssign_operation (const GGS_mapMethod & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_mapMethod *) inElement.getPtr ())->mMethodName,
                                ((cPtr_mapMethod *) inElement.getPtr ())->mGetIDMethodName,
                                ((cPtr_mapMethod *) inElement.getPtr ())->mErrorMessage,
                                ((cPtr_mapMethod *) inElement.getPtr ())->mShadowErrorMessage) ;
  }
}

//---------------------------------------------------------------------------*

GGS__list_mapMethod GGS__list_mapMethod::
_operator_concat (const GGS__list_mapMethod & inOperand) const {
  GGS__list_mapMethod result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_mapMethod * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mMethodName ;
          GGS_lstring  p_1 = p->mGetIDMethodName ;
          GGS_lstring  p_2 = p->mErrorMessage ;
          GGS_lstring  p_3 = p->mShadowErrorMessage ;
          result._internalAppendValues (p_0, p_1, p_2, p_3) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_mapMethod::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_lstring & argument_2,
                     const GGS_lstring & argument_3
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3) ;
  }
}

//---------------------------------------------------------------------------*

void GGS__list_mapMethod::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mMethodName,
                                _p->mGetIDMethodName,
                                _p->mErrorMessage,
                                _p->mShadowErrorMessage) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS__list_mapMethod  GGS__list_mapMethod::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_mapMethod result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_mapMethod  GGS__list_mapMethod::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_lstring & argument_1,
                           const GGS_lstring & argument_2,
                           const GGS_lstring & argument_3
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_mapMethod result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1, argument_2, argument_3) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_mapMethod::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_mapMethod", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS__list_mapMethod::
_addModel (const GGS_mapMethod & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_mapMethod::
method_first (C_Compiler & _inLexique,
              GGS_mapMethod & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_mapMethod::constructor_new (_inLexique,
       _p->mMethodName,
       _p->mGetIDMethodName,
       _p->mErrorMessage,
       _p->mShadowErrorMessage) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_mapMethod::
method_last (C_Compiler & _inLexique,
             GGS_mapMethod & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_mapMethod::constructor_new (_inLexique,
       _p->mMethodName,
       _p->mGetIDMethodName,
       _p->mErrorMessage,
       _p->mShadowErrorMessage) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_mapMethod::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_mapMethod & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_mapMethod::constructor_new (_inLexique,
       _p->mMethodName,
       _p->mGetIDMethodName,
       _p->mErrorMessage,
       _p->mShadowErrorMessage) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_mapMethod::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_mapMethod & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_mapMethod::constructor_new (_inLexique,
       _p->mMethodName,
       _p->mGetIDMethodName,
       _p->mErrorMessage,
       _p->mShadowErrorMessage) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                        GALGAS entity '@mapMethod'                         *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_mapMethod GGS_mapMethod::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_lstring & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_mapMethod result ;
  macroMyNew (result.mPointer, cPtr_mapMethod (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapMethod::
reader_mMethodName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapMethod *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapMethod *) mPointer)->mMethodName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapMethod::
reader_mGetIDMethodName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapMethod *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapMethod *) mPointer)->mGetIDMethodName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapMethod::
reader_mErrorMessage (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapMethod *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapMethod *) mPointer)->mErrorMessage ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapMethod::
reader_mShadowErrorMessage (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapMethod *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapMethod *) mPointer)->mShadowErrorMessage ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_mapMethod::actualTypeName (void) const {
 return "mapMethod" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_mapMethod * GGS_mapMethod::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_mapMethod *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@mapindexDeclaration'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_mapindexDeclaration::
cPtr_mapindexDeclaration (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3
                                COMMA_LOCATION_ARGS) :
cPtr_semanticDeclaration (THERE),
mMapIndexName (argument_0),
mMapTypeName (argument_1),
mSearchMethodName (argument_2),
mSearchMethodErrorMessage (argument_3) {
}

//---------------------------------------------------------------------------*

bool cPtr_mapindexDeclaration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_mapindexDeclaration * _p = dynamic_cast <const cPtr_mapindexDeclaration *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mMapIndexName._operator_isEqual (_p->mMapIndexName).boolValue ()
         && mMapTypeName._operator_isEqual (_p->mMapTypeName).boolValue ()
         && mSearchMethodName._operator_isEqual (_p->mSearchMethodName).boolValue ()
         && mSearchMethodErrorMessage._operator_isEqual (_p->mSearchMethodErrorMessage).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_mapindexDeclaration::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @mapindexDeclaration" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMapIndexName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMapTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSearchMethodName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSearchMethodErrorMessage.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_mapindexDeclaration::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticDeclaration::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_mapindexDeclaration::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticDeclaration::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_mapindexDeclaration::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 4 ;
  if (inLevel > 0) {
    result = cPtr_semanticDeclaration::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_mapindexDeclaration::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "mapindexDeclaration" ;
  if (inLevel > 0) {
    result = cPtr_semanticDeclaration::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_mapindexDeclaration * cPtr_mapindexDeclaration::
_cloneObject (void) const {
  cPtr_mapindexDeclaration * _p = NULL ;
  macroMyNew (_p, cPtr_mapindexDeclaration (mMapIndexName, mMapTypeName, mSearchMethodName, mSearchMethodErrorMessage COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@_list_mapindexDeclaration'                      *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS__list_mapindexDeclaration::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_lstring & argument_3) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_mapindexDeclaration::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_lstring & argument_3) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_mapindexDeclaration::
_addAssign_operation (const GGS_mapindexDeclaration & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_mapindexDeclaration *) inElement.getPtr ())->mMapIndexName,
                                ((cPtr_mapindexDeclaration *) inElement.getPtr ())->mMapTypeName,
                                ((cPtr_mapindexDeclaration *) inElement.getPtr ())->mSearchMethodName,
                                ((cPtr_mapindexDeclaration *) inElement.getPtr ())->mSearchMethodErrorMessage) ;
  }
}

//---------------------------------------------------------------------------*

GGS__list_mapindexDeclaration GGS__list_mapindexDeclaration::
_operator_concat (const GGS__list_mapindexDeclaration & inOperand) const {
  GGS__list_mapindexDeclaration result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_mapindexDeclaration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mMapIndexName ;
          GGS_lstring  p_1 = p->mMapTypeName ;
          GGS_lstring  p_2 = p->mSearchMethodName ;
          GGS_lstring  p_3 = p->mSearchMethodErrorMessage ;
          result._internalAppendValues (p_0, p_1, p_2, p_3) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_mapindexDeclaration::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_lstring & argument_2,
                     const GGS_lstring & argument_3
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3) ;
  }
}

//---------------------------------------------------------------------------*

void GGS__list_mapindexDeclaration::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mMapIndexName,
                                _p->mMapTypeName,
                                _p->mSearchMethodName,
                                _p->mSearchMethodErrorMessage) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS__list_mapindexDeclaration  GGS__list_mapindexDeclaration::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_mapindexDeclaration result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_mapindexDeclaration  GGS__list_mapindexDeclaration::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_lstring & argument_1,
                           const GGS_lstring & argument_2,
                           const GGS_lstring & argument_3
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_mapindexDeclaration result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1, argument_2, argument_3) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_mapindexDeclaration::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_mapindexDeclaration", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS__list_mapindexDeclaration::
_addModel (const GGS_mapindexDeclaration & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_mapindexDeclaration::
method_first (C_Compiler & _inLexique,
              GGS_mapindexDeclaration & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_mapindexDeclaration::constructor_new (_inLexique,
       _p->mMapIndexName,
       _p->mMapTypeName,
       _p->mSearchMethodName,
       _p->mSearchMethodErrorMessage) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_mapindexDeclaration::
method_last (C_Compiler & _inLexique,
             GGS_mapindexDeclaration & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_mapindexDeclaration::constructor_new (_inLexique,
       _p->mMapIndexName,
       _p->mMapTypeName,
       _p->mSearchMethodName,
       _p->mSearchMethodErrorMessage) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_mapindexDeclaration::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_mapindexDeclaration & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_mapindexDeclaration::constructor_new (_inLexique,
       _p->mMapIndexName,
       _p->mMapTypeName,
       _p->mSearchMethodName,
       _p->mSearchMethodErrorMessage) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_mapindexDeclaration::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_mapindexDeclaration & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_mapindexDeclaration::constructor_new (_inLexique,
       _p->mMapIndexName,
       _p->mMapTypeName,
       _p->mSearchMethodName,
       _p->mSearchMethodErrorMessage) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS entity '@mapindexDeclaration'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_mapindexDeclaration GGS_mapindexDeclaration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_lstring & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_mapindexDeclaration result ;
  macroMyNew (result.mPointer, cPtr_mapindexDeclaration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapindexDeclaration::
reader_mMapIndexName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapindexDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapindexDeclaration *) mPointer)->mMapIndexName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapindexDeclaration::
reader_mMapTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapindexDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapindexDeclaration *) mPointer)->mMapTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapindexDeclaration::
reader_mSearchMethodName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapindexDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapindexDeclaration *) mPointer)->mSearchMethodName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapindexDeclaration::
reader_mSearchMethodErrorMessage (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapindexDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapindexDeclaration *) mPointer)->mSearchMethodErrorMessage ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_mapindexDeclaration::actualTypeName (void) const {
 return "mapindexDeclaration" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_mapindexDeclaration * GGS_mapindexDeclaration::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_mapindexDeclaration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                   Element of list '@classDeclaration'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_classDeclaration::
cPtr_classDeclaration (const GGS_bool& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS__list_attributeInCollection & argument_3,
                                const GGS__list_abstractMethodDefinition & argument_4,
                                const GGS__list_overridenMethodDefinition & argument_5,
                                const GGS__list_methodDefinition & argument_6,
                                const GGS__list_classMessageDefinition & argument_7,
                                const GGS_string& argument_8
                                COMMA_LOCATION_ARGS) :
cPtr_semanticDeclaration (THERE),
mIsAbstract (argument_0),
mClassTypeName (argument_1),
mSuperClassName (argument_2),
mAttributeList (argument_3),
mAbstractMethodList (argument_4),
mOverridenMethodList (argument_5),
mMethodList (argument_6),
mMessageList (argument_7),
mClassMessage (argument_8) {
}

//---------------------------------------------------------------------------*

bool cPtr_classDeclaration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_classDeclaration * _p = dynamic_cast <const cPtr_classDeclaration *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mIsAbstract._operator_isEqual (_p->mIsAbstract).boolValue ()
         && mClassTypeName._operator_isEqual (_p->mClassTypeName).boolValue ()
         && mSuperClassName._operator_isEqual (_p->mSuperClassName).boolValue ()
         && mAttributeList._operator_isEqual (_p->mAttributeList).boolValue ()
         && mAbstractMethodList._operator_isEqual (_p->mAbstractMethodList).boolValue ()
         && mOverridenMethodList._operator_isEqual (_p->mOverridenMethodList).boolValue ()
         && mMethodList._operator_isEqual (_p->mMethodList).boolValue ()
         && mMessageList._operator_isEqual (_p->mMessageList).boolValue ()
         && mClassMessage._operator_isEqual (_p->mClassMessage).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_classDeclaration::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @classDeclaration" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mIsAbstract.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mClassTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSuperClassName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAttributeList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAbstractMethodList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOverridenMethodList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMethodList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMessageList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mClassMessage.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_classDeclaration::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticDeclaration::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_classDeclaration::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticDeclaration::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_classDeclaration::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 5 ;
  if (inLevel > 0) {
    result = cPtr_semanticDeclaration::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_classDeclaration::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "classDeclaration" ;
  if (inLevel > 0) {
    result = cPtr_semanticDeclaration::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_classDeclaration * cPtr_classDeclaration::
_cloneObject (void) const {
  cPtr_classDeclaration * _p = NULL ;
  macroMyNew (_p, cPtr_classDeclaration (mIsAbstract, mClassTypeName, mSuperClassName, mAttributeList, mAbstractMethodList, mOverridenMethodList, mMethodList, mMessageList, mClassMessage COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@_list_classDeclaration'                       *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS__list_classDeclaration::
_internalAppendValues (const GGS_bool& argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS__list_attributeInCollection & argument_3,
                    const GGS__list_abstractMethodDefinition & argument_4,
                    const GGS__list_overridenMethodDefinition & argument_5,
                    const GGS__list_methodDefinition & argument_6,
                    const GGS__list_classMessageDefinition & argument_7,
                    const GGS_string& argument_8) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7,
                                argument_8
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_classDeclaration::
_internalPrependValues (const GGS_bool& argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS__list_attributeInCollection & argument_3,
                    const GGS__list_abstractMethodDefinition & argument_4,
                    const GGS__list_overridenMethodDefinition & argument_5,
                    const GGS__list_methodDefinition & argument_6,
                    const GGS__list_classMessageDefinition & argument_7,
                    const GGS_string& argument_8) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7,
                                argument_8
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_classDeclaration::
_addAssign_operation (const GGS_classDeclaration & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_classDeclaration *) inElement.getPtr ())->mIsAbstract,
                                ((cPtr_classDeclaration *) inElement.getPtr ())->mClassTypeName,
                                ((cPtr_classDeclaration *) inElement.getPtr ())->mSuperClassName,
                                ((cPtr_classDeclaration *) inElement.getPtr ())->mAttributeList,
                                ((cPtr_classDeclaration *) inElement.getPtr ())->mAbstractMethodList,
                                ((cPtr_classDeclaration *) inElement.getPtr ())->mOverridenMethodList,
                                ((cPtr_classDeclaration *) inElement.getPtr ())->mMethodList,
                                ((cPtr_classDeclaration *) inElement.getPtr ())->mMessageList,
                                ((cPtr_classDeclaration *) inElement.getPtr ())->mClassMessage) ;
  }
}

//---------------------------------------------------------------------------*

GGS__list_classDeclaration GGS__list_classDeclaration::
_operator_concat (const GGS__list_classDeclaration & inOperand) const {
  GGS__list_classDeclaration result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_classDeclaration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_bool p_0 = p->mIsAbstract ;
          GGS_lstring  p_1 = p->mClassTypeName ;
          GGS_lstring  p_2 = p->mSuperClassName ;
          GGS__list_attributeInCollection  p_3 = p->mAttributeList ;
          GGS__list_abstractMethodDefinition  p_4 = p->mAbstractMethodList ;
          GGS__list_overridenMethodDefinition  p_5 = p->mOverridenMethodList ;
          GGS__list_methodDefinition  p_6 = p->mMethodList ;
          GGS__list_classMessageDefinition  p_7 = p->mMessageList ;
          GGS_string p_8 = p->mClassMessage ;
          result._internalAppendValues (p_0, p_1, p_2, p_3, p_4, p_5, p_6, p_7, p_8) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_classDeclaration::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_bool& argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_lstring & argument_2,
                     const GGS__list_attributeInCollection & argument_3,
                     const GGS__list_abstractMethodDefinition & argument_4,
                     const GGS__list_overridenMethodDefinition & argument_5,
                     const GGS__list_methodDefinition & argument_6,
                     const GGS__list_classMessageDefinition & argument_7,
                     const GGS_string& argument_8
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7,
                                argument_8) ;
  }
}

//---------------------------------------------------------------------------*

void GGS__list_classDeclaration::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mIsAbstract,
                                _p->mClassTypeName,
                                _p->mSuperClassName,
                                _p->mAttributeList,
                                _p->mAbstractMethodList,
                                _p->mOverridenMethodList,
                                _p->mMethodList,
                                _p->mMessageList,
                                _p->mClassMessage) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS__list_classDeclaration  GGS__list_classDeclaration::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_classDeclaration result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_classDeclaration  GGS__list_classDeclaration::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_bool& argument_0,
                           const GGS_lstring & argument_1,
                           const GGS_lstring & argument_2,
                           const GGS__list_attributeInCollection & argument_3,
                           const GGS__list_abstractMethodDefinition & argument_4,
                           const GGS__list_overridenMethodDefinition & argument_5,
                           const GGS__list_methodDefinition & argument_6,
                           const GGS__list_classMessageDefinition & argument_7,
                           const GGS_string& argument_8
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_classDeclaration result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1, argument_2, argument_3, argument_4, argument_5, argument_6, argument_7, argument_8) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_classDeclaration::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_classDeclaration", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS__list_classDeclaration::
_addModel (const GGS_classDeclaration & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_classDeclaration::
method_first (C_Compiler & _inLexique,
              GGS_classDeclaration & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_classDeclaration::constructor_new (_inLexique,
       _p->mIsAbstract,
       _p->mClassTypeName,
       _p->mSuperClassName,
       _p->mAttributeList,
       _p->mAbstractMethodList,
       _p->mOverridenMethodList,
       _p->mMethodList,
       _p->mMessageList,
       _p->mClassMessage) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_classDeclaration::
method_last (C_Compiler & _inLexique,
             GGS_classDeclaration & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_classDeclaration::constructor_new (_inLexique,
       _p->mIsAbstract,
       _p->mClassTypeName,
       _p->mSuperClassName,
       _p->mAttributeList,
       _p->mAbstractMethodList,
       _p->mOverridenMethodList,
       _p->mMethodList,
       _p->mMessageList,
       _p->mClassMessage) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_classDeclaration::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_classDeclaration & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_classDeclaration::constructor_new (_inLexique,
       _p->mIsAbstract,
       _p->mClassTypeName,
       _p->mSuperClassName,
       _p->mAttributeList,
       _p->mAbstractMethodList,
       _p->mOverridenMethodList,
       _p->mMethodList,
       _p->mMessageList,
       _p->mClassMessage) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_classDeclaration::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_classDeclaration & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_classDeclaration::constructor_new (_inLexique,
       _p->mIsAbstract,
       _p->mClassTypeName,
       _p->mSuperClassName,
       _p->mAttributeList,
       _p->mAbstractMethodList,
       _p->mOverridenMethodList,
       _p->mMethodList,
       _p->mMessageList,
       _p->mClassMessage) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS entity '@classDeclaration'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_classDeclaration GGS_classDeclaration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_bool& argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS__list_attributeInCollection & argument_3,
                 const GGS__list_abstractMethodDefinition & argument_4,
                 const GGS__list_overridenMethodDefinition & argument_5,
                 const GGS__list_methodDefinition & argument_6,
                 const GGS__list_classMessageDefinition & argument_7,
                 const GGS_string& argument_8
                                COMMA_LOCATION_ARGS) {
  GGS_classDeclaration result ;
  macroMyNew (result.mPointer, cPtr_classDeclaration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7,
                                argument_8 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_classDeclaration::
reader_mIsAbstract (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classDeclaration *) mPointer)->mIsAbstract ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_classDeclaration::
reader_mClassTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classDeclaration *) mPointer)->mClassTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_classDeclaration::
reader_mSuperClassName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classDeclaration *) mPointer)->mSuperClassName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_attributeInCollection  GGS_classDeclaration::
reader_mAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_attributeInCollection   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classDeclaration *) mPointer)->mAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_abstractMethodDefinition  GGS_classDeclaration::
reader_mAbstractMethodList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_abstractMethodDefinition   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classDeclaration *) mPointer)->mAbstractMethodList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_overridenMethodDefinition  GGS_classDeclaration::
reader_mOverridenMethodList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_overridenMethodDefinition   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classDeclaration *) mPointer)->mOverridenMethodList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_methodDefinition  GGS_classDeclaration::
reader_mMethodList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_methodDefinition   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classDeclaration *) mPointer)->mMethodList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_classMessageDefinition  GGS_classDeclaration::
reader_mMessageList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_classMessageDefinition   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classDeclaration *) mPointer)->mMessageList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_classDeclaration::
reader_mClassMessage (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classDeclaration *) mPointer)->mClassMessage ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_classDeclaration::actualTypeName (void) const {
 return "classDeclaration" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_classDeclaration * GGS_classDeclaration::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_classDeclaration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@abstractMethodDefinition'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_abstractMethodDefinition::
cPtr_abstractMethodDefinition (const GGS_lstring & argument_0,
                                const GGS_formalParameters & argument_1
                                COMMA_LOCATION_ARGS) :
EX_C_GGS_MetamodelEntity (THERE),
mMethodName (argument_0),
mSignature (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_abstractMethodDefinition::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_abstractMethodDefinition * _p = dynamic_cast <const cPtr_abstractMethodDefinition *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mMethodName._operator_isEqual (_p->mMethodName).boolValue ()
         && mSignature._operator_isEqual (_p->mSignature).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_abstractMethodDefinition::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @abstractMethodDefinition" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMethodName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSignature.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_abstractMethodDefinition::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_abstractMethodDefinition::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_abstractMethodDefinition::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 6 ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_abstractMethodDefinition::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "abstractMethodDefinition" ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_abstractMethodDefinition * cPtr_abstractMethodDefinition::
_cloneObject (void) const {
  cPtr_abstractMethodDefinition * _p = NULL ;
  macroMyNew (_p, cPtr_abstractMethodDefinition (mMethodName, mSignature COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@_list_abstractMethodDefinition'                   *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS__list_abstractMethodDefinition::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_formalParameters & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_abstractMethodDefinition::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_formalParameters & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_abstractMethodDefinition::
_addAssign_operation (const GGS_abstractMethodDefinition & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_abstractMethodDefinition *) inElement.getPtr ())->mMethodName,
                                ((cPtr_abstractMethodDefinition *) inElement.getPtr ())->mSignature) ;
  }
}

//---------------------------------------------------------------------------*

GGS__list_abstractMethodDefinition GGS__list_abstractMethodDefinition::
_operator_concat (const GGS__list_abstractMethodDefinition & inOperand) const {
  GGS__list_abstractMethodDefinition result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_abstractMethodDefinition * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mMethodName ;
          GGS_formalParameters  p_1 = p->mSignature ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_abstractMethodDefinition::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_formalParameters & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS__list_abstractMethodDefinition::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mMethodName,
                                _p->mSignature) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS__list_abstractMethodDefinition  GGS__list_abstractMethodDefinition::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_abstractMethodDefinition result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_abstractMethodDefinition  GGS__list_abstractMethodDefinition::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_formalParameters & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_abstractMethodDefinition result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_abstractMethodDefinition::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_abstractMethodDefinition", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS__list_abstractMethodDefinition::
_addModel (const GGS_abstractMethodDefinition & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_abstractMethodDefinition::
method_first (C_Compiler & _inLexique,
              GGS_abstractMethodDefinition & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_abstractMethodDefinition::constructor_new (_inLexique,
       _p->mMethodName,
       _p->mSignature) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_abstractMethodDefinition::
method_last (C_Compiler & _inLexique,
             GGS_abstractMethodDefinition & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_abstractMethodDefinition::constructor_new (_inLexique,
       _p->mMethodName,
       _p->mSignature) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_abstractMethodDefinition::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_abstractMethodDefinition & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_abstractMethodDefinition::constructor_new (_inLexique,
       _p->mMethodName,
       _p->mSignature) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_abstractMethodDefinition::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_abstractMethodDefinition & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_abstractMethodDefinition::constructor_new (_inLexique,
       _p->mMethodName,
       _p->mSignature) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS entity '@abstractMethodDefinition'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_abstractMethodDefinition GGS_abstractMethodDefinition::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_formalParameters & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_abstractMethodDefinition result ;
  macroMyNew (result.mPointer, cPtr_abstractMethodDefinition (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_abstractMethodDefinition::
reader_mMethodName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_abstractMethodDefinition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_abstractMethodDefinition *) mPointer)->mMethodName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameters  GGS_abstractMethodDefinition::
reader_mSignature (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_formalParameters   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_abstractMethodDefinition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_abstractMethodDefinition *) mPointer)->mSignature ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_abstractMethodDefinition::actualTypeName (void) const {
 return "abstractMethodDefinition" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_abstractMethodDefinition * GGS_abstractMethodDefinition::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_abstractMethodDefinition *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@overridenMethodDefinition'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_overridenMethodDefinition::
cPtr_overridenMethodDefinition (const GGS_lstring & argument_0,
                                const GGS_formalParameters & argument_1,
                                const GGS_semanticInstructions & argument_2
                                COMMA_LOCATION_ARGS) :
EX_C_GGS_MetamodelEntity (THERE),
mMethodName (argument_0),
mSignature (argument_1),
mInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_overridenMethodDefinition::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_overridenMethodDefinition * _p = dynamic_cast <const cPtr_overridenMethodDefinition *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mMethodName._operator_isEqual (_p->mMethodName).boolValue ()
         && mSignature._operator_isEqual (_p->mSignature).boolValue ()
         && mInstructionList._operator_isEqual (_p->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_overridenMethodDefinition::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @overridenMethodDefinition" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMethodName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSignature.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_overridenMethodDefinition::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_overridenMethodDefinition::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_overridenMethodDefinition::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 7 ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_overridenMethodDefinition::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "overridenMethodDefinition" ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_overridenMethodDefinition * cPtr_overridenMethodDefinition::
_cloneObject (void) const {
  cPtr_overridenMethodDefinition * _p = NULL ;
  macroMyNew (_p, cPtr_overridenMethodDefinition (mMethodName, mSignature, mInstructionList COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 List '@_list_overridenMethodDefinition'                   *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS__list_overridenMethodDefinition::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_formalParameters & argument_1,
                    const GGS_semanticInstructions & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_overridenMethodDefinition::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_formalParameters & argument_1,
                    const GGS_semanticInstructions & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_overridenMethodDefinition::
_addAssign_operation (const GGS_overridenMethodDefinition & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_overridenMethodDefinition *) inElement.getPtr ())->mMethodName,
                                ((cPtr_overridenMethodDefinition *) inElement.getPtr ())->mSignature,
                                ((cPtr_overridenMethodDefinition *) inElement.getPtr ())->mInstructionList) ;
  }
}

//---------------------------------------------------------------------------*

GGS__list_overridenMethodDefinition GGS__list_overridenMethodDefinition::
_operator_concat (const GGS__list_overridenMethodDefinition & inOperand) const {
  GGS__list_overridenMethodDefinition result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_overridenMethodDefinition * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mMethodName ;
          GGS_formalParameters  p_1 = p->mSignature ;
          GGS_semanticInstructions  p_2 = p->mInstructionList ;
          result._internalAppendValues (p_0, p_1, p_2) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_overridenMethodDefinition::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_formalParameters & argument_1,
                     const GGS_semanticInstructions & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

void GGS__list_overridenMethodDefinition::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mMethodName,
                                _p->mSignature,
                                _p->mInstructionList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS__list_overridenMethodDefinition  GGS__list_overridenMethodDefinition::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_overridenMethodDefinition result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_overridenMethodDefinition  GGS__list_overridenMethodDefinition::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_formalParameters & argument_1,
                           const GGS_semanticInstructions & argument_2
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_overridenMethodDefinition result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_overridenMethodDefinition::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_overridenMethodDefinition", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS__list_overridenMethodDefinition::
_addModel (const GGS_overridenMethodDefinition & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_overridenMethodDefinition::
method_first (C_Compiler & _inLexique,
              GGS_overridenMethodDefinition & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_overridenMethodDefinition::constructor_new (_inLexique,
       _p->mMethodName,
       _p->mSignature,
       _p->mInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_overridenMethodDefinition::
method_last (C_Compiler & _inLexique,
             GGS_overridenMethodDefinition & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_overridenMethodDefinition::constructor_new (_inLexique,
       _p->mMethodName,
       _p->mSignature,
       _p->mInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_overridenMethodDefinition::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_overridenMethodDefinition & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_overridenMethodDefinition::constructor_new (_inLexique,
       _p->mMethodName,
       _p->mSignature,
       _p->mInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_overridenMethodDefinition::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_overridenMethodDefinition & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_overridenMethodDefinition::constructor_new (_inLexique,
       _p->mMethodName,
       _p->mSignature,
       _p->mInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS entity '@overridenMethodDefinition'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_overridenMethodDefinition GGS_overridenMethodDefinition::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_formalParameters & argument_1,
                 const GGS_semanticInstructions & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_overridenMethodDefinition result ;
  macroMyNew (result.mPointer, cPtr_overridenMethodDefinition (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_overridenMethodDefinition::
reader_mMethodName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_overridenMethodDefinition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_overridenMethodDefinition *) mPointer)->mMethodName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameters  GGS_overridenMethodDefinition::
reader_mSignature (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_formalParameters   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_overridenMethodDefinition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_overridenMethodDefinition *) mPointer)->mSignature ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructions  GGS_overridenMethodDefinition::
reader_mInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructions   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_overridenMethodDefinition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_overridenMethodDefinition *) mPointer)->mInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_overridenMethodDefinition::actualTypeName (void) const {
 return "overridenMethodDefinition" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_overridenMethodDefinition * GGS_overridenMethodDefinition::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_overridenMethodDefinition *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                   Element of list '@methodDefinition'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_methodDefinition::
cPtr_methodDefinition (const GGS_lstring & argument_0,
                                const GGS_formalParameters & argument_1,
                                const GGS_semanticInstructions & argument_2
                                COMMA_LOCATION_ARGS) :
EX_C_GGS_MetamodelEntity (THERE),
mMethodName (argument_0),
mSignature (argument_1),
mInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_methodDefinition::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_methodDefinition * _p = dynamic_cast <const cPtr_methodDefinition *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mMethodName._operator_isEqual (_p->mMethodName).boolValue ()
         && mSignature._operator_isEqual (_p->mSignature).boolValue ()
         && mInstructionList._operator_isEqual (_p->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_methodDefinition::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @methodDefinition" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMethodName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSignature.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_methodDefinition::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_methodDefinition::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_methodDefinition::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 8 ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_methodDefinition::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "methodDefinition" ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_methodDefinition * cPtr_methodDefinition::
_cloneObject (void) const {
  cPtr_methodDefinition * _p = NULL ;
  macroMyNew (_p, cPtr_methodDefinition (mMethodName, mSignature, mInstructionList COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@_list_methodDefinition'                       *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS__list_methodDefinition::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_formalParameters & argument_1,
                    const GGS_semanticInstructions & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_methodDefinition::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_formalParameters & argument_1,
                    const GGS_semanticInstructions & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_methodDefinition::
_addAssign_operation (const GGS_methodDefinition & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_methodDefinition *) inElement.getPtr ())->mMethodName,
                                ((cPtr_methodDefinition *) inElement.getPtr ())->mSignature,
                                ((cPtr_methodDefinition *) inElement.getPtr ())->mInstructionList) ;
  }
}

//---------------------------------------------------------------------------*

GGS__list_methodDefinition GGS__list_methodDefinition::
_operator_concat (const GGS__list_methodDefinition & inOperand) const {
  GGS__list_methodDefinition result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_methodDefinition * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mMethodName ;
          GGS_formalParameters  p_1 = p->mSignature ;
          GGS_semanticInstructions  p_2 = p->mInstructionList ;
          result._internalAppendValues (p_0, p_1, p_2) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_methodDefinition::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_formalParameters & argument_1,
                     const GGS_semanticInstructions & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

void GGS__list_methodDefinition::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mMethodName,
                                _p->mSignature,
                                _p->mInstructionList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS__list_methodDefinition  GGS__list_methodDefinition::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_methodDefinition result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_methodDefinition  GGS__list_methodDefinition::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_formalParameters & argument_1,
                           const GGS_semanticInstructions & argument_2
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_methodDefinition result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_methodDefinition::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_methodDefinition", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS__list_methodDefinition::
_addModel (const GGS_methodDefinition & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_methodDefinition::
method_first (C_Compiler & _inLexique,
              GGS_methodDefinition & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_methodDefinition::constructor_new (_inLexique,
       _p->mMethodName,
       _p->mSignature,
       _p->mInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_methodDefinition::
method_last (C_Compiler & _inLexique,
             GGS_methodDefinition & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_methodDefinition::constructor_new (_inLexique,
       _p->mMethodName,
       _p->mSignature,
       _p->mInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_methodDefinition::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_methodDefinition & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_methodDefinition::constructor_new (_inLexique,
       _p->mMethodName,
       _p->mSignature,
       _p->mInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_methodDefinition::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_methodDefinition & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_methodDefinition::constructor_new (_inLexique,
       _p->mMethodName,
       _p->mSignature,
       _p->mInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS entity '@methodDefinition'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_methodDefinition GGS_methodDefinition::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_formalParameters & argument_1,
                 const GGS_semanticInstructions & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_methodDefinition result ;
  macroMyNew (result.mPointer, cPtr_methodDefinition (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_methodDefinition::
reader_mMethodName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_methodDefinition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_methodDefinition *) mPointer)->mMethodName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameters  GGS_methodDefinition::
reader_mSignature (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_formalParameters   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_methodDefinition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_methodDefinition *) mPointer)->mSignature ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructions  GGS_methodDefinition::
reader_mInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructions   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_methodDefinition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_methodDefinition *) mPointer)->mInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_methodDefinition::actualTypeName (void) const {
 return "methodDefinition" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_methodDefinition * GGS_methodDefinition::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_methodDefinition *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@classMessageDefinition'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_classMessageDefinition::
cPtr_classMessageDefinition (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
EX_C_GGS_MetamodelEntity (THERE),
mMessageName (argument_0),
mMessageValue (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_classMessageDefinition::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_classMessageDefinition * _p = dynamic_cast <const cPtr_classMessageDefinition *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mMessageName._operator_isEqual (_p->mMessageName).boolValue ()
         && mMessageValue._operator_isEqual (_p->mMessageValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_classMessageDefinition::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @classMessageDefinition" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMessageName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMessageValue.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_classMessageDefinition::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_classMessageDefinition::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_classMessageDefinition::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 9 ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_classMessageDefinition::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "classMessageDefinition" ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_classMessageDefinition * cPtr_classMessageDefinition::
_cloneObject (void) const {
  cPtr_classMessageDefinition * _p = NULL ;
  macroMyNew (_p, cPtr_classMessageDefinition (mMessageName, mMessageValue COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@_list_classMessageDefinition'                    *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS__list_classMessageDefinition::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_classMessageDefinition::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_classMessageDefinition::
_addAssign_operation (const GGS_classMessageDefinition & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_classMessageDefinition *) inElement.getPtr ())->mMessageName,
                                ((cPtr_classMessageDefinition *) inElement.getPtr ())->mMessageValue) ;
  }
}

//---------------------------------------------------------------------------*

GGS__list_classMessageDefinition GGS__list_classMessageDefinition::
_operator_concat (const GGS__list_classMessageDefinition & inOperand) const {
  GGS__list_classMessageDefinition result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_classMessageDefinition * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mMessageName ;
          GGS_lstring  p_1 = p->mMessageValue ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_classMessageDefinition::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS__list_classMessageDefinition::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mMessageName,
                                _p->mMessageValue) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS__list_classMessageDefinition  GGS__list_classMessageDefinition::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_classMessageDefinition result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_classMessageDefinition  GGS__list_classMessageDefinition::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_lstring & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_classMessageDefinition result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_classMessageDefinition::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_classMessageDefinition", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS__list_classMessageDefinition::
_addModel (const GGS_classMessageDefinition & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_classMessageDefinition::
method_first (C_Compiler & _inLexique,
              GGS_classMessageDefinition & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_classMessageDefinition::constructor_new (_inLexique,
       _p->mMessageName,
       _p->mMessageValue) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_classMessageDefinition::
method_last (C_Compiler & _inLexique,
             GGS_classMessageDefinition & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_classMessageDefinition::constructor_new (_inLexique,
       _p->mMessageName,
       _p->mMessageValue) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_classMessageDefinition::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_classMessageDefinition & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_classMessageDefinition::constructor_new (_inLexique,
       _p->mMessageName,
       _p->mMessageValue) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_classMessageDefinition::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_classMessageDefinition & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_classMessageDefinition::constructor_new (_inLexique,
       _p->mMessageName,
       _p->mMessageValue) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS entity '@classMessageDefinition'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_classMessageDefinition GGS_classMessageDefinition::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_classMessageDefinition result ;
  macroMyNew (result.mPointer, cPtr_classMessageDefinition (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_classMessageDefinition::
reader_mMessageName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classMessageDefinition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classMessageDefinition *) mPointer)->mMessageName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_classMessageDefinition::
reader_mMessageValue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classMessageDefinition *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classMessageDefinition *) mPointer)->mMessageValue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_classMessageDefinition::actualTypeName (void) const {
 return "classMessageDefinition" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_classMessageDefinition * GGS_classMessageDefinition::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_classMessageDefinition *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                    Element of list '@listDeclaration'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_listDeclaration::
cPtr_listDeclaration (const GGS_lstring & argument_0,
                                const GGS__list_attributeInCollection & argument_1
                                COMMA_LOCATION_ARGS) :
cPtr_semanticDeclaration (THERE),
mListTypeName (argument_0),
mAttributeList (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_listDeclaration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_listDeclaration * _p = dynamic_cast <const cPtr_listDeclaration *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mListTypeName._operator_isEqual (_p->mListTypeName).boolValue ()
         && mAttributeList._operator_isEqual (_p->mAttributeList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_listDeclaration::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @listDeclaration" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mListTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAttributeList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_listDeclaration::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticDeclaration::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_listDeclaration::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticDeclaration::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_listDeclaration::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 10 ;
  if (inLevel > 0) {
    result = cPtr_semanticDeclaration::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_listDeclaration::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "listDeclaration" ;
  if (inLevel > 0) {
    result = cPtr_semanticDeclaration::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_listDeclaration * cPtr_listDeclaration::
_cloneObject (void) const {
  cPtr_listDeclaration * _p = NULL ;
  macroMyNew (_p, cPtr_listDeclaration (mListTypeName, mAttributeList COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@_list_listDeclaration'                        *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS__list_listDeclaration::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS__list_attributeInCollection & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_listDeclaration::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS__list_attributeInCollection & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_listDeclaration::
_addAssign_operation (const GGS_listDeclaration & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_listDeclaration *) inElement.getPtr ())->mListTypeName,
                                ((cPtr_listDeclaration *) inElement.getPtr ())->mAttributeList) ;
  }
}

//---------------------------------------------------------------------------*

GGS__list_listDeclaration GGS__list_listDeclaration::
_operator_concat (const GGS__list_listDeclaration & inOperand) const {
  GGS__list_listDeclaration result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_listDeclaration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mListTypeName ;
          GGS__list_attributeInCollection  p_1 = p->mAttributeList ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_listDeclaration::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS__list_attributeInCollection & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS__list_listDeclaration::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mListTypeName,
                                _p->mAttributeList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS__list_listDeclaration  GGS__list_listDeclaration::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_listDeclaration result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_listDeclaration  GGS__list_listDeclaration::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS__list_attributeInCollection & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_listDeclaration result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_listDeclaration::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_listDeclaration", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS__list_listDeclaration::
_addModel (const GGS_listDeclaration & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_listDeclaration::
method_first (C_Compiler & _inLexique,
              GGS_listDeclaration & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_listDeclaration::constructor_new (_inLexique,
       _p->mListTypeName,
       _p->mAttributeList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_listDeclaration::
method_last (C_Compiler & _inLexique,
             GGS_listDeclaration & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_listDeclaration::constructor_new (_inLexique,
       _p->mListTypeName,
       _p->mAttributeList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_listDeclaration::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_listDeclaration & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_listDeclaration::constructor_new (_inLexique,
       _p->mListTypeName,
       _p->mAttributeList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_listDeclaration::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_listDeclaration & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_listDeclaration::constructor_new (_inLexique,
       _p->mListTypeName,
       _p->mAttributeList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS entity '@listDeclaration'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_listDeclaration GGS_listDeclaration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS__list_attributeInCollection & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_listDeclaration result ;
  macroMyNew (result.mPointer, cPtr_listDeclaration (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_listDeclaration::
reader_mListTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_listDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_listDeclaration *) mPointer)->mListTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_attributeInCollection  GGS_listDeclaration::
reader_mAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_attributeInCollection   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_listDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_listDeclaration *) mPointer)->mAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_listDeclaration::actualTypeName (void) const {
 return "listDeclaration" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_listDeclaration * GGS_listDeclaration::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_listDeclaration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@sortedListSortDescriptor'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_sortedListSortDescriptor::
cPtr_sortedListSortDescriptor (const GGS_lstring & argument_0,
                                const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS) :
EX_C_GGS_MetamodelEntity (THERE),
mSortedAttributeName (argument_0),
mAscending (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_sortedListSortDescriptor::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_sortedListSortDescriptor * _p = dynamic_cast <const cPtr_sortedListSortDescriptor *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mSortedAttributeName._operator_isEqual (_p->mSortedAttributeName).boolValue ()
         && mAscending._operator_isEqual (_p->mAscending).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_sortedListSortDescriptor::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @sortedListSortDescriptor" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSortedAttributeName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAscending.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_sortedListSortDescriptor::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_sortedListSortDescriptor::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_sortedListSortDescriptor::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 11 ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_sortedListSortDescriptor::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "sortedListSortDescriptor" ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_sortedListSortDescriptor * cPtr_sortedListSortDescriptor::
_cloneObject (void) const {
  cPtr_sortedListSortDescriptor * _p = NULL ;
  macroMyNew (_p, cPtr_sortedListSortDescriptor (mSortedAttributeName, mAscending COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@_list_sortedListSortDescriptor'                   *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS__list_sortedListSortDescriptor::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_bool& argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_sortedListSortDescriptor::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_bool& argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_sortedListSortDescriptor::
_addAssign_operation (const GGS_sortedListSortDescriptor & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_sortedListSortDescriptor *) inElement.getPtr ())->mSortedAttributeName,
                                ((cPtr_sortedListSortDescriptor *) inElement.getPtr ())->mAscending) ;
  }
}

//---------------------------------------------------------------------------*

GGS__list_sortedListSortDescriptor GGS__list_sortedListSortDescriptor::
_operator_concat (const GGS__list_sortedListSortDescriptor & inOperand) const {
  GGS__list_sortedListSortDescriptor result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_sortedListSortDescriptor * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mSortedAttributeName ;
          GGS_bool p_1 = p->mAscending ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_sortedListSortDescriptor::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_bool& argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS__list_sortedListSortDescriptor::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mSortedAttributeName,
                                _p->mAscending) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS__list_sortedListSortDescriptor  GGS__list_sortedListSortDescriptor::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_sortedListSortDescriptor result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_sortedListSortDescriptor  GGS__list_sortedListSortDescriptor::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_bool& argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_sortedListSortDescriptor result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_sortedListSortDescriptor::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_sortedListSortDescriptor", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS__list_sortedListSortDescriptor::
_addModel (const GGS_sortedListSortDescriptor & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_sortedListSortDescriptor::
method_first (C_Compiler & _inLexique,
              GGS_sortedListSortDescriptor & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_sortedListSortDescriptor::constructor_new (_inLexique,
       _p->mSortedAttributeName,
       _p->mAscending) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_sortedListSortDescriptor::
method_last (C_Compiler & _inLexique,
             GGS_sortedListSortDescriptor & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_sortedListSortDescriptor::constructor_new (_inLexique,
       _p->mSortedAttributeName,
       _p->mAscending) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_sortedListSortDescriptor::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_sortedListSortDescriptor & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_sortedListSortDescriptor::constructor_new (_inLexique,
       _p->mSortedAttributeName,
       _p->mAscending) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_sortedListSortDescriptor::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_sortedListSortDescriptor & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_sortedListSortDescriptor::constructor_new (_inLexique,
       _p->mSortedAttributeName,
       _p->mAscending) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS entity '@sortedListSortDescriptor'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_sortedListSortDescriptor GGS_sortedListSortDescriptor::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_sortedListSortDescriptor result ;
  macroMyNew (result.mPointer, cPtr_sortedListSortDescriptor (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_sortedListSortDescriptor::
reader_mSortedAttributeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sortedListSortDescriptor *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sortedListSortDescriptor *) mPointer)->mSortedAttributeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_sortedListSortDescriptor::
reader_mAscending (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sortedListSortDescriptor *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sortedListSortDescriptor *) mPointer)->mAscending ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_sortedListSortDescriptor::actualTypeName (void) const {
 return "sortedListSortDescriptor" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_sortedListSortDescriptor * GGS_sortedListSortDescriptor::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_sortedListSortDescriptor *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@sortedListDeclaration'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_sortedListDeclaration::
cPtr_sortedListDeclaration (const GGS_lstring & argument_0,
                                const GGS__list_attributeInCollection & argument_1,
                                const GGS__list_sortedListSortDescriptor & argument_2
                                COMMA_LOCATION_ARGS) :
cPtr_semanticDeclaration (THERE),
mSortedListTypeName (argument_0),
mAttributeList (argument_1),
mSortDescriptorList (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_sortedListDeclaration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_sortedListDeclaration * _p = dynamic_cast <const cPtr_sortedListDeclaration *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mSortedListTypeName._operator_isEqual (_p->mSortedListTypeName).boolValue ()
         && mAttributeList._operator_isEqual (_p->mAttributeList).boolValue ()
         && mSortDescriptorList._operator_isEqual (_p->mSortDescriptorList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_sortedListDeclaration::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @sortedListDeclaration" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSortedListTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAttributeList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSortDescriptorList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_sortedListDeclaration::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticDeclaration::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_sortedListDeclaration::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticDeclaration::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_sortedListDeclaration::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 12 ;
  if (inLevel > 0) {
    result = cPtr_semanticDeclaration::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_sortedListDeclaration::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "sortedListDeclaration" ;
  if (inLevel > 0) {
    result = cPtr_semanticDeclaration::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_sortedListDeclaration * cPtr_sortedListDeclaration::
_cloneObject (void) const {
  cPtr_sortedListDeclaration * _p = NULL ;
  macroMyNew (_p, cPtr_sortedListDeclaration (mSortedListTypeName, mAttributeList, mSortDescriptorList COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@_list_sortedListDeclaration'                     *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS__list_sortedListDeclaration::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS__list_attributeInCollection & argument_1,
                    const GGS__list_sortedListSortDescriptor & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_sortedListDeclaration::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS__list_attributeInCollection & argument_1,
                    const GGS__list_sortedListSortDescriptor & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_sortedListDeclaration::
_addAssign_operation (const GGS_sortedListDeclaration & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_sortedListDeclaration *) inElement.getPtr ())->mSortedListTypeName,
                                ((cPtr_sortedListDeclaration *) inElement.getPtr ())->mAttributeList,
                                ((cPtr_sortedListDeclaration *) inElement.getPtr ())->mSortDescriptorList) ;
  }
}

//---------------------------------------------------------------------------*

GGS__list_sortedListDeclaration GGS__list_sortedListDeclaration::
_operator_concat (const GGS__list_sortedListDeclaration & inOperand) const {
  GGS__list_sortedListDeclaration result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_sortedListDeclaration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mSortedListTypeName ;
          GGS__list_attributeInCollection  p_1 = p->mAttributeList ;
          GGS__list_sortedListSortDescriptor  p_2 = p->mSortDescriptorList ;
          result._internalAppendValues (p_0, p_1, p_2) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_sortedListDeclaration::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS__list_attributeInCollection & argument_1,
                     const GGS__list_sortedListSortDescriptor & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

void GGS__list_sortedListDeclaration::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mSortedListTypeName,
                                _p->mAttributeList,
                                _p->mSortDescriptorList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS__list_sortedListDeclaration  GGS__list_sortedListDeclaration::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_sortedListDeclaration result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_sortedListDeclaration  GGS__list_sortedListDeclaration::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS__list_attributeInCollection & argument_1,
                           const GGS__list_sortedListSortDescriptor & argument_2
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_sortedListDeclaration result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_sortedListDeclaration::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_sortedListDeclaration", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS__list_sortedListDeclaration::
_addModel (const GGS_sortedListDeclaration & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_sortedListDeclaration::
method_first (C_Compiler & _inLexique,
              GGS_sortedListDeclaration & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_sortedListDeclaration::constructor_new (_inLexique,
       _p->mSortedListTypeName,
       _p->mAttributeList,
       _p->mSortDescriptorList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_sortedListDeclaration::
method_last (C_Compiler & _inLexique,
             GGS_sortedListDeclaration & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_sortedListDeclaration::constructor_new (_inLexique,
       _p->mSortedListTypeName,
       _p->mAttributeList,
       _p->mSortDescriptorList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_sortedListDeclaration::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_sortedListDeclaration & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_sortedListDeclaration::constructor_new (_inLexique,
       _p->mSortedListTypeName,
       _p->mAttributeList,
       _p->mSortDescriptorList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_sortedListDeclaration::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_sortedListDeclaration & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_sortedListDeclaration::constructor_new (_inLexique,
       _p->mSortedListTypeName,
       _p->mAttributeList,
       _p->mSortDescriptorList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS entity '@sortedListDeclaration'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_sortedListDeclaration GGS_sortedListDeclaration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS__list_attributeInCollection & argument_1,
                 const GGS__list_sortedListSortDescriptor & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_sortedListDeclaration result ;
  macroMyNew (result.mPointer, cPtr_sortedListDeclaration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_sortedListDeclaration::
reader_mSortedListTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sortedListDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sortedListDeclaration *) mPointer)->mSortedListTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_attributeInCollection  GGS_sortedListDeclaration::
reader_mAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_attributeInCollection   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sortedListDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sortedListDeclaration *) mPointer)->mAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_sortedListSortDescriptor  GGS_sortedListDeclaration::
reader_mSortDescriptorList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_sortedListSortDescriptor   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sortedListDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sortedListDeclaration *) mPointer)->mSortDescriptorList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_sortedListDeclaration::actualTypeName (void) const {
 return "sortedListDeclaration" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_sortedListDeclaration * GGS_sortedListDeclaration::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_sortedListDeclaration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                    Element of list '@enumDeclaration'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_enumDeclaration::
cPtr_enumDeclaration (const GGS_lstring & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS__list_enumMessage & argument_2
                                COMMA_LOCATION_ARGS) :
cPtr_semanticDeclaration (THERE),
mEnumTypeName (argument_0),
mConstantList (argument_1),
mEnumMessageList (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_enumDeclaration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_enumDeclaration * _p = dynamic_cast <const cPtr_enumDeclaration *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mEnumTypeName._operator_isEqual (_p->mEnumTypeName).boolValue ()
         && mConstantList._operator_isEqual (_p->mConstantList).boolValue ()
         && mEnumMessageList._operator_isEqual (_p->mEnumMessageList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_enumDeclaration::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @enumDeclaration" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEnumTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mConstantList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEnumMessageList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_enumDeclaration::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticDeclaration::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_enumDeclaration::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticDeclaration::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_enumDeclaration::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 13 ;
  if (inLevel > 0) {
    result = cPtr_semanticDeclaration::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_enumDeclaration::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "enumDeclaration" ;
  if (inLevel > 0) {
    result = cPtr_semanticDeclaration::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_enumDeclaration * cPtr_enumDeclaration::
_cloneObject (void) const {
  cPtr_enumDeclaration * _p = NULL ;
  macroMyNew (_p, cPtr_enumDeclaration (mEnumTypeName, mConstantList, mEnumMessageList COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@_list_enumDeclaration'                        *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS__list_enumDeclaration::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstringlist & argument_1,
                    const GGS__list_enumMessage & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_enumDeclaration::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstringlist & argument_1,
                    const GGS__list_enumMessage & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_enumDeclaration::
_addAssign_operation (const GGS_enumDeclaration & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_enumDeclaration *) inElement.getPtr ())->mEnumTypeName,
                                ((cPtr_enumDeclaration *) inElement.getPtr ())->mConstantList,
                                ((cPtr_enumDeclaration *) inElement.getPtr ())->mEnumMessageList) ;
  }
}

//---------------------------------------------------------------------------*

GGS__list_enumDeclaration GGS__list_enumDeclaration::
_operator_concat (const GGS__list_enumDeclaration & inOperand) const {
  GGS__list_enumDeclaration result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_enumDeclaration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mEnumTypeName ;
          GGS_lstringlist  p_1 = p->mConstantList ;
          GGS__list_enumMessage  p_2 = p->mEnumMessageList ;
          result._internalAppendValues (p_0, p_1, p_2) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_enumDeclaration::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstringlist & argument_1,
                     const GGS__list_enumMessage & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

void GGS__list_enumDeclaration::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mEnumTypeName,
                                _p->mConstantList,
                                _p->mEnumMessageList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS__list_enumDeclaration  GGS__list_enumDeclaration::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_enumDeclaration result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_enumDeclaration  GGS__list_enumDeclaration::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_lstringlist & argument_1,
                           const GGS__list_enumMessage & argument_2
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_enumDeclaration result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_enumDeclaration::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_enumDeclaration", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS__list_enumDeclaration::
_addModel (const GGS_enumDeclaration & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_enumDeclaration::
method_first (C_Compiler & _inLexique,
              GGS_enumDeclaration & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_enumDeclaration::constructor_new (_inLexique,
       _p->mEnumTypeName,
       _p->mConstantList,
       _p->mEnumMessageList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_enumDeclaration::
method_last (C_Compiler & _inLexique,
             GGS_enumDeclaration & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_enumDeclaration::constructor_new (_inLexique,
       _p->mEnumTypeName,
       _p->mConstantList,
       _p->mEnumMessageList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_enumDeclaration::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_enumDeclaration & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_enumDeclaration::constructor_new (_inLexique,
       _p->mEnumTypeName,
       _p->mConstantList,
       _p->mEnumMessageList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_enumDeclaration::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_enumDeclaration & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_enumDeclaration::constructor_new (_inLexique,
       _p->mEnumTypeName,
       _p->mConstantList,
       _p->mEnumMessageList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS entity '@enumDeclaration'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_enumDeclaration GGS_enumDeclaration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstringlist & argument_1,
                 const GGS__list_enumMessage & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_enumDeclaration result ;
  macroMyNew (result.mPointer, cPtr_enumDeclaration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_enumDeclaration::
reader_mEnumTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumDeclaration *) mPointer)->mEnumTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_enumDeclaration::
reader_mConstantList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumDeclaration *) mPointer)->mConstantList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_enumMessage  GGS_enumDeclaration::
reader_mEnumMessageList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_enumMessage   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumDeclaration *) mPointer)->mEnumMessageList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_enumDeclaration::actualTypeName (void) const {
 return "enumDeclaration" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_enumDeclaration * GGS_enumDeclaration::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_enumDeclaration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                      Element of list '@enumMessage'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_enumMessage::
cPtr_enumMessage (const GGS_lstring & argument_0,
                                const GGS__list_enumMessageAssociation & argument_1
                                COMMA_LOCATION_ARGS) :
EX_C_GGS_MetamodelEntity (THERE),
mEnumMessageName (argument_0),
mMessageAssociationList (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_enumMessage::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_enumMessage * _p = dynamic_cast <const cPtr_enumMessage *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mEnumMessageName._operator_isEqual (_p->mEnumMessageName).boolValue ()
         && mMessageAssociationList._operator_isEqual (_p->mMessageAssociationList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_enumMessage::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @enumMessage" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEnumMessageName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMessageAssociationList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_enumMessage::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_enumMessage::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_enumMessage::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 14 ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_enumMessage::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "enumMessage" ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_enumMessage * cPtr_enumMessage::
_cloneObject (void) const {
  cPtr_enumMessage * _p = NULL ;
  macroMyNew (_p, cPtr_enumMessage (mEnumMessageName, mMessageAssociationList COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        List '@_list_enumMessage'                          *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS__list_enumMessage::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS__list_enumMessageAssociation & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_enumMessage::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS__list_enumMessageAssociation & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_enumMessage::
_addAssign_operation (const GGS_enumMessage & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_enumMessage *) inElement.getPtr ())->mEnumMessageName,
                                ((cPtr_enumMessage *) inElement.getPtr ())->mMessageAssociationList) ;
  }
}

//---------------------------------------------------------------------------*

GGS__list_enumMessage GGS__list_enumMessage::
_operator_concat (const GGS__list_enumMessage & inOperand) const {
  GGS__list_enumMessage result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_enumMessage * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mEnumMessageName ;
          GGS__list_enumMessageAssociation  p_1 = p->mMessageAssociationList ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_enumMessage::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS__list_enumMessageAssociation & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS__list_enumMessage::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mEnumMessageName,
                                _p->mMessageAssociationList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS__list_enumMessage  GGS__list_enumMessage::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_enumMessage result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_enumMessage  GGS__list_enumMessage::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS__list_enumMessageAssociation & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_enumMessage result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_enumMessage::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_enumMessage", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS__list_enumMessage::
_addModel (const GGS_enumMessage & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_enumMessage::
method_first (C_Compiler & _inLexique,
              GGS_enumMessage & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_enumMessage::constructor_new (_inLexique,
       _p->mEnumMessageName,
       _p->mMessageAssociationList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_enumMessage::
method_last (C_Compiler & _inLexique,
             GGS_enumMessage & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_enumMessage::constructor_new (_inLexique,
       _p->mEnumMessageName,
       _p->mMessageAssociationList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_enumMessage::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_enumMessage & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_enumMessage::constructor_new (_inLexique,
       _p->mEnumMessageName,
       _p->mMessageAssociationList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_enumMessage::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_enumMessage & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_enumMessage::constructor_new (_inLexique,
       _p->mEnumMessageName,
       _p->mMessageAssociationList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS entity '@enumMessage'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_enumMessage GGS_enumMessage::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS__list_enumMessageAssociation & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_enumMessage result ;
  macroMyNew (result.mPointer, cPtr_enumMessage (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_enumMessage::
reader_mEnumMessageName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumMessage *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumMessage *) mPointer)->mEnumMessageName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_enumMessageAssociation  GGS_enumMessage::
reader_mMessageAssociationList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_enumMessageAssociation   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumMessage *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumMessage *) mPointer)->mMessageAssociationList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_enumMessage::actualTypeName (void) const {
 return "enumMessage" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_enumMessage * GGS_enumMessage::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_enumMessage *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@enumMessageAssociation'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_enumMessageAssociation::
cPtr_enumMessageAssociation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
EX_C_GGS_MetamodelEntity (THERE),
mConstantName (argument_0),
mMessage (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_enumMessageAssociation::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_enumMessageAssociation * _p = dynamic_cast <const cPtr_enumMessageAssociation *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mConstantName._operator_isEqual (_p->mConstantName).boolValue ()
         && mMessage._operator_isEqual (_p->mMessage).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_enumMessageAssociation::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @enumMessageAssociation" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mConstantName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMessage.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_enumMessageAssociation::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_enumMessageAssociation::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_enumMessageAssociation::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 15 ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_enumMessageAssociation::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "enumMessageAssociation" ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_enumMessageAssociation * cPtr_enumMessageAssociation::
_cloneObject (void) const {
  cPtr_enumMessageAssociation * _p = NULL ;
  macroMyNew (_p, cPtr_enumMessageAssociation (mConstantName, mMessage COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@_list_enumMessageAssociation'                    *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS__list_enumMessageAssociation::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_enumMessageAssociation::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_enumMessageAssociation::
_addAssign_operation (const GGS_enumMessageAssociation & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_enumMessageAssociation *) inElement.getPtr ())->mConstantName,
                                ((cPtr_enumMessageAssociation *) inElement.getPtr ())->mMessage) ;
  }
}

//---------------------------------------------------------------------------*

GGS__list_enumMessageAssociation GGS__list_enumMessageAssociation::
_operator_concat (const GGS__list_enumMessageAssociation & inOperand) const {
  GGS__list_enumMessageAssociation result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_enumMessageAssociation * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mConstantName ;
          GGS_lstring  p_1 = p->mMessage ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_enumMessageAssociation::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS__list_enumMessageAssociation::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mConstantName,
                                _p->mMessage) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS__list_enumMessageAssociation  GGS__list_enumMessageAssociation::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_enumMessageAssociation result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_enumMessageAssociation  GGS__list_enumMessageAssociation::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_lstring & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_enumMessageAssociation result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_enumMessageAssociation::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_enumMessageAssociation", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS__list_enumMessageAssociation::
_addModel (const GGS_enumMessageAssociation & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_enumMessageAssociation::
method_first (C_Compiler & _inLexique,
              GGS_enumMessageAssociation & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_enumMessageAssociation::constructor_new (_inLexique,
       _p->mConstantName,
       _p->mMessage) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_enumMessageAssociation::
method_last (C_Compiler & _inLexique,
             GGS_enumMessageAssociation & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_enumMessageAssociation::constructor_new (_inLexique,
       _p->mConstantName,
       _p->mMessage) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_enumMessageAssociation::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_enumMessageAssociation & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_enumMessageAssociation::constructor_new (_inLexique,
       _p->mConstantName,
       _p->mMessage) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_enumMessageAssociation::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_enumMessageAssociation & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_enumMessageAssociation::constructor_new (_inLexique,
       _p->mConstantName,
       _p->mMessage) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS entity '@enumMessageAssociation'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_enumMessageAssociation GGS_enumMessageAssociation::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_enumMessageAssociation result ;
  macroMyNew (result.mPointer, cPtr_enumMessageAssociation (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_enumMessageAssociation::
reader_mConstantName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumMessageAssociation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumMessageAssociation *) mPointer)->mConstantName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_enumMessageAssociation::
reader_mMessage (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumMessageAssociation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumMessageAssociation *) mPointer)->mMessage ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_enumMessageAssociation::actualTypeName (void) const {
 return "enumMessageAssociation" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_enumMessageAssociation * GGS_enumMessageAssociation::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_enumMessageAssociation *) mPointer ;
  }
#endif

