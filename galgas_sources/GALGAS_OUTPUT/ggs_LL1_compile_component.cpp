//---------------------------------------------------------------------------*
//                                                                           *
//                   File 'ggs_LL1_compile_component.cpp'                    *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                     october 29th, 2010, at 22h17'53"                      *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if CURRENT_LIBPM_VERSION != VERSION_OF_LIBPM_USED_BY_GALGAS_COMPILER
  #error "This file has been compiled with a version of GALGAS that uses libpm version VERSION_OF_LIBPM_USED_BY_GALGAS_COMPILER, different than the current version (CURRENT_LIBPM_VERSION) of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "galgas2/C_galgas_CLI_Options.h"
#include "ggs_LL1_compile_component.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "ggs_LL1_compile_component.gSyntax", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//             Include directives generated by grammar includes              *
//                                                                           *
//---------------------------------------------------------------------------*

#include "galgas_LL1_grammar.h"

//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_EXtargetFileListMap ("EXtargetFileListMap", false, NULL) ;

//---------------------------------------------------------------------------*

GGS_EXtargetFileListMap::cElement::cElement (LOCATION_ARGS) :
cPtrListMapObject (THERE),
mListObject (GGS_stringlist::constructor_emptyList ()) {
}

//---------------------------------------------------------------------------*

cPtrObject * GGS_EXtargetFileListMap::cElement::cloneObject (LOCATION_ARGS) {
  cElement * result = NULL ;
  macroMyNew (result, cElement (THERE)) ;
  result->mListObject = mListObject ;
  return result ;
}

//---------------------------------------------------------------------------*

bool GGS_EXtargetFileListMap::cElement::isEqual (const cPtrListMapObject * inOperand) const {
  const GGS_bool equal = mListObject.operator_isEqual (((cElement *) inOperand)->mListObject) ;
  return equal.boolValue () ;
}

//---------------------------------------------------------------------------*

C_String GGS_EXtargetFileListMap::cElement::
performDescription (const PMSInt32 inIndentation) const {
  const GGS_string s = mListObject.reader_description (inIndentation) ;
  return s.string () ;
}

//---------------------------------------------------------------------------*

GGS_EXtargetFileListMap GGS_EXtargetFileListMap::
constructor_emptyMap (void) {
  GGS_EXtargetFileListMap result ;
  result.alloc (HERE) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_EXtargetFileListMap::
_typeNameForDescriptionReader (void) const {
  return "@EXtargetFileListMap" ;
}

//---------------------------------------------------------------------------*

GGS_EXtargetFileListMap GGS_EXtargetFileListMap::
operator_concat (const GGS_EXtargetFileListMap & inOperand) const {
  GGS_EXtargetFileListMap result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_EXtargetFileListMap::
dotAssign_operation (const GGS_EXtargetFileListMap inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count (HERE) == 0) {
      * this = inOperand ;
    }else if (inOperand.count (HERE) > 0) {
      cPtrDictionary * dictPtr = macroPtr (inOperand, cPtrDictionary)  ;
      cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
      const PMSInt32 objectCount = dictPtr->count () ;
      for (PMSInt32 i=0 ; i<objectCount ; i++) {
        const GGS_string key = nodeSortedArray [i].key () ;
        const PM_C_Object object = nodeSortedArray [i].mObject ;
        cElement * elementPtr = macroPtr (object, cElement) ;
        bool wasInserted = false ;
        cPtrDictionaryNode * nodePtr = findOrAddNodeForKey (key, wasInserted) ;
        if (wasInserted) {
           cElement * p = NULL ;
           macroMyNew (p, cElement (HERE)) ;
           nodePtr->mObject.setPointer (p) ;
        }
        GGS_stringlist & listPtr = macroPtr (nodePtr->mObject, cElement)->mListObject ;
        listPtr.dotAssign_operation (elementPtr->mListObject) ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_EXtargetFileListMap::
addAssign_operation (const GGS_string & inKey,
                      const GGS_string& inAttribute0) {
  if (isBuilt () && inKey.isBuilt () && inAttribute0.isBuilt ()) {
    bool wasInserted = false ;
    cPtrDictionaryNode * nodePtr = findOrAddNodeForKey (inKey, wasInserted) ;
    MF_Assert (nodePtr != NULL, "NULL pointer (was inserted %d)", wasInserted, 0) ;
    if (wasInserted) {
       cElement * p = NULL ;
       macroMyNew (p, cElement (HERE)) ;
       nodePtr->mObject.setPointer (p) ;
    }
    GGS_stringlist & listPtr = macroPtr (nodePtr->mObject, cElement)->mListObject ;
    listPtr.addAssign_operation (inAttribute0) ;
  }
}

//---------------------------------------------------------------------------*

GGS_stringlist GGS_EXtargetFileListMap::
reader_listForKey (C_CompilerEx & /* inLexique */,
                   const GGS_string & inKey
                   COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_stringlist result ;
  if (isBuilt () && inKey.isBuilt ()) {
    cPtrDictionaryNode * nodePtr = dictionaryNodeForKey (inKey.string ()) ; 
    if (nodePtr == NULL) {
      result = GGS_stringlist::constructor_emptyList () ;
    }else{
      result = macroPtr (nodePtr->mObject, cElement)->mListObject ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringset GGS_EXtargetFileListMap::
reader_allKeys (C_CompilerEx & /* inLexique */
                COMMA_UNUSED_LOCATION_ARGS) const {

  GGS_stringset result ;
  result.setPointer (_pointer ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringlist GGS_EXtargetFileListMap::
reader_keyList (C_CompilerEx & /* inLexique */
                COMMA_UNUSED_LOCATION_ARGS) const {

  GGS_stringlist result ;
  if (isBuilt ()) {
    result = GGS_stringlist::constructor_emptyList () ;
    cPtrDictionary * dictPtr = macroPtr (*this, cPtrDictionary)  ;
    cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
    const PMSInt32 objectCount = dictPtr->count () ;
    for (PMSInt32 i=0 ; i<objectCount ; i++) {
      const GGS_string key = nodeSortedArray [i].key () ;
      result.addAssign_operation (key) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_EXtargetFileListMap::cEnumerator::
cEnumerator (const GGS_EXtargetFileListMap & inListMap,
             const bool inAscending) :
cAbstractDictionaryEnumerator (inListMap, inAscending) {
}

//---------------------------------------------------------------------------*

const GGS_stringlist & GGS_EXtargetFileListMap::cEnumerator::
_mList (LOCATION_ARGS) const {
  cPtrDictionary * dictPtr = macroPtr (mEnumeratedDictionary, cPtrDictionary)  ;
  MF_AssertThere (currentIndex () >= 0, "Access with negative index %d", currentIndex (), 0) ;
  MF_AssertThere (currentIndex () < dictPtr->count (), "Access with index %d >= count %d", currentIndex (), dictPtr->count ()) ;
  cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
  PM_C_Object listObject = nodeSortedArray [currentIndex ()].mObject ;
  cElement * objectPtr = macroPtr (listObject, cElement) ;
  return objectPtr->mListObject ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_EXtargetFileListMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_EXtargetFileListMap * p = NULL ;
    macroMyNew (p, GGS_EXtargetFileListMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_EXtargetFileListMap GGS_EXtargetFileListMap::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_EXtargetFileListMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_EXtargetFileListMap * p = dynamic_cast <const GGS_EXtargetFileListMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_EXtargetFileListMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_EXtargetFileListMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_EXtargetFileListMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 Class for 'EXsourceFileKind' Enumeration                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_EXsourceFileKind ("EXsourceFileKind", false, NULL) ;

//---------------------------------------------------------------------------*

bool GGS_EXsourceFileKind::
isBuilt (void) const {
  return mValue > kNotBuilt ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_EXsourceFileKind::
operator_isEqual (const GGS_EXsourceFileKind inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_EXsourceFileKind::
operator_isNotEqual (const GGS_EXsourceFileKind inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_EXsourceFileKind::
operator_infOrEqual (const GGS_EXsourceFileKind inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_EXsourceFileKind::
operator_supOrEqual (const GGS_EXsourceFileKind inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_EXsourceFileKind::
operator_strictInf (const GGS_EXsourceFileKind inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_EXsourceFileKind::
operator_strictSup (const GGS_EXsourceFileKind inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_EXsourceFileKind::
reader_description (const PMSInt32 /* inIndentation */) const {
  C_String s ;
  s << "<enum @EXsourceFileKind" ;
  switch (mValue) {
  case enum_externSourceFile:
    s << " externSourceFile>" ;
    break ;
  case enum_grammarSourceFile:
    s << " grammarSourceFile>" ;
    break ;
  case enum_guiSourceFile:
    s << " guiSourceFile>" ;
    break ;
  case enum_lexiqueSourceFile:
    s << " lexiqueSourceFile>" ;
    break ;
  case enum_optionSourceFile:
    s << " optionSourceFile>" ;
    break ;
  case enum_programSourceFile:
    s << " programSourceFile>" ;
    break ;
  case enum_semanticsSourceFile:
    s << " semanticsSourceFile>" ;
    break ;
  case enum_syntaxSourceFile:
    s << " syntaxSourceFile>" ;
    break ;
  case kNotBuilt:
    s << " (not built)>" ;
    break ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_EXsourceFileKind::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_EXsourceFileKind * p = NULL ;
    macroMyNew (p, GGS_EXsourceFileKind (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_EXsourceFileKind GGS_EXsourceFileKind::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_EXsourceFileKind result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_EXsourceFileKind * p = dynamic_cast <const GGS_EXsourceFileKind *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_EXsourceFileKind, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_EXsourceFileKind::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_EXsourceFileKind ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'e_EXsourceFileMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

e_EXsourceFileMap::e_EXsourceFileMap (void) :
mFullPath (),
mSourceKind () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map '@EXsourceFileMap'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_EXsourceFileMap ("EXsourceFileMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_EXsourceFileMap::
elementOf_GGS_EXsourceFileMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_EXsourceFileMap & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_EXsourceFileMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mFullPath.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mSourceKind.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_EXsourceFileMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_EXsourceFileMap * ptr = dynamic_cast <const elementOf_GGS_EXsourceFileMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mFullPath.operator_isEqual (ptr->mInfo.mFullPath)).boolValue ()
           && (mInfo.mSourceKind.operator_isEqual (ptr->mInfo.mSourceKind)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_EXsourceFileMap::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_EXsourceFileMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_EXsourceFileMap * info = (e_EXsourceFileMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_EXsourceFileMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_EXsourceFileMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_EXsourceFileMap * info = (e_EXsourceFileMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_EXsourceFileMap GGS_EXsourceFileMap::
constructor_emptyMap (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_EXsourceFileMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_EXsourceFileMap::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_EXsourceFileMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

void GGS_EXsourceFileMap::modifier_insertFakeKey (C_CompilerEx & inCompiler,
                         const GGS_string & inKey,
                         const GGS_location & inHelperMessageErrorLocation,
                         const GGS_string & inHelperMessage
                         COMMA_LOCATION_ARGS) {
  e_EXsourceFileMap info  ;
  internal_insertFakeKey (inCompiler,
                          (void *) & info,
                          inKey,
                          inHelperMessageErrorLocation,
                          inHelperMessage
                          COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_EXsourceFileMap::
operator_isEqual (const GGS_EXsourceFileMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_EXsourceFileMap::
operator_isNotEqual (const GGS_EXsourceFileMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_EXsourceFileMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_EXsourceFileMap::
insertElement (C_CompilerEx & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_string& inParameter0,
               const GGS_EXsourceFileKind& inParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap (THERE) ;
    e_EXsourceFileMap info  ;
    info.mFullPath = inParameter0 ;
    info.mSourceKind = inParameter1 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_EXsourceFileMap::
searchElement (C_CompilerEx & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_string  & outParameter0,
               GGS_EXsourceFileKind  & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inLexique, inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    outParameter0 = node->mInfo.mFullPath ;
    outParameter1 = node->mInfo.mSourceKind ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_EXsourceFileMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('s'),
  TO_UNICODE ('o'),
  TO_UNICODE ('u'),
  TO_UNICODE ('r'),
  TO_UNICODE ('c'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('a'),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_EXsourceFileMap::
method_searchKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                GGS_string  & outParameter0,
                                GGS_EXsourceFileKind  & outParameter1 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 0,
                 kSearchMessage_searchKey,
                 inKey,
                 outParameter0,
                 outParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_EXsourceFileMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('s'),
  TO_UNICODE ('o'),
  TO_UNICODE ('u'),
  TO_UNICODE ('r'),
  TO_UNICODE ('c'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('a'),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_EXsourceFileMap::
modifier_insertKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_string& inParameter0,
                                const GGS_EXsourceFileKind& inParameter1 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                NULL
                COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_EXsourceFileMap GGS_EXsourceFileMap::
constructor_mapWithMapToOverride (C_CompilerEx & /* inLexique */,
                                  const GGS_EXsourceFileMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_EXsourceFileMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_EXsourceFileMap GGS_EXsourceFileMap::
reader_overriddenMap (C_CompilerEx & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_EXsourceFileMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_EXsourceFileMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @EXsourceFileMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_EXsourceFileMap::cEnumerator::_mFullPath (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mFullPath ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_EXsourceFileKind & GGS_EXsourceFileMap::cEnumerator::_mSourceKind (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mSourceKind ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_EXsourceFileMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_EXsourceFileMap * p = NULL ;
    macroMyNew (p, GGS_EXsourceFileMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_EXsourceFileMap GGS_EXsourceFileMap::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_EXsourceFileMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_EXsourceFileMap * p = dynamic_cast <const GGS_EXsourceFileMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_EXsourceFileMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_EXsourceFileMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_EXsourceFileMap ;
}

//---------------------------------------------------------------------------*

GGS_EXsourceFileMap GGS_EXsourceFileMap::constructor_mapWithKeyAndValue (C_CompilerEx & inLexique,
                                             const GGS_lstring & inKey,
                                             const GGS_string& inValue0,
                                             const GGS_EXsourceFileKind& inValue1
                                             COMMA_LOCATION_ARGS) {
  GGS_EXsourceFileMap result = constructor_emptyMap (inLexique COMMA_THERE) ;
  result.insertElement (inLexique,
                        0,
                        NULL,
                        inKey,
                        inValue0,
                        inValue1,
                        NULL
                        COMMA_THERE) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//     Implementation of production rule 'parse_lexique_for_importing'       *
//                                                                           *
//---------------------------------------------------------------------------*

void ggs_LL1_compile_component::rule_ggs_5F_LL_31__5F_compile_5F_component_parse_5F_lexique_5F_for_5F_importing_i0_ (C_Lexique_galgas_5F_scanner & inLexique,
                                const GGS_lstring  var_cas_inFileName,
                                GGS_M_lexiqueComponents  &var_cas_ioLexiqueMapForUse) {
  const GGS_string _depExtension = GGS_string ("") ;
  const GGS_string _depPath = GGS_string ("") ;
  if (_depExtension.isBuilt () && _depPath.isBuilt ()) {
    C_Grammar_galgas_5F_LL_31__5F_grammar::_performSourceFileParsing_importLexique (inLexique,
                                  _depExtension.string (),
                                  _depPath.string (),
                                  NULL,
                                  var_cas_inFileName,
                                  var_cas_ioLexiqueMapForUse
                                  COMMA_SOURCE_FILE_AT_LINE (612)) ;
  }
}

//---------------------------------------------------------------------------*

void ggs_LL1_compile_component::rule_ggs_5F_LL_31__5F_compile_5F_component_parse_5F_lexique_5F_for_5F_importing_i0_parse (C_Lexique_galgas_5F_scanner & inLexique) {
  GGS_lstring::constructor_retrieveAndResetTemplateString (inLexique COMMA_HERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Implementation of production rule 'parse_syntax_for_importing'       *
//                                                                           *
//---------------------------------------------------------------------------*

void ggs_LL1_compile_component::rule_ggs_5F_LL_31__5F_compile_5F_component_parse_5F_syntax_5F_for_5F_importing_i1_ (C_Lexique_galgas_5F_scanner & inLexique,
                                const GGS_lstring  var_cas_inFileName,
                                GGS_M_syntaxComponents  &var_cas_ioSyntaxComponentsMap,
                                GGS_EXsemanticContext &var_cas_ioSemanticContext) {
  const GGS_string _depExtension = GGS_string ("") ;
  const GGS_string _depPath = GGS_string ("") ;
  if (_depExtension.isBuilt () && _depPath.isBuilt ()) {
    C_Grammar_galgas_5F_LL_31__5F_grammar::_performSourceFileParsing_importSyntax (inLexique,
                                  _depExtension.string (),
                                  _depPath.string (),
                                  NULL,
                                  var_cas_inFileName,
                                  var_cas_ioSyntaxComponentsMap,
                                  var_cas_ioSemanticContext
                                  COMMA_SOURCE_FILE_AT_LINE (628)) ;
  }
}

//---------------------------------------------------------------------------*

void ggs_LL1_compile_component::rule_ggs_5F_LL_31__5F_compile_5F_component_parse_5F_syntax_5F_for_5F_importing_i1_parse (C_Lexique_galgas_5F_scanner & inLexique) {
  GGS_lstring::constructor_retrieveAndResetTemplateString (inLexique COMMA_HERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//Implementation of production rule 'parse_grammar_component_for_importing'  *
//                                                                           *
//---------------------------------------------------------------------------*

void ggs_LL1_compile_component::rule_ggs_5F_LL_31__5F_compile_5F_component_parse_5F_grammar_5F_component_5F_for_5F_importing_i2_ (C_Lexique_galgas_5F_scanner & inLexique,
                                const GGS_lstring  var_cas_inFileName,
                                GGS_M_grammarComponents  &var_cas_ioGrammarComponentsMap,
                                GGS_M_optionComponents  &var_cas_ioOptionsComponentsMapForUse,
                                GGS_EXsemanticContext &var_cas_ioSemanticContext) {
  const GGS_string _depExtension = GGS_string ("") ;
  const GGS_string _depPath = GGS_string ("") ;
  if (_depExtension.isBuilt () && _depPath.isBuilt ()) {
    C_Grammar_galgas_5F_LL_31__5F_grammar::_performSourceFileParsing_importGrammarForSemantics (inLexique,
                                  _depExtension.string (),
                                  _depPath.string (),
                                  NULL,
                                  var_cas_inFileName,
                                  var_cas_ioGrammarComponentsMap,
                                  var_cas_ioOptionsComponentsMapForUse,
                                  var_cas_ioSemanticContext
                                  COMMA_SOURCE_FILE_AT_LINE (646)) ;
  }
}

//---------------------------------------------------------------------------*

void ggs_LL1_compile_component::rule_ggs_5F_LL_31__5F_compile_5F_component_parse_5F_grammar_5F_component_5F_for_5F_importing_i2_parse (C_Lexique_galgas_5F_scanner & inLexique) {
  GGS_lstring::constructor_retrieveAndResetTemplateString (inLexique COMMA_HERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
// Implementation of production rule 'parse_option_component_for_importing'  *
//                                                                           *
//---------------------------------------------------------------------------*

void ggs_LL1_compile_component::rule_ggs_5F_LL_31__5F_compile_5F_component_parse_5F_option_5F_component_5F_for_5F_importing_i3_ (C_Lexique_galgas_5F_scanner & inLexique,
                                const GGS_lstring  var_cas_inFileName,
                                GGS_M_optionComponents  &var_cas_ioOptionsComponentsMap) {
  const GGS_string _depExtension = GGS_string ("") ;
  const GGS_string _depPath = GGS_string ("") ;
  if (_depExtension.isBuilt () && _depPath.isBuilt ()) {
    C_Grammar_galgas_5F_LL_31__5F_grammar::_performSourceFileParsing_importOptions (inLexique,
                                  _depExtension.string (),
                                  _depPath.string (),
                                  NULL,
                                  var_cas_inFileName,
                                  var_cas_ioOptionsComponentsMap
                                  COMMA_SOURCE_FILE_AT_LINE (663)) ;
  }
}

//---------------------------------------------------------------------------*

void ggs_LL1_compile_component::rule_ggs_5F_LL_31__5F_compile_5F_component_parse_5F_option_5F_component_5F_for_5F_importing_i3_parse (C_Lexique_galgas_5F_scanner & inLexique) {
  GGS_lstring::constructor_retrieveAndResetTemplateString (inLexique COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

