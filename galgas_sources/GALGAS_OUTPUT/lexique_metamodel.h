//---------------------------------------------------------------------------*
//                                                                           *
//                        File 'lexique_metamodel.h'                         *
//         Generated by version GALGAS_BETA_VERSION (LL(1) grammar)          *
//                      march 31th, 2007, at 20h42'47"                       *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

#ifndef lexique_metamodel_METAMODEL_DEFINED
#define lexique_metamodel_METAMODEL_DEFINED

#include <string.h>

//---------------------------------------------------------------------------*

#include "galgas/predefined_types.h"

//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*

uint32 _metamodel_index_for_lexique_metamodel (void) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                          Class Predeclarations                            *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexiqueComponentRootList ;
class GGS_lexiqueComponentRoot ;
class cPtr_lexiqueComponentRoot ;
class GGS_lexicalImplicitRuleList ;
class GGS_lexicalImplicitRule ;
class cPtr_lexicalImplicitRule ;
class GGS_lexicalErrorMessageDeclarationList ;
class GGS_lexicalErrorMessageDeclaration ;
class cPtr_lexicalErrorMessageDeclaration ;
class GGS_lexicalAttributeList ;
class GGS_lexicalAttribute ;
class cPtr_lexicalAttribute ;
class GGS_lexicalStyleList ;
class GGS_lexicalStyle ;
class cPtr_lexicalStyle ;
class GGS_terminalDeclarationList ;
class GGS_terminalDeclaration ;
class cPtr_terminalDeclaration ;
class GGS_lexicalListDeclarationList ;
class GGS_lexicalListDeclaration ;
class cPtr_lexicalListDeclaration ;
class GGS_lexicalListEntryList ;
class GGS_lexicalListEntry ;
class cPtr_lexicalListEntry ;
class GGS_lexicalExplicitRuleList ;
class GGS_lexicalExplicitRule ;
class cPtr_lexicalExplicitRule ;
class GGS_lexicalExpressionList ;
class GGS_lexicalExpression ;
class cPtr_lexicalExpression ;
class GGS_lexicalOrExpressionList ;
class GGS_lexicalOrExpression ;
class cPtr_lexicalOrExpression ;
class GGS_lexicalCharacterMatchList ;
class GGS_lexicalCharacterMatch ;
class cPtr_lexicalCharacterMatch ;
class GGS_lexicalCharacterIntervalMatchList ;
class GGS_lexicalCharacterIntervalMatch ;
class cPtr_lexicalCharacterIntervalMatch ;
class GGS_lexicalStringMatchList ;
class GGS_lexicalStringMatch ;
class cPtr_lexicalStringMatch ;
class GGS_lexicalStringNotMatchList ;
class GGS_lexicalStringNotMatch ;
class cPtr_lexicalStringNotMatch ;
class GGS_lexicalInstructionList ;
class GGS_lexicalInstruction ;
class cPtr_lexicalInstruction ;
class GGS_lexicalStructuredSendInstructionList ;
class GGS_lexicalStructuredSendInstruction ;
class cPtr_lexicalStructuredSendInstruction ;
class GGS_lexicalSimpleSendInstructionList ;
class GGS_lexicalSimpleSendInstruction ;
class cPtr_lexicalSimpleSendInstruction ;
class GGS_lexicalSendDefaultActionList ;
class GGS_lexicalSendDefaultAction ;
class cPtr_lexicalSendDefaultAction ;
class GGS_lexicalSendTerminalByDefaultList ;
class GGS_lexicalSendTerminalByDefault ;
class cPtr_lexicalSendTerminalByDefault ;
class GGS_lexicalErrorByDefaultList ;
class GGS_lexicalErrorByDefault ;
class cPtr_lexicalErrorByDefault ;
class GGS_lexicalSendSearchList ;
class GGS_lexicalSendSearch ;
class cPtr_lexicalSendSearch ;
class GGS_lexicalRepeatInstructionList ;
class GGS_lexicalRepeatInstruction ;
class cPtr_lexicalRepeatInstruction ;
class GGS_lexicalWhileBranchList ;
class GGS_lexicalWhileBranch ;
class cPtr_lexicalWhileBranch ;
class GGS_lexicalSelectInstructionList ;
class GGS_lexicalSelectInstruction ;
class cPtr_lexicalSelectInstruction ;
class GGS_lexicalSelectBranchList ;
class GGS_lexicalSelectBranch ;
class cPtr_lexicalSelectBranch ;
class GGS_lexicalActionInstructionList ;
class GGS_lexicalActionInstruction ;
class cPtr_lexicalActionInstruction ;
class GGS_lexicalActualArgumentList ;
class GGS_lexicalActualArgument ;
class cPtr_lexicalActualArgument ;
class GGS_lexicalAttributeArgumentList ;
class GGS_lexicalAttributeArgument ;
class cPtr_lexicalAttributeArgument ;
class GGS_lexicalCharacterArgumentList ;
class GGS_lexicalCharacterArgument ;
class cPtr_lexicalCharacterArgument ;
class GGS_lexicalCurrentCharacterArgumentList ;
class GGS_lexicalCurrentCharacterArgument ;
class cPtr_lexicalCurrentCharacterArgument ;
class GGS_lexicalFunctionArgumentList ;
class GGS_lexicalFunctionArgument ;
class cPtr_lexicalFunctionArgument ;
class GGS_lexicalDropInstructionList ;
class GGS_lexicalDropInstruction ;
class cPtr_lexicalDropInstruction ;
class GGS_lexicalErrorInstructionList ;
class GGS_lexicalErrorInstruction ;
class cPtr_lexicalErrorInstruction ;
class GGS_lexicalTagInstructionList ;
class GGS_lexicalTagInstruction ;
class cPtr_lexicalTagInstruction ;
class GGS_lexicalRewindInstructionList ;
class GGS_lexicalRewindInstruction ;
class cPtr_lexicalRewindInstruction ;
class GGS_lexicalLogInstructionList ;
class GGS_lexicalLogInstruction ;
class cPtr_lexicalLogInstruction ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_lexiqueComponentRoot'                   *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexiqueComponentRoot {
//--- Pointer to actual instance
  protected : cPtr_lexiqueComponentRoot * mPointer ;
//--- Default constructor
  public : GGS_lexiqueComponentRoot (void) ;
//--- Copy constructor
  public : GGS_lexiqueComponentRoot (const GGS_lexiqueComponentRoot &) ;
//--- Virtual destructor
  public : virtual ~GGS_lexiqueComponentRoot (void) ;
//--- 'new' constructor
  public : static GGS_lexiqueComponentRoot constructor_new (C_Compiler & inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lexicalAttributeList & argument_1,
                                const GGS_lexicalStyleList & argument_2,
                                const GGS_terminalDeclarationList & argument_3,
                                const GGS_lexicalErrorMessageDeclarationList & argument_4,
                                const GGS_lexicalListDeclarationList & argument_5,
                                const GGS_lexicalImplicitRuleList & argument_6,
                                const GGS_lexicalExplicitRuleList & argument_7
                                COMMA_LOCATION_ARGS) ;
//--- Assignment operator
  public : void operator = (const GGS_lexiqueComponentRoot &) ;
//--- Comparison methods
  public : GGS_bool _operator_isEqual (const GGS_lexiqueComponentRoot & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexiqueComponentRoot & inOperand) const ;

//--- _isBuilt
  public : inline bool _isBuilt (void) const { return mPointer != NULL ; }

//--- isEqualTo
  public : inline bool isEqualTo (const GGS_lexiqueComponentRoot & _inOperand) const {
    return mPointer == _inOperand.mPointer ;
  }

//--- getPtr
  public : inline cPtr_lexiqueComponentRoot * getPtr (void) const {
    return mPointer ;
  }

//--- drop
  public : void _drop_operation (void) ;

//--- 'description' reader
  public : GGS_string reader_description (C_Compiler & _inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;

//--- Readers
  public : GGS_lstring  reader_mLexiqueComponentName (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_lexicalAttributeList  reader_mLexicalAttributeList (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_lexicalStyleList  reader_mLexicalStyleList (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_terminalDeclarationList  reader_mTerminalDeclarationList (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_lexicalErrorMessageDeclarationList  reader_mLexicalErrorMessageDeclarationList (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_lexicalListDeclarationList  reader_mLexicalListDeclarationList (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_lexicalImplicitRuleList  reader_mLexicalImplicitRuleList (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_lexicalExplicitRuleList  reader_mLexicalExplicitRuleList (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexiqueComponentRoot * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexiqueComponentRoot * operator () (void) const {
      return mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     list '@lexiqueComponentRootList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexiqueComponentRootList : public AC_galgas_list {
  public : typedef cPtr_lexiqueComponentRoot element_type ;
//--- Default Constructor
  public : GGS_lexiqueComponentRootList (void) ;
//--- Copy Constructor
  public : GGS_lexiqueComponentRootList (const GGS_lexiqueComponentRootList & inSource) ;
//--- Comparison Operators
  public : GGS_bool _operator_isEqual (const GGS_lexiqueComponentRootList & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexiqueComponentRootList & inOperand) const ;
//--- Constructor 'emptyList'
  public : static GGS_lexiqueComponentRootList constructor_emptyList (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_lexiqueComponentRootList constructor_listWithValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lexicalAttributeList & argument_1,
                                const GGS_lexicalStyleList & argument_2,
                                const GGS_terminalDeclarationList & argument_3,
                                const GGS_lexicalErrorMessageDeclarationList & argument_4,
                                const GGS_lexicalListDeclarationList & argument_5,
                                const GGS_lexicalImplicitRuleList & argument_6,
                                const GGS_lexicalExplicitRuleList & argument_7
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operators () used for method call
  public : const GGS_lexiqueComponentRootList * operator () (UNUSED_LOCATION_ARGS) const { return this ;} 
//--- Method 'first'
  public : void method_first (C_Compiler & _inLexique,
                              GGS_lstring & _out_0,
                              GGS_lexicalAttributeList & _out_1,
                              GGS_lexicalStyleList & _out_2,
                              GGS_terminalDeclarationList & _out_3,
                              GGS_lexicalErrorMessageDeclarationList & _out_4,
                              GGS_lexicalListDeclarationList & _out_5,
                              GGS_lexicalImplicitRuleList & _out_6,
                              GGS_lexicalExplicitRuleList & _out_7
                              COMMA_LOCATION_ARGS) const ;
//--- Method 'last'
  public : void method_last (C_Compiler & _inLexique,
                             GGS_lstring & _out_0,
                             GGS_lexicalAttributeList & _out_1,
                             GGS_lexicalStyleList & _out_2,
                             GGS_terminalDeclarationList & _out_3,
                             GGS_lexicalErrorMessageDeclarationList & _out_4,
                             GGS_lexicalListDeclarationList & _out_5,
                             GGS_lexicalImplicitRuleList & _out_6,
                             GGS_lexicalExplicitRuleList & _out_7
                             COMMA_LOCATION_ARGS) const ;
//--- Modifier 'popLast'
  public : void modifier_popLast (C_Compiler & _inLexique,
                                GGS_lstring & _out_0,
                                GGS_lexicalAttributeList & _out_1,
                                GGS_lexicalStyleList & _out_2,
                                GGS_terminalDeclarationList & _out_3,
                                GGS_lexicalErrorMessageDeclarationList & _out_4,
                                GGS_lexicalListDeclarationList & _out_5,
                                GGS_lexicalImplicitRuleList & _out_6,
                                GGS_lexicalExplicitRuleList & _out_7
                                COMMA_LOCATION_ARGS) ;
//--- Modifier 'popFirst'
  public : void modifier_popFirst (C_Compiler & _inLexique,
                                 GGS_lstring & _out_0,
                                 GGS_lexicalAttributeList & _out_1,
                                 GGS_lexicalStyleList & _out_2,
                                 GGS_terminalDeclarationList & _out_3,
                                 GGS_lexicalErrorMessageDeclarationList & _out_4,
                                 GGS_lexicalListDeclarationList & _out_5,
                                 GGS_lexicalImplicitRuleList & _out_6,
                                 GGS_lexicalExplicitRuleList & _out_7
                                 COMMA_LOCATION_ARGS) ;
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lexicalAttributeList & argument_1,
                                const GGS_lexicalStyleList & argument_2,
                                const GGS_terminalDeclarationList & argument_3,
                                const GGS_lexicalErrorMessageDeclarationList & argument_4,
                                const GGS_lexicalListDeclarationList & argument_5,
                                const GGS_lexicalImplicitRuleList & argument_6,
                                const GGS_lexicalExplicitRuleList & argument_7) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexiqueComponentRootList _operator_concat (const GGS_lexiqueComponentRootList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lexicalAttributeList & argument_1,
                                const GGS_lexicalStyleList & argument_2,
                                const GGS_terminalDeclarationList & argument_3,
                                const GGS_lexicalErrorMessageDeclarationList & argument_4,
                                const GGS_lexicalListDeclarationList & argument_5,
                                const GGS_lexicalImplicitRuleList & argument_6,
                                const GGS_lexicalExplicitRuleList & argument_7
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lstring & argument_0,
                                const GGS_lexicalAttributeList & argument_1,
                                const GGS_lexicalStyleList & argument_2,
                                const GGS_terminalDeclarationList & argument_3,
                                const GGS_lexicalErrorMessageDeclarationList & argument_4,
                                const GGS_lexicalListDeclarationList & argument_5,
                                const GGS_lexicalImplicitRuleList & argument_6,
                                const GGS_lexicalExplicitRuleList & argument_7) ;

  protected : void _internalPrependValues (const GGS_lstring & argument_0,
                                const GGS_lexicalAttributeList & argument_1,
                                const GGS_lexicalStyleList & argument_2,
                                const GGS_terminalDeclarationList & argument_3,
                                const GGS_lexicalErrorMessageDeclarationList & argument_4,
                                const GGS_lexicalListDeclarationList & argument_5,
                                const GGS_lexicalImplicitRuleList & argument_6,
                                const GGS_lexicalExplicitRuleList & argument_7) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & _inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--- Metamodel Add method
  public : void _addModel (const GGS_lexiqueComponentRoot & inOperand) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_lexicalImplicitRule'                   *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalImplicitRule {
//--- Pointer to actual instance
  protected : cPtr_lexicalImplicitRule * mPointer ;
//--- Default constructor
  public : GGS_lexicalImplicitRule (void) ;
//--- Copy constructor
  public : GGS_lexicalImplicitRule (const GGS_lexicalImplicitRule &) ;
//--- Virtual destructor
  public : virtual ~GGS_lexicalImplicitRule (void) ;
//--- 'new' constructor
  public : static GGS_lexicalImplicitRule constructor_new (C_Compiler & inLexique,
                                const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- Assignment operator
  public : void operator = (const GGS_lexicalImplicitRule &) ;
//--- Comparison methods
  public : GGS_bool _operator_isEqual (const GGS_lexicalImplicitRule & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalImplicitRule & inOperand) const ;

//--- _isBuilt
  public : inline bool _isBuilt (void) const { return mPointer != NULL ; }

//--- isEqualTo
  public : inline bool isEqualTo (const GGS_lexicalImplicitRule & _inOperand) const {
    return mPointer == _inOperand.mPointer ;
  }

//--- getPtr
  public : inline cPtr_lexicalImplicitRule * getPtr (void) const {
    return mPointer ;
  }

//--- drop
  public : void _drop_operation (void) ;

//--- 'description' reader
  public : GGS_string reader_description (C_Compiler & _inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;

//--- Readers
  public : GGS_lstring  reader_mListName (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalImplicitRule * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalImplicitRule * operator () (void) const {
      return mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     list '@lexicalImplicitRuleList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalImplicitRuleList : public AC_galgas_list {
  public : typedef cPtr_lexicalImplicitRule element_type ;
//--- Default Constructor
  public : GGS_lexicalImplicitRuleList (void) ;
//--- Copy Constructor
  public : GGS_lexicalImplicitRuleList (const GGS_lexicalImplicitRuleList & inSource) ;
//--- Comparison Operators
  public : GGS_bool _operator_isEqual (const GGS_lexicalImplicitRuleList & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalImplicitRuleList & inOperand) const ;
//--- Constructor 'emptyList'
  public : static GGS_lexicalImplicitRuleList constructor_emptyList (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_lexicalImplicitRuleList constructor_listWithValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operators () used for method call
  public : const GGS_lexicalImplicitRuleList * operator () (UNUSED_LOCATION_ARGS) const { return this ;} 
//--- Method 'first'
  public : void method_first (C_Compiler & _inLexique,
                              GGS_lstring & _out_0
                              COMMA_LOCATION_ARGS) const ;
//--- Method 'last'
  public : void method_last (C_Compiler & _inLexique,
                             GGS_lstring & _out_0
                             COMMA_LOCATION_ARGS) const ;
//--- Modifier 'popLast'
  public : void modifier_popLast (C_Compiler & _inLexique,
                                GGS_lstring & _out_0
                                COMMA_LOCATION_ARGS) ;
//--- Modifier 'popFirst'
  public : void modifier_popFirst (C_Compiler & _inLexique,
                                 GGS_lstring & _out_0
                                 COMMA_LOCATION_ARGS) ;
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lstring & argument_0) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalImplicitRuleList _operator_concat (const GGS_lexicalImplicitRuleList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lstring & argument_0) ;

  protected : void _internalPrependValues (const GGS_lstring & argument_0) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & _inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--- Metamodel Add method
  public : void _addModel (const GGS_lexicalImplicitRule & inOperand) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_lexicalErrorMessageDeclaration'              *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalErrorMessageDeclaration {
//--- Pointer to actual instance
  protected : cPtr_lexicalErrorMessageDeclaration * mPointer ;
//--- Default constructor
  public : GGS_lexicalErrorMessageDeclaration (void) ;
//--- Copy constructor
  public : GGS_lexicalErrorMessageDeclaration (const GGS_lexicalErrorMessageDeclaration &) ;
//--- Virtual destructor
  public : virtual ~GGS_lexicalErrorMessageDeclaration (void) ;
//--- 'new' constructor
  public : static GGS_lexicalErrorMessageDeclaration constructor_new (C_Compiler & inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Assignment operator
  public : void operator = (const GGS_lexicalErrorMessageDeclaration &) ;
//--- Comparison methods
  public : GGS_bool _operator_isEqual (const GGS_lexicalErrorMessageDeclaration & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalErrorMessageDeclaration & inOperand) const ;

//--- _isBuilt
  public : inline bool _isBuilt (void) const { return mPointer != NULL ; }

//--- isEqualTo
  public : inline bool isEqualTo (const GGS_lexicalErrorMessageDeclaration & _inOperand) const {
    return mPointer == _inOperand.mPointer ;
  }

//--- getPtr
  public : inline cPtr_lexicalErrorMessageDeclaration * getPtr (void) const {
    return mPointer ;
  }

//--- drop
  public : void _drop_operation (void) ;

//--- 'description' reader
  public : GGS_string reader_description (C_Compiler & _inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;

//--- Readers
  public : GGS_lstring  reader_mMessageName (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_lstring  reader_mMessageValue (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalErrorMessageDeclaration * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalErrorMessageDeclaration * operator () (void) const {
      return mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                list '@lexicalErrorMessageDeclarationList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalErrorMessageDeclarationList : public AC_galgas_list {
  public : typedef cPtr_lexicalErrorMessageDeclaration element_type ;
//--- Default Constructor
  public : GGS_lexicalErrorMessageDeclarationList (void) ;
//--- Copy Constructor
  public : GGS_lexicalErrorMessageDeclarationList (const GGS_lexicalErrorMessageDeclarationList & inSource) ;
//--- Comparison Operators
  public : GGS_bool _operator_isEqual (const GGS_lexicalErrorMessageDeclarationList & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalErrorMessageDeclarationList & inOperand) const ;
//--- Constructor 'emptyList'
  public : static GGS_lexicalErrorMessageDeclarationList constructor_emptyList (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_lexicalErrorMessageDeclarationList constructor_listWithValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operators () used for method call
  public : const GGS_lexicalErrorMessageDeclarationList * operator () (UNUSED_LOCATION_ARGS) const { return this ;} 
//--- Method 'first'
  public : void method_first (C_Compiler & _inLexique,
                              GGS_lstring & _out_0,
                              GGS_lstring & _out_1
                              COMMA_LOCATION_ARGS) const ;
//--- Method 'last'
  public : void method_last (C_Compiler & _inLexique,
                             GGS_lstring & _out_0,
                             GGS_lstring & _out_1
                             COMMA_LOCATION_ARGS) const ;
//--- Modifier 'popLast'
  public : void modifier_popLast (C_Compiler & _inLexique,
                                GGS_lstring & _out_0,
                                GGS_lstring & _out_1
                                COMMA_LOCATION_ARGS) ;
//--- Modifier 'popFirst'
  public : void modifier_popFirst (C_Compiler & _inLexique,
                                 GGS_lstring & _out_0,
                                 GGS_lstring & _out_1
                                 COMMA_LOCATION_ARGS) ;
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalErrorMessageDeclarationList _operator_concat (const GGS_lexicalErrorMessageDeclarationList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) ;

  protected : void _internalPrependValues (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & _inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--- Metamodel Add method
  public : void _addModel (const GGS_lexicalErrorMessageDeclaration & inOperand) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_lexicalAttribute'                     *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalAttribute {
//--- Pointer to actual instance
  protected : cPtr_lexicalAttribute * mPointer ;
//--- Default constructor
  public : GGS_lexicalAttribute (void) ;
//--- Copy constructor
  public : GGS_lexicalAttribute (const GGS_lexicalAttribute &) ;
//--- Virtual destructor
  public : virtual ~GGS_lexicalAttribute (void) ;
//--- 'new' constructor
  public : static GGS_lexicalAttribute constructor_new (C_Compiler & inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Assignment operator
  public : void operator = (const GGS_lexicalAttribute &) ;
//--- Comparison methods
  public : GGS_bool _operator_isEqual (const GGS_lexicalAttribute & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalAttribute & inOperand) const ;

//--- _isBuilt
  public : inline bool _isBuilt (void) const { return mPointer != NULL ; }

//--- isEqualTo
  public : inline bool isEqualTo (const GGS_lexicalAttribute & _inOperand) const {
    return mPointer == _inOperand.mPointer ;
  }

//--- getPtr
  public : inline cPtr_lexicalAttribute * getPtr (void) const {
    return mPointer ;
  }

//--- drop
  public : void _drop_operation (void) ;

//--- 'description' reader
  public : GGS_string reader_description (C_Compiler & _inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;

//--- Readers
  public : GGS_lstring  reader_mTypeName (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_lstring  reader_mName (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalAttribute * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalAttribute * operator () (void) const {
      return mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       list '@lexicalAttributeList'                        *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalAttributeList : public AC_galgas_list {
  public : typedef cPtr_lexicalAttribute element_type ;
//--- Default Constructor
  public : GGS_lexicalAttributeList (void) ;
//--- Copy Constructor
  public : GGS_lexicalAttributeList (const GGS_lexicalAttributeList & inSource) ;
//--- Comparison Operators
  public : GGS_bool _operator_isEqual (const GGS_lexicalAttributeList & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalAttributeList & inOperand) const ;
//--- Constructor 'emptyList'
  public : static GGS_lexicalAttributeList constructor_emptyList (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_lexicalAttributeList constructor_listWithValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operators () used for method call
  public : const GGS_lexicalAttributeList * operator () (UNUSED_LOCATION_ARGS) const { return this ;} 
//--- Method 'first'
  public : void method_first (C_Compiler & _inLexique,
                              GGS_lstring & _out_0,
                              GGS_lstring & _out_1
                              COMMA_LOCATION_ARGS) const ;
//--- Method 'last'
  public : void method_last (C_Compiler & _inLexique,
                             GGS_lstring & _out_0,
                             GGS_lstring & _out_1
                             COMMA_LOCATION_ARGS) const ;
//--- Modifier 'popLast'
  public : void modifier_popLast (C_Compiler & _inLexique,
                                GGS_lstring & _out_0,
                                GGS_lstring & _out_1
                                COMMA_LOCATION_ARGS) ;
//--- Modifier 'popFirst'
  public : void modifier_popFirst (C_Compiler & _inLexique,
                                 GGS_lstring & _out_0,
                                 GGS_lstring & _out_1
                                 COMMA_LOCATION_ARGS) ;
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalAttributeList _operator_concat (const GGS_lexicalAttributeList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) ;

  protected : void _internalPrependValues (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & _inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--- Metamodel Add method
  public : void _addModel (const GGS_lexicalAttribute & inOperand) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_lexicalStyle'                       *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalStyle {
//--- Pointer to actual instance
  protected : cPtr_lexicalStyle * mPointer ;
//--- Default constructor
  public : GGS_lexicalStyle (void) ;
//--- Copy constructor
  public : GGS_lexicalStyle (const GGS_lexicalStyle &) ;
//--- Virtual destructor
  public : virtual ~GGS_lexicalStyle (void) ;
//--- 'new' constructor
  public : static GGS_lexicalStyle constructor_new (C_Compiler & inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Assignment operator
  public : void operator = (const GGS_lexicalStyle &) ;
//--- Comparison methods
  public : GGS_bool _operator_isEqual (const GGS_lexicalStyle & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalStyle & inOperand) const ;

//--- _isBuilt
  public : inline bool _isBuilt (void) const { return mPointer != NULL ; }

//--- isEqualTo
  public : inline bool isEqualTo (const GGS_lexicalStyle & _inOperand) const {
    return mPointer == _inOperand.mPointer ;
  }

//--- getPtr
  public : inline cPtr_lexicalStyle * getPtr (void) const {
    return mPointer ;
  }

//--- drop
  public : void _drop_operation (void) ;

//--- 'description' reader
  public : GGS_string reader_description (C_Compiler & _inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;

//--- Readers
  public : GGS_lstring  reader_mName (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_lstring  reader_mComment (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalStyle * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalStyle * operator () (void) const {
      return mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         list '@lexicalStyleList'                          *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalStyleList : public AC_galgas_list {
  public : typedef cPtr_lexicalStyle element_type ;
//--- Default Constructor
  public : GGS_lexicalStyleList (void) ;
//--- Copy Constructor
  public : GGS_lexicalStyleList (const GGS_lexicalStyleList & inSource) ;
//--- Comparison Operators
  public : GGS_bool _operator_isEqual (const GGS_lexicalStyleList & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalStyleList & inOperand) const ;
//--- Constructor 'emptyList'
  public : static GGS_lexicalStyleList constructor_emptyList (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_lexicalStyleList constructor_listWithValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operators () used for method call
  public : const GGS_lexicalStyleList * operator () (UNUSED_LOCATION_ARGS) const { return this ;} 
//--- Method 'first'
  public : void method_first (C_Compiler & _inLexique,
                              GGS_lstring & _out_0,
                              GGS_lstring & _out_1
                              COMMA_LOCATION_ARGS) const ;
//--- Method 'last'
  public : void method_last (C_Compiler & _inLexique,
                             GGS_lstring & _out_0,
                             GGS_lstring & _out_1
                             COMMA_LOCATION_ARGS) const ;
//--- Modifier 'popLast'
  public : void modifier_popLast (C_Compiler & _inLexique,
                                GGS_lstring & _out_0,
                                GGS_lstring & _out_1
                                COMMA_LOCATION_ARGS) ;
//--- Modifier 'popFirst'
  public : void modifier_popFirst (C_Compiler & _inLexique,
                                 GGS_lstring & _out_0,
                                 GGS_lstring & _out_1
                                 COMMA_LOCATION_ARGS) ;
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalStyleList _operator_concat (const GGS_lexicalStyleList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) ;

  protected : void _internalPrependValues (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & _inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--- Metamodel Add method
  public : void _addModel (const GGS_lexicalStyle & inOperand) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_terminalDeclaration'                   *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_terminalDeclaration {
//--- Pointer to actual instance
  protected : cPtr_terminalDeclaration * mPointer ;
//--- Default constructor
  public : GGS_terminalDeclaration (void) ;
//--- Copy constructor
  public : GGS_terminalDeclaration (const GGS_terminalDeclaration &) ;
//--- Virtual destructor
  public : virtual ~GGS_terminalDeclaration (void) ;
//--- 'new' constructor
  public : static GGS_terminalDeclaration constructor_new (C_Compiler & inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3
                                COMMA_LOCATION_ARGS) ;
//--- Assignment operator
  public : void operator = (const GGS_terminalDeclaration &) ;
//--- Comparison methods
  public : GGS_bool _operator_isEqual (const GGS_terminalDeclaration & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_terminalDeclaration & inOperand) const ;

//--- _isBuilt
  public : inline bool _isBuilt (void) const { return mPointer != NULL ; }

//--- isEqualTo
  public : inline bool isEqualTo (const GGS_terminalDeclaration & _inOperand) const {
    return mPointer == _inOperand.mPointer ;
  }

//--- getPtr
  public : inline cPtr_terminalDeclaration * getPtr (void) const {
    return mPointer ;
  }

//--- drop
  public : void _drop_operation (void) ;

//--- 'description' reader
  public : GGS_string reader_description (C_Compiler & _inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;

//--- Readers
  public : GGS_lstring  reader_mName (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_lstringlist  reader_mSentAttributeList (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_lstring  reader_mErrorMessage (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_lstring  reader_mStyle (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_terminalDeclaration * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_terminalDeclaration * operator () (void) const {
      return mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     list '@terminalDeclarationList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_terminalDeclarationList : public AC_galgas_list {
  public : typedef cPtr_terminalDeclaration element_type ;
//--- Default Constructor
  public : GGS_terminalDeclarationList (void) ;
//--- Copy Constructor
  public : GGS_terminalDeclarationList (const GGS_terminalDeclarationList & inSource) ;
//--- Comparison Operators
  public : GGS_bool _operator_isEqual (const GGS_terminalDeclarationList & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_terminalDeclarationList & inOperand) const ;
//--- Constructor 'emptyList'
  public : static GGS_terminalDeclarationList constructor_emptyList (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_terminalDeclarationList constructor_listWithValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operators () used for method call
  public : const GGS_terminalDeclarationList * operator () (UNUSED_LOCATION_ARGS) const { return this ;} 
//--- Method 'first'
  public : void method_first (C_Compiler & _inLexique,
                              GGS_lstring & _out_0,
                              GGS_lstringlist & _out_1,
                              GGS_lstring & _out_2,
                              GGS_lstring & _out_3
                              COMMA_LOCATION_ARGS) const ;
//--- Method 'last'
  public : void method_last (C_Compiler & _inLexique,
                             GGS_lstring & _out_0,
                             GGS_lstringlist & _out_1,
                             GGS_lstring & _out_2,
                             GGS_lstring & _out_3
                             COMMA_LOCATION_ARGS) const ;
//--- Modifier 'popLast'
  public : void modifier_popLast (C_Compiler & _inLexique,
                                GGS_lstring & _out_0,
                                GGS_lstringlist & _out_1,
                                GGS_lstring & _out_2,
                                GGS_lstring & _out_3
                                COMMA_LOCATION_ARGS) ;
//--- Modifier 'popFirst'
  public : void modifier_popFirst (C_Compiler & _inLexique,
                                 GGS_lstring & _out_0,
                                 GGS_lstringlist & _out_1,
                                 GGS_lstring & _out_2,
                                 GGS_lstring & _out_3
                                 COMMA_LOCATION_ARGS) ;
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3) ;
//--- Handling '.' GALGAS operator
  public : GGS_terminalDeclarationList _operator_concat (const GGS_terminalDeclarationList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lstring & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3) ;

  protected : void _internalPrependValues (const GGS_lstring & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & _inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--- Metamodel Add method
  public : void _addModel (const GGS_terminalDeclaration & inOperand) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_lexicalListDeclaration'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalListDeclaration {
//--- Pointer to actual instance
  protected : cPtr_lexicalListDeclaration * mPointer ;
//--- Default constructor
  public : GGS_lexicalListDeclaration (void) ;
//--- Copy constructor
  public : GGS_lexicalListDeclaration (const GGS_lexicalListDeclaration &) ;
//--- Virtual destructor
  public : virtual ~GGS_lexicalListDeclaration (void) ;
//--- 'new' constructor
  public : static GGS_lexicalListDeclaration constructor_new (C_Compiler & inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstringlist & argument_3,
                                const GGS_lexicalListEntryList & argument_4
                                COMMA_LOCATION_ARGS) ;
//--- Assignment operator
  public : void operator = (const GGS_lexicalListDeclaration &) ;
//--- Comparison methods
  public : GGS_bool _operator_isEqual (const GGS_lexicalListDeclaration & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalListDeclaration & inOperand) const ;

//--- _isBuilt
  public : inline bool _isBuilt (void) const { return mPointer != NULL ; }

//--- isEqualTo
  public : inline bool isEqualTo (const GGS_lexicalListDeclaration & _inOperand) const {
    return mPointer == _inOperand.mPointer ;
  }

//--- getPtr
  public : inline cPtr_lexicalListDeclaration * getPtr (void) const {
    return mPointer ;
  }

//--- drop
  public : void _drop_operation (void) ;

//--- 'description' reader
  public : GGS_string reader_description (C_Compiler & _inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;

//--- Readers
  public : GGS_lstring  reader_mName (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_lstring  reader_mStyle (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_lstring  reader_mErrorMessage (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_lstringlist  reader_mSentAttributeList (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_lexicalListEntryList  reader_mEntryList (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalListDeclaration * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalListDeclaration * operator () (void) const {
      return mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    list '@lexicalListDeclarationList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalListDeclarationList : public AC_galgas_list {
  public : typedef cPtr_lexicalListDeclaration element_type ;
//--- Default Constructor
  public : GGS_lexicalListDeclarationList (void) ;
//--- Copy Constructor
  public : GGS_lexicalListDeclarationList (const GGS_lexicalListDeclarationList & inSource) ;
//--- Comparison Operators
  public : GGS_bool _operator_isEqual (const GGS_lexicalListDeclarationList & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalListDeclarationList & inOperand) const ;
//--- Constructor 'emptyList'
  public : static GGS_lexicalListDeclarationList constructor_emptyList (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_lexicalListDeclarationList constructor_listWithValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstringlist & argument_3,
                                const GGS_lexicalListEntryList & argument_4
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operators () used for method call
  public : const GGS_lexicalListDeclarationList * operator () (UNUSED_LOCATION_ARGS) const { return this ;} 
//--- Method 'first'
  public : void method_first (C_Compiler & _inLexique,
                              GGS_lstring & _out_0,
                              GGS_lstring & _out_1,
                              GGS_lstring & _out_2,
                              GGS_lstringlist & _out_3,
                              GGS_lexicalListEntryList & _out_4
                              COMMA_LOCATION_ARGS) const ;
//--- Method 'last'
  public : void method_last (C_Compiler & _inLexique,
                             GGS_lstring & _out_0,
                             GGS_lstring & _out_1,
                             GGS_lstring & _out_2,
                             GGS_lstringlist & _out_3,
                             GGS_lexicalListEntryList & _out_4
                             COMMA_LOCATION_ARGS) const ;
//--- Modifier 'popLast'
  public : void modifier_popLast (C_Compiler & _inLexique,
                                GGS_lstring & _out_0,
                                GGS_lstring & _out_1,
                                GGS_lstring & _out_2,
                                GGS_lstringlist & _out_3,
                                GGS_lexicalListEntryList & _out_4
                                COMMA_LOCATION_ARGS) ;
//--- Modifier 'popFirst'
  public : void modifier_popFirst (C_Compiler & _inLexique,
                                 GGS_lstring & _out_0,
                                 GGS_lstring & _out_1,
                                 GGS_lstring & _out_2,
                                 GGS_lstringlist & _out_3,
                                 GGS_lexicalListEntryList & _out_4
                                 COMMA_LOCATION_ARGS) ;
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstringlist & argument_3,
                                const GGS_lexicalListEntryList & argument_4) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalListDeclarationList _operator_concat (const GGS_lexicalListDeclarationList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstringlist & argument_3,
                                const GGS_lexicalListEntryList & argument_4
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstringlist & argument_3,
                                const GGS_lexicalListEntryList & argument_4) ;

  protected : void _internalPrependValues (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstringlist & argument_3,
                                const GGS_lexicalListEntryList & argument_4) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & _inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--- Metamodel Add method
  public : void _addModel (const GGS_lexicalListDeclaration & inOperand) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_lexicalListEntry'                     *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalListEntry {
//--- Pointer to actual instance
  protected : cPtr_lexicalListEntry * mPointer ;
//--- Default constructor
  public : GGS_lexicalListEntry (void) ;
//--- Copy constructor
  public : GGS_lexicalListEntry (const GGS_lexicalListEntry &) ;
//--- Virtual destructor
  public : virtual ~GGS_lexicalListEntry (void) ;
//--- 'new' constructor
  public : static GGS_lexicalListEntry constructor_new (C_Compiler & inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Assignment operator
  public : void operator = (const GGS_lexicalListEntry &) ;
//--- Comparison methods
  public : GGS_bool _operator_isEqual (const GGS_lexicalListEntry & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalListEntry & inOperand) const ;

//--- _isBuilt
  public : inline bool _isBuilt (void) const { return mPointer != NULL ; }

//--- isEqualTo
  public : inline bool isEqualTo (const GGS_lexicalListEntry & _inOperand) const {
    return mPointer == _inOperand.mPointer ;
  }

//--- getPtr
  public : inline cPtr_lexicalListEntry * getPtr (void) const {
    return mPointer ;
  }

//--- drop
  public : void _drop_operation (void) ;

//--- 'description' reader
  public : GGS_string reader_description (C_Compiler & _inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;

//--- Readers
  public : GGS_lstring  reader_mEntrySpelling (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_lstring  reader_mTerminalSpelling (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalListEntry * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalListEntry * operator () (void) const {
      return mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       list '@lexicalListEntryList'                        *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalListEntryList : public AC_galgas_list {
  public : typedef cPtr_lexicalListEntry element_type ;
//--- Default Constructor
  public : GGS_lexicalListEntryList (void) ;
//--- Copy Constructor
  public : GGS_lexicalListEntryList (const GGS_lexicalListEntryList & inSource) ;
//--- Comparison Operators
  public : GGS_bool _operator_isEqual (const GGS_lexicalListEntryList & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalListEntryList & inOperand) const ;
//--- Constructor 'emptyList'
  public : static GGS_lexicalListEntryList constructor_emptyList (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_lexicalListEntryList constructor_listWithValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operators () used for method call
  public : const GGS_lexicalListEntryList * operator () (UNUSED_LOCATION_ARGS) const { return this ;} 
//--- Method 'first'
  public : void method_first (C_Compiler & _inLexique,
                              GGS_lstring & _out_0,
                              GGS_lstring & _out_1
                              COMMA_LOCATION_ARGS) const ;
//--- Method 'last'
  public : void method_last (C_Compiler & _inLexique,
                             GGS_lstring & _out_0,
                             GGS_lstring & _out_1
                             COMMA_LOCATION_ARGS) const ;
//--- Modifier 'popLast'
  public : void modifier_popLast (C_Compiler & _inLexique,
                                GGS_lstring & _out_0,
                                GGS_lstring & _out_1
                                COMMA_LOCATION_ARGS) ;
//--- Modifier 'popFirst'
  public : void modifier_popFirst (C_Compiler & _inLexique,
                                 GGS_lstring & _out_0,
                                 GGS_lstring & _out_1
                                 COMMA_LOCATION_ARGS) ;
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalListEntryList _operator_concat (const GGS_lexicalListEntryList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) ;

  protected : void _internalPrependValues (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & _inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--- Metamodel Add method
  public : void _addModel (const GGS_lexicalListEntry & inOperand) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_lexicalExplicitRule'                   *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalExplicitRule {
//--- Pointer to actual instance
  protected : cPtr_lexicalExplicitRule * mPointer ;
//--- Default constructor
  public : GGS_lexicalExplicitRule (void) ;
//--- Copy constructor
  public : GGS_lexicalExplicitRule (const GGS_lexicalExplicitRule &) ;
//--- Virtual destructor
  public : virtual ~GGS_lexicalExplicitRule (void) ;
//--- 'new' constructor
  public : static GGS_lexicalExplicitRule constructor_new (C_Compiler & inLexique,
                                const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalInstructionList & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Assignment operator
  public : void operator = (const GGS_lexicalExplicitRule &) ;
//--- Comparison methods
  public : GGS_bool _operator_isEqual (const GGS_lexicalExplicitRule & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalExplicitRule & inOperand) const ;

//--- _isBuilt
  public : inline bool _isBuilt (void) const { return mPointer != NULL ; }

//--- isEqualTo
  public : inline bool isEqualTo (const GGS_lexicalExplicitRule & _inOperand) const {
    return mPointer == _inOperand.mPointer ;
  }

//--- getPtr
  public : inline cPtr_lexicalExplicitRule * getPtr (void) const {
    return mPointer ;
  }

//--- drop
  public : void _drop_operation (void) ;

//--- 'description' reader
  public : GGS_string reader_description (C_Compiler & _inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;

//--- Readers
  public : GGS_lexicalExpression  reader_mLexicalRuleExpression (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_lexicalInstructionList  reader_mInstructionList (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalExplicitRule * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalExplicitRule * operator () (void) const {
      return mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     list '@lexicalExplicitRuleList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalExplicitRuleList : public AC_galgas_list {
  public : typedef cPtr_lexicalExplicitRule element_type ;
//--- Default Constructor
  public : GGS_lexicalExplicitRuleList (void) ;
//--- Copy Constructor
  public : GGS_lexicalExplicitRuleList (const GGS_lexicalExplicitRuleList & inSource) ;
//--- Comparison Operators
  public : GGS_bool _operator_isEqual (const GGS_lexicalExplicitRuleList & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalExplicitRuleList & inOperand) const ;
//--- Constructor 'emptyList'
  public : static GGS_lexicalExplicitRuleList constructor_emptyList (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_lexicalExplicitRuleList constructor_listWithValue (C_Compiler & _inLexique,
                                const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalInstructionList & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operators () used for method call
  public : const GGS_lexicalExplicitRuleList * operator () (UNUSED_LOCATION_ARGS) const { return this ;} 
//--- Method 'first'
  public : void method_first (C_Compiler & _inLexique,
                              GGS_lexicalExpression & _out_0,
                              GGS_lexicalInstructionList & _out_1
                              COMMA_LOCATION_ARGS) const ;
//--- Method 'last'
  public : void method_last (C_Compiler & _inLexique,
                             GGS_lexicalExpression & _out_0,
                             GGS_lexicalInstructionList & _out_1
                             COMMA_LOCATION_ARGS) const ;
//--- Modifier 'popLast'
  public : void modifier_popLast (C_Compiler & _inLexique,
                                GGS_lexicalExpression & _out_0,
                                GGS_lexicalInstructionList & _out_1
                                COMMA_LOCATION_ARGS) ;
//--- Modifier 'popFirst'
  public : void modifier_popFirst (C_Compiler & _inLexique,
                                 GGS_lexicalExpression & _out_0,
                                 GGS_lexicalInstructionList & _out_1
                                 COMMA_LOCATION_ARGS) ;
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalInstructionList & argument_1) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalExplicitRuleList _operator_concat (const GGS_lexicalExplicitRuleList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & _inLexique,
                                const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalInstructionList & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalInstructionList & argument_1) ;

  protected : void _internalPrependValues (const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalInstructionList & argument_1) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & _inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--- Metamodel Add method
  public : void _addModel (const GGS_lexicalExplicitRule & inOperand) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_lexicalExpression'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalExpression {
//--- Pointer to actual instance
  protected : cPtr_lexicalExpression * mPointer ;
//--- Default constructor
  public : GGS_lexicalExpression (void) ;
//--- Copy constructor
  public : GGS_lexicalExpression (const GGS_lexicalExpression &) ;
//--- Virtual destructor
  public : virtual ~GGS_lexicalExpression (void) ;
//--- Assignment operator
  public : void operator = (const GGS_lexicalExpression &) ;
//--- Comparison methods
  public : GGS_bool _operator_isEqual (const GGS_lexicalExpression & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalExpression & inOperand) const ;

//--- _isBuilt
  public : inline bool _isBuilt (void) const { return mPointer != NULL ; }

//--- isEqualTo
  public : inline bool isEqualTo (const GGS_lexicalExpression & _inOperand) const {
    return mPointer == _inOperand.mPointer ;
  }

//--- getPtr
  public : inline cPtr_lexicalExpression * getPtr (void) const {
    return mPointer ;
  }

//--- drop
  public : void _drop_operation (void) ;

//--- 'description' reader
  public : GGS_string reader_description (C_Compiler & _inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;

//--- Readers
//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalExpression * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalExpression * operator () (void) const {
      return mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      list '@lexicalExpressionList'                        *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalExpressionList : public AC_galgas_list {
  public : typedef cPtr_lexicalExpression element_type ;
//--- Default Constructor
  public : GGS_lexicalExpressionList (void) ;
//--- Copy Constructor
  public : GGS_lexicalExpressionList (const GGS_lexicalExpressionList & inSource) ;
//--- Comparison Operators
  public : GGS_bool _operator_isEqual (const GGS_lexicalExpressionList & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalExpressionList & inOperand) const ;
//--- Constructor 'emptyList'
  public : static GGS_lexicalExpressionList constructor_emptyList (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_lexicalExpressionList constructor_listWithValue (C_Compiler & _inLexique
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operators () used for method call
  public : const GGS_lexicalExpressionList * operator () (UNUSED_LOCATION_ARGS) const { return this ;} 
//--- Method 'first'
  public : void method_first (C_Compiler & _inLexique
                              COMMA_LOCATION_ARGS) const ;
//--- Method 'last'
  public : void method_last (C_Compiler & _inLexique
                             COMMA_LOCATION_ARGS) const ;
//--- Modifier 'popLast'
  public : void modifier_popLast (C_Compiler & _inLexique
                                COMMA_LOCATION_ARGS) ;
//--- Modifier 'popFirst'
  public : void modifier_popFirst (C_Compiler & _inLexique
                                 COMMA_LOCATION_ARGS) ;
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation () ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalExpressionList _operator_concat (const GGS_lexicalExpressionList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & _inLexique
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues () ;

  protected : void _internalPrependValues () ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & _inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--- Metamodel Add method
  public : void _addModel (const GGS_lexicalExpression & inOperand) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_lexicalOrExpression'                   *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalOrExpression : public GGS_lexicalExpression {
//--- Default constructor
  public : GGS_lexicalOrExpression (void) ;
//--- Copy constructor
  public : GGS_lexicalOrExpression (const GGS_lexicalOrExpression &) ;
//--- Virtual destructor
  public : virtual ~GGS_lexicalOrExpression (void) ;
//--- 'new' constructor
  public : static GGS_lexicalOrExpression constructor_new (C_Compiler & inLexique,
                                const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalExpression & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Assignment operator
  public : void operator = (const GGS_lexicalOrExpression &) ;
//--- Comparison methods
  public : GGS_bool _operator_isEqual (const GGS_lexicalOrExpression & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalOrExpression & inOperand) const ;

//--- 'description' reader
  public : GGS_string reader_description (C_Compiler & _inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;

//--- Readers
  public : GGS_lexicalExpression  reader_mLeftOperand (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_lexicalExpression  reader_mRightOperand (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalOrExpression * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalOrExpression * operator () (void) const {
      return (cPtr_lexicalOrExpression *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     list '@lexicalOrExpressionList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalOrExpressionList : public AC_galgas_list {
  public : typedef cPtr_lexicalOrExpression element_type ;
//--- Default Constructor
  public : GGS_lexicalOrExpressionList (void) ;
//--- Copy Constructor
  public : GGS_lexicalOrExpressionList (const GGS_lexicalOrExpressionList & inSource) ;
//--- Comparison Operators
  public : GGS_bool _operator_isEqual (const GGS_lexicalOrExpressionList & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalOrExpressionList & inOperand) const ;
//--- Constructor 'emptyList'
  public : static GGS_lexicalOrExpressionList constructor_emptyList (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_lexicalOrExpressionList constructor_listWithValue (C_Compiler & _inLexique,
                                const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalExpression & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operators () used for method call
  public : const GGS_lexicalOrExpressionList * operator () (UNUSED_LOCATION_ARGS) const { return this ;} 
//--- Method 'first'
  public : void method_first (C_Compiler & _inLexique,
                              GGS_lexicalExpression & _out_0,
                              GGS_lexicalExpression & _out_1
                              COMMA_LOCATION_ARGS) const ;
//--- Method 'last'
  public : void method_last (C_Compiler & _inLexique,
                             GGS_lexicalExpression & _out_0,
                             GGS_lexicalExpression & _out_1
                             COMMA_LOCATION_ARGS) const ;
//--- Modifier 'popLast'
  public : void modifier_popLast (C_Compiler & _inLexique,
                                GGS_lexicalExpression & _out_0,
                                GGS_lexicalExpression & _out_1
                                COMMA_LOCATION_ARGS) ;
//--- Modifier 'popFirst'
  public : void modifier_popFirst (C_Compiler & _inLexique,
                                 GGS_lexicalExpression & _out_0,
                                 GGS_lexicalExpression & _out_1
                                 COMMA_LOCATION_ARGS) ;
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalExpression & argument_1) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalOrExpressionList _operator_concat (const GGS_lexicalOrExpressionList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & _inLexique,
                                const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalExpression & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalExpression & argument_1) ;

  protected : void _internalPrependValues (const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalExpression & argument_1) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & _inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--- Metamodel Add method
  public : void _addModel (const GGS_lexicalOrExpression & inOperand) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_lexicalCharacterMatch'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalCharacterMatch : public GGS_lexicalExpression {
//--- Default constructor
  public : GGS_lexicalCharacterMatch (void) ;
//--- Copy constructor
  public : GGS_lexicalCharacterMatch (const GGS_lexicalCharacterMatch &) ;
//--- Virtual destructor
  public : virtual ~GGS_lexicalCharacterMatch (void) ;
//--- 'new' constructor
  public : static GGS_lexicalCharacterMatch constructor_new (C_Compiler & inLexique,
                                const GGS_lchar & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- Assignment operator
  public : void operator = (const GGS_lexicalCharacterMatch &) ;
//--- Comparison methods
  public : GGS_bool _operator_isEqual (const GGS_lexicalCharacterMatch & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalCharacterMatch & inOperand) const ;

//--- 'description' reader
  public : GGS_string reader_description (C_Compiler & _inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;

//--- Readers
  public : GGS_lchar  reader_mCharacter (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalCharacterMatch * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalCharacterMatch * operator () (void) const {
      return (cPtr_lexicalCharacterMatch *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    list '@lexicalCharacterMatchList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalCharacterMatchList : public AC_galgas_list {
  public : typedef cPtr_lexicalCharacterMatch element_type ;
//--- Default Constructor
  public : GGS_lexicalCharacterMatchList (void) ;
//--- Copy Constructor
  public : GGS_lexicalCharacterMatchList (const GGS_lexicalCharacterMatchList & inSource) ;
//--- Comparison Operators
  public : GGS_bool _operator_isEqual (const GGS_lexicalCharacterMatchList & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalCharacterMatchList & inOperand) const ;
//--- Constructor 'emptyList'
  public : static GGS_lexicalCharacterMatchList constructor_emptyList (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_lexicalCharacterMatchList constructor_listWithValue (C_Compiler & _inLexique,
                                const GGS_lchar & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operators () used for method call
  public : const GGS_lexicalCharacterMatchList * operator () (UNUSED_LOCATION_ARGS) const { return this ;} 
//--- Method 'first'
  public : void method_first (C_Compiler & _inLexique,
                              GGS_lchar & _out_0
                              COMMA_LOCATION_ARGS) const ;
//--- Method 'last'
  public : void method_last (C_Compiler & _inLexique,
                             GGS_lchar & _out_0
                             COMMA_LOCATION_ARGS) const ;
//--- Modifier 'popLast'
  public : void modifier_popLast (C_Compiler & _inLexique,
                                GGS_lchar & _out_0
                                COMMA_LOCATION_ARGS) ;
//--- Modifier 'popFirst'
  public : void modifier_popFirst (C_Compiler & _inLexique,
                                 GGS_lchar & _out_0
                                 COMMA_LOCATION_ARGS) ;
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lchar & argument_0) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalCharacterMatchList _operator_concat (const GGS_lexicalCharacterMatchList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & _inLexique,
                                const GGS_lchar & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lchar & argument_0) ;

  protected : void _internalPrependValues (const GGS_lchar & argument_0) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & _inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--- Metamodel Add method
  public : void _addModel (const GGS_lexicalCharacterMatch & inOperand) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_lexicalCharacterIntervalMatch'              *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalCharacterIntervalMatch : public GGS_lexicalExpression {
//--- Default constructor
  public : GGS_lexicalCharacterIntervalMatch (void) ;
//--- Copy constructor
  public : GGS_lexicalCharacterIntervalMatch (const GGS_lexicalCharacterIntervalMatch &) ;
//--- Virtual destructor
  public : virtual ~GGS_lexicalCharacterIntervalMatch (void) ;
//--- 'new' constructor
  public : static GGS_lexicalCharacterIntervalMatch constructor_new (C_Compiler & inLexique,
                                const GGS_lchar & argument_0,
                                const GGS_lchar & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Assignment operator
  public : void operator = (const GGS_lexicalCharacterIntervalMatch &) ;
//--- Comparison methods
  public : GGS_bool _operator_isEqual (const GGS_lexicalCharacterIntervalMatch & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalCharacterIntervalMatch & inOperand) const ;

//--- 'description' reader
  public : GGS_string reader_description (C_Compiler & _inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;

//--- Readers
  public : GGS_lchar  reader_mLowerBound (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_lchar  reader_mUpperBound (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalCharacterIntervalMatch * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalCharacterIntervalMatch * operator () (void) const {
      return (cPtr_lexicalCharacterIntervalMatch *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                list '@lexicalCharacterIntervalMatchList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalCharacterIntervalMatchList : public AC_galgas_list {
  public : typedef cPtr_lexicalCharacterIntervalMatch element_type ;
//--- Default Constructor
  public : GGS_lexicalCharacterIntervalMatchList (void) ;
//--- Copy Constructor
  public : GGS_lexicalCharacterIntervalMatchList (const GGS_lexicalCharacterIntervalMatchList & inSource) ;
//--- Comparison Operators
  public : GGS_bool _operator_isEqual (const GGS_lexicalCharacterIntervalMatchList & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalCharacterIntervalMatchList & inOperand) const ;
//--- Constructor 'emptyList'
  public : static GGS_lexicalCharacterIntervalMatchList constructor_emptyList (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_lexicalCharacterIntervalMatchList constructor_listWithValue (C_Compiler & _inLexique,
                                const GGS_lchar & argument_0,
                                const GGS_lchar & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operators () used for method call
  public : const GGS_lexicalCharacterIntervalMatchList * operator () (UNUSED_LOCATION_ARGS) const { return this ;} 
//--- Method 'first'
  public : void method_first (C_Compiler & _inLexique,
                              GGS_lchar & _out_0,
                              GGS_lchar & _out_1
                              COMMA_LOCATION_ARGS) const ;
//--- Method 'last'
  public : void method_last (C_Compiler & _inLexique,
                             GGS_lchar & _out_0,
                             GGS_lchar & _out_1
                             COMMA_LOCATION_ARGS) const ;
//--- Modifier 'popLast'
  public : void modifier_popLast (C_Compiler & _inLexique,
                                GGS_lchar & _out_0,
                                GGS_lchar & _out_1
                                COMMA_LOCATION_ARGS) ;
//--- Modifier 'popFirst'
  public : void modifier_popFirst (C_Compiler & _inLexique,
                                 GGS_lchar & _out_0,
                                 GGS_lchar & _out_1
                                 COMMA_LOCATION_ARGS) ;
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lchar & argument_0,
                                const GGS_lchar & argument_1) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalCharacterIntervalMatchList _operator_concat (const GGS_lexicalCharacterIntervalMatchList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & _inLexique,
                                const GGS_lchar & argument_0,
                                const GGS_lchar & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lchar & argument_0,
                                const GGS_lchar & argument_1) ;

  protected : void _internalPrependValues (const GGS_lchar & argument_0,
                                const GGS_lchar & argument_1) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & _inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--- Metamodel Add method
  public : void _addModel (const GGS_lexicalCharacterIntervalMatch & inOperand) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_lexicalStringMatch'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalStringMatch : public GGS_lexicalExpression {
//--- Default constructor
  public : GGS_lexicalStringMatch (void) ;
//--- Copy constructor
  public : GGS_lexicalStringMatch (const GGS_lexicalStringMatch &) ;
//--- Virtual destructor
  public : virtual ~GGS_lexicalStringMatch (void) ;
//--- 'new' constructor
  public : static GGS_lexicalStringMatch constructor_new (C_Compiler & inLexique,
                                const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- Assignment operator
  public : void operator = (const GGS_lexicalStringMatch &) ;
//--- Comparison methods
  public : GGS_bool _operator_isEqual (const GGS_lexicalStringMatch & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalStringMatch & inOperand) const ;

//--- 'description' reader
  public : GGS_string reader_description (C_Compiler & _inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;

//--- Readers
  public : GGS_lstring  reader_mString (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalStringMatch * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalStringMatch * operator () (void) const {
      return (cPtr_lexicalStringMatch *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      list '@lexicalStringMatchList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalStringMatchList : public AC_galgas_list {
  public : typedef cPtr_lexicalStringMatch element_type ;
//--- Default Constructor
  public : GGS_lexicalStringMatchList (void) ;
//--- Copy Constructor
  public : GGS_lexicalStringMatchList (const GGS_lexicalStringMatchList & inSource) ;
//--- Comparison Operators
  public : GGS_bool _operator_isEqual (const GGS_lexicalStringMatchList & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalStringMatchList & inOperand) const ;
//--- Constructor 'emptyList'
  public : static GGS_lexicalStringMatchList constructor_emptyList (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_lexicalStringMatchList constructor_listWithValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operators () used for method call
  public : const GGS_lexicalStringMatchList * operator () (UNUSED_LOCATION_ARGS) const { return this ;} 
//--- Method 'first'
  public : void method_first (C_Compiler & _inLexique,
                              GGS_lstring & _out_0
                              COMMA_LOCATION_ARGS) const ;
//--- Method 'last'
  public : void method_last (C_Compiler & _inLexique,
                             GGS_lstring & _out_0
                             COMMA_LOCATION_ARGS) const ;
//--- Modifier 'popLast'
  public : void modifier_popLast (C_Compiler & _inLexique,
                                GGS_lstring & _out_0
                                COMMA_LOCATION_ARGS) ;
//--- Modifier 'popFirst'
  public : void modifier_popFirst (C_Compiler & _inLexique,
                                 GGS_lstring & _out_0
                                 COMMA_LOCATION_ARGS) ;
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lstring & argument_0) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalStringMatchList _operator_concat (const GGS_lexicalStringMatchList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lstring & argument_0) ;

  protected : void _internalPrependValues (const GGS_lstring & argument_0) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & _inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--- Metamodel Add method
  public : void _addModel (const GGS_lexicalStringMatch & inOperand) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_lexicalStringNotMatch'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalStringNotMatch : public GGS_lexicalExpression {
//--- Default constructor
  public : GGS_lexicalStringNotMatch (void) ;
//--- Copy constructor
  public : GGS_lexicalStringNotMatch (const GGS_lexicalStringNotMatch &) ;
//--- Virtual destructor
  public : virtual ~GGS_lexicalStringNotMatch (void) ;
//--- 'new' constructor
  public : static GGS_lexicalStringNotMatch constructor_new (C_Compiler & inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Assignment operator
  public : void operator = (const GGS_lexicalStringNotMatch &) ;
//--- Comparison methods
  public : GGS_bool _operator_isEqual (const GGS_lexicalStringNotMatch & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalStringNotMatch & inOperand) const ;

//--- 'description' reader
  public : GGS_string reader_description (C_Compiler & _inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;

//--- Readers
  public : GGS_lstring  reader_mString (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_lstring  reader_mErrorMessage (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalStringNotMatch * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalStringNotMatch * operator () (void) const {
      return (cPtr_lexicalStringNotMatch *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    list '@lexicalStringNotMatchList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalStringNotMatchList : public AC_galgas_list {
  public : typedef cPtr_lexicalStringNotMatch element_type ;
//--- Default Constructor
  public : GGS_lexicalStringNotMatchList (void) ;
//--- Copy Constructor
  public : GGS_lexicalStringNotMatchList (const GGS_lexicalStringNotMatchList & inSource) ;
//--- Comparison Operators
  public : GGS_bool _operator_isEqual (const GGS_lexicalStringNotMatchList & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalStringNotMatchList & inOperand) const ;
//--- Constructor 'emptyList'
  public : static GGS_lexicalStringNotMatchList constructor_emptyList (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_lexicalStringNotMatchList constructor_listWithValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operators () used for method call
  public : const GGS_lexicalStringNotMatchList * operator () (UNUSED_LOCATION_ARGS) const { return this ;} 
//--- Method 'first'
  public : void method_first (C_Compiler & _inLexique,
                              GGS_lstring & _out_0,
                              GGS_lstring & _out_1
                              COMMA_LOCATION_ARGS) const ;
//--- Method 'last'
  public : void method_last (C_Compiler & _inLexique,
                             GGS_lstring & _out_0,
                             GGS_lstring & _out_1
                             COMMA_LOCATION_ARGS) const ;
//--- Modifier 'popLast'
  public : void modifier_popLast (C_Compiler & _inLexique,
                                GGS_lstring & _out_0,
                                GGS_lstring & _out_1
                                COMMA_LOCATION_ARGS) ;
//--- Modifier 'popFirst'
  public : void modifier_popFirst (C_Compiler & _inLexique,
                                 GGS_lstring & _out_0,
                                 GGS_lstring & _out_1
                                 COMMA_LOCATION_ARGS) ;
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalStringNotMatchList _operator_concat (const GGS_lexicalStringNotMatchList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) ;

  protected : void _internalPrependValues (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & _inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--- Metamodel Add method
  public : void _addModel (const GGS_lexicalStringNotMatch & inOperand) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_lexicalInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalInstruction {
//--- Pointer to actual instance
  protected : cPtr_lexicalInstruction * mPointer ;
//--- Default constructor
  public : GGS_lexicalInstruction (void) ;
//--- Copy constructor
  public : GGS_lexicalInstruction (const GGS_lexicalInstruction &) ;
//--- Virtual destructor
  public : virtual ~GGS_lexicalInstruction (void) ;
//--- Assignment operator
  public : void operator = (const GGS_lexicalInstruction &) ;
//--- Comparison methods
  public : GGS_bool _operator_isEqual (const GGS_lexicalInstruction & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalInstruction & inOperand) const ;

//--- _isBuilt
  public : inline bool _isBuilt (void) const { return mPointer != NULL ; }

//--- isEqualTo
  public : inline bool isEqualTo (const GGS_lexicalInstruction & _inOperand) const {
    return mPointer == _inOperand.mPointer ;
  }

//--- getPtr
  public : inline cPtr_lexicalInstruction * getPtr (void) const {
    return mPointer ;
  }

//--- drop
  public : void _drop_operation (void) ;

//--- 'description' reader
  public : GGS_string reader_description (C_Compiler & _inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;

//--- Readers
//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalInstruction * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalInstruction * operator () (void) const {
      return mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      list '@lexicalInstructionList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalInstructionList : public AC_galgas_list {
  public : typedef cPtr_lexicalInstruction element_type ;
//--- Default Constructor
  public : GGS_lexicalInstructionList (void) ;
//--- Copy Constructor
  public : GGS_lexicalInstructionList (const GGS_lexicalInstructionList & inSource) ;
//--- Comparison Operators
  public : GGS_bool _operator_isEqual (const GGS_lexicalInstructionList & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalInstructionList & inOperand) const ;
//--- Constructor 'emptyList'
  public : static GGS_lexicalInstructionList constructor_emptyList (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_lexicalInstructionList constructor_listWithValue (C_Compiler & _inLexique
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operators () used for method call
  public : const GGS_lexicalInstructionList * operator () (UNUSED_LOCATION_ARGS) const { return this ;} 
//--- Method 'first'
  public : void method_first (C_Compiler & _inLexique
                              COMMA_LOCATION_ARGS) const ;
//--- Method 'last'
  public : void method_last (C_Compiler & _inLexique
                             COMMA_LOCATION_ARGS) const ;
//--- Modifier 'popLast'
  public : void modifier_popLast (C_Compiler & _inLexique
                                COMMA_LOCATION_ARGS) ;
//--- Modifier 'popFirst'
  public : void modifier_popFirst (C_Compiler & _inLexique
                                 COMMA_LOCATION_ARGS) ;
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation () ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalInstructionList _operator_concat (const GGS_lexicalInstructionList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & _inLexique
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues () ;

  protected : void _internalPrependValues () ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & _inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--- Metamodel Add method
  public : void _addModel (const GGS_lexicalInstruction & inOperand) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_lexicalStructuredSendInstruction'             *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalStructuredSendInstruction : public GGS_lexicalInstruction {
//--- Default constructor
  public : GGS_lexicalStructuredSendInstruction (void) ;
//--- Copy constructor
  public : GGS_lexicalStructuredSendInstruction (const GGS_lexicalStructuredSendInstruction &) ;
//--- Virtual destructor
  public : virtual ~GGS_lexicalStructuredSendInstruction (void) ;
//--- 'new' constructor
  public : static GGS_lexicalStructuredSendInstruction constructor_new (C_Compiler & inLexique,
                                const GGS_lexicalSendSearchList & argument_0,
                                const GGS_lexicalSendDefaultAction & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Assignment operator
  public : void operator = (const GGS_lexicalStructuredSendInstruction &) ;
//--- Comparison methods
  public : GGS_bool _operator_isEqual (const GGS_lexicalStructuredSendInstruction & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalStructuredSendInstruction & inOperand) const ;

//--- 'description' reader
  public : GGS_string reader_description (C_Compiler & _inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;

//--- Readers
  public : GGS_lexicalSendSearchList  reader_mLexicalSendSearchList (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_lexicalSendDefaultAction  reader_mLexicalSendDefaultAction (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalStructuredSendInstruction * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalStructuredSendInstruction * operator () (void) const {
      return (cPtr_lexicalStructuredSendInstruction *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//               list '@lexicalStructuredSendInstructionList'                *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalStructuredSendInstructionList : public AC_galgas_list {
  public : typedef cPtr_lexicalStructuredSendInstruction element_type ;
//--- Default Constructor
  public : GGS_lexicalStructuredSendInstructionList (void) ;
//--- Copy Constructor
  public : GGS_lexicalStructuredSendInstructionList (const GGS_lexicalStructuredSendInstructionList & inSource) ;
//--- Comparison Operators
  public : GGS_bool _operator_isEqual (const GGS_lexicalStructuredSendInstructionList & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalStructuredSendInstructionList & inOperand) const ;
//--- Constructor 'emptyList'
  public : static GGS_lexicalStructuredSendInstructionList constructor_emptyList (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_lexicalStructuredSendInstructionList constructor_listWithValue (C_Compiler & _inLexique,
                                const GGS_lexicalSendSearchList & argument_0,
                                const GGS_lexicalSendDefaultAction & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operators () used for method call
  public : const GGS_lexicalStructuredSendInstructionList * operator () (UNUSED_LOCATION_ARGS) const { return this ;} 
//--- Method 'first'
  public : void method_first (C_Compiler & _inLexique,
                              GGS_lexicalSendSearchList & _out_0,
                              GGS_lexicalSendDefaultAction & _out_1
                              COMMA_LOCATION_ARGS) const ;
//--- Method 'last'
  public : void method_last (C_Compiler & _inLexique,
                             GGS_lexicalSendSearchList & _out_0,
                             GGS_lexicalSendDefaultAction & _out_1
                             COMMA_LOCATION_ARGS) const ;
//--- Modifier 'popLast'
  public : void modifier_popLast (C_Compiler & _inLexique,
                                GGS_lexicalSendSearchList & _out_0,
                                GGS_lexicalSendDefaultAction & _out_1
                                COMMA_LOCATION_ARGS) ;
//--- Modifier 'popFirst'
  public : void modifier_popFirst (C_Compiler & _inLexique,
                                 GGS_lexicalSendSearchList & _out_0,
                                 GGS_lexicalSendDefaultAction & _out_1
                                 COMMA_LOCATION_ARGS) ;
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lexicalSendSearchList & argument_0,
                                const GGS_lexicalSendDefaultAction & argument_1) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalStructuredSendInstructionList _operator_concat (const GGS_lexicalStructuredSendInstructionList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & _inLexique,
                                const GGS_lexicalSendSearchList & argument_0,
                                const GGS_lexicalSendDefaultAction & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lexicalSendSearchList & argument_0,
                                const GGS_lexicalSendDefaultAction & argument_1) ;

  protected : void _internalPrependValues (const GGS_lexicalSendSearchList & argument_0,
                                const GGS_lexicalSendDefaultAction & argument_1) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & _inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--- Metamodel Add method
  public : void _addModel (const GGS_lexicalStructuredSendInstruction & inOperand) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_lexicalSimpleSendInstruction'               *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalSimpleSendInstruction : public GGS_lexicalInstruction {
//--- Default constructor
  public : GGS_lexicalSimpleSendInstruction (void) ;
//--- Copy constructor
  public : GGS_lexicalSimpleSendInstruction (const GGS_lexicalSimpleSendInstruction &) ;
//--- Virtual destructor
  public : virtual ~GGS_lexicalSimpleSendInstruction (void) ;
//--- 'new' constructor
  public : static GGS_lexicalSimpleSendInstruction constructor_new (C_Compiler & inLexique,
                                const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- Assignment operator
  public : void operator = (const GGS_lexicalSimpleSendInstruction &) ;
//--- Comparison methods
  public : GGS_bool _operator_isEqual (const GGS_lexicalSimpleSendInstruction & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalSimpleSendInstruction & inOperand) const ;

//--- 'description' reader
  public : GGS_string reader_description (C_Compiler & _inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;

//--- Readers
  public : GGS_lstring  reader_mSentTerminal (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalSimpleSendInstruction * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalSimpleSendInstruction * operator () (void) const {
      return (cPtr_lexicalSimpleSendInstruction *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 list '@lexicalSimpleSendInstructionList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalSimpleSendInstructionList : public AC_galgas_list {
  public : typedef cPtr_lexicalSimpleSendInstruction element_type ;
//--- Default Constructor
  public : GGS_lexicalSimpleSendInstructionList (void) ;
//--- Copy Constructor
  public : GGS_lexicalSimpleSendInstructionList (const GGS_lexicalSimpleSendInstructionList & inSource) ;
//--- Comparison Operators
  public : GGS_bool _operator_isEqual (const GGS_lexicalSimpleSendInstructionList & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalSimpleSendInstructionList & inOperand) const ;
//--- Constructor 'emptyList'
  public : static GGS_lexicalSimpleSendInstructionList constructor_emptyList (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_lexicalSimpleSendInstructionList constructor_listWithValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operators () used for method call
  public : const GGS_lexicalSimpleSendInstructionList * operator () (UNUSED_LOCATION_ARGS) const { return this ;} 
//--- Method 'first'
  public : void method_first (C_Compiler & _inLexique,
                              GGS_lstring & _out_0
                              COMMA_LOCATION_ARGS) const ;
//--- Method 'last'
  public : void method_last (C_Compiler & _inLexique,
                             GGS_lstring & _out_0
                             COMMA_LOCATION_ARGS) const ;
//--- Modifier 'popLast'
  public : void modifier_popLast (C_Compiler & _inLexique,
                                GGS_lstring & _out_0
                                COMMA_LOCATION_ARGS) ;
//--- Modifier 'popFirst'
  public : void modifier_popFirst (C_Compiler & _inLexique,
                                 GGS_lstring & _out_0
                                 COMMA_LOCATION_ARGS) ;
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lstring & argument_0) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalSimpleSendInstructionList _operator_concat (const GGS_lexicalSimpleSendInstructionList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lstring & argument_0) ;

  protected : void _internalPrependValues (const GGS_lstring & argument_0) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & _inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--- Metamodel Add method
  public : void _addModel (const GGS_lexicalSimpleSendInstruction & inOperand) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_lexicalSendDefaultAction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalSendDefaultAction {
//--- Pointer to actual instance
  protected : cPtr_lexicalSendDefaultAction * mPointer ;
//--- Default constructor
  public : GGS_lexicalSendDefaultAction (void) ;
//--- Copy constructor
  public : GGS_lexicalSendDefaultAction (const GGS_lexicalSendDefaultAction &) ;
//--- Virtual destructor
  public : virtual ~GGS_lexicalSendDefaultAction (void) ;
//--- Assignment operator
  public : void operator = (const GGS_lexicalSendDefaultAction &) ;
//--- Comparison methods
  public : GGS_bool _operator_isEqual (const GGS_lexicalSendDefaultAction & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalSendDefaultAction & inOperand) const ;

//--- _isBuilt
  public : inline bool _isBuilt (void) const { return mPointer != NULL ; }

//--- isEqualTo
  public : inline bool isEqualTo (const GGS_lexicalSendDefaultAction & _inOperand) const {
    return mPointer == _inOperand.mPointer ;
  }

//--- getPtr
  public : inline cPtr_lexicalSendDefaultAction * getPtr (void) const {
    return mPointer ;
  }

//--- drop
  public : void _drop_operation (void) ;

//--- 'description' reader
  public : GGS_string reader_description (C_Compiler & _inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;

//--- Readers
//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalSendDefaultAction * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalSendDefaultAction * operator () (void) const {
      return mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   list '@lexicalSendDefaultActionList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalSendDefaultActionList : public AC_galgas_list {
  public : typedef cPtr_lexicalSendDefaultAction element_type ;
//--- Default Constructor
  public : GGS_lexicalSendDefaultActionList (void) ;
//--- Copy Constructor
  public : GGS_lexicalSendDefaultActionList (const GGS_lexicalSendDefaultActionList & inSource) ;
//--- Comparison Operators
  public : GGS_bool _operator_isEqual (const GGS_lexicalSendDefaultActionList & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalSendDefaultActionList & inOperand) const ;
//--- Constructor 'emptyList'
  public : static GGS_lexicalSendDefaultActionList constructor_emptyList (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_lexicalSendDefaultActionList constructor_listWithValue (C_Compiler & _inLexique
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operators () used for method call
  public : const GGS_lexicalSendDefaultActionList * operator () (UNUSED_LOCATION_ARGS) const { return this ;} 
//--- Method 'first'
  public : void method_first (C_Compiler & _inLexique
                              COMMA_LOCATION_ARGS) const ;
//--- Method 'last'
  public : void method_last (C_Compiler & _inLexique
                             COMMA_LOCATION_ARGS) const ;
//--- Modifier 'popLast'
  public : void modifier_popLast (C_Compiler & _inLexique
                                COMMA_LOCATION_ARGS) ;
//--- Modifier 'popFirst'
  public : void modifier_popFirst (C_Compiler & _inLexique
                                 COMMA_LOCATION_ARGS) ;
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation () ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalSendDefaultActionList _operator_concat (const GGS_lexicalSendDefaultActionList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & _inLexique
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues () ;

  protected : void _internalPrependValues () ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & _inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--- Metamodel Add method
  public : void _addModel (const GGS_lexicalSendDefaultAction & inOperand) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_lexicalSendTerminalByDefault'               *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalSendTerminalByDefault : public GGS_lexicalSendDefaultAction {
//--- Default constructor
  public : GGS_lexicalSendTerminalByDefault (void) ;
//--- Copy constructor
  public : GGS_lexicalSendTerminalByDefault (const GGS_lexicalSendTerminalByDefault &) ;
//--- Virtual destructor
  public : virtual ~GGS_lexicalSendTerminalByDefault (void) ;
//--- 'new' constructor
  public : static GGS_lexicalSendTerminalByDefault constructor_new (C_Compiler & inLexique,
                                const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- Assignment operator
  public : void operator = (const GGS_lexicalSendTerminalByDefault &) ;
//--- Comparison methods
  public : GGS_bool _operator_isEqual (const GGS_lexicalSendTerminalByDefault & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalSendTerminalByDefault & inOperand) const ;

//--- 'description' reader
  public : GGS_string reader_description (C_Compiler & _inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;

//--- Readers
  public : GGS_lstring  reader_mDefaultSentTerminal (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalSendTerminalByDefault * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalSendTerminalByDefault * operator () (void) const {
      return (cPtr_lexicalSendTerminalByDefault *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 list '@lexicalSendTerminalByDefaultList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalSendTerminalByDefaultList : public AC_galgas_list {
  public : typedef cPtr_lexicalSendTerminalByDefault element_type ;
//--- Default Constructor
  public : GGS_lexicalSendTerminalByDefaultList (void) ;
//--- Copy Constructor
  public : GGS_lexicalSendTerminalByDefaultList (const GGS_lexicalSendTerminalByDefaultList & inSource) ;
//--- Comparison Operators
  public : GGS_bool _operator_isEqual (const GGS_lexicalSendTerminalByDefaultList & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalSendTerminalByDefaultList & inOperand) const ;
//--- Constructor 'emptyList'
  public : static GGS_lexicalSendTerminalByDefaultList constructor_emptyList (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_lexicalSendTerminalByDefaultList constructor_listWithValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operators () used for method call
  public : const GGS_lexicalSendTerminalByDefaultList * operator () (UNUSED_LOCATION_ARGS) const { return this ;} 
//--- Method 'first'
  public : void method_first (C_Compiler & _inLexique,
                              GGS_lstring & _out_0
                              COMMA_LOCATION_ARGS) const ;
//--- Method 'last'
  public : void method_last (C_Compiler & _inLexique,
                             GGS_lstring & _out_0
                             COMMA_LOCATION_ARGS) const ;
//--- Modifier 'popLast'
  public : void modifier_popLast (C_Compiler & _inLexique,
                                GGS_lstring & _out_0
                                COMMA_LOCATION_ARGS) ;
//--- Modifier 'popFirst'
  public : void modifier_popFirst (C_Compiler & _inLexique,
                                 GGS_lstring & _out_0
                                 COMMA_LOCATION_ARGS) ;
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lstring & argument_0) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalSendTerminalByDefaultList _operator_concat (const GGS_lexicalSendTerminalByDefaultList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lstring & argument_0) ;

  protected : void _internalPrependValues (const GGS_lstring & argument_0) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & _inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--- Metamodel Add method
  public : void _addModel (const GGS_lexicalSendTerminalByDefault & inOperand) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_lexicalErrorByDefault'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalErrorByDefault : public GGS_lexicalSendDefaultAction {
//--- Default constructor
  public : GGS_lexicalErrorByDefault (void) ;
//--- Copy constructor
  public : GGS_lexicalErrorByDefault (const GGS_lexicalErrorByDefault &) ;
//--- Virtual destructor
  public : virtual ~GGS_lexicalErrorByDefault (void) ;
//--- 'new' constructor
  public : static GGS_lexicalErrorByDefault constructor_new (C_Compiler & inLexique,
                                const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- Assignment operator
  public : void operator = (const GGS_lexicalErrorByDefault &) ;
//--- Comparison methods
  public : GGS_bool _operator_isEqual (const GGS_lexicalErrorByDefault & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalErrorByDefault & inOperand) const ;

//--- 'description' reader
  public : GGS_string reader_description (C_Compiler & _inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;

//--- Readers
  public : GGS_lstring  reader_mDefaultErrorMessageName (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalErrorByDefault * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalErrorByDefault * operator () (void) const {
      return (cPtr_lexicalErrorByDefault *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    list '@lexicalErrorByDefaultList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalErrorByDefaultList : public AC_galgas_list {
  public : typedef cPtr_lexicalErrorByDefault element_type ;
//--- Default Constructor
  public : GGS_lexicalErrorByDefaultList (void) ;
//--- Copy Constructor
  public : GGS_lexicalErrorByDefaultList (const GGS_lexicalErrorByDefaultList & inSource) ;
//--- Comparison Operators
  public : GGS_bool _operator_isEqual (const GGS_lexicalErrorByDefaultList & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalErrorByDefaultList & inOperand) const ;
//--- Constructor 'emptyList'
  public : static GGS_lexicalErrorByDefaultList constructor_emptyList (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_lexicalErrorByDefaultList constructor_listWithValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operators () used for method call
  public : const GGS_lexicalErrorByDefaultList * operator () (UNUSED_LOCATION_ARGS) const { return this ;} 
//--- Method 'first'
  public : void method_first (C_Compiler & _inLexique,
                              GGS_lstring & _out_0
                              COMMA_LOCATION_ARGS) const ;
//--- Method 'last'
  public : void method_last (C_Compiler & _inLexique,
                             GGS_lstring & _out_0
                             COMMA_LOCATION_ARGS) const ;
//--- Modifier 'popLast'
  public : void modifier_popLast (C_Compiler & _inLexique,
                                GGS_lstring & _out_0
                                COMMA_LOCATION_ARGS) ;
//--- Modifier 'popFirst'
  public : void modifier_popFirst (C_Compiler & _inLexique,
                                 GGS_lstring & _out_0
                                 COMMA_LOCATION_ARGS) ;
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lstring & argument_0) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalErrorByDefaultList _operator_concat (const GGS_lexicalErrorByDefaultList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lstring & argument_0) ;

  protected : void _internalPrependValues (const GGS_lstring & argument_0) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & _inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--- Metamodel Add method
  public : void _addModel (const GGS_lexicalErrorByDefault & inOperand) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_lexicalSendSearch'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalSendSearch {
//--- Pointer to actual instance
  protected : cPtr_lexicalSendSearch * mPointer ;
//--- Default constructor
  public : GGS_lexicalSendSearch (void) ;
//--- Copy constructor
  public : GGS_lexicalSendSearch (const GGS_lexicalSendSearch &) ;
//--- Virtual destructor
  public : virtual ~GGS_lexicalSendSearch (void) ;
//--- 'new' constructor
  public : static GGS_lexicalSendSearch constructor_new (C_Compiler & inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Assignment operator
  public : void operator = (const GGS_lexicalSendSearch &) ;
//--- Comparison methods
  public : GGS_bool _operator_isEqual (const GGS_lexicalSendSearch & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalSendSearch & inOperand) const ;

//--- _isBuilt
  public : inline bool _isBuilt (void) const { return mPointer != NULL ; }

//--- isEqualTo
  public : inline bool isEqualTo (const GGS_lexicalSendSearch & _inOperand) const {
    return mPointer == _inOperand.mPointer ;
  }

//--- getPtr
  public : inline cPtr_lexicalSendSearch * getPtr (void) const {
    return mPointer ;
  }

//--- drop
  public : void _drop_operation (void) ;

//--- 'description' reader
  public : GGS_string reader_description (C_Compiler & _inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;

//--- Readers
  public : GGS_lstring  reader_mAttributeName (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_lstring  reader_mSearchListName (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalSendSearch * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalSendSearch * operator () (void) const {
      return mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      list '@lexicalSendSearchList'                        *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalSendSearchList : public AC_galgas_list {
  public : typedef cPtr_lexicalSendSearch element_type ;
//--- Default Constructor
  public : GGS_lexicalSendSearchList (void) ;
//--- Copy Constructor
  public : GGS_lexicalSendSearchList (const GGS_lexicalSendSearchList & inSource) ;
//--- Comparison Operators
  public : GGS_bool _operator_isEqual (const GGS_lexicalSendSearchList & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalSendSearchList & inOperand) const ;
//--- Constructor 'emptyList'
  public : static GGS_lexicalSendSearchList constructor_emptyList (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_lexicalSendSearchList constructor_listWithValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operators () used for method call
  public : const GGS_lexicalSendSearchList * operator () (UNUSED_LOCATION_ARGS) const { return this ;} 
//--- Method 'first'
  public : void method_first (C_Compiler & _inLexique,
                              GGS_lstring & _out_0,
                              GGS_lstring & _out_1
                              COMMA_LOCATION_ARGS) const ;
//--- Method 'last'
  public : void method_last (C_Compiler & _inLexique,
                             GGS_lstring & _out_0,
                             GGS_lstring & _out_1
                             COMMA_LOCATION_ARGS) const ;
//--- Modifier 'popLast'
  public : void modifier_popLast (C_Compiler & _inLexique,
                                GGS_lstring & _out_0,
                                GGS_lstring & _out_1
                                COMMA_LOCATION_ARGS) ;
//--- Modifier 'popFirst'
  public : void modifier_popFirst (C_Compiler & _inLexique,
                                 GGS_lstring & _out_0,
                                 GGS_lstring & _out_1
                                 COMMA_LOCATION_ARGS) ;
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalSendSearchList _operator_concat (const GGS_lexicalSendSearchList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) ;

  protected : void _internalPrependValues (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & _inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--- Metamodel Add method
  public : void _addModel (const GGS_lexicalSendSearch & inOperand) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_lexicalRepeatInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalRepeatInstruction : public GGS_lexicalInstruction {
//--- Default constructor
  public : GGS_lexicalRepeatInstruction (void) ;
//--- Copy constructor
  public : GGS_lexicalRepeatInstruction (const GGS_lexicalRepeatInstruction &) ;
//--- Virtual destructor
  public : virtual ~GGS_lexicalRepeatInstruction (void) ;
//--- 'new' constructor
  public : static GGS_lexicalRepeatInstruction constructor_new (C_Compiler & inLexique,
                                const GGS_lexicalInstructionList & argument_0,
                                const GGS_lexicalWhileBranchList & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Assignment operator
  public : void operator = (const GGS_lexicalRepeatInstruction &) ;
//--- Comparison methods
  public : GGS_bool _operator_isEqual (const GGS_lexicalRepeatInstruction & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalRepeatInstruction & inOperand) const ;

//--- 'description' reader
  public : GGS_string reader_description (C_Compiler & _inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;

//--- Readers
  public : GGS_lexicalInstructionList  reader_mRepeatedInstructionList (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_lexicalWhileBranchList  reader_mLexicalWhileBranchList (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalRepeatInstruction * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalRepeatInstruction * operator () (void) const {
      return (cPtr_lexicalRepeatInstruction *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   list '@lexicalRepeatInstructionList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalRepeatInstructionList : public AC_galgas_list {
  public : typedef cPtr_lexicalRepeatInstruction element_type ;
//--- Default Constructor
  public : GGS_lexicalRepeatInstructionList (void) ;
//--- Copy Constructor
  public : GGS_lexicalRepeatInstructionList (const GGS_lexicalRepeatInstructionList & inSource) ;
//--- Comparison Operators
  public : GGS_bool _operator_isEqual (const GGS_lexicalRepeatInstructionList & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalRepeatInstructionList & inOperand) const ;
//--- Constructor 'emptyList'
  public : static GGS_lexicalRepeatInstructionList constructor_emptyList (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_lexicalRepeatInstructionList constructor_listWithValue (C_Compiler & _inLexique,
                                const GGS_lexicalInstructionList & argument_0,
                                const GGS_lexicalWhileBranchList & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operators () used for method call
  public : const GGS_lexicalRepeatInstructionList * operator () (UNUSED_LOCATION_ARGS) const { return this ;} 
//--- Method 'first'
  public : void method_first (C_Compiler & _inLexique,
                              GGS_lexicalInstructionList & _out_0,
                              GGS_lexicalWhileBranchList & _out_1
                              COMMA_LOCATION_ARGS) const ;
//--- Method 'last'
  public : void method_last (C_Compiler & _inLexique,
                             GGS_lexicalInstructionList & _out_0,
                             GGS_lexicalWhileBranchList & _out_1
                             COMMA_LOCATION_ARGS) const ;
//--- Modifier 'popLast'
  public : void modifier_popLast (C_Compiler & _inLexique,
                                GGS_lexicalInstructionList & _out_0,
                                GGS_lexicalWhileBranchList & _out_1
                                COMMA_LOCATION_ARGS) ;
//--- Modifier 'popFirst'
  public : void modifier_popFirst (C_Compiler & _inLexique,
                                 GGS_lexicalInstructionList & _out_0,
                                 GGS_lexicalWhileBranchList & _out_1
                                 COMMA_LOCATION_ARGS) ;
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lexicalInstructionList & argument_0,
                                const GGS_lexicalWhileBranchList & argument_1) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalRepeatInstructionList _operator_concat (const GGS_lexicalRepeatInstructionList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & _inLexique,
                                const GGS_lexicalInstructionList & argument_0,
                                const GGS_lexicalWhileBranchList & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lexicalInstructionList & argument_0,
                                const GGS_lexicalWhileBranchList & argument_1) ;

  protected : void _internalPrependValues (const GGS_lexicalInstructionList & argument_0,
                                const GGS_lexicalWhileBranchList & argument_1) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & _inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--- Metamodel Add method
  public : void _addModel (const GGS_lexicalRepeatInstruction & inOperand) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_lexicalWhileBranch'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalWhileBranch {
//--- Pointer to actual instance
  protected : cPtr_lexicalWhileBranch * mPointer ;
//--- Default constructor
  public : GGS_lexicalWhileBranch (void) ;
//--- Copy constructor
  public : GGS_lexicalWhileBranch (const GGS_lexicalWhileBranch &) ;
//--- Virtual destructor
  public : virtual ~GGS_lexicalWhileBranch (void) ;
//--- 'new' constructor
  public : static GGS_lexicalWhileBranch constructor_new (C_Compiler & inLexique,
                                const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalInstructionList & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Assignment operator
  public : void operator = (const GGS_lexicalWhileBranch &) ;
//--- Comparison methods
  public : GGS_bool _operator_isEqual (const GGS_lexicalWhileBranch & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalWhileBranch & inOperand) const ;

//--- _isBuilt
  public : inline bool _isBuilt (void) const { return mPointer != NULL ; }

//--- isEqualTo
  public : inline bool isEqualTo (const GGS_lexicalWhileBranch & _inOperand) const {
    return mPointer == _inOperand.mPointer ;
  }

//--- getPtr
  public : inline cPtr_lexicalWhileBranch * getPtr (void) const {
    return mPointer ;
  }

//--- drop
  public : void _drop_operation (void) ;

//--- 'description' reader
  public : GGS_string reader_description (C_Compiler & _inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;

//--- Readers
  public : GGS_lexicalExpression  reader_mWhileExpression (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_lexicalInstructionList  reader_mWhileInstructionList (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalWhileBranch * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalWhileBranch * operator () (void) const {
      return mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      list '@lexicalWhileBranchList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalWhileBranchList : public AC_galgas_list {
  public : typedef cPtr_lexicalWhileBranch element_type ;
//--- Default Constructor
  public : GGS_lexicalWhileBranchList (void) ;
//--- Copy Constructor
  public : GGS_lexicalWhileBranchList (const GGS_lexicalWhileBranchList & inSource) ;
//--- Comparison Operators
  public : GGS_bool _operator_isEqual (const GGS_lexicalWhileBranchList & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalWhileBranchList & inOperand) const ;
//--- Constructor 'emptyList'
  public : static GGS_lexicalWhileBranchList constructor_emptyList (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_lexicalWhileBranchList constructor_listWithValue (C_Compiler & _inLexique,
                                const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalInstructionList & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operators () used for method call
  public : const GGS_lexicalWhileBranchList * operator () (UNUSED_LOCATION_ARGS) const { return this ;} 
//--- Method 'first'
  public : void method_first (C_Compiler & _inLexique,
                              GGS_lexicalExpression & _out_0,
                              GGS_lexicalInstructionList & _out_1
                              COMMA_LOCATION_ARGS) const ;
//--- Method 'last'
  public : void method_last (C_Compiler & _inLexique,
                             GGS_lexicalExpression & _out_0,
                             GGS_lexicalInstructionList & _out_1
                             COMMA_LOCATION_ARGS) const ;
//--- Modifier 'popLast'
  public : void modifier_popLast (C_Compiler & _inLexique,
                                GGS_lexicalExpression & _out_0,
                                GGS_lexicalInstructionList & _out_1
                                COMMA_LOCATION_ARGS) ;
//--- Modifier 'popFirst'
  public : void modifier_popFirst (C_Compiler & _inLexique,
                                 GGS_lexicalExpression & _out_0,
                                 GGS_lexicalInstructionList & _out_1
                                 COMMA_LOCATION_ARGS) ;
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalInstructionList & argument_1) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalWhileBranchList _operator_concat (const GGS_lexicalWhileBranchList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & _inLexique,
                                const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalInstructionList & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalInstructionList & argument_1) ;

  protected : void _internalPrependValues (const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalInstructionList & argument_1) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & _inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--- Metamodel Add method
  public : void _addModel (const GGS_lexicalWhileBranch & inOperand) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_lexicalSelectInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalSelectInstruction : public GGS_lexicalInstruction {
//--- Default constructor
  public : GGS_lexicalSelectInstruction (void) ;
//--- Copy constructor
  public : GGS_lexicalSelectInstruction (const GGS_lexicalSelectInstruction &) ;
//--- Virtual destructor
  public : virtual ~GGS_lexicalSelectInstruction (void) ;
//--- 'new' constructor
  public : static GGS_lexicalSelectInstruction constructor_new (C_Compiler & inLexique,
                                const GGS_lexicalSelectBranchList & argument_0,
                                const GGS_lexicalInstructionList & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Assignment operator
  public : void operator = (const GGS_lexicalSelectInstruction &) ;
//--- Comparison methods
  public : GGS_bool _operator_isEqual (const GGS_lexicalSelectInstruction & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalSelectInstruction & inOperand) const ;

//--- 'description' reader
  public : GGS_string reader_description (C_Compiler & _inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;

//--- Readers
  public : GGS_lexicalSelectBranchList  reader_mLexicalWhileBranchList (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_lexicalInstructionList  reader_mDefaultInstructionList (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalSelectInstruction * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalSelectInstruction * operator () (void) const {
      return (cPtr_lexicalSelectInstruction *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   list '@lexicalSelectInstructionList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalSelectInstructionList : public AC_galgas_list {
  public : typedef cPtr_lexicalSelectInstruction element_type ;
//--- Default Constructor
  public : GGS_lexicalSelectInstructionList (void) ;
//--- Copy Constructor
  public : GGS_lexicalSelectInstructionList (const GGS_lexicalSelectInstructionList & inSource) ;
//--- Comparison Operators
  public : GGS_bool _operator_isEqual (const GGS_lexicalSelectInstructionList & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalSelectInstructionList & inOperand) const ;
//--- Constructor 'emptyList'
  public : static GGS_lexicalSelectInstructionList constructor_emptyList (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_lexicalSelectInstructionList constructor_listWithValue (C_Compiler & _inLexique,
                                const GGS_lexicalSelectBranchList & argument_0,
                                const GGS_lexicalInstructionList & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operators () used for method call
  public : const GGS_lexicalSelectInstructionList * operator () (UNUSED_LOCATION_ARGS) const { return this ;} 
//--- Method 'first'
  public : void method_first (C_Compiler & _inLexique,
                              GGS_lexicalSelectBranchList & _out_0,
                              GGS_lexicalInstructionList & _out_1
                              COMMA_LOCATION_ARGS) const ;
//--- Method 'last'
  public : void method_last (C_Compiler & _inLexique,
                             GGS_lexicalSelectBranchList & _out_0,
                             GGS_lexicalInstructionList & _out_1
                             COMMA_LOCATION_ARGS) const ;
//--- Modifier 'popLast'
  public : void modifier_popLast (C_Compiler & _inLexique,
                                GGS_lexicalSelectBranchList & _out_0,
                                GGS_lexicalInstructionList & _out_1
                                COMMA_LOCATION_ARGS) ;
//--- Modifier 'popFirst'
  public : void modifier_popFirst (C_Compiler & _inLexique,
                                 GGS_lexicalSelectBranchList & _out_0,
                                 GGS_lexicalInstructionList & _out_1
                                 COMMA_LOCATION_ARGS) ;
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lexicalSelectBranchList & argument_0,
                                const GGS_lexicalInstructionList & argument_1) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalSelectInstructionList _operator_concat (const GGS_lexicalSelectInstructionList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & _inLexique,
                                const GGS_lexicalSelectBranchList & argument_0,
                                const GGS_lexicalInstructionList & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lexicalSelectBranchList & argument_0,
                                const GGS_lexicalInstructionList & argument_1) ;

  protected : void _internalPrependValues (const GGS_lexicalSelectBranchList & argument_0,
                                const GGS_lexicalInstructionList & argument_1) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & _inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--- Metamodel Add method
  public : void _addModel (const GGS_lexicalSelectInstruction & inOperand) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_lexicalSelectBranch'                   *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalSelectBranch {
//--- Pointer to actual instance
  protected : cPtr_lexicalSelectBranch * mPointer ;
//--- Default constructor
  public : GGS_lexicalSelectBranch (void) ;
//--- Copy constructor
  public : GGS_lexicalSelectBranch (const GGS_lexicalSelectBranch &) ;
//--- Virtual destructor
  public : virtual ~GGS_lexicalSelectBranch (void) ;
//--- 'new' constructor
  public : static GGS_lexicalSelectBranch constructor_new (C_Compiler & inLexique,
                                const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalInstructionList & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Assignment operator
  public : void operator = (const GGS_lexicalSelectBranch &) ;
//--- Comparison methods
  public : GGS_bool _operator_isEqual (const GGS_lexicalSelectBranch & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalSelectBranch & inOperand) const ;

//--- _isBuilt
  public : inline bool _isBuilt (void) const { return mPointer != NULL ; }

//--- isEqualTo
  public : inline bool isEqualTo (const GGS_lexicalSelectBranch & _inOperand) const {
    return mPointer == _inOperand.mPointer ;
  }

//--- getPtr
  public : inline cPtr_lexicalSelectBranch * getPtr (void) const {
    return mPointer ;
  }

//--- drop
  public : void _drop_operation (void) ;

//--- 'description' reader
  public : GGS_string reader_description (C_Compiler & _inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;

//--- Readers
  public : GGS_lexicalExpression  reader_mSelectExpression (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_lexicalInstructionList  reader_mSelectInstructionList (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalSelectBranch * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalSelectBranch * operator () (void) const {
      return mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     list '@lexicalSelectBranchList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalSelectBranchList : public AC_galgas_list {
  public : typedef cPtr_lexicalSelectBranch element_type ;
//--- Default Constructor
  public : GGS_lexicalSelectBranchList (void) ;
//--- Copy Constructor
  public : GGS_lexicalSelectBranchList (const GGS_lexicalSelectBranchList & inSource) ;
//--- Comparison Operators
  public : GGS_bool _operator_isEqual (const GGS_lexicalSelectBranchList & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalSelectBranchList & inOperand) const ;
//--- Constructor 'emptyList'
  public : static GGS_lexicalSelectBranchList constructor_emptyList (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_lexicalSelectBranchList constructor_listWithValue (C_Compiler & _inLexique,
                                const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalInstructionList & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operators () used for method call
  public : const GGS_lexicalSelectBranchList * operator () (UNUSED_LOCATION_ARGS) const { return this ;} 
//--- Method 'first'
  public : void method_first (C_Compiler & _inLexique,
                              GGS_lexicalExpression & _out_0,
                              GGS_lexicalInstructionList & _out_1
                              COMMA_LOCATION_ARGS) const ;
//--- Method 'last'
  public : void method_last (C_Compiler & _inLexique,
                             GGS_lexicalExpression & _out_0,
                             GGS_lexicalInstructionList & _out_1
                             COMMA_LOCATION_ARGS) const ;
//--- Modifier 'popLast'
  public : void modifier_popLast (C_Compiler & _inLexique,
                                GGS_lexicalExpression & _out_0,
                                GGS_lexicalInstructionList & _out_1
                                COMMA_LOCATION_ARGS) ;
//--- Modifier 'popFirst'
  public : void modifier_popFirst (C_Compiler & _inLexique,
                                 GGS_lexicalExpression & _out_0,
                                 GGS_lexicalInstructionList & _out_1
                                 COMMA_LOCATION_ARGS) ;
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalInstructionList & argument_1) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalSelectBranchList _operator_concat (const GGS_lexicalSelectBranchList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & _inLexique,
                                const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalInstructionList & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalInstructionList & argument_1) ;

  protected : void _internalPrependValues (const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalInstructionList & argument_1) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & _inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--- Metamodel Add method
  public : void _addModel (const GGS_lexicalSelectBranch & inOperand) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_lexicalActionInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalActionInstruction : public GGS_lexicalInstruction {
//--- Default constructor
  public : GGS_lexicalActionInstruction (void) ;
//--- Copy constructor
  public : GGS_lexicalActionInstruction (const GGS_lexicalActionInstruction &) ;
//--- Virtual destructor
  public : virtual ~GGS_lexicalActionInstruction (void) ;
//--- 'new' constructor
  public : static GGS_lexicalActionInstruction constructor_new (C_Compiler & inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lexicalActualArgumentList & argument_1,
                                const GGS_lstringlist & argument_2
                                COMMA_LOCATION_ARGS) ;
//--- Assignment operator
  public : void operator = (const GGS_lexicalActionInstruction &) ;
//--- Comparison methods
  public : GGS_bool _operator_isEqual (const GGS_lexicalActionInstruction & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalActionInstruction & inOperand) const ;

//--- 'description' reader
  public : GGS_string reader_description (C_Compiler & _inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;

//--- Readers
  public : GGS_lstring  reader_mActionName (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_lexicalActualArgumentList  reader_mActualArgumentList (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_lstringlist  reader_mErrorMessageList (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalActionInstruction * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalActionInstruction * operator () (void) const {
      return (cPtr_lexicalActionInstruction *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   list '@lexicalActionInstructionList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalActionInstructionList : public AC_galgas_list {
  public : typedef cPtr_lexicalActionInstruction element_type ;
//--- Default Constructor
  public : GGS_lexicalActionInstructionList (void) ;
//--- Copy Constructor
  public : GGS_lexicalActionInstructionList (const GGS_lexicalActionInstructionList & inSource) ;
//--- Comparison Operators
  public : GGS_bool _operator_isEqual (const GGS_lexicalActionInstructionList & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalActionInstructionList & inOperand) const ;
//--- Constructor 'emptyList'
  public : static GGS_lexicalActionInstructionList constructor_emptyList (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_lexicalActionInstructionList constructor_listWithValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lexicalActualArgumentList & argument_1,
                                const GGS_lstringlist & argument_2
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operators () used for method call
  public : const GGS_lexicalActionInstructionList * operator () (UNUSED_LOCATION_ARGS) const { return this ;} 
//--- Method 'first'
  public : void method_first (C_Compiler & _inLexique,
                              GGS_lstring & _out_0,
                              GGS_lexicalActualArgumentList & _out_1,
                              GGS_lstringlist & _out_2
                              COMMA_LOCATION_ARGS) const ;
//--- Method 'last'
  public : void method_last (C_Compiler & _inLexique,
                             GGS_lstring & _out_0,
                             GGS_lexicalActualArgumentList & _out_1,
                             GGS_lstringlist & _out_2
                             COMMA_LOCATION_ARGS) const ;
//--- Modifier 'popLast'
  public : void modifier_popLast (C_Compiler & _inLexique,
                                GGS_lstring & _out_0,
                                GGS_lexicalActualArgumentList & _out_1,
                                GGS_lstringlist & _out_2
                                COMMA_LOCATION_ARGS) ;
//--- Modifier 'popFirst'
  public : void modifier_popFirst (C_Compiler & _inLexique,
                                 GGS_lstring & _out_0,
                                 GGS_lexicalActualArgumentList & _out_1,
                                 GGS_lstringlist & _out_2
                                 COMMA_LOCATION_ARGS) ;
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lexicalActualArgumentList & argument_1,
                                const GGS_lstringlist & argument_2) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalActionInstructionList _operator_concat (const GGS_lexicalActionInstructionList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lexicalActualArgumentList & argument_1,
                                const GGS_lstringlist & argument_2
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lstring & argument_0,
                                const GGS_lexicalActualArgumentList & argument_1,
                                const GGS_lstringlist & argument_2) ;

  protected : void _internalPrependValues (const GGS_lstring & argument_0,
                                const GGS_lexicalActualArgumentList & argument_1,
                                const GGS_lstringlist & argument_2) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & _inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--- Metamodel Add method
  public : void _addModel (const GGS_lexicalActionInstruction & inOperand) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_lexicalActualArgument'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalActualArgument {
//--- Pointer to actual instance
  protected : cPtr_lexicalActualArgument * mPointer ;
//--- Default constructor
  public : GGS_lexicalActualArgument (void) ;
//--- Copy constructor
  public : GGS_lexicalActualArgument (const GGS_lexicalActualArgument &) ;
//--- Virtual destructor
  public : virtual ~GGS_lexicalActualArgument (void) ;
//--- Assignment operator
  public : void operator = (const GGS_lexicalActualArgument &) ;
//--- Comparison methods
  public : GGS_bool _operator_isEqual (const GGS_lexicalActualArgument & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalActualArgument & inOperand) const ;

//--- _isBuilt
  public : inline bool _isBuilt (void) const { return mPointer != NULL ; }

//--- isEqualTo
  public : inline bool isEqualTo (const GGS_lexicalActualArgument & _inOperand) const {
    return mPointer == _inOperand.mPointer ;
  }

//--- getPtr
  public : inline cPtr_lexicalActualArgument * getPtr (void) const {
    return mPointer ;
  }

//--- drop
  public : void _drop_operation (void) ;

//--- 'description' reader
  public : GGS_string reader_description (C_Compiler & _inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;

//--- Readers
//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalActualArgument * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalActualArgument * operator () (void) const {
      return mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    list '@lexicalActualArgumentList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalActualArgumentList : public AC_galgas_list {
  public : typedef cPtr_lexicalActualArgument element_type ;
//--- Default Constructor
  public : GGS_lexicalActualArgumentList (void) ;
//--- Copy Constructor
  public : GGS_lexicalActualArgumentList (const GGS_lexicalActualArgumentList & inSource) ;
//--- Comparison Operators
  public : GGS_bool _operator_isEqual (const GGS_lexicalActualArgumentList & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalActualArgumentList & inOperand) const ;
//--- Constructor 'emptyList'
  public : static GGS_lexicalActualArgumentList constructor_emptyList (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_lexicalActualArgumentList constructor_listWithValue (C_Compiler & _inLexique
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operators () used for method call
  public : const GGS_lexicalActualArgumentList * operator () (UNUSED_LOCATION_ARGS) const { return this ;} 
//--- Method 'first'
  public : void method_first (C_Compiler & _inLexique
                              COMMA_LOCATION_ARGS) const ;
//--- Method 'last'
  public : void method_last (C_Compiler & _inLexique
                             COMMA_LOCATION_ARGS) const ;
//--- Modifier 'popLast'
  public : void modifier_popLast (C_Compiler & _inLexique
                                COMMA_LOCATION_ARGS) ;
//--- Modifier 'popFirst'
  public : void modifier_popFirst (C_Compiler & _inLexique
                                 COMMA_LOCATION_ARGS) ;
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation () ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalActualArgumentList _operator_concat (const GGS_lexicalActualArgumentList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & _inLexique
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues () ;

  protected : void _internalPrependValues () ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & _inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--- Metamodel Add method
  public : void _addModel (const GGS_lexicalActualArgument & inOperand) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_lexicalAttributeArgument'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalAttributeArgument : public GGS_lexicalActualArgument {
//--- Default constructor
  public : GGS_lexicalAttributeArgument (void) ;
//--- Copy constructor
  public : GGS_lexicalAttributeArgument (const GGS_lexicalAttributeArgument &) ;
//--- Virtual destructor
  public : virtual ~GGS_lexicalAttributeArgument (void) ;
//--- 'new' constructor
  public : static GGS_lexicalAttributeArgument constructor_new (C_Compiler & inLexique,
                                const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- Assignment operator
  public : void operator = (const GGS_lexicalAttributeArgument &) ;
//--- Comparison methods
  public : GGS_bool _operator_isEqual (const GGS_lexicalAttributeArgument & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalAttributeArgument & inOperand) const ;

//--- 'description' reader
  public : GGS_string reader_description (C_Compiler & _inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;

//--- Readers
  public : GGS_lstring  reader_mAttributeName (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalAttributeArgument * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalAttributeArgument * operator () (void) const {
      return (cPtr_lexicalAttributeArgument *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   list '@lexicalAttributeArgumentList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalAttributeArgumentList : public AC_galgas_list {
  public : typedef cPtr_lexicalAttributeArgument element_type ;
//--- Default Constructor
  public : GGS_lexicalAttributeArgumentList (void) ;
//--- Copy Constructor
  public : GGS_lexicalAttributeArgumentList (const GGS_lexicalAttributeArgumentList & inSource) ;
//--- Comparison Operators
  public : GGS_bool _operator_isEqual (const GGS_lexicalAttributeArgumentList & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalAttributeArgumentList & inOperand) const ;
//--- Constructor 'emptyList'
  public : static GGS_lexicalAttributeArgumentList constructor_emptyList (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_lexicalAttributeArgumentList constructor_listWithValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operators () used for method call
  public : const GGS_lexicalAttributeArgumentList * operator () (UNUSED_LOCATION_ARGS) const { return this ;} 
//--- Method 'first'
  public : void method_first (C_Compiler & _inLexique,
                              GGS_lstring & _out_0
                              COMMA_LOCATION_ARGS) const ;
//--- Method 'last'
  public : void method_last (C_Compiler & _inLexique,
                             GGS_lstring & _out_0
                             COMMA_LOCATION_ARGS) const ;
//--- Modifier 'popLast'
  public : void modifier_popLast (C_Compiler & _inLexique,
                                GGS_lstring & _out_0
                                COMMA_LOCATION_ARGS) ;
//--- Modifier 'popFirst'
  public : void modifier_popFirst (C_Compiler & _inLexique,
                                 GGS_lstring & _out_0
                                 COMMA_LOCATION_ARGS) ;
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lstring & argument_0) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalAttributeArgumentList _operator_concat (const GGS_lexicalAttributeArgumentList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lstring & argument_0) ;

  protected : void _internalPrependValues (const GGS_lstring & argument_0) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & _inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--- Metamodel Add method
  public : void _addModel (const GGS_lexicalAttributeArgument & inOperand) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_lexicalCharacterArgument'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalCharacterArgument : public GGS_lexicalActualArgument {
//--- Default constructor
  public : GGS_lexicalCharacterArgument (void) ;
//--- Copy constructor
  public : GGS_lexicalCharacterArgument (const GGS_lexicalCharacterArgument &) ;
//--- Virtual destructor
  public : virtual ~GGS_lexicalCharacterArgument (void) ;
//--- 'new' constructor
  public : static GGS_lexicalCharacterArgument constructor_new (C_Compiler & inLexique,
                                const GGS_lchar & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- Assignment operator
  public : void operator = (const GGS_lexicalCharacterArgument &) ;
//--- Comparison methods
  public : GGS_bool _operator_isEqual (const GGS_lexicalCharacterArgument & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalCharacterArgument & inOperand) const ;

//--- 'description' reader
  public : GGS_string reader_description (C_Compiler & _inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;

//--- Readers
  public : GGS_lchar  reader_mCharacter (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalCharacterArgument * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalCharacterArgument * operator () (void) const {
      return (cPtr_lexicalCharacterArgument *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   list '@lexicalCharacterArgumentList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalCharacterArgumentList : public AC_galgas_list {
  public : typedef cPtr_lexicalCharacterArgument element_type ;
//--- Default Constructor
  public : GGS_lexicalCharacterArgumentList (void) ;
//--- Copy Constructor
  public : GGS_lexicalCharacterArgumentList (const GGS_lexicalCharacterArgumentList & inSource) ;
//--- Comparison Operators
  public : GGS_bool _operator_isEqual (const GGS_lexicalCharacterArgumentList & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalCharacterArgumentList & inOperand) const ;
//--- Constructor 'emptyList'
  public : static GGS_lexicalCharacterArgumentList constructor_emptyList (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_lexicalCharacterArgumentList constructor_listWithValue (C_Compiler & _inLexique,
                                const GGS_lchar & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operators () used for method call
  public : const GGS_lexicalCharacterArgumentList * operator () (UNUSED_LOCATION_ARGS) const { return this ;} 
//--- Method 'first'
  public : void method_first (C_Compiler & _inLexique,
                              GGS_lchar & _out_0
                              COMMA_LOCATION_ARGS) const ;
//--- Method 'last'
  public : void method_last (C_Compiler & _inLexique,
                             GGS_lchar & _out_0
                             COMMA_LOCATION_ARGS) const ;
//--- Modifier 'popLast'
  public : void modifier_popLast (C_Compiler & _inLexique,
                                GGS_lchar & _out_0
                                COMMA_LOCATION_ARGS) ;
//--- Modifier 'popFirst'
  public : void modifier_popFirst (C_Compiler & _inLexique,
                                 GGS_lchar & _out_0
                                 COMMA_LOCATION_ARGS) ;
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lchar & argument_0) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalCharacterArgumentList _operator_concat (const GGS_lexicalCharacterArgumentList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & _inLexique,
                                const GGS_lchar & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lchar & argument_0) ;

  protected : void _internalPrependValues (const GGS_lchar & argument_0) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & _inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--- Metamodel Add method
  public : void _addModel (const GGS_lexicalCharacterArgument & inOperand) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_lexicalCurrentCharacterArgument'             *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalCurrentCharacterArgument : public GGS_lexicalActualArgument {
//--- Default constructor
  public : GGS_lexicalCurrentCharacterArgument (void) ;
//--- Copy constructor
  public : GGS_lexicalCurrentCharacterArgument (const GGS_lexicalCurrentCharacterArgument &) ;
//--- Virtual destructor
  public : virtual ~GGS_lexicalCurrentCharacterArgument (void) ;
//--- 'new' constructor
  public : static GGS_lexicalCurrentCharacterArgument constructor_new (C_Compiler & inLexique
                                COMMA_LOCATION_ARGS) ;
//--- Assignment operator
  public : void operator = (const GGS_lexicalCurrentCharacterArgument &) ;
//--- Comparison methods
  public : GGS_bool _operator_isEqual (const GGS_lexicalCurrentCharacterArgument & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalCurrentCharacterArgument & inOperand) const ;

//--- 'description' reader
  public : GGS_string reader_description (C_Compiler & _inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;

//--- Readers
//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalCurrentCharacterArgument * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalCurrentCharacterArgument * operator () (void) const {
      return (cPtr_lexicalCurrentCharacterArgument *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//               list '@lexicalCurrentCharacterArgumentList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalCurrentCharacterArgumentList : public AC_galgas_list {
  public : typedef cPtr_lexicalCurrentCharacterArgument element_type ;
//--- Default Constructor
  public : GGS_lexicalCurrentCharacterArgumentList (void) ;
//--- Copy Constructor
  public : GGS_lexicalCurrentCharacterArgumentList (const GGS_lexicalCurrentCharacterArgumentList & inSource) ;
//--- Comparison Operators
  public : GGS_bool _operator_isEqual (const GGS_lexicalCurrentCharacterArgumentList & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalCurrentCharacterArgumentList & inOperand) const ;
//--- Constructor 'emptyList'
  public : static GGS_lexicalCurrentCharacterArgumentList constructor_emptyList (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_lexicalCurrentCharacterArgumentList constructor_listWithValue (C_Compiler & _inLexique
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operators () used for method call
  public : const GGS_lexicalCurrentCharacterArgumentList * operator () (UNUSED_LOCATION_ARGS) const { return this ;} 
//--- Method 'first'
  public : void method_first (C_Compiler & _inLexique
                              COMMA_LOCATION_ARGS) const ;
//--- Method 'last'
  public : void method_last (C_Compiler & _inLexique
                             COMMA_LOCATION_ARGS) const ;
//--- Modifier 'popLast'
  public : void modifier_popLast (C_Compiler & _inLexique
                                COMMA_LOCATION_ARGS) ;
//--- Modifier 'popFirst'
  public : void modifier_popFirst (C_Compiler & _inLexique
                                 COMMA_LOCATION_ARGS) ;
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation () ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalCurrentCharacterArgumentList _operator_concat (const GGS_lexicalCurrentCharacterArgumentList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & _inLexique
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues () ;

  protected : void _internalPrependValues () ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & _inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--- Metamodel Add method
  public : void _addModel (const GGS_lexicalCurrentCharacterArgument & inOperand) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_lexicalFunctionArgument'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalFunctionArgument : public GGS_lexicalActualArgument {
//--- Default constructor
  public : GGS_lexicalFunctionArgument (void) ;
//--- Copy constructor
  public : GGS_lexicalFunctionArgument (const GGS_lexicalFunctionArgument &) ;
//--- Virtual destructor
  public : virtual ~GGS_lexicalFunctionArgument (void) ;
//--- 'new' constructor
  public : static GGS_lexicalFunctionArgument constructor_new (C_Compiler & inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lexicalActualArgumentList & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Assignment operator
  public : void operator = (const GGS_lexicalFunctionArgument &) ;
//--- Comparison methods
  public : GGS_bool _operator_isEqual (const GGS_lexicalFunctionArgument & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalFunctionArgument & inOperand) const ;

//--- 'description' reader
  public : GGS_string reader_description (C_Compiler & _inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;

//--- Readers
  public : GGS_lstring  reader_mFunctionName (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_lexicalActualArgumentList  reader_mFunctionActualArgumentList (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalFunctionArgument * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalFunctionArgument * operator () (void) const {
      return (cPtr_lexicalFunctionArgument *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   list '@lexicalFunctionArgumentList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalFunctionArgumentList : public AC_galgas_list {
  public : typedef cPtr_lexicalFunctionArgument element_type ;
//--- Default Constructor
  public : GGS_lexicalFunctionArgumentList (void) ;
//--- Copy Constructor
  public : GGS_lexicalFunctionArgumentList (const GGS_lexicalFunctionArgumentList & inSource) ;
//--- Comparison Operators
  public : GGS_bool _operator_isEqual (const GGS_lexicalFunctionArgumentList & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalFunctionArgumentList & inOperand) const ;
//--- Constructor 'emptyList'
  public : static GGS_lexicalFunctionArgumentList constructor_emptyList (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_lexicalFunctionArgumentList constructor_listWithValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lexicalActualArgumentList & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operators () used for method call
  public : const GGS_lexicalFunctionArgumentList * operator () (UNUSED_LOCATION_ARGS) const { return this ;} 
//--- Method 'first'
  public : void method_first (C_Compiler & _inLexique,
                              GGS_lstring & _out_0,
                              GGS_lexicalActualArgumentList & _out_1
                              COMMA_LOCATION_ARGS) const ;
//--- Method 'last'
  public : void method_last (C_Compiler & _inLexique,
                             GGS_lstring & _out_0,
                             GGS_lexicalActualArgumentList & _out_1
                             COMMA_LOCATION_ARGS) const ;
//--- Modifier 'popLast'
  public : void modifier_popLast (C_Compiler & _inLexique,
                                GGS_lstring & _out_0,
                                GGS_lexicalActualArgumentList & _out_1
                                COMMA_LOCATION_ARGS) ;
//--- Modifier 'popFirst'
  public : void modifier_popFirst (C_Compiler & _inLexique,
                                 GGS_lstring & _out_0,
                                 GGS_lexicalActualArgumentList & _out_1
                                 COMMA_LOCATION_ARGS) ;
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lexicalActualArgumentList & argument_1) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalFunctionArgumentList _operator_concat (const GGS_lexicalFunctionArgumentList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lexicalActualArgumentList & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lstring & argument_0,
                                const GGS_lexicalActualArgumentList & argument_1) ;

  protected : void _internalPrependValues (const GGS_lstring & argument_0,
                                const GGS_lexicalActualArgumentList & argument_1) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & _inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--- Metamodel Add method
  public : void _addModel (const GGS_lexicalFunctionArgument & inOperand) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_lexicalDropInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalDropInstruction : public GGS_lexicalInstruction {
//--- Default constructor
  public : GGS_lexicalDropInstruction (void) ;
//--- Copy constructor
  public : GGS_lexicalDropInstruction (const GGS_lexicalDropInstruction &) ;
//--- Virtual destructor
  public : virtual ~GGS_lexicalDropInstruction (void) ;
//--- 'new' constructor
  public : static GGS_lexicalDropInstruction constructor_new (C_Compiler & inLexique,
                                const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- Assignment operator
  public : void operator = (const GGS_lexicalDropInstruction &) ;
//--- Comparison methods
  public : GGS_bool _operator_isEqual (const GGS_lexicalDropInstruction & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalDropInstruction & inOperand) const ;

//--- 'description' reader
  public : GGS_string reader_description (C_Compiler & _inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;

//--- Readers
  public : GGS_lstring  reader_mTerminalName (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalDropInstruction * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalDropInstruction * operator () (void) const {
      return (cPtr_lexicalDropInstruction *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    list '@lexicalDropInstructionList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalDropInstructionList : public AC_galgas_list {
  public : typedef cPtr_lexicalDropInstruction element_type ;
//--- Default Constructor
  public : GGS_lexicalDropInstructionList (void) ;
//--- Copy Constructor
  public : GGS_lexicalDropInstructionList (const GGS_lexicalDropInstructionList & inSource) ;
//--- Comparison Operators
  public : GGS_bool _operator_isEqual (const GGS_lexicalDropInstructionList & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalDropInstructionList & inOperand) const ;
//--- Constructor 'emptyList'
  public : static GGS_lexicalDropInstructionList constructor_emptyList (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_lexicalDropInstructionList constructor_listWithValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operators () used for method call
  public : const GGS_lexicalDropInstructionList * operator () (UNUSED_LOCATION_ARGS) const { return this ;} 
//--- Method 'first'
  public : void method_first (C_Compiler & _inLexique,
                              GGS_lstring & _out_0
                              COMMA_LOCATION_ARGS) const ;
//--- Method 'last'
  public : void method_last (C_Compiler & _inLexique,
                             GGS_lstring & _out_0
                             COMMA_LOCATION_ARGS) const ;
//--- Modifier 'popLast'
  public : void modifier_popLast (C_Compiler & _inLexique,
                                GGS_lstring & _out_0
                                COMMA_LOCATION_ARGS) ;
//--- Modifier 'popFirst'
  public : void modifier_popFirst (C_Compiler & _inLexique,
                                 GGS_lstring & _out_0
                                 COMMA_LOCATION_ARGS) ;
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lstring & argument_0) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalDropInstructionList _operator_concat (const GGS_lexicalDropInstructionList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lstring & argument_0) ;

  protected : void _internalPrependValues (const GGS_lstring & argument_0) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & _inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--- Metamodel Add method
  public : void _addModel (const GGS_lexicalDropInstruction & inOperand) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_lexicalErrorInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalErrorInstruction : public GGS_lexicalInstruction {
//--- Default constructor
  public : GGS_lexicalErrorInstruction (void) ;
//--- Copy constructor
  public : GGS_lexicalErrorInstruction (const GGS_lexicalErrorInstruction &) ;
//--- Virtual destructor
  public : virtual ~GGS_lexicalErrorInstruction (void) ;
//--- 'new' constructor
  public : static GGS_lexicalErrorInstruction constructor_new (C_Compiler & inLexique,
                                const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- Assignment operator
  public : void operator = (const GGS_lexicalErrorInstruction &) ;
//--- Comparison methods
  public : GGS_bool _operator_isEqual (const GGS_lexicalErrorInstruction & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalErrorInstruction & inOperand) const ;

//--- 'description' reader
  public : GGS_string reader_description (C_Compiler & _inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;

//--- Readers
  public : GGS_lstring  reader_mErrorMessageName (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalErrorInstruction * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalErrorInstruction * operator () (void) const {
      return (cPtr_lexicalErrorInstruction *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   list '@lexicalErrorInstructionList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalErrorInstructionList : public AC_galgas_list {
  public : typedef cPtr_lexicalErrorInstruction element_type ;
//--- Default Constructor
  public : GGS_lexicalErrorInstructionList (void) ;
//--- Copy Constructor
  public : GGS_lexicalErrorInstructionList (const GGS_lexicalErrorInstructionList & inSource) ;
//--- Comparison Operators
  public : GGS_bool _operator_isEqual (const GGS_lexicalErrorInstructionList & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalErrorInstructionList & inOperand) const ;
//--- Constructor 'emptyList'
  public : static GGS_lexicalErrorInstructionList constructor_emptyList (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_lexicalErrorInstructionList constructor_listWithValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operators () used for method call
  public : const GGS_lexicalErrorInstructionList * operator () (UNUSED_LOCATION_ARGS) const { return this ;} 
//--- Method 'first'
  public : void method_first (C_Compiler & _inLexique,
                              GGS_lstring & _out_0
                              COMMA_LOCATION_ARGS) const ;
//--- Method 'last'
  public : void method_last (C_Compiler & _inLexique,
                             GGS_lstring & _out_0
                             COMMA_LOCATION_ARGS) const ;
//--- Modifier 'popLast'
  public : void modifier_popLast (C_Compiler & _inLexique,
                                GGS_lstring & _out_0
                                COMMA_LOCATION_ARGS) ;
//--- Modifier 'popFirst'
  public : void modifier_popFirst (C_Compiler & _inLexique,
                                 GGS_lstring & _out_0
                                 COMMA_LOCATION_ARGS) ;
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lstring & argument_0) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalErrorInstructionList _operator_concat (const GGS_lexicalErrorInstructionList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lstring & argument_0) ;

  protected : void _internalPrependValues (const GGS_lstring & argument_0) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & _inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--- Metamodel Add method
  public : void _addModel (const GGS_lexicalErrorInstruction & inOperand) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_lexicalTagInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalTagInstruction : public GGS_lexicalInstruction {
//--- Default constructor
  public : GGS_lexicalTagInstruction (void) ;
//--- Copy constructor
  public : GGS_lexicalTagInstruction (const GGS_lexicalTagInstruction &) ;
//--- Virtual destructor
  public : virtual ~GGS_lexicalTagInstruction (void) ;
//--- 'new' constructor
  public : static GGS_lexicalTagInstruction constructor_new (C_Compiler & inLexique,
                                const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- Assignment operator
  public : void operator = (const GGS_lexicalTagInstruction &) ;
//--- Comparison methods
  public : GGS_bool _operator_isEqual (const GGS_lexicalTagInstruction & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalTagInstruction & inOperand) const ;

//--- 'description' reader
  public : GGS_string reader_description (C_Compiler & _inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;

//--- Readers
  public : GGS_lstring  reader_mTagName (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalTagInstruction * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalTagInstruction * operator () (void) const {
      return (cPtr_lexicalTagInstruction *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    list '@lexicalTagInstructionList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalTagInstructionList : public AC_galgas_list {
  public : typedef cPtr_lexicalTagInstruction element_type ;
//--- Default Constructor
  public : GGS_lexicalTagInstructionList (void) ;
//--- Copy Constructor
  public : GGS_lexicalTagInstructionList (const GGS_lexicalTagInstructionList & inSource) ;
//--- Comparison Operators
  public : GGS_bool _operator_isEqual (const GGS_lexicalTagInstructionList & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalTagInstructionList & inOperand) const ;
//--- Constructor 'emptyList'
  public : static GGS_lexicalTagInstructionList constructor_emptyList (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_lexicalTagInstructionList constructor_listWithValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operators () used for method call
  public : const GGS_lexicalTagInstructionList * operator () (UNUSED_LOCATION_ARGS) const { return this ;} 
//--- Method 'first'
  public : void method_first (C_Compiler & _inLexique,
                              GGS_lstring & _out_0
                              COMMA_LOCATION_ARGS) const ;
//--- Method 'last'
  public : void method_last (C_Compiler & _inLexique,
                             GGS_lstring & _out_0
                             COMMA_LOCATION_ARGS) const ;
//--- Modifier 'popLast'
  public : void modifier_popLast (C_Compiler & _inLexique,
                                GGS_lstring & _out_0
                                COMMA_LOCATION_ARGS) ;
//--- Modifier 'popFirst'
  public : void modifier_popFirst (C_Compiler & _inLexique,
                                 GGS_lstring & _out_0
                                 COMMA_LOCATION_ARGS) ;
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lstring & argument_0) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalTagInstructionList _operator_concat (const GGS_lexicalTagInstructionList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lstring & argument_0) ;

  protected : void _internalPrependValues (const GGS_lstring & argument_0) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & _inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--- Metamodel Add method
  public : void _addModel (const GGS_lexicalTagInstruction & inOperand) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_lexicalRewindInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalRewindInstruction : public GGS_lexicalInstruction {
//--- Default constructor
  public : GGS_lexicalRewindInstruction (void) ;
//--- Copy constructor
  public : GGS_lexicalRewindInstruction (const GGS_lexicalRewindInstruction &) ;
//--- Virtual destructor
  public : virtual ~GGS_lexicalRewindInstruction (void) ;
//--- 'new' constructor
  public : static GGS_lexicalRewindInstruction constructor_new (C_Compiler & inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Assignment operator
  public : void operator = (const GGS_lexicalRewindInstruction &) ;
//--- Comparison methods
  public : GGS_bool _operator_isEqual (const GGS_lexicalRewindInstruction & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalRewindInstruction & inOperand) const ;

//--- 'description' reader
  public : GGS_string reader_description (C_Compiler & _inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;

//--- Readers
  public : GGS_lstring  reader_mTagName (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_lstring  reader_mTerminalName (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalRewindInstruction * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalRewindInstruction * operator () (void) const {
      return (cPtr_lexicalRewindInstruction *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   list '@lexicalRewindInstructionList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalRewindInstructionList : public AC_galgas_list {
  public : typedef cPtr_lexicalRewindInstruction element_type ;
//--- Default Constructor
  public : GGS_lexicalRewindInstructionList (void) ;
//--- Copy Constructor
  public : GGS_lexicalRewindInstructionList (const GGS_lexicalRewindInstructionList & inSource) ;
//--- Comparison Operators
  public : GGS_bool _operator_isEqual (const GGS_lexicalRewindInstructionList & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalRewindInstructionList & inOperand) const ;
//--- Constructor 'emptyList'
  public : static GGS_lexicalRewindInstructionList constructor_emptyList (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_lexicalRewindInstructionList constructor_listWithValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operators () used for method call
  public : const GGS_lexicalRewindInstructionList * operator () (UNUSED_LOCATION_ARGS) const { return this ;} 
//--- Method 'first'
  public : void method_first (C_Compiler & _inLexique,
                              GGS_lstring & _out_0,
                              GGS_lstring & _out_1
                              COMMA_LOCATION_ARGS) const ;
//--- Method 'last'
  public : void method_last (C_Compiler & _inLexique,
                             GGS_lstring & _out_0,
                             GGS_lstring & _out_1
                             COMMA_LOCATION_ARGS) const ;
//--- Modifier 'popLast'
  public : void modifier_popLast (C_Compiler & _inLexique,
                                GGS_lstring & _out_0,
                                GGS_lstring & _out_1
                                COMMA_LOCATION_ARGS) ;
//--- Modifier 'popFirst'
  public : void modifier_popFirst (C_Compiler & _inLexique,
                                 GGS_lstring & _out_0,
                                 GGS_lstring & _out_1
                                 COMMA_LOCATION_ARGS) ;
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalRewindInstructionList _operator_concat (const GGS_lexicalRewindInstructionList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) ;

  protected : void _internalPrependValues (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & _inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--- Metamodel Add method
  public : void _addModel (const GGS_lexicalRewindInstruction & inOperand) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_lexicalLogInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalLogInstruction : public GGS_lexicalInstruction {
//--- Default constructor
  public : GGS_lexicalLogInstruction (void) ;
//--- Copy constructor
  public : GGS_lexicalLogInstruction (const GGS_lexicalLogInstruction &) ;
//--- Virtual destructor
  public : virtual ~GGS_lexicalLogInstruction (void) ;
//--- 'new' constructor
  public : static GGS_lexicalLogInstruction constructor_new (C_Compiler & inLexique
                                COMMA_LOCATION_ARGS) ;
//--- Assignment operator
  public : void operator = (const GGS_lexicalLogInstruction &) ;
//--- Comparison methods
  public : GGS_bool _operator_isEqual (const GGS_lexicalLogInstruction & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalLogInstruction & inOperand) const ;

//--- 'description' reader
  public : GGS_string reader_description (C_Compiler & _inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;

//--- Readers
//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalLogInstruction * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalLogInstruction * operator () (void) const {
      return (cPtr_lexicalLogInstruction *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    list '@lexicalLogInstructionList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalLogInstructionList : public AC_galgas_list {
  public : typedef cPtr_lexicalLogInstruction element_type ;
//--- Default Constructor
  public : GGS_lexicalLogInstructionList (void) ;
//--- Copy Constructor
  public : GGS_lexicalLogInstructionList (const GGS_lexicalLogInstructionList & inSource) ;
//--- Comparison Operators
  public : GGS_bool _operator_isEqual (const GGS_lexicalLogInstructionList & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalLogInstructionList & inOperand) const ;
//--- Constructor 'emptyList'
  public : static GGS_lexicalLogInstructionList constructor_emptyList (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_lexicalLogInstructionList constructor_listWithValue (C_Compiler & _inLexique
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operators () used for method call
  public : const GGS_lexicalLogInstructionList * operator () (UNUSED_LOCATION_ARGS) const { return this ;} 
//--- Method 'first'
  public : void method_first (C_Compiler & _inLexique
                              COMMA_LOCATION_ARGS) const ;
//--- Method 'last'
  public : void method_last (C_Compiler & _inLexique
                             COMMA_LOCATION_ARGS) const ;
//--- Modifier 'popLast'
  public : void modifier_popLast (C_Compiler & _inLexique
                                COMMA_LOCATION_ARGS) ;
//--- Modifier 'popFirst'
  public : void modifier_popFirst (C_Compiler & _inLexique
                                 COMMA_LOCATION_ARGS) ;
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation () ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalLogInstructionList _operator_concat (const GGS_lexicalLogInstructionList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & _inLexique
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues () ;

  protected : void _internalPrependValues () ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & _inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--- Metamodel Add method
  public : void _addModel (const GGS_lexicalLogInstruction & inOperand) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@lexiqueComponentRootList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexiqueComponentRoot : public C_GGS_MetamodelEntity {
//--- Attributes
  public : GGS_lstring  mLexiqueComponentName ;
  public : GGS_lexicalAttributeList  mLexicalAttributeList ;
  public : GGS_lexicalStyleList  mLexicalStyleList ;
  public : GGS_terminalDeclarationList  mTerminalDeclarationList ;
  public : GGS_lexicalErrorMessageDeclarationList  mLexicalErrorMessageDeclarationList ;
  public : GGS_lexicalListDeclarationList  mLexicalListDeclarationList ;
  public : GGS_lexicalImplicitRuleList  mLexicalImplicitRuleList ;
  public : GGS_lexicalExplicitRuleList  mLexicalExplicitRuleList ;
//--- Constructor
  public : cPtr_lexiqueComponentRoot (const GGS_lstring & ,
                                const GGS_lexicalAttributeList & ,
                                const GGS_lexicalStyleList & ,
                                const GGS_terminalDeclarationList & ,
                                const GGS_lexicalErrorMessageDeclarationList & ,
                                const GGS_lexicalListDeclarationList & ,
                                const GGS_lexicalImplicitRuleList & ,
                                const GGS_lexicalExplicitRuleList & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline cPtr_lexiqueComponentRoot * nextObject (void) const {
    return (cPtr_lexiqueComponentRoot *) internalNextItem () ;
  }

//--- Access to previous
  public : inline cPtr_lexiqueComponentRoot * previousObject (void) const {
    return (cPtr_lexiqueComponentRoot *) internalPreviousItem () ;
  }

//--- Element comparison
  public : bool isEqualToObject ( const  cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & _inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Metamodel Index
  public : virtual uint32 _metamodelIndex (void) const ;

//--- Metamodel Class ID
  public : virtual uint32 _metamodelClassID (void) const ;

//--- 'clone' virtual method
  public : virtual cPtr_lexiqueComponentRoot * _cloneObject (void) const ;

//--- Friend class declarations
  friend class GGS_lexiqueComponentRootList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@lexicalImplicitRuleList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalImplicitRule : public C_GGS_MetamodelEntity {
//--- Attributes
  public : GGS_lstring  mListName ;
//--- Constructor
  public : cPtr_lexicalImplicitRule (const GGS_lstring & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline cPtr_lexicalImplicitRule * nextObject (void) const {
    return (cPtr_lexicalImplicitRule *) internalNextItem () ;
  }

//--- Access to previous
  public : inline cPtr_lexicalImplicitRule * previousObject (void) const {
    return (cPtr_lexicalImplicitRule *) internalPreviousItem () ;
  }

//--- Element comparison
  public : bool isEqualToObject ( const  cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & _inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Metamodel Index
  public : virtual uint32 _metamodelIndex (void) const ;

//--- Metamodel Class ID
  public : virtual uint32 _metamodelClassID (void) const ;

//--- 'clone' virtual method
  public : virtual cPtr_lexicalImplicitRule * _cloneObject (void) const ;

//--- Friend class declarations
  friend class GGS_lexicalImplicitRuleList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//          Element of list '@lexicalErrorMessageDeclarationList'            *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalErrorMessageDeclaration : public C_GGS_MetamodelEntity {
//--- Attributes
  public : GGS_lstring  mMessageName ;
  public : GGS_lstring  mMessageValue ;
//--- Constructor
  public : cPtr_lexicalErrorMessageDeclaration (const GGS_lstring & ,
                                const GGS_lstring & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline cPtr_lexicalErrorMessageDeclaration * nextObject (void) const {
    return (cPtr_lexicalErrorMessageDeclaration *) internalNextItem () ;
  }

//--- Access to previous
  public : inline cPtr_lexicalErrorMessageDeclaration * previousObject (void) const {
    return (cPtr_lexicalErrorMessageDeclaration *) internalPreviousItem () ;
  }

//--- Element comparison
  public : bool isEqualToObject ( const  cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & _inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Metamodel Index
  public : virtual uint32 _metamodelIndex (void) const ;

//--- Metamodel Class ID
  public : virtual uint32 _metamodelClassID (void) const ;

//--- 'clone' virtual method
  public : virtual cPtr_lexicalErrorMessageDeclaration * _cloneObject (void) const ;

//--- Friend class declarations
  friend class GGS_lexicalErrorMessageDeclarationList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@lexicalAttributeList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalAttribute : public C_GGS_MetamodelEntity {
//--- Attributes
  public : GGS_lstring  mTypeName ;
  public : GGS_lstring  mName ;
//--- Constructor
  public : cPtr_lexicalAttribute (const GGS_lstring & ,
                                const GGS_lstring & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline cPtr_lexicalAttribute * nextObject (void) const {
    return (cPtr_lexicalAttribute *) internalNextItem () ;
  }

//--- Access to previous
  public : inline cPtr_lexicalAttribute * previousObject (void) const {
    return (cPtr_lexicalAttribute *) internalPreviousItem () ;
  }

//--- Element comparison
  public : bool isEqualToObject ( const  cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & _inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Metamodel Index
  public : virtual uint32 _metamodelIndex (void) const ;

//--- Metamodel Class ID
  public : virtual uint32 _metamodelClassID (void) const ;

//--- 'clone' virtual method
  public : virtual cPtr_lexicalAttribute * _cloneObject (void) const ;

//--- Friend class declarations
  friend class GGS_lexicalAttributeList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   Element of list '@lexicalStyleList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalStyle : public C_GGS_MetamodelEntity {
//--- Attributes
  public : GGS_lstring  mName ;
  public : GGS_lstring  mComment ;
//--- Constructor
  public : cPtr_lexicalStyle (const GGS_lstring & ,
                                const GGS_lstring & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline cPtr_lexicalStyle * nextObject (void) const {
    return (cPtr_lexicalStyle *) internalNextItem () ;
  }

//--- Access to previous
  public : inline cPtr_lexicalStyle * previousObject (void) const {
    return (cPtr_lexicalStyle *) internalPreviousItem () ;
  }

//--- Element comparison
  public : bool isEqualToObject ( const  cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & _inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Metamodel Index
  public : virtual uint32 _metamodelIndex (void) const ;

//--- Metamodel Class ID
  public : virtual uint32 _metamodelClassID (void) const ;

//--- 'clone' virtual method
  public : virtual cPtr_lexicalStyle * _cloneObject (void) const ;

//--- Friend class declarations
  friend class GGS_lexicalStyleList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@terminalDeclarationList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_terminalDeclaration : public C_GGS_MetamodelEntity {
//--- Attributes
  public : GGS_lstring  mName ;
  public : GGS_lstringlist  mSentAttributeList ;
  public : GGS_lstring  mErrorMessage ;
  public : GGS_lstring  mStyle ;
//--- Constructor
  public : cPtr_terminalDeclaration (const GGS_lstring & ,
                                const GGS_lstringlist & ,
                                const GGS_lstring & ,
                                const GGS_lstring & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline cPtr_terminalDeclaration * nextObject (void) const {
    return (cPtr_terminalDeclaration *) internalNextItem () ;
  }

//--- Access to previous
  public : inline cPtr_terminalDeclaration * previousObject (void) const {
    return (cPtr_terminalDeclaration *) internalPreviousItem () ;
  }

//--- Element comparison
  public : bool isEqualToObject ( const  cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & _inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Metamodel Index
  public : virtual uint32 _metamodelIndex (void) const ;

//--- Metamodel Class ID
  public : virtual uint32 _metamodelClassID (void) const ;

//--- 'clone' virtual method
  public : virtual cPtr_terminalDeclaration * _cloneObject (void) const ;

//--- Friend class declarations
  friend class GGS_terminalDeclarationList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@lexicalListDeclarationList'                *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalListDeclaration : public C_GGS_MetamodelEntity {
//--- Attributes
  public : GGS_lstring  mName ;
  public : GGS_lstring  mStyle ;
  public : GGS_lstring  mErrorMessage ;
  public : GGS_lstringlist  mSentAttributeList ;
  public : GGS_lexicalListEntryList  mEntryList ;
//--- Constructor
  public : cPtr_lexicalListDeclaration (const GGS_lstring & ,
                                const GGS_lstring & ,
                                const GGS_lstring & ,
                                const GGS_lstringlist & ,
                                const GGS_lexicalListEntryList & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline cPtr_lexicalListDeclaration * nextObject (void) const {
    return (cPtr_lexicalListDeclaration *) internalNextItem () ;
  }

//--- Access to previous
  public : inline cPtr_lexicalListDeclaration * previousObject (void) const {
    return (cPtr_lexicalListDeclaration *) internalPreviousItem () ;
  }

//--- Element comparison
  public : bool isEqualToObject ( const  cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & _inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Metamodel Index
  public : virtual uint32 _metamodelIndex (void) const ;

//--- Metamodel Class ID
  public : virtual uint32 _metamodelClassID (void) const ;

//--- 'clone' virtual method
  public : virtual cPtr_lexicalListDeclaration * _cloneObject (void) const ;

//--- Friend class declarations
  friend class GGS_lexicalListDeclarationList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@lexicalListEntryList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalListEntry : public C_GGS_MetamodelEntity {
//--- Attributes
  public : GGS_lstring  mEntrySpelling ;
  public : GGS_lstring  mTerminalSpelling ;
//--- Constructor
  public : cPtr_lexicalListEntry (const GGS_lstring & ,
                                const GGS_lstring & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline cPtr_lexicalListEntry * nextObject (void) const {
    return (cPtr_lexicalListEntry *) internalNextItem () ;
  }

//--- Access to previous
  public : inline cPtr_lexicalListEntry * previousObject (void) const {
    return (cPtr_lexicalListEntry *) internalPreviousItem () ;
  }

//--- Element comparison
  public : bool isEqualToObject ( const  cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & _inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Metamodel Index
  public : virtual uint32 _metamodelIndex (void) const ;

//--- Metamodel Class ID
  public : virtual uint32 _metamodelClassID (void) const ;

//--- 'clone' virtual method
  public : virtual cPtr_lexicalListEntry * _cloneObject (void) const ;

//--- Friend class declarations
  friend class GGS_lexicalListEntryList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@lexicalExplicitRuleList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalExplicitRule : public C_GGS_MetamodelEntity {
//--- Attributes
  public : GGS_lexicalExpression  mLexicalRuleExpression ;
  public : GGS_lexicalInstructionList  mInstructionList ;
//--- Constructor
  public : cPtr_lexicalExplicitRule (const GGS_lexicalExpression & ,
                                const GGS_lexicalInstructionList & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline cPtr_lexicalExplicitRule * nextObject (void) const {
    return (cPtr_lexicalExplicitRule *) internalNextItem () ;
  }

//--- Access to previous
  public : inline cPtr_lexicalExplicitRule * previousObject (void) const {
    return (cPtr_lexicalExplicitRule *) internalPreviousItem () ;
  }

//--- Element comparison
  public : bool isEqualToObject ( const  cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & _inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Metamodel Index
  public : virtual uint32 _metamodelIndex (void) const ;

//--- Metamodel Class ID
  public : virtual uint32 _metamodelClassID (void) const ;

//--- 'clone' virtual method
  public : virtual cPtr_lexicalExplicitRule * _cloneObject (void) const ;

//--- Friend class declarations
  friend class GGS_lexicalExplicitRuleList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@lexicalExpressionList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalExpression : public C_GGS_MetamodelEntity {
//--- Attributes
//--- Constructor
  public : cPtr_lexicalExpression (LOCATION_ARGS) ;

//--- Access to next
  public : inline cPtr_lexicalExpression * nextObject (void) const {
    return (cPtr_lexicalExpression *) internalNextItem () ;
  }

//--- Access to previous
  public : inline cPtr_lexicalExpression * previousObject (void) const {
    return (cPtr_lexicalExpression *) internalPreviousItem () ;
  }

//--- Element comparison
  public : bool isEqualToObject ( const  cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & _inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Metamodel Index
  public : virtual uint32 _metamodelIndex (void) const ;

//--- Metamodel Class ID
  public : virtual uint32 _metamodelClassID (void) const ;

//--- 'clone' virtual method
  public : virtual cPtr_lexicalExpression * _cloneObject (void) const ;

//--- Friend class declarations
  friend class GGS_lexicalExpressionList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@lexicalOrExpressionList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalOrExpression : public cPtr_lexicalExpression {
//--- Attributes
  public : GGS_lexicalExpression  mLeftOperand ;
  public : GGS_lexicalExpression  mRightOperand ;
//--- Constructor
  public : cPtr_lexicalOrExpression (const GGS_lexicalExpression & ,
                                const GGS_lexicalExpression & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline cPtr_lexicalOrExpression * nextObject (void) const {
    return (cPtr_lexicalOrExpression *) internalNextItem () ;
  }

//--- Access to previous
  public : inline cPtr_lexicalOrExpression * previousObject (void) const {
    return (cPtr_lexicalOrExpression *) internalPreviousItem () ;
  }

//--- Element comparison
  public : bool isEqualToObject ( const  cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & _inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Metamodel Index
  public : virtual uint32 _metamodelIndex (void) const ;

//--- Metamodel Class ID
  public : virtual uint32 _metamodelClassID (void) const ;

//--- 'clone' virtual method
  public : virtual cPtr_lexicalOrExpression * _cloneObject (void) const ;

//--- Friend class declarations
  friend class GGS_lexicalOrExpressionList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@lexicalCharacterMatchList'                *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalCharacterMatch : public cPtr_lexicalExpression {
//--- Attributes
  public : GGS_lchar  mCharacter ;
//--- Constructor
  public : cPtr_lexicalCharacterMatch (const GGS_lchar & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline cPtr_lexicalCharacterMatch * nextObject (void) const {
    return (cPtr_lexicalCharacterMatch *) internalNextItem () ;
  }

//--- Access to previous
  public : inline cPtr_lexicalCharacterMatch * previousObject (void) const {
    return (cPtr_lexicalCharacterMatch *) internalPreviousItem () ;
  }

//--- Element comparison
  public : bool isEqualToObject ( const  cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & _inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Metamodel Index
  public : virtual uint32 _metamodelIndex (void) const ;

//--- Metamodel Class ID
  public : virtual uint32 _metamodelClassID (void) const ;

//--- 'clone' virtual method
  public : virtual cPtr_lexicalCharacterMatch * _cloneObject (void) const ;

//--- Friend class declarations
  friend class GGS_lexicalCharacterMatchList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//           Element of list '@lexicalCharacterIntervalMatchList'            *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalCharacterIntervalMatch : public cPtr_lexicalExpression {
//--- Attributes
  public : GGS_lchar  mLowerBound ;
  public : GGS_lchar  mUpperBound ;
//--- Constructor
  public : cPtr_lexicalCharacterIntervalMatch (const GGS_lchar & ,
                                const GGS_lchar & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline cPtr_lexicalCharacterIntervalMatch * nextObject (void) const {
    return (cPtr_lexicalCharacterIntervalMatch *) internalNextItem () ;
  }

//--- Access to previous
  public : inline cPtr_lexicalCharacterIntervalMatch * previousObject (void) const {
    return (cPtr_lexicalCharacterIntervalMatch *) internalPreviousItem () ;
  }

//--- Element comparison
  public : bool isEqualToObject ( const  cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & _inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Metamodel Index
  public : virtual uint32 _metamodelIndex (void) const ;

//--- Metamodel Class ID
  public : virtual uint32 _metamodelClassID (void) const ;

//--- 'clone' virtual method
  public : virtual cPtr_lexicalCharacterIntervalMatch * _cloneObject (void) const ;

//--- Friend class declarations
  friend class GGS_lexicalCharacterIntervalMatchList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@lexicalStringMatchList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalStringMatch : public cPtr_lexicalExpression {
//--- Attributes
  public : GGS_lstring  mString ;
//--- Constructor
  public : cPtr_lexicalStringMatch (const GGS_lstring & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline cPtr_lexicalStringMatch * nextObject (void) const {
    return (cPtr_lexicalStringMatch *) internalNextItem () ;
  }

//--- Access to previous
  public : inline cPtr_lexicalStringMatch * previousObject (void) const {
    return (cPtr_lexicalStringMatch *) internalPreviousItem () ;
  }

//--- Element comparison
  public : bool isEqualToObject ( const  cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & _inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Metamodel Index
  public : virtual uint32 _metamodelIndex (void) const ;

//--- Metamodel Class ID
  public : virtual uint32 _metamodelClassID (void) const ;

//--- 'clone' virtual method
  public : virtual cPtr_lexicalStringMatch * _cloneObject (void) const ;

//--- Friend class declarations
  friend class GGS_lexicalStringMatchList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@lexicalStringNotMatchList'                *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalStringNotMatch : public cPtr_lexicalExpression {
//--- Attributes
  public : GGS_lstring  mString ;
  public : GGS_lstring  mErrorMessage ;
//--- Constructor
  public : cPtr_lexicalStringNotMatch (const GGS_lstring & ,
                                const GGS_lstring & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline cPtr_lexicalStringNotMatch * nextObject (void) const {
    return (cPtr_lexicalStringNotMatch *) internalNextItem () ;
  }

//--- Access to previous
  public : inline cPtr_lexicalStringNotMatch * previousObject (void) const {
    return (cPtr_lexicalStringNotMatch *) internalPreviousItem () ;
  }

//--- Element comparison
  public : bool isEqualToObject ( const  cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & _inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Metamodel Index
  public : virtual uint32 _metamodelIndex (void) const ;

//--- Metamodel Class ID
  public : virtual uint32 _metamodelClassID (void) const ;

//--- 'clone' virtual method
  public : virtual cPtr_lexicalStringNotMatch * _cloneObject (void) const ;

//--- Friend class declarations
  friend class GGS_lexicalStringNotMatchList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@lexicalInstructionList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalInstruction : public C_GGS_MetamodelEntity {
//--- Attributes
//--- Constructor
  public : cPtr_lexicalInstruction (LOCATION_ARGS) ;

//--- Access to next
  public : inline cPtr_lexicalInstruction * nextObject (void) const {
    return (cPtr_lexicalInstruction *) internalNextItem () ;
  }

//--- Access to previous
  public : inline cPtr_lexicalInstruction * previousObject (void) const {
    return (cPtr_lexicalInstruction *) internalPreviousItem () ;
  }

//--- Element comparison
  public : bool isEqualToObject ( const  cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & _inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Metamodel Index
  public : virtual uint32 _metamodelIndex (void) const ;

//--- Metamodel Class ID
  public : virtual uint32 _metamodelClassID (void) const ;

//--- 'clone' virtual method
  public : virtual cPtr_lexicalInstruction * _cloneObject (void) const ;

//--- Friend class declarations
  friend class GGS_lexicalInstructionList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//         Element of list '@lexicalStructuredSendInstructionList'           *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalStructuredSendInstruction : public cPtr_lexicalInstruction {
//--- Attributes
  public : GGS_lexicalSendSearchList  mLexicalSendSearchList ;
  public : GGS_lexicalSendDefaultAction  mLexicalSendDefaultAction ;
//--- Constructor
  public : cPtr_lexicalStructuredSendInstruction (const GGS_lexicalSendSearchList & ,
                                const GGS_lexicalSendDefaultAction & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline cPtr_lexicalStructuredSendInstruction * nextObject (void) const {
    return (cPtr_lexicalStructuredSendInstruction *) internalNextItem () ;
  }

//--- Access to previous
  public : inline cPtr_lexicalStructuredSendInstruction * previousObject (void) const {
    return (cPtr_lexicalStructuredSendInstruction *) internalPreviousItem () ;
  }

//--- Element comparison
  public : bool isEqualToObject ( const  cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & _inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Metamodel Index
  public : virtual uint32 _metamodelIndex (void) const ;

//--- Metamodel Class ID
  public : virtual uint32 _metamodelClassID (void) const ;

//--- 'clone' virtual method
  public : virtual cPtr_lexicalStructuredSendInstruction * _cloneObject (void) const ;

//--- Friend class declarations
  friend class GGS_lexicalStructuredSendInstructionList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//           Element of list '@lexicalSimpleSendInstructionList'             *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalSimpleSendInstruction : public cPtr_lexicalInstruction {
//--- Attributes
  public : GGS_lstring  mSentTerminal ;
//--- Constructor
  public : cPtr_lexicalSimpleSendInstruction (const GGS_lstring & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline cPtr_lexicalSimpleSendInstruction * nextObject (void) const {
    return (cPtr_lexicalSimpleSendInstruction *) internalNextItem () ;
  }

//--- Access to previous
  public : inline cPtr_lexicalSimpleSendInstruction * previousObject (void) const {
    return (cPtr_lexicalSimpleSendInstruction *) internalPreviousItem () ;
  }

//--- Element comparison
  public : bool isEqualToObject ( const  cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & _inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Metamodel Index
  public : virtual uint32 _metamodelIndex (void) const ;

//--- Metamodel Class ID
  public : virtual uint32 _metamodelClassID (void) const ;

//--- 'clone' virtual method
  public : virtual cPtr_lexicalSimpleSendInstruction * _cloneObject (void) const ;

//--- Friend class declarations
  friend class GGS_lexicalSimpleSendInstructionList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@lexicalSendDefaultActionList'               *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalSendDefaultAction : public C_GGS_MetamodelEntity {
//--- Attributes
//--- Constructor
  public : cPtr_lexicalSendDefaultAction (LOCATION_ARGS) ;

//--- Access to next
  public : inline cPtr_lexicalSendDefaultAction * nextObject (void) const {
    return (cPtr_lexicalSendDefaultAction *) internalNextItem () ;
  }

//--- Access to previous
  public : inline cPtr_lexicalSendDefaultAction * previousObject (void) const {
    return (cPtr_lexicalSendDefaultAction *) internalPreviousItem () ;
  }

//--- Element comparison
  public : bool isEqualToObject ( const  cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & _inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Metamodel Index
  public : virtual uint32 _metamodelIndex (void) const ;

//--- Metamodel Class ID
  public : virtual uint32 _metamodelClassID (void) const ;

//--- 'clone' virtual method
  public : virtual cPtr_lexicalSendDefaultAction * _cloneObject (void) const ;

//--- Friend class declarations
  friend class GGS_lexicalSendDefaultActionList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//           Element of list '@lexicalSendTerminalByDefaultList'             *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalSendTerminalByDefault : public cPtr_lexicalSendDefaultAction {
//--- Attributes
  public : GGS_lstring  mDefaultSentTerminal ;
//--- Constructor
  public : cPtr_lexicalSendTerminalByDefault (const GGS_lstring & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline cPtr_lexicalSendTerminalByDefault * nextObject (void) const {
    return (cPtr_lexicalSendTerminalByDefault *) internalNextItem () ;
  }

//--- Access to previous
  public : inline cPtr_lexicalSendTerminalByDefault * previousObject (void) const {
    return (cPtr_lexicalSendTerminalByDefault *) internalPreviousItem () ;
  }

//--- Element comparison
  public : bool isEqualToObject ( const  cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & _inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Metamodel Index
  public : virtual uint32 _metamodelIndex (void) const ;

//--- Metamodel Class ID
  public : virtual uint32 _metamodelClassID (void) const ;

//--- 'clone' virtual method
  public : virtual cPtr_lexicalSendTerminalByDefault * _cloneObject (void) const ;

//--- Friend class declarations
  friend class GGS_lexicalSendTerminalByDefaultList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@lexicalErrorByDefaultList'                *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalErrorByDefault : public cPtr_lexicalSendDefaultAction {
//--- Attributes
  public : GGS_lstring  mDefaultErrorMessageName ;
//--- Constructor
  public : cPtr_lexicalErrorByDefault (const GGS_lstring & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline cPtr_lexicalErrorByDefault * nextObject (void) const {
    return (cPtr_lexicalErrorByDefault *) internalNextItem () ;
  }

//--- Access to previous
  public : inline cPtr_lexicalErrorByDefault * previousObject (void) const {
    return (cPtr_lexicalErrorByDefault *) internalPreviousItem () ;
  }

//--- Element comparison
  public : bool isEqualToObject ( const  cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & _inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Metamodel Index
  public : virtual uint32 _metamodelIndex (void) const ;

//--- Metamodel Class ID
  public : virtual uint32 _metamodelClassID (void) const ;

//--- 'clone' virtual method
  public : virtual cPtr_lexicalErrorByDefault * _cloneObject (void) const ;

//--- Friend class declarations
  friend class GGS_lexicalErrorByDefaultList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@lexicalSendSearchList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalSendSearch : public C_GGS_MetamodelEntity {
//--- Attributes
  public : GGS_lstring  mAttributeName ;
  public : GGS_lstring  mSearchListName ;
//--- Constructor
  public : cPtr_lexicalSendSearch (const GGS_lstring & ,
                                const GGS_lstring & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline cPtr_lexicalSendSearch * nextObject (void) const {
    return (cPtr_lexicalSendSearch *) internalNextItem () ;
  }

//--- Access to previous
  public : inline cPtr_lexicalSendSearch * previousObject (void) const {
    return (cPtr_lexicalSendSearch *) internalPreviousItem () ;
  }

//--- Element comparison
  public : bool isEqualToObject ( const  cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & _inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Metamodel Index
  public : virtual uint32 _metamodelIndex (void) const ;

//--- Metamodel Class ID
  public : virtual uint32 _metamodelClassID (void) const ;

//--- 'clone' virtual method
  public : virtual cPtr_lexicalSendSearch * _cloneObject (void) const ;

//--- Friend class declarations
  friend class GGS_lexicalSendSearchList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@lexicalRepeatInstructionList'               *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalRepeatInstruction : public cPtr_lexicalInstruction {
//--- Attributes
  public : GGS_lexicalInstructionList  mRepeatedInstructionList ;
  public : GGS_lexicalWhileBranchList  mLexicalWhileBranchList ;
//--- Constructor
  public : cPtr_lexicalRepeatInstruction (const GGS_lexicalInstructionList & ,
                                const GGS_lexicalWhileBranchList & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline cPtr_lexicalRepeatInstruction * nextObject (void) const {
    return (cPtr_lexicalRepeatInstruction *) internalNextItem () ;
  }

//--- Access to previous
  public : inline cPtr_lexicalRepeatInstruction * previousObject (void) const {
    return (cPtr_lexicalRepeatInstruction *) internalPreviousItem () ;
  }

//--- Element comparison
  public : bool isEqualToObject ( const  cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & _inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Metamodel Index
  public : virtual uint32 _metamodelIndex (void) const ;

//--- Metamodel Class ID
  public : virtual uint32 _metamodelClassID (void) const ;

//--- 'clone' virtual method
  public : virtual cPtr_lexicalRepeatInstruction * _cloneObject (void) const ;

//--- Friend class declarations
  friend class GGS_lexicalRepeatInstructionList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@lexicalWhileBranchList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalWhileBranch : public C_GGS_MetamodelEntity {
//--- Attributes
  public : GGS_lexicalExpression  mWhileExpression ;
  public : GGS_lexicalInstructionList  mWhileInstructionList ;
//--- Constructor
  public : cPtr_lexicalWhileBranch (const GGS_lexicalExpression & ,
                                const GGS_lexicalInstructionList & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline cPtr_lexicalWhileBranch * nextObject (void) const {
    return (cPtr_lexicalWhileBranch *) internalNextItem () ;
  }

//--- Access to previous
  public : inline cPtr_lexicalWhileBranch * previousObject (void) const {
    return (cPtr_lexicalWhileBranch *) internalPreviousItem () ;
  }

//--- Element comparison
  public : bool isEqualToObject ( const  cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & _inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Metamodel Index
  public : virtual uint32 _metamodelIndex (void) const ;

//--- Metamodel Class ID
  public : virtual uint32 _metamodelClassID (void) const ;

//--- 'clone' virtual method
  public : virtual cPtr_lexicalWhileBranch * _cloneObject (void) const ;

//--- Friend class declarations
  friend class GGS_lexicalWhileBranchList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@lexicalSelectInstructionList'               *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalSelectInstruction : public cPtr_lexicalInstruction {
//--- Attributes
  public : GGS_lexicalSelectBranchList  mLexicalWhileBranchList ;
  public : GGS_lexicalInstructionList  mDefaultInstructionList ;
//--- Constructor
  public : cPtr_lexicalSelectInstruction (const GGS_lexicalSelectBranchList & ,
                                const GGS_lexicalInstructionList & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline cPtr_lexicalSelectInstruction * nextObject (void) const {
    return (cPtr_lexicalSelectInstruction *) internalNextItem () ;
  }

//--- Access to previous
  public : inline cPtr_lexicalSelectInstruction * previousObject (void) const {
    return (cPtr_lexicalSelectInstruction *) internalPreviousItem () ;
  }

//--- Element comparison
  public : bool isEqualToObject ( const  cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & _inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Metamodel Index
  public : virtual uint32 _metamodelIndex (void) const ;

//--- Metamodel Class ID
  public : virtual uint32 _metamodelClassID (void) const ;

//--- 'clone' virtual method
  public : virtual cPtr_lexicalSelectInstruction * _cloneObject (void) const ;

//--- Friend class declarations
  friend class GGS_lexicalSelectInstructionList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@lexicalSelectBranchList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalSelectBranch : public C_GGS_MetamodelEntity {
//--- Attributes
  public : GGS_lexicalExpression  mSelectExpression ;
  public : GGS_lexicalInstructionList  mSelectInstructionList ;
//--- Constructor
  public : cPtr_lexicalSelectBranch (const GGS_lexicalExpression & ,
                                const GGS_lexicalInstructionList & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline cPtr_lexicalSelectBranch * nextObject (void) const {
    return (cPtr_lexicalSelectBranch *) internalNextItem () ;
  }

//--- Access to previous
  public : inline cPtr_lexicalSelectBranch * previousObject (void) const {
    return (cPtr_lexicalSelectBranch *) internalPreviousItem () ;
  }

//--- Element comparison
  public : bool isEqualToObject ( const  cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & _inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Metamodel Index
  public : virtual uint32 _metamodelIndex (void) const ;

//--- Metamodel Class ID
  public : virtual uint32 _metamodelClassID (void) const ;

//--- 'clone' virtual method
  public : virtual cPtr_lexicalSelectBranch * _cloneObject (void) const ;

//--- Friend class declarations
  friend class GGS_lexicalSelectBranchList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@lexicalActionInstructionList'               *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalActionInstruction : public cPtr_lexicalInstruction {
//--- Attributes
  public : GGS_lstring  mActionName ;
  public : GGS_lexicalActualArgumentList  mActualArgumentList ;
  public : GGS_lstringlist  mErrorMessageList ;
//--- Constructor
  public : cPtr_lexicalActionInstruction (const GGS_lstring & ,
                                const GGS_lexicalActualArgumentList & ,
                                const GGS_lstringlist & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline cPtr_lexicalActionInstruction * nextObject (void) const {
    return (cPtr_lexicalActionInstruction *) internalNextItem () ;
  }

//--- Access to previous
  public : inline cPtr_lexicalActionInstruction * previousObject (void) const {
    return (cPtr_lexicalActionInstruction *) internalPreviousItem () ;
  }

//--- Element comparison
  public : bool isEqualToObject ( const  cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & _inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Metamodel Index
  public : virtual uint32 _metamodelIndex (void) const ;

//--- Metamodel Class ID
  public : virtual uint32 _metamodelClassID (void) const ;

//--- 'clone' virtual method
  public : virtual cPtr_lexicalActionInstruction * _cloneObject (void) const ;

//--- Friend class declarations
  friend class GGS_lexicalActionInstructionList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@lexicalActualArgumentList'                *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalActualArgument : public C_GGS_MetamodelEntity {
//--- Attributes
//--- Constructor
  public : cPtr_lexicalActualArgument (LOCATION_ARGS) ;

//--- Access to next
  public : inline cPtr_lexicalActualArgument * nextObject (void) const {
    return (cPtr_lexicalActualArgument *) internalNextItem () ;
  }

//--- Access to previous
  public : inline cPtr_lexicalActualArgument * previousObject (void) const {
    return (cPtr_lexicalActualArgument *) internalPreviousItem () ;
  }

//--- Element comparison
  public : bool isEqualToObject ( const  cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & _inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Metamodel Index
  public : virtual uint32 _metamodelIndex (void) const ;

//--- Metamodel Class ID
  public : virtual uint32 _metamodelClassID (void) const ;

//--- 'clone' virtual method
  public : virtual cPtr_lexicalActualArgument * _cloneObject (void) const ;

//--- Friend class declarations
  friend class GGS_lexicalActualArgumentList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@lexicalAttributeArgumentList'               *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalAttributeArgument : public cPtr_lexicalActualArgument {
//--- Attributes
  public : GGS_lstring  mAttributeName ;
//--- Constructor
  public : cPtr_lexicalAttributeArgument (const GGS_lstring & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline cPtr_lexicalAttributeArgument * nextObject (void) const {
    return (cPtr_lexicalAttributeArgument *) internalNextItem () ;
  }

//--- Access to previous
  public : inline cPtr_lexicalAttributeArgument * previousObject (void) const {
    return (cPtr_lexicalAttributeArgument *) internalPreviousItem () ;
  }

//--- Element comparison
  public : bool isEqualToObject ( const  cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & _inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Metamodel Index
  public : virtual uint32 _metamodelIndex (void) const ;

//--- Metamodel Class ID
  public : virtual uint32 _metamodelClassID (void) const ;

//--- 'clone' virtual method
  public : virtual cPtr_lexicalAttributeArgument * _cloneObject (void) const ;

//--- Friend class declarations
  friend class GGS_lexicalAttributeArgumentList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@lexicalCharacterArgumentList'               *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalCharacterArgument : public cPtr_lexicalActualArgument {
//--- Attributes
  public : GGS_lchar  mCharacter ;
//--- Constructor
  public : cPtr_lexicalCharacterArgument (const GGS_lchar & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline cPtr_lexicalCharacterArgument * nextObject (void) const {
    return (cPtr_lexicalCharacterArgument *) internalNextItem () ;
  }

//--- Access to previous
  public : inline cPtr_lexicalCharacterArgument * previousObject (void) const {
    return (cPtr_lexicalCharacterArgument *) internalPreviousItem () ;
  }

//--- Element comparison
  public : bool isEqualToObject ( const  cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & _inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Metamodel Index
  public : virtual uint32 _metamodelIndex (void) const ;

//--- Metamodel Class ID
  public : virtual uint32 _metamodelClassID (void) const ;

//--- 'clone' virtual method
  public : virtual cPtr_lexicalCharacterArgument * _cloneObject (void) const ;

//--- Friend class declarations
  friend class GGS_lexicalCharacterArgumentList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//          Element of list '@lexicalCurrentCharacterArgumentList'           *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalCurrentCharacterArgument : public cPtr_lexicalActualArgument {
//--- Attributes
//--- Constructor
  public : cPtr_lexicalCurrentCharacterArgument (LOCATION_ARGS) ;

//--- Access to next
  public : inline cPtr_lexicalCurrentCharacterArgument * nextObject (void) const {
    return (cPtr_lexicalCurrentCharacterArgument *) internalNextItem () ;
  }

//--- Access to previous
  public : inline cPtr_lexicalCurrentCharacterArgument * previousObject (void) const {
    return (cPtr_lexicalCurrentCharacterArgument *) internalPreviousItem () ;
  }

//--- Element comparison
  public : bool isEqualToObject ( const  cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & _inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Metamodel Index
  public : virtual uint32 _metamodelIndex (void) const ;

//--- Metamodel Class ID
  public : virtual uint32 _metamodelClassID (void) const ;

//--- 'clone' virtual method
  public : virtual cPtr_lexicalCurrentCharacterArgument * _cloneObject (void) const ;

//--- Friend class declarations
  friend class GGS_lexicalCurrentCharacterArgumentList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@lexicalFunctionArgumentList'               *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalFunctionArgument : public cPtr_lexicalActualArgument {
//--- Attributes
  public : GGS_lstring  mFunctionName ;
  public : GGS_lexicalActualArgumentList  mFunctionActualArgumentList ;
//--- Constructor
  public : cPtr_lexicalFunctionArgument (const GGS_lstring & ,
                                const GGS_lexicalActualArgumentList & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline cPtr_lexicalFunctionArgument * nextObject (void) const {
    return (cPtr_lexicalFunctionArgument *) internalNextItem () ;
  }

//--- Access to previous
  public : inline cPtr_lexicalFunctionArgument * previousObject (void) const {
    return (cPtr_lexicalFunctionArgument *) internalPreviousItem () ;
  }

//--- Element comparison
  public : bool isEqualToObject ( const  cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & _inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Metamodel Index
  public : virtual uint32 _metamodelIndex (void) const ;

//--- Metamodel Class ID
  public : virtual uint32 _metamodelClassID (void) const ;

//--- 'clone' virtual method
  public : virtual cPtr_lexicalFunctionArgument * _cloneObject (void) const ;

//--- Friend class declarations
  friend class GGS_lexicalFunctionArgumentList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@lexicalDropInstructionList'                *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalDropInstruction : public cPtr_lexicalInstruction {
//--- Attributes
  public : GGS_lstring  mTerminalName ;
//--- Constructor
  public : cPtr_lexicalDropInstruction (const GGS_lstring & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline cPtr_lexicalDropInstruction * nextObject (void) const {
    return (cPtr_lexicalDropInstruction *) internalNextItem () ;
  }

//--- Access to previous
  public : inline cPtr_lexicalDropInstruction * previousObject (void) const {
    return (cPtr_lexicalDropInstruction *) internalPreviousItem () ;
  }

//--- Element comparison
  public : bool isEqualToObject ( const  cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & _inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Metamodel Index
  public : virtual uint32 _metamodelIndex (void) const ;

//--- Metamodel Class ID
  public : virtual uint32 _metamodelClassID (void) const ;

//--- 'clone' virtual method
  public : virtual cPtr_lexicalDropInstruction * _cloneObject (void) const ;

//--- Friend class declarations
  friend class GGS_lexicalDropInstructionList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@lexicalErrorInstructionList'               *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalErrorInstruction : public cPtr_lexicalInstruction {
//--- Attributes
  public : GGS_lstring  mErrorMessageName ;
//--- Constructor
  public : cPtr_lexicalErrorInstruction (const GGS_lstring & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline cPtr_lexicalErrorInstruction * nextObject (void) const {
    return (cPtr_lexicalErrorInstruction *) internalNextItem () ;
  }

//--- Access to previous
  public : inline cPtr_lexicalErrorInstruction * previousObject (void) const {
    return (cPtr_lexicalErrorInstruction *) internalPreviousItem () ;
  }

//--- Element comparison
  public : bool isEqualToObject ( const  cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & _inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Metamodel Index
  public : virtual uint32 _metamodelIndex (void) const ;

//--- Metamodel Class ID
  public : virtual uint32 _metamodelClassID (void) const ;

//--- 'clone' virtual method
  public : virtual cPtr_lexicalErrorInstruction * _cloneObject (void) const ;

//--- Friend class declarations
  friend class GGS_lexicalErrorInstructionList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@lexicalTagInstructionList'                *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalTagInstruction : public cPtr_lexicalInstruction {
//--- Attributes
  public : GGS_lstring  mTagName ;
//--- Constructor
  public : cPtr_lexicalTagInstruction (const GGS_lstring & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline cPtr_lexicalTagInstruction * nextObject (void) const {
    return (cPtr_lexicalTagInstruction *) internalNextItem () ;
  }

//--- Access to previous
  public : inline cPtr_lexicalTagInstruction * previousObject (void) const {
    return (cPtr_lexicalTagInstruction *) internalPreviousItem () ;
  }

//--- Element comparison
  public : bool isEqualToObject ( const  cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & _inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Metamodel Index
  public : virtual uint32 _metamodelIndex (void) const ;

//--- Metamodel Class ID
  public : virtual uint32 _metamodelClassID (void) const ;

//--- 'clone' virtual method
  public : virtual cPtr_lexicalTagInstruction * _cloneObject (void) const ;

//--- Friend class declarations
  friend class GGS_lexicalTagInstructionList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@lexicalRewindInstructionList'               *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalRewindInstruction : public cPtr_lexicalInstruction {
//--- Attributes
  public : GGS_lstring  mTagName ;
  public : GGS_lstring  mTerminalName ;
//--- Constructor
  public : cPtr_lexicalRewindInstruction (const GGS_lstring & ,
                                const GGS_lstring & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline cPtr_lexicalRewindInstruction * nextObject (void) const {
    return (cPtr_lexicalRewindInstruction *) internalNextItem () ;
  }

//--- Access to previous
  public : inline cPtr_lexicalRewindInstruction * previousObject (void) const {
    return (cPtr_lexicalRewindInstruction *) internalPreviousItem () ;
  }

//--- Element comparison
  public : bool isEqualToObject ( const  cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & _inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Metamodel Index
  public : virtual uint32 _metamodelIndex (void) const ;

//--- Metamodel Class ID
  public : virtual uint32 _metamodelClassID (void) const ;

//--- 'clone' virtual method
  public : virtual cPtr_lexicalRewindInstruction * _cloneObject (void) const ;

//--- Friend class declarations
  friend class GGS_lexicalRewindInstructionList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@lexicalLogInstructionList'                *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalLogInstruction : public cPtr_lexicalInstruction {
//--- Attributes
//--- Constructor
  public : cPtr_lexicalLogInstruction (LOCATION_ARGS) ;

//--- Access to next
  public : inline cPtr_lexicalLogInstruction * nextObject (void) const {
    return (cPtr_lexicalLogInstruction *) internalNextItem () ;
  }

//--- Access to previous
  public : inline cPtr_lexicalLogInstruction * previousObject (void) const {
    return (cPtr_lexicalLogInstruction *) internalPreviousItem () ;
  }

//--- Element comparison
  public : bool isEqualToObject ( const  cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & _inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Metamodel Index
  public : virtual uint32 _metamodelIndex (void) const ;

//--- Metamodel Class ID
  public : virtual uint32 _metamodelClassID (void) const ;

//--- 'clone' virtual method
  public : virtual cPtr_lexicalLogInstruction * _cloneObject (void) const ;

//--- Friend class declarations
  friend class GGS_lexicalLogInstructionList ;
} ;

//---------------------------------------------------------------------------*

#endif
