//---------------------------------------------------------------------------*
//                                                                           *
//                       File 'grammarSemantics.cpp'                         *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                       may 2nd, 2010, at 20h31'22"                         *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if CURRENT_LIBPM_VERSION != VERSION_OF_LIBPM_USED_BY_GALGAS_COMPILER
  #error "This file has been compiled with a version of GALGAS that uses libpm version VERSION_OF_LIBPM_USED_BY_GALGAS_COMPILER, different than the current version (CURRENT_LIBPM_VERSION) of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "galgas/C_galgas_CLI_Options.h"
#include "grammarSemantics.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "grammarSemantics.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@signatureForGrammarAnalysis'               *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_signatureForGrammarAnalysis::
elementOf_GGS_signatureForGrammarAnalysis (const GGS_formalArgumentPassingModeAST& argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mFormalArgumentPassingModeForGrammarAnalysis (argument_0),
mGalgasTypeNameForGrammarAnalysis (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_signatureForGrammarAnalysis::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_signatureForGrammarAnalysis * ptr = dynamic_cast <const elementOf_GGS_signatureForGrammarAnalysis *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mFormalArgumentPassingModeForGrammarAnalysis.operator_isEqual (ptr->mFormalArgumentPassingModeForGrammarAnalysis).boolValue ()
         && mGalgasTypeNameForGrammarAnalysis.operator_isEqual (ptr->mGalgasTypeNameForGrammarAnalysis).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_signatureForGrammarAnalysis::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFormalArgumentPassingModeForGrammarAnalysis.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mGalgasTypeNameForGrammarAnalysis.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@signatureForGrammarAnalysis'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_signatureForGrammarAnalysis ("signatureForGrammarAnalysis", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_signatureForGrammarAnalysis::
internalAppendValues (const GGS_formalArgumentPassingModeAST& argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_signatureForGrammarAnalysis::
internalPrependValues (const GGS_formalArgumentPassingModeAST& argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_signatureForGrammarAnalysis::
addAssign_operation (const GGS_formalArgumentPassingModeAST& argument_0,
                                const GGS_lstring & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_signatureForGrammarAnalysis GGS_signatureForGrammarAnalysis::
operator_concat (const GGS_signatureForGrammarAnalysis & inOperand) const {
  GGS_signatureForGrammarAnalysis result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_signatureForGrammarAnalysis::
dotAssign_operation (const GGS_signatureForGrammarAnalysis inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_signatureForGrammarAnalysis * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_formalArgumentPassingModeAST p_0 = p->mFormalArgumentPassingModeForGrammarAnalysis ;
          GGS_lstring  p_1 = p->mGalgasTypeNameForGrammarAnalysis ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_signatureForGrammarAnalysis::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_formalArgumentPassingModeAST& argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_signatureForGrammarAnalysis::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mFormalArgumentPassingModeForGrammarAnalysis,
                                ptr->mGalgasTypeNameForGrammarAnalysis
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_signatureForGrammarAnalysis  GGS_signatureForGrammarAnalysis::
constructor_emptyList (void) {
  GGS_signatureForGrammarAnalysis result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_signatureForGrammarAnalysis  GGS_signatureForGrammarAnalysis::
constructor_listWithValue (const GGS_formalArgumentPassingModeAST& argument_0,
                                const GGS_lstring & argument_1) {
  GGS_signatureForGrammarAnalysis result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_signatureForGrammarAnalysis::
internalSubListWithRange (GGS_signatureForGrammarAnalysis & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mFormalArgumentPassingModeForGrammarAnalysis, ptr->mGalgasTypeNameForGrammarAnalysis) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_signatureForGrammarAnalysis GGS_signatureForGrammarAnalysis::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_signatureForGrammarAnalysis result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_signatureForGrammarAnalysis GGS_signatureForGrammarAnalysis::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_signatureForGrammarAnalysis result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_signatureForGrammarAnalysis::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@signatureForGrammarAnalysis", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_signatureForGrammarAnalysis::
method_first (C_Compiler & inLexique,
              GGS_formalArgumentPassingModeAST& _out_0,
              GGS_lstring & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mFormalArgumentPassingModeForGrammarAnalysis ;
    _out_1 = ptr->mGalgasTypeNameForGrammarAnalysis ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_signatureForGrammarAnalysis::
method_last (C_Compiler & inLexique,
             GGS_formalArgumentPassingModeAST& _out_0,
             GGS_lstring & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mFormalArgumentPassingModeForGrammarAnalysis ;
    _out_1 = ptr->mGalgasTypeNameForGrammarAnalysis ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_signatureForGrammarAnalysis::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_formalArgumentPassingModeAST& _out_0,
                 GGS_lstring & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mFormalArgumentPassingModeForGrammarAnalysis ;
    _out_1 = ptr->mGalgasTypeNameForGrammarAnalysis ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_signatureForGrammarAnalysis::
modifier_popLast (C_Compiler & inLexique,
                GGS_formalArgumentPassingModeAST& _out_0,
                GGS_lstring & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mFormalArgumentPassingModeForGrammarAnalysis ;
    _out_1 = ptr->mGalgasTypeNameForGrammarAnalysis ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_formalArgumentPassingModeAST GGS_signatureForGrammarAnalysis::
reader_mFormalArgumentPassingModeForGrammarAnalysisAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_formalArgumentPassingModeAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mFormalArgumentPassingModeForGrammarAnalysis ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_signatureForGrammarAnalysis::
reader_mGalgasTypeNameForGrammarAnalysisAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mGalgasTypeNameForGrammarAnalysis ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_signatureForGrammarAnalysis::
modifier_setMFormalArgumentPassingModeForGrammarAnalysisAtIndex (C_Compiler & inLexique,
                              const GGS_formalArgumentPassingModeAST & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mFormalArgumentPassingModeForGrammarAnalysis = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_signatureForGrammarAnalysis::
modifier_setMGalgasTypeNameForGrammarAnalysisAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mGalgasTypeNameForGrammarAnalysis = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_formalArgumentPassingModeAST & GGS_signatureForGrammarAnalysis::cEnumerator::_mFormalArgumentPassingModeForGrammarAnalysis (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mFormalArgumentPassingModeForGrammarAnalysis ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_signatureForGrammarAnalysis::cEnumerator::_mGalgasTypeNameForGrammarAnalysis (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mGalgasTypeNameForGrammarAnalysis ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_signatureForGrammarAnalysis::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_signatureForGrammarAnalysis * p = NULL ;
    macroMyNew (p, GGS_signatureForGrammarAnalysis (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_signatureForGrammarAnalysis GGS_signatureForGrammarAnalysis::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_signatureForGrammarAnalysis result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_signatureForGrammarAnalysis * p = dynamic_cast <const GGS_signatureForGrammarAnalysis *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_signatureForGrammarAnalysis, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_signatureForGrammarAnalysis::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_signatureForGrammarAnalysis ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          class 'e_nonterminalSymbolLabelMapForGrammarAnalysis'            *
//                                                                           *
//---------------------------------------------------------------------------*

e_nonterminalSymbolLabelMapForGrammarAnalysis::e_nonterminalSymbolLabelMapForGrammarAnalysis (void) :
mFormalParametersList () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//         class map '@nonterminalSymbolLabelMapForGrammarAnalysis'          *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_nonterminalSymbolLabelMapForGrammarAnalysis ("nonterminalSymbolLabelMapForGrammarAnalysis", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_nonterminalSymbolLabelMapForGrammarAnalysis::
elementOf_GGS_nonterminalSymbolLabelMapForGrammarAnalysis (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_nonterminalSymbolLabelMapForGrammarAnalysis & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_nonterminalSymbolLabelMapForGrammarAnalysis::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mFormalParametersList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_nonterminalSymbolLabelMapForGrammarAnalysis::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_nonterminalSymbolLabelMapForGrammarAnalysis * ptr = dynamic_cast <const elementOf_GGS_nonterminalSymbolLabelMapForGrammarAnalysis *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mFormalParametersList.operator_isEqual (ptr->mInfo.mFormalParametersList)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_nonterminalSymbolLabelMapForGrammarAnalysis::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_nonterminalSymbolLabelMapForGrammarAnalysis *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_nonterminalSymbolLabelMapForGrammarAnalysis * info = (e_nonterminalSymbolLabelMapForGrammarAnalysis *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_nonterminalSymbolLabelMapForGrammarAnalysis::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_nonterminalSymbolLabelMapForGrammarAnalysis *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_nonterminalSymbolLabelMapForGrammarAnalysis * info = (e_nonterminalSymbolLabelMapForGrammarAnalysis *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_nonterminalSymbolLabelMapForGrammarAnalysis GGS_nonterminalSymbolLabelMapForGrammarAnalysis::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_nonterminalSymbolLabelMapForGrammarAnalysis result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_nonterminalSymbolLabelMapForGrammarAnalysis::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_nonterminalSymbolLabelMapForGrammarAnalysis info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_nonterminalSymbolLabelMapForGrammarAnalysis::
operator_isEqual (const GGS_nonterminalSymbolLabelMapForGrammarAnalysis & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_nonterminalSymbolLabelMapForGrammarAnalysis::
operator_isNotEqual (const GGS_nonterminalSymbolLabelMapForGrammarAnalysis & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_nonterminalSymbolLabelMapForGrammarAnalysis::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_nonterminalSymbolLabelMapForGrammarAnalysis::
insertElement (C_Compiler & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_signatureForGrammarAnalysis & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_nonterminalSymbolLabelMapForGrammarAnalysis info  ;
    info.mFormalParametersList = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_nonterminalSymbolLabelMapForGrammarAnalysis::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_signatureForGrammarAnalysis   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mFormalParametersList ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_nonterminalSymbolLabelMapForGrammarAnalysis::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('r'),
  TO_UNICODE ('u'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('l'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_nonterminalSymbolLabelMapForGrammarAnalysis::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_signatureForGrammarAnalysis   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_nonterminalSymbolLabelMapForGrammarAnalysis::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('r'),
  TO_UNICODE ('u'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('l'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_nonterminalSymbolLabelMapForGrammarAnalysis::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_signatureForGrammarAnalysis & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_nonterminalSymbolLabelMapForGrammarAnalysis GGS_nonterminalSymbolLabelMapForGrammarAnalysis::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_nonterminalSymbolLabelMapForGrammarAnalysis & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_nonterminalSymbolLabelMapForGrammarAnalysis result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_nonterminalSymbolLabelMapForGrammarAnalysis GGS_nonterminalSymbolLabelMapForGrammarAnalysis::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_nonterminalSymbolLabelMapForGrammarAnalysis result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_nonterminalSymbolLabelMapForGrammarAnalysis::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @nonterminalSymbolLabelMapForGrammarAnalysis " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_signatureForGrammarAnalysis  & GGS_nonterminalSymbolLabelMapForGrammarAnalysis::cEnumerator::_mFormalParametersList (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mFormalParametersList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_nonterminalSymbolLabelMapForGrammarAnalysis::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_nonterminalSymbolLabelMapForGrammarAnalysis * p = NULL ;
    macroMyNew (p, GGS_nonterminalSymbolLabelMapForGrammarAnalysis (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_nonterminalSymbolLabelMapForGrammarAnalysis GGS_nonterminalSymbolLabelMapForGrammarAnalysis::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_nonterminalSymbolLabelMapForGrammarAnalysis result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_nonterminalSymbolLabelMapForGrammarAnalysis * p = dynamic_cast <const GGS_nonterminalSymbolLabelMapForGrammarAnalysis *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_nonterminalSymbolLabelMapForGrammarAnalysis, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_nonterminalSymbolLabelMapForGrammarAnalysis::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_nonterminalSymbolLabelMapForGrammarAnalysis ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         class 'cPtr_abstractSyntaxInstructionForGrammarAnalysis'          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_abstractSyntaxInstructionForGrammarAnalysis::
cPtr_abstractSyntaxInstructionForGrammarAnalysis (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE),
mStartLocation (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_abstractSyntaxInstructionForGrammarAnalysis * GGS_abstractSyntaxInstructionForGrammarAnalysis::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_abstractSyntaxInstructionForGrammarAnalysis) ;
    return (cPtr_abstractSyntaxInstructionForGrammarAnalysis *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_abstractSyntaxInstructionForGrammarAnalysis::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@abstractSyntaxInstructionForGrammarAnalysis:"
           << mStartLocation.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_abstractSyntaxInstructionForGrammarAnalysis::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_abstractSyntaxInstructionForGrammarAnalysis::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_abstractSyntaxInstructionForGrammarAnalysis (& typeid (cPtr_abstractSyntaxInstructionForGrammarAnalysis), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_abstractSyntaxInstructionForGrammarAnalysis::galgasRTTI (void) const {
  return & gClassInfoFor__abstractSyntaxInstructionForGrammarAnalysis ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//      GALGAS class 'GGS_abstractSyntaxInstructionForGrammarAnalysis'       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_abstractSyntaxInstructionForGrammarAnalysis ("abstractSyntaxInstructionForGrammarAnalysis", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_abstractSyntaxInstructionForGrammarAnalysis::
GGS_abstractSyntaxInstructionForGrammarAnalysis (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_abstractSyntaxInstructionForGrammarAnalysis::
GGS_abstractSyntaxInstructionForGrammarAnalysis (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_abstractSyntaxInstructionForGrammarAnalysis GGS_abstractSyntaxInstructionForGrammarAnalysis::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_abstractSyntaxInstructionForGrammarAnalysis result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_abstractSyntaxInstructionForGrammarAnalysis *> (inPointer) != NULL)
      : (typeid (cPtr_abstractSyntaxInstructionForGrammarAnalysis) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_abstractSyntaxInstructionForGrammarAnalysis (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_abstractSyntaxInstructionForGrammarAnalysis),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_abstractSyntaxInstructionForGrammarAnalysis::actualTypeName (void) const {
  return "abstractSyntaxInstructionForGrammarAnalysis" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_abstractSyntaxInstructionForGrammarAnalysis::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__abstractSyntaxInstructionForGrammarAnalysis ("abstractSyntaxInstructionForGrammarAnalysis", & kTypeDescriptor_GGS_abstractSyntaxInstructionForGrammarAnalysis) ;

//---------------------------------------------------------------------------*

GGS_object GGS_abstractSyntaxInstructionForGrammarAnalysis::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_abstractSyntaxInstructionForGrammarAnalysis * p = NULL ;
    macroMyNew (p, GGS_abstractSyntaxInstructionForGrammarAnalysis (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_abstractSyntaxInstructionForGrammarAnalysis GGS_abstractSyntaxInstructionForGrammarAnalysis::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_abstractSyntaxInstructionForGrammarAnalysis result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_abstractSyntaxInstructionForGrammarAnalysis * p = dynamic_cast <const GGS_abstractSyntaxInstructionForGrammarAnalysis *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_abstractSyntaxInstructionForGrammarAnalysis, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_abstractSyntaxInstructionForGrammarAnalysis::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_abstractSyntaxInstructionForGrammarAnalysis ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        Element of list '@syntaxInstructionListForGrammarAnalysis'         *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_syntaxInstructionListForGrammarAnalysis::
elementOf_GGS_syntaxInstructionListForGrammarAnalysis (const GGS_abstractSyntaxInstructionForGrammarAnalysis & argument_0
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mInstruction (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_syntaxInstructionListForGrammarAnalysis::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_syntaxInstructionListForGrammarAnalysis * ptr = dynamic_cast <const elementOf_GGS_syntaxInstructionListForGrammarAnalysis *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstruction.operator_isEqual (ptr->mInstruction).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_syntaxInstructionListForGrammarAnalysis::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstruction.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             List '@syntaxInstructionListForGrammarAnalysis'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_syntaxInstructionListForGrammarAnalysis ("syntaxInstructionListForGrammarAnalysis", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_syntaxInstructionListForGrammarAnalysis::
internalAppendValues (const GGS_abstractSyntaxInstructionForGrammarAnalysis & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_syntaxInstructionListForGrammarAnalysis::
internalPrependValues (const GGS_abstractSyntaxInstructionForGrammarAnalysis & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_syntaxInstructionListForGrammarAnalysis::
addAssign_operation (const GGS_abstractSyntaxInstructionForGrammarAnalysis & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_syntaxInstructionListForGrammarAnalysis GGS_syntaxInstructionListForGrammarAnalysis::
operator_concat (const GGS_syntaxInstructionListForGrammarAnalysis & inOperand) const {
  GGS_syntaxInstructionListForGrammarAnalysis result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_syntaxInstructionListForGrammarAnalysis::
dotAssign_operation (const GGS_syntaxInstructionListForGrammarAnalysis inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_syntaxInstructionListForGrammarAnalysis * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_abstractSyntaxInstructionForGrammarAnalysis  p_0 = p->mInstruction ;
          internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_syntaxInstructionListForGrammarAnalysis::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_abstractSyntaxInstructionForGrammarAnalysis & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_syntaxInstructionListForGrammarAnalysis::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mInstruction
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_syntaxInstructionListForGrammarAnalysis  GGS_syntaxInstructionListForGrammarAnalysis::
constructor_emptyList (void) {
  GGS_syntaxInstructionListForGrammarAnalysis result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_syntaxInstructionListForGrammarAnalysis  GGS_syntaxInstructionListForGrammarAnalysis::
constructor_listWithValue (const GGS_abstractSyntaxInstructionForGrammarAnalysis & argument_0) {
  GGS_syntaxInstructionListForGrammarAnalysis result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_syntaxInstructionListForGrammarAnalysis::
internalSubListWithRange (GGS_syntaxInstructionListForGrammarAnalysis & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mInstruction) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_syntaxInstructionListForGrammarAnalysis GGS_syntaxInstructionListForGrammarAnalysis::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_syntaxInstructionListForGrammarAnalysis result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_syntaxInstructionListForGrammarAnalysis GGS_syntaxInstructionListForGrammarAnalysis::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_syntaxInstructionListForGrammarAnalysis result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_syntaxInstructionListForGrammarAnalysis::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@syntaxInstructionListForGrammarAnalysis", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_syntaxInstructionListForGrammarAnalysis::
method_first (C_Compiler & inLexique,
              GGS_abstractSyntaxInstructionForGrammarAnalysis & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInstruction ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_syntaxInstructionListForGrammarAnalysis::
method_last (C_Compiler & inLexique,
             GGS_abstractSyntaxInstructionForGrammarAnalysis & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInstruction ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_syntaxInstructionListForGrammarAnalysis::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_abstractSyntaxInstructionForGrammarAnalysis & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInstruction ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_syntaxInstructionListForGrammarAnalysis::
modifier_popLast (C_Compiler & inLexique,
                GGS_abstractSyntaxInstructionForGrammarAnalysis & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInstruction ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_abstractSyntaxInstructionForGrammarAnalysis  GGS_syntaxInstructionListForGrammarAnalysis::
reader_mInstructionAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_abstractSyntaxInstructionForGrammarAnalysis  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstruction ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_syntaxInstructionListForGrammarAnalysis::
modifier_setMInstructionAtIndex (C_Compiler & inLexique,
                              const GGS_abstractSyntaxInstructionForGrammarAnalysis  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstruction = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_abstractSyntaxInstructionForGrammarAnalysis  & GGS_syntaxInstructionListForGrammarAnalysis::cEnumerator::_mInstruction (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mInstruction ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_syntaxInstructionListForGrammarAnalysis::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_syntaxInstructionListForGrammarAnalysis * p = NULL ;
    macroMyNew (p, GGS_syntaxInstructionListForGrammarAnalysis (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_syntaxInstructionListForGrammarAnalysis GGS_syntaxInstructionListForGrammarAnalysis::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_syntaxInstructionListForGrammarAnalysis result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_syntaxInstructionListForGrammarAnalysis * p = dynamic_cast <const GGS_syntaxInstructionListForGrammarAnalysis *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_syntaxInstructionListForGrammarAnalysis, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_syntaxInstructionListForGrammarAnalysis::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_syntaxInstructionListForGrammarAnalysis ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         Element of list '@productionRuleListForGrammarAnalysis'           *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_productionRuleListForGrammarAnalysis::
elementOf_GGS_productionRuleListForGrammarAnalysis (const GGS_lstring & argument_0,
                                const GGS_uint & argument_1,
                                const GGS_syntaxInstructionListForGrammarAnalysis & argument_2,
                                const GGS_uint & argument_3
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mLeftNonterminalSymbol (argument_0),
mLeftNonterminalSymbolIndex (argument_1),
mInstructionList (argument_2),
mProductionIndex (argument_3) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_productionRuleListForGrammarAnalysis::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_productionRuleListForGrammarAnalysis * ptr = dynamic_cast <const elementOf_GGS_productionRuleListForGrammarAnalysis *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLeftNonterminalSymbol.operator_isEqual (ptr->mLeftNonterminalSymbol).boolValue ()
         && mLeftNonterminalSymbolIndex.operator_isEqual (ptr->mLeftNonterminalSymbolIndex).boolValue ()
         && mInstructionList.operator_isEqual (ptr->mInstructionList).boolValue ()
         && mProductionIndex.operator_isEqual (ptr->mProductionIndex).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_productionRuleListForGrammarAnalysis::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLeftNonterminalSymbol.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLeftNonterminalSymbolIndex.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mProductionIndex.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               List '@productionRuleListForGrammarAnalysis'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_productionRuleListForGrammarAnalysis ("productionRuleListForGrammarAnalysis", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_productionRuleListForGrammarAnalysis::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_uint & argument_1,
                    const GGS_syntaxInstructionListForGrammarAnalysis & argument_2,
                    const GGS_uint & argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_productionRuleListForGrammarAnalysis::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_uint & argument_1,
                    const GGS_syntaxInstructionListForGrammarAnalysis & argument_2,
                    const GGS_uint & argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_productionRuleListForGrammarAnalysis::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_uint & argument_1,
                                const GGS_syntaxInstructionListForGrammarAnalysis & argument_2,
                                const GGS_uint & argument_3) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()&& argument_3.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_productionRuleListForGrammarAnalysis GGS_productionRuleListForGrammarAnalysis::
operator_concat (const GGS_productionRuleListForGrammarAnalysis & inOperand) const {
  GGS_productionRuleListForGrammarAnalysis result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_productionRuleListForGrammarAnalysis::
dotAssign_operation (const GGS_productionRuleListForGrammarAnalysis inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_productionRuleListForGrammarAnalysis * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mLeftNonterminalSymbol ;
          GGS_uint  p_1 = p->mLeftNonterminalSymbolIndex ;
          GGS_syntaxInstructionListForGrammarAnalysis  p_2 = p->mInstructionList ;
          GGS_uint  p_3 = p->mProductionIndex ;
          internalAppendValues (p_0, p_1, p_2, p_3 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_productionRuleListForGrammarAnalysis::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_uint & argument_1,
                     const GGS_syntaxInstructionListForGrammarAnalysis & argument_2,
                     const GGS_uint & argument_3
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_productionRuleListForGrammarAnalysis::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mLeftNonterminalSymbol,
                                ptr->mLeftNonterminalSymbolIndex,
                                ptr->mInstructionList,
                                ptr->mProductionIndex
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_productionRuleListForGrammarAnalysis  GGS_productionRuleListForGrammarAnalysis::
constructor_emptyList (void) {
  GGS_productionRuleListForGrammarAnalysis result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_productionRuleListForGrammarAnalysis  GGS_productionRuleListForGrammarAnalysis::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_uint & argument_1,
                                const GGS_syntaxInstructionListForGrammarAnalysis & argument_2,
                                const GGS_uint & argument_3) {
  GGS_productionRuleListForGrammarAnalysis result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2, argument_3) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_productionRuleListForGrammarAnalysis::
internalSubListWithRange (GGS_productionRuleListForGrammarAnalysis & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mLeftNonterminalSymbol, ptr->mLeftNonterminalSymbolIndex, ptr->mInstructionList, ptr->mProductionIndex) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_productionRuleListForGrammarAnalysis GGS_productionRuleListForGrammarAnalysis::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_productionRuleListForGrammarAnalysis result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_productionRuleListForGrammarAnalysis GGS_productionRuleListForGrammarAnalysis::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_productionRuleListForGrammarAnalysis result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_productionRuleListForGrammarAnalysis::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@productionRuleListForGrammarAnalysis", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_productionRuleListForGrammarAnalysis::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_uint & _out_1,
              GGS_syntaxInstructionListForGrammarAnalysis & _out_2,
              GGS_uint & _out_3
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mLeftNonterminalSymbol ;
    _out_1 = ptr->mLeftNonterminalSymbolIndex ;
    _out_2 = ptr->mInstructionList ;
    _out_3 = ptr->mProductionIndex ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_productionRuleListForGrammarAnalysis::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_uint & _out_1,
             GGS_syntaxInstructionListForGrammarAnalysis & _out_2,
             GGS_uint & _out_3
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mLeftNonterminalSymbol ;
    _out_1 = ptr->mLeftNonterminalSymbolIndex ;
    _out_2 = ptr->mInstructionList ;
    _out_3 = ptr->mProductionIndex ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_productionRuleListForGrammarAnalysis::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_uint & _out_1,
                 GGS_syntaxInstructionListForGrammarAnalysis & _out_2,
                 GGS_uint & _out_3
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mLeftNonterminalSymbol ;
    _out_1 = ptr->mLeftNonterminalSymbolIndex ;
    _out_2 = ptr->mInstructionList ;
    _out_3 = ptr->mProductionIndex ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_productionRuleListForGrammarAnalysis::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_uint & _out_1,
                GGS_syntaxInstructionListForGrammarAnalysis & _out_2,
                GGS_uint & _out_3
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mLeftNonterminalSymbol ;
    _out_1 = ptr->mLeftNonterminalSymbolIndex ;
    _out_2 = ptr->mInstructionList ;
    _out_3 = ptr->mProductionIndex ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_productionRuleListForGrammarAnalysis::
reader_mLeftNonterminalSymbolAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mLeftNonterminalSymbol ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_productionRuleListForGrammarAnalysis::
reader_mLeftNonterminalSymbolIndexAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_uint  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mLeftNonterminalSymbolIndex ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_syntaxInstructionListForGrammarAnalysis  GGS_productionRuleListForGrammarAnalysis::
reader_mInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_syntaxInstructionListForGrammarAnalysis  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_productionRuleListForGrammarAnalysis::
reader_mProductionIndexAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_uint  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mProductionIndex ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_productionRuleListForGrammarAnalysis::
modifier_setMLeftNonterminalSymbolAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mLeftNonterminalSymbol = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_productionRuleListForGrammarAnalysis::
modifier_setMLeftNonterminalSymbolIndexAtIndex (C_Compiler & inLexique,
                              const GGS_uint  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mLeftNonterminalSymbolIndex = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_productionRuleListForGrammarAnalysis::
modifier_setMInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_syntaxInstructionListForGrammarAnalysis  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_productionRuleListForGrammarAnalysis::
modifier_setMProductionIndexAtIndex (C_Compiler & inLexique,
                              const GGS_uint  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mProductionIndex = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_productionRuleListForGrammarAnalysis::cEnumerator::_mLeftNonterminalSymbol (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mLeftNonterminalSymbol ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_productionRuleListForGrammarAnalysis::cEnumerator::_mLeftNonterminalSymbolIndex (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mLeftNonterminalSymbolIndex ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_syntaxInstructionListForGrammarAnalysis  & GGS_productionRuleListForGrammarAnalysis::cEnumerator::_mInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mInstructionList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_productionRuleListForGrammarAnalysis::cEnumerator::_mProductionIndex (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mProductionIndex ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_productionRuleListForGrammarAnalysis::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_productionRuleListForGrammarAnalysis * p = NULL ;
    macroMyNew (p, GGS_productionRuleListForGrammarAnalysis (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_productionRuleListForGrammarAnalysis GGS_productionRuleListForGrammarAnalysis::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_productionRuleListForGrammarAnalysis result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_productionRuleListForGrammarAnalysis * p = dynamic_cast <const GGS_productionRuleListForGrammarAnalysis *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_productionRuleListForGrammarAnalysis, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_productionRuleListForGrammarAnalysis::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_productionRuleListForGrammarAnalysis ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          class 'e_unusedNonTerminalSymbolMapForGrammarAnalysis'           *
//                                                                           *
//---------------------------------------------------------------------------*

e_unusedNonTerminalSymbolMapForGrammarAnalysis::e_unusedNonTerminalSymbolMapForGrammarAnalysis (void) :
mNonTerminalIndex () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//        class map '@unusedNonTerminalSymbolMapForGrammarAnalysis'          *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_unusedNonTerminalSymbolMapForGrammarAnalysis ("unusedNonTerminalSymbolMapForGrammarAnalysis", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_unusedNonTerminalSymbolMapForGrammarAnalysis::
elementOf_GGS_unusedNonTerminalSymbolMapForGrammarAnalysis (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_unusedNonTerminalSymbolMapForGrammarAnalysis & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_unusedNonTerminalSymbolMapForGrammarAnalysis::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mNonTerminalIndex.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_unusedNonTerminalSymbolMapForGrammarAnalysis::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_unusedNonTerminalSymbolMapForGrammarAnalysis * ptr = dynamic_cast <const elementOf_GGS_unusedNonTerminalSymbolMapForGrammarAnalysis *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mNonTerminalIndex.operator_isEqual (ptr->mInfo.mNonTerminalIndex)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_unusedNonTerminalSymbolMapForGrammarAnalysis::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_unusedNonTerminalSymbolMapForGrammarAnalysis *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_unusedNonTerminalSymbolMapForGrammarAnalysis * info = (e_unusedNonTerminalSymbolMapForGrammarAnalysis *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_unusedNonTerminalSymbolMapForGrammarAnalysis::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_unusedNonTerminalSymbolMapForGrammarAnalysis *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_unusedNonTerminalSymbolMapForGrammarAnalysis * info = (e_unusedNonTerminalSymbolMapForGrammarAnalysis *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_unusedNonTerminalSymbolMapForGrammarAnalysis GGS_unusedNonTerminalSymbolMapForGrammarAnalysis::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_unusedNonTerminalSymbolMapForGrammarAnalysis result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_unusedNonTerminalSymbolMapForGrammarAnalysis::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_unusedNonTerminalSymbolMapForGrammarAnalysis info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_unusedNonTerminalSymbolMapForGrammarAnalysis::
operator_isEqual (const GGS_unusedNonTerminalSymbolMapForGrammarAnalysis & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_unusedNonTerminalSymbolMapForGrammarAnalysis::
operator_isNotEqual (const GGS_unusedNonTerminalSymbolMapForGrammarAnalysis & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_unusedNonTerminalSymbolMapForGrammarAnalysis::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_unusedNonTerminalSymbolMapForGrammarAnalysis::
insertElement (C_Compiler & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_uint & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_unusedNonTerminalSymbolMapForGrammarAnalysis info  ;
    info.mNonTerminalIndex = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_unusedNonTerminalSymbolMapForGrammarAnalysis::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_uint   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mNonTerminalIndex ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_unusedNonTerminalSymbolMapForGrammarAnalysis::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('<'),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('>'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('m'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE (' '),
  TO_UNICODE ('s'),
  TO_UNICODE ('y'),
  TO_UNICODE ('m'),
  TO_UNICODE ('b'),
  TO_UNICODE ('o'),
  TO_UNICODE ('l'),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('u'),
  TO_UNICODE ('n'),
  TO_UNICODE ('u'),
  TO_UNICODE ('s'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_unusedNonTerminalSymbolMapForGrammarAnalysis::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_uint & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_unusedNonTerminalSymbolMapForGrammarAnalysis GGS_unusedNonTerminalSymbolMapForGrammarAnalysis::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_unusedNonTerminalSymbolMapForGrammarAnalysis & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_unusedNonTerminalSymbolMapForGrammarAnalysis result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_unusedNonTerminalSymbolMapForGrammarAnalysis GGS_unusedNonTerminalSymbolMapForGrammarAnalysis::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_unusedNonTerminalSymbolMapForGrammarAnalysis result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_unusedNonTerminalSymbolMapForGrammarAnalysis::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @unusedNonTerminalSymbolMapForGrammarAnalysis " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_unusedNonTerminalSymbolMapForGrammarAnalysis::cEnumerator::_mNonTerminalIndex (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mNonTerminalIndex ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_unusedNonTerminalSymbolMapForGrammarAnalysis::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_unusedNonTerminalSymbolMapForGrammarAnalysis * p = NULL ;
    macroMyNew (p, GGS_unusedNonTerminalSymbolMapForGrammarAnalysis (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_unusedNonTerminalSymbolMapForGrammarAnalysis GGS_unusedNonTerminalSymbolMapForGrammarAnalysis::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_unusedNonTerminalSymbolMapForGrammarAnalysis result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_unusedNonTerminalSymbolMapForGrammarAnalysis * p = dynamic_cast <const GGS_unusedNonTerminalSymbolMapForGrammarAnalysis *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_unusedNonTerminalSymbolMapForGrammarAnalysis, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_unusedNonTerminalSymbolMapForGrammarAnalysis::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_unusedNonTerminalSymbolMapForGrammarAnalysis ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'e_nonTerminalSymbolMapForGrammarAnalysis'              *
//                                                                           *
//---------------------------------------------------------------------------*

e_nonTerminalSymbolMapForGrammarAnalysis::e_nonTerminalSymbolMapForGrammarAnalysis (void) :
mNonTerminalIndex (),
mNonterminalSymbolParametersMap () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//           class map '@nonTerminalSymbolMapForGrammarAnalysis'             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_nonTerminalSymbolMapForGrammarAnalysis ("nonTerminalSymbolMapForGrammarAnalysis", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_nonTerminalSymbolMapForGrammarAnalysis::
elementOf_GGS_nonTerminalSymbolMapForGrammarAnalysis (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_nonTerminalSymbolMapForGrammarAnalysis & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_nonTerminalSymbolMapForGrammarAnalysis::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mNonTerminalIndex.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mNonterminalSymbolParametersMap.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_nonTerminalSymbolMapForGrammarAnalysis::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_nonTerminalSymbolMapForGrammarAnalysis * ptr = dynamic_cast <const elementOf_GGS_nonTerminalSymbolMapForGrammarAnalysis *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mNonTerminalIndex.operator_isEqual (ptr->mInfo.mNonTerminalIndex)).boolValue ()
           && (mInfo.mNonterminalSymbolParametersMap.operator_isEqual (ptr->mInfo.mNonterminalSymbolParametersMap)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_nonTerminalSymbolMapForGrammarAnalysis::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_nonTerminalSymbolMapForGrammarAnalysis *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_nonTerminalSymbolMapForGrammarAnalysis * info = (e_nonTerminalSymbolMapForGrammarAnalysis *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_nonTerminalSymbolMapForGrammarAnalysis::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_nonTerminalSymbolMapForGrammarAnalysis *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_nonTerminalSymbolMapForGrammarAnalysis * info = (e_nonTerminalSymbolMapForGrammarAnalysis *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_nonTerminalSymbolMapForGrammarAnalysis GGS_nonTerminalSymbolMapForGrammarAnalysis::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_nonTerminalSymbolMapForGrammarAnalysis result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_nonTerminalSymbolMapForGrammarAnalysis::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_nonTerminalSymbolMapForGrammarAnalysis info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_nonTerminalSymbolMapForGrammarAnalysis::
operator_isEqual (const GGS_nonTerminalSymbolMapForGrammarAnalysis & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_nonTerminalSymbolMapForGrammarAnalysis::
operator_isNotEqual (const GGS_nonTerminalSymbolMapForGrammarAnalysis & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_nonTerminalSymbolMapForGrammarAnalysis::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_nonTerminalSymbolMapForGrammarAnalysis::
insertElement (C_Compiler & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_uint & inParameter0,
               const GGS_nonterminalSymbolLabelMapForGrammarAnalysis & inParameter1,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_nonTerminalSymbolMapForGrammarAnalysis info  ;
    info.mNonTerminalIndex = inParameter0 ;
    info.mNonterminalSymbolParametersMap = inParameter1 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_nonTerminalSymbolMapForGrammarAnalysis::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_uint   & outParameter0,
               GGS_nonterminalSymbolLabelMapForGrammarAnalysis   & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mNonTerminalIndex ;
    outParameter1 = node->mInfo.mNonterminalSymbolParametersMap ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_nonTerminalSymbolMapForGrammarAnalysis::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('<'),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('>'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('m'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE (' '),
  TO_UNICODE ('s'),
  TO_UNICODE ('y'),
  TO_UNICODE ('m'),
  TO_UNICODE ('b'),
  TO_UNICODE ('o'),
  TO_UNICODE ('l'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_nonTerminalSymbolMapForGrammarAnalysis::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_uint   & outParameter0,
                                GGS_nonterminalSymbolLabelMapForGrammarAnalysis   & outParameter1 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  outParameter1,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_nonTerminalSymbolMapForGrammarAnalysis::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('<'),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('>'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('m'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE (' '),
  TO_UNICODE ('s'),
  TO_UNICODE ('y'),
  TO_UNICODE ('m'),
  TO_UNICODE ('b'),
  TO_UNICODE ('o'),
  TO_UNICODE ('l'),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_nonTerminalSymbolMapForGrammarAnalysis::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_uint & inParameter0,
                                const GGS_nonterminalSymbolLabelMapForGrammarAnalysis & inParameter1 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_nonTerminalSymbolMapForGrammarAnalysis GGS_nonTerminalSymbolMapForGrammarAnalysis::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_nonTerminalSymbolMapForGrammarAnalysis & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_nonTerminalSymbolMapForGrammarAnalysis result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_nonTerminalSymbolMapForGrammarAnalysis GGS_nonTerminalSymbolMapForGrammarAnalysis::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_nonTerminalSymbolMapForGrammarAnalysis result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_nonTerminalSymbolMapForGrammarAnalysis::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @nonTerminalSymbolMapForGrammarAnalysis " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_nonTerminalSymbolMapForGrammarAnalysis::cEnumerator::_mNonTerminalIndex (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mNonTerminalIndex ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_nonterminalSymbolLabelMapForGrammarAnalysis  & GGS_nonTerminalSymbolMapForGrammarAnalysis::cEnumerator::_mNonterminalSymbolParametersMap (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mNonterminalSymbolParametersMap ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_nonTerminalSymbolMapForGrammarAnalysis::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_nonTerminalSymbolMapForGrammarAnalysis * p = NULL ;
    macroMyNew (p, GGS_nonTerminalSymbolMapForGrammarAnalysis (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_nonTerminalSymbolMapForGrammarAnalysis GGS_nonTerminalSymbolMapForGrammarAnalysis::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_nonTerminalSymbolMapForGrammarAnalysis result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_nonTerminalSymbolMapForGrammarAnalysis * p = dynamic_cast <const GGS_nonTerminalSymbolMapForGrammarAnalysis *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_nonTerminalSymbolMapForGrammarAnalysis, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_nonTerminalSymbolMapForGrammarAnalysis::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_nonTerminalSymbolMapForGrammarAnalysis ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            class 'cPtr_terminalInstructionForGrammarAnalysis'             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_terminalInstructionForGrammarAnalysis::
cPtr_terminalInstructionForGrammarAnalysis (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_uint & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_abstractSyntaxInstructionForGrammarAnalysis (argument_0 COMMA_THERE),
mTerminalSymbolName (argument_1),
mTerminalSymbolIndex (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_terminalInstructionForGrammarAnalysis * GGS_terminalInstructionForGrammarAnalysis::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_terminalInstructionForGrammarAnalysis) ;
    return (cPtr_terminalInstructionForGrammarAnalysis *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_terminalInstructionForGrammarAnalysis::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_terminalInstructionForGrammarAnalysis * ptr = dynamic_cast <const cPtr_terminalInstructionForGrammarAnalysis *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mTerminalSymbolName.operator_isEqual (ptr->mTerminalSymbolName).boolValue ()
         && mTerminalSymbolIndex.operator_isEqual (ptr->mTerminalSymbolIndex).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_terminalInstructionForGrammarAnalysis::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@terminalInstructionForGrammarAnalysis:"
           << mStartLocation.reader_description (inIndentation + 1)
           << mTerminalSymbolName.reader_description (inIndentation + 1)
           << mTerminalSymbolIndex.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_terminalInstructionForGrammarAnalysis::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_terminalInstructionForGrammarAnalysis::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_terminalInstructionForGrammarAnalysis (& typeid (cPtr_terminalInstructionForGrammarAnalysis), & typeid (cPtr_abstractSyntaxInstructionForGrammarAnalysis), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_terminalInstructionForGrammarAnalysis::galgasRTTI (void) const {
  return & gClassInfoFor__terminalInstructionForGrammarAnalysis ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_terminalInstructionForGrammarAnalysis::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_terminalInstructionForGrammarAnalysis (mStartLocation, mTerminalSymbolName, mTerminalSymbolIndex COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         GALGAS class 'GGS_terminalInstructionForGrammarAnalysis'          *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_terminalInstructionForGrammarAnalysis ("terminalInstructionForGrammarAnalysis", true, & kTypeDescriptor_GGS_abstractSyntaxInstructionForGrammarAnalysis) ;

//---------------------------------------------------------------------------*

GGS_terminalInstructionForGrammarAnalysis::
GGS_terminalInstructionForGrammarAnalysis (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_terminalInstructionForGrammarAnalysis::
GGS_terminalInstructionForGrammarAnalysis (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_terminalInstructionForGrammarAnalysis GGS_terminalInstructionForGrammarAnalysis::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_terminalInstructionForGrammarAnalysis result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_terminalInstructionForGrammarAnalysis *> (inPointer) != NULL)
      : (typeid (cPtr_terminalInstructionForGrammarAnalysis) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_terminalInstructionForGrammarAnalysis (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_terminalInstructionForGrammarAnalysis),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_terminalInstructionForGrammarAnalysis GGS_terminalInstructionForGrammarAnalysis::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_uint & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_terminalInstructionForGrammarAnalysis result ;
  macroMyNew (result.mPointer, cPtr_terminalInstructionForGrammarAnalysis (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_terminalInstructionForGrammarAnalysis::actualTypeName (void) const {
  return "terminalInstructionForGrammarAnalysis" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__terminalInstructionForGrammarAnalysis ("terminalInstructionForGrammarAnalysis", gClassInfoFor__abstractSyntaxInstructionForGrammarAnalysis, & kTypeDescriptor_GGS_terminalInstructionForGrammarAnalysis) ;

//---------------------------------------------------------------------------*

GGS_object GGS_terminalInstructionForGrammarAnalysis::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_terminalInstructionForGrammarAnalysis * p = NULL ;
    macroMyNew (p, GGS_terminalInstructionForGrammarAnalysis (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_terminalInstructionForGrammarAnalysis GGS_terminalInstructionForGrammarAnalysis::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_terminalInstructionForGrammarAnalysis result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_terminalInstructionForGrammarAnalysis * p = dynamic_cast <const GGS_terminalInstructionForGrammarAnalysis *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_terminalInstructionForGrammarAnalysis, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_terminalInstructionForGrammarAnalysis::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_terminalInstructionForGrammarAnalysis ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          class 'cPtr_nonTerminalInstructionForGrammarAnalysis'            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_nonTerminalInstructionForGrammarAnalysis::
cPtr_nonTerminalInstructionForGrammarAnalysis (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_uint & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_abstractSyntaxInstructionForGrammarAnalysis (argument_0 COMMA_THERE),
mNonterminalSymbolName (argument_1),
mNonterminalSymbolIndex (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_nonTerminalInstructionForGrammarAnalysis * GGS_nonTerminalInstructionForGrammarAnalysis::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_nonTerminalInstructionForGrammarAnalysis) ;
    return (cPtr_nonTerminalInstructionForGrammarAnalysis *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_nonTerminalInstructionForGrammarAnalysis::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_nonTerminalInstructionForGrammarAnalysis * ptr = dynamic_cast <const cPtr_nonTerminalInstructionForGrammarAnalysis *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mNonterminalSymbolName.operator_isEqual (ptr->mNonterminalSymbolName).boolValue ()
         && mNonterminalSymbolIndex.operator_isEqual (ptr->mNonterminalSymbolIndex).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_nonTerminalInstructionForGrammarAnalysis::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@nonTerminalInstructionForGrammarAnalysis:"
           << mStartLocation.reader_description (inIndentation + 1)
           << mNonterminalSymbolName.reader_description (inIndentation + 1)
           << mNonterminalSymbolIndex.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_nonTerminalInstructionForGrammarAnalysis::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_nonTerminalInstructionForGrammarAnalysis::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_nonTerminalInstructionForGrammarAnalysis (& typeid (cPtr_nonTerminalInstructionForGrammarAnalysis), & typeid (cPtr_abstractSyntaxInstructionForGrammarAnalysis), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_nonTerminalInstructionForGrammarAnalysis::galgasRTTI (void) const {
  return & gClassInfoFor__nonTerminalInstructionForGrammarAnalysis ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_nonTerminalInstructionForGrammarAnalysis::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_nonTerminalInstructionForGrammarAnalysis (mStartLocation, mNonterminalSymbolName, mNonterminalSymbolIndex COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//       GALGAS class 'GGS_nonTerminalInstructionForGrammarAnalysis'         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_nonTerminalInstructionForGrammarAnalysis ("nonTerminalInstructionForGrammarAnalysis", true, & kTypeDescriptor_GGS_abstractSyntaxInstructionForGrammarAnalysis) ;

//---------------------------------------------------------------------------*

GGS_nonTerminalInstructionForGrammarAnalysis::
GGS_nonTerminalInstructionForGrammarAnalysis (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_nonTerminalInstructionForGrammarAnalysis::
GGS_nonTerminalInstructionForGrammarAnalysis (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_nonTerminalInstructionForGrammarAnalysis GGS_nonTerminalInstructionForGrammarAnalysis::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_nonTerminalInstructionForGrammarAnalysis result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_nonTerminalInstructionForGrammarAnalysis *> (inPointer) != NULL)
      : (typeid (cPtr_nonTerminalInstructionForGrammarAnalysis) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_nonTerminalInstructionForGrammarAnalysis (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_nonTerminalInstructionForGrammarAnalysis),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_nonTerminalInstructionForGrammarAnalysis GGS_nonTerminalInstructionForGrammarAnalysis::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_uint & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_nonTerminalInstructionForGrammarAnalysis result ;
  macroMyNew (result.mPointer, cPtr_nonTerminalInstructionForGrammarAnalysis (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_nonTerminalInstructionForGrammarAnalysis::actualTypeName (void) const {
  return "nonTerminalInstructionForGrammarAnalysis" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__nonTerminalInstructionForGrammarAnalysis ("nonTerminalInstructionForGrammarAnalysis", gClassInfoFor__abstractSyntaxInstructionForGrammarAnalysis, & kTypeDescriptor_GGS_nonTerminalInstructionForGrammarAnalysis) ;

//---------------------------------------------------------------------------*

GGS_object GGS_nonTerminalInstructionForGrammarAnalysis::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_nonTerminalInstructionForGrammarAnalysis * p = NULL ;
    macroMyNew (p, GGS_nonTerminalInstructionForGrammarAnalysis (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_nonTerminalInstructionForGrammarAnalysis GGS_nonTerminalInstructionForGrammarAnalysis::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_nonTerminalInstructionForGrammarAnalysis result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_nonTerminalInstructionForGrammarAnalysis * p = dynamic_cast <const GGS_nonTerminalInstructionForGrammarAnalysis *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_nonTerminalInstructionForGrammarAnalysis, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_nonTerminalInstructionForGrammarAnalysis::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_nonTerminalInstructionForGrammarAnalysis ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@branchListForGrammarAnalysis'               *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_branchListForGrammarAnalysis::
elementOf_GGS_branchListForGrammarAnalysis (const GGS_syntaxInstructionListForGrammarAnalysis & argument_0
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mSyntaxInstructionList (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_branchListForGrammarAnalysis::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_branchListForGrammarAnalysis * ptr = dynamic_cast <const elementOf_GGS_branchListForGrammarAnalysis *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mSyntaxInstructionList.operator_isEqual (ptr->mSyntaxInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_branchListForGrammarAnalysis::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSyntaxInstructionList.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@branchListForGrammarAnalysis'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_branchListForGrammarAnalysis ("branchListForGrammarAnalysis", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_branchListForGrammarAnalysis::
internalAppendValues (const GGS_syntaxInstructionListForGrammarAnalysis & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_branchListForGrammarAnalysis::
internalPrependValues (const GGS_syntaxInstructionListForGrammarAnalysis & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_branchListForGrammarAnalysis::
addAssign_operation (const GGS_syntaxInstructionListForGrammarAnalysis & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_branchListForGrammarAnalysis GGS_branchListForGrammarAnalysis::
operator_concat (const GGS_branchListForGrammarAnalysis & inOperand) const {
  GGS_branchListForGrammarAnalysis result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_branchListForGrammarAnalysis::
dotAssign_operation (const GGS_branchListForGrammarAnalysis inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_branchListForGrammarAnalysis * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_syntaxInstructionListForGrammarAnalysis  p_0 = p->mSyntaxInstructionList ;
          internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_branchListForGrammarAnalysis::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_syntaxInstructionListForGrammarAnalysis & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_branchListForGrammarAnalysis::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mSyntaxInstructionList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_branchListForGrammarAnalysis  GGS_branchListForGrammarAnalysis::
constructor_emptyList (void) {
  GGS_branchListForGrammarAnalysis result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_branchListForGrammarAnalysis  GGS_branchListForGrammarAnalysis::
constructor_listWithValue (const GGS_syntaxInstructionListForGrammarAnalysis & argument_0) {
  GGS_branchListForGrammarAnalysis result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_branchListForGrammarAnalysis::
internalSubListWithRange (GGS_branchListForGrammarAnalysis & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mSyntaxInstructionList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_branchListForGrammarAnalysis GGS_branchListForGrammarAnalysis::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_branchListForGrammarAnalysis result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_branchListForGrammarAnalysis GGS_branchListForGrammarAnalysis::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_branchListForGrammarAnalysis result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_branchListForGrammarAnalysis::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@branchListForGrammarAnalysis", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_branchListForGrammarAnalysis::
method_first (C_Compiler & inLexique,
              GGS_syntaxInstructionListForGrammarAnalysis & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSyntaxInstructionList ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_branchListForGrammarAnalysis::
method_last (C_Compiler & inLexique,
             GGS_syntaxInstructionListForGrammarAnalysis & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSyntaxInstructionList ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_branchListForGrammarAnalysis::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_syntaxInstructionListForGrammarAnalysis & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSyntaxInstructionList ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_branchListForGrammarAnalysis::
modifier_popLast (C_Compiler & inLexique,
                GGS_syntaxInstructionListForGrammarAnalysis & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSyntaxInstructionList ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_syntaxInstructionListForGrammarAnalysis  GGS_branchListForGrammarAnalysis::
reader_mSyntaxInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_syntaxInstructionListForGrammarAnalysis  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSyntaxInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_branchListForGrammarAnalysis::
modifier_setMSyntaxInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_syntaxInstructionListForGrammarAnalysis  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSyntaxInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_syntaxInstructionListForGrammarAnalysis  & GGS_branchListForGrammarAnalysis::cEnumerator::_mSyntaxInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mSyntaxInstructionList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_branchListForGrammarAnalysis::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_branchListForGrammarAnalysis * p = NULL ;
    macroMyNew (p, GGS_branchListForGrammarAnalysis (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_branchListForGrammarAnalysis GGS_branchListForGrammarAnalysis::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_branchListForGrammarAnalysis result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_branchListForGrammarAnalysis * p = dynamic_cast <const GGS_branchListForGrammarAnalysis *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_branchListForGrammarAnalysis, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_branchListForGrammarAnalysis::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_branchListForGrammarAnalysis ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_selectInstructionForGrammarAnalysis'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_selectInstructionForGrammarAnalysis::
cPtr_selectInstructionForGrammarAnalysis (const GGS_location & argument_0,
                                const GGS_branchListForGrammarAnalysis & argument_1,
                                const GGS_uint & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_abstractSyntaxInstructionForGrammarAnalysis (argument_0 COMMA_THERE),
mSelectBranchList (argument_1),
mAddedNonTerminalSymbolIndex (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_selectInstructionForGrammarAnalysis * GGS_selectInstructionForGrammarAnalysis::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_selectInstructionForGrammarAnalysis) ;
    return (cPtr_selectInstructionForGrammarAnalysis *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_selectInstructionForGrammarAnalysis::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_selectInstructionForGrammarAnalysis * ptr = dynamic_cast <const cPtr_selectInstructionForGrammarAnalysis *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mSelectBranchList.operator_isEqual (ptr->mSelectBranchList).boolValue ()
         && mAddedNonTerminalSymbolIndex.operator_isEqual (ptr->mAddedNonTerminalSymbolIndex).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_selectInstructionForGrammarAnalysis::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@selectInstructionForGrammarAnalysis:"
           << mStartLocation.reader_description (inIndentation + 1)
           << mSelectBranchList.reader_description (inIndentation + 1)
           << mAddedNonTerminalSymbolIndex.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_selectInstructionForGrammarAnalysis::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_selectInstructionForGrammarAnalysis::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_selectInstructionForGrammarAnalysis (& typeid (cPtr_selectInstructionForGrammarAnalysis), & typeid (cPtr_abstractSyntaxInstructionForGrammarAnalysis), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_selectInstructionForGrammarAnalysis::galgasRTTI (void) const {
  return & gClassInfoFor__selectInstructionForGrammarAnalysis ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_selectInstructionForGrammarAnalysis::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_selectInstructionForGrammarAnalysis (mStartLocation, mSelectBranchList, mAddedNonTerminalSymbolIndex COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_selectInstructionForGrammarAnalysis'           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_selectInstructionForGrammarAnalysis ("selectInstructionForGrammarAnalysis", true, & kTypeDescriptor_GGS_abstractSyntaxInstructionForGrammarAnalysis) ;

//---------------------------------------------------------------------------*

GGS_selectInstructionForGrammarAnalysis::
GGS_selectInstructionForGrammarAnalysis (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_selectInstructionForGrammarAnalysis::
GGS_selectInstructionForGrammarAnalysis (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_selectInstructionForGrammarAnalysis GGS_selectInstructionForGrammarAnalysis::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_selectInstructionForGrammarAnalysis result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_selectInstructionForGrammarAnalysis *> (inPointer) != NULL)
      : (typeid (cPtr_selectInstructionForGrammarAnalysis) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_selectInstructionForGrammarAnalysis (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_selectInstructionForGrammarAnalysis),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_selectInstructionForGrammarAnalysis GGS_selectInstructionForGrammarAnalysis::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_branchListForGrammarAnalysis & argument_1,
                 const GGS_uint & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_selectInstructionForGrammarAnalysis result ;
  macroMyNew (result.mPointer, cPtr_selectInstructionForGrammarAnalysis (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_selectInstructionForGrammarAnalysis::actualTypeName (void) const {
  return "selectInstructionForGrammarAnalysis" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__selectInstructionForGrammarAnalysis ("selectInstructionForGrammarAnalysis", gClassInfoFor__abstractSyntaxInstructionForGrammarAnalysis, & kTypeDescriptor_GGS_selectInstructionForGrammarAnalysis) ;

//---------------------------------------------------------------------------*

GGS_object GGS_selectInstructionForGrammarAnalysis::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_selectInstructionForGrammarAnalysis * p = NULL ;
    macroMyNew (p, GGS_selectInstructionForGrammarAnalysis (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_selectInstructionForGrammarAnalysis GGS_selectInstructionForGrammarAnalysis::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_selectInstructionForGrammarAnalysis result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_selectInstructionForGrammarAnalysis * p = dynamic_cast <const GGS_selectInstructionForGrammarAnalysis *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_selectInstructionForGrammarAnalysis, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_selectInstructionForGrammarAnalysis::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_selectInstructionForGrammarAnalysis ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_repeatInstructionForGrammarAnalysis'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_repeatInstructionForGrammarAnalysis::
cPtr_repeatInstructionForGrammarAnalysis (const GGS_location & argument_0,
                                const GGS_branchListForGrammarAnalysis & argument_1,
                                const GGS_uint & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_abstractSyntaxInstructionForGrammarAnalysis (argument_0 COMMA_THERE),
mRepeatBranchList (argument_1),
mAddedNonTerminalSymbolIndex (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_repeatInstructionForGrammarAnalysis * GGS_repeatInstructionForGrammarAnalysis::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_repeatInstructionForGrammarAnalysis) ;
    return (cPtr_repeatInstructionForGrammarAnalysis *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_repeatInstructionForGrammarAnalysis::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_repeatInstructionForGrammarAnalysis * ptr = dynamic_cast <const cPtr_repeatInstructionForGrammarAnalysis *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mRepeatBranchList.operator_isEqual (ptr->mRepeatBranchList).boolValue ()
         && mAddedNonTerminalSymbolIndex.operator_isEqual (ptr->mAddedNonTerminalSymbolIndex).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_repeatInstructionForGrammarAnalysis::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@repeatInstructionForGrammarAnalysis:"
           << mStartLocation.reader_description (inIndentation + 1)
           << mRepeatBranchList.reader_description (inIndentation + 1)
           << mAddedNonTerminalSymbolIndex.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_repeatInstructionForGrammarAnalysis::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_repeatInstructionForGrammarAnalysis::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_repeatInstructionForGrammarAnalysis (& typeid (cPtr_repeatInstructionForGrammarAnalysis), & typeid (cPtr_abstractSyntaxInstructionForGrammarAnalysis), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_repeatInstructionForGrammarAnalysis::galgasRTTI (void) const {
  return & gClassInfoFor__repeatInstructionForGrammarAnalysis ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_repeatInstructionForGrammarAnalysis::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_repeatInstructionForGrammarAnalysis (mStartLocation, mRepeatBranchList, mAddedNonTerminalSymbolIndex COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_repeatInstructionForGrammarAnalysis'           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_repeatInstructionForGrammarAnalysis ("repeatInstructionForGrammarAnalysis", true, & kTypeDescriptor_GGS_abstractSyntaxInstructionForGrammarAnalysis) ;

//---------------------------------------------------------------------------*

GGS_repeatInstructionForGrammarAnalysis::
GGS_repeatInstructionForGrammarAnalysis (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_repeatInstructionForGrammarAnalysis::
GGS_repeatInstructionForGrammarAnalysis (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_repeatInstructionForGrammarAnalysis GGS_repeatInstructionForGrammarAnalysis::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_repeatInstructionForGrammarAnalysis result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_repeatInstructionForGrammarAnalysis *> (inPointer) != NULL)
      : (typeid (cPtr_repeatInstructionForGrammarAnalysis) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_repeatInstructionForGrammarAnalysis (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_repeatInstructionForGrammarAnalysis),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_repeatInstructionForGrammarAnalysis GGS_repeatInstructionForGrammarAnalysis::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_branchListForGrammarAnalysis & argument_1,
                 const GGS_uint & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_repeatInstructionForGrammarAnalysis result ;
  macroMyNew (result.mPointer, cPtr_repeatInstructionForGrammarAnalysis (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_repeatInstructionForGrammarAnalysis::actualTypeName (void) const {
  return "repeatInstructionForGrammarAnalysis" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__repeatInstructionForGrammarAnalysis ("repeatInstructionForGrammarAnalysis", gClassInfoFor__abstractSyntaxInstructionForGrammarAnalysis, & kTypeDescriptor_GGS_repeatInstructionForGrammarAnalysis) ;

//---------------------------------------------------------------------------*

GGS_object GGS_repeatInstructionForGrammarAnalysis::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_repeatInstructionForGrammarAnalysis * p = NULL ;
    macroMyNew (p, GGS_repeatInstructionForGrammarAnalysis (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_repeatInstructionForGrammarAnalysis GGS_repeatInstructionForGrammarAnalysis::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_repeatInstructionForGrammarAnalysis result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_repeatInstructionForGrammarAnalysis * p = dynamic_cast <const GGS_repeatInstructionForGrammarAnalysis *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_repeatInstructionForGrammarAnalysis, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_repeatInstructionForGrammarAnalysis::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_repeatInstructionForGrammarAnalysis ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         Element of list '@syntaxComponentListForGrammarAnalysis'          *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_syntaxComponentListForGrammarAnalysis::
elementOf_GGS_syntaxComponentListForGrammarAnalysis (const GGS_productionRuleListForGrammarAnalysis & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mProductionRulesList (argument_0),
mSyntaxComponentName (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_syntaxComponentListForGrammarAnalysis::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_syntaxComponentListForGrammarAnalysis * ptr = dynamic_cast <const elementOf_GGS_syntaxComponentListForGrammarAnalysis *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mProductionRulesList.operator_isEqual (ptr->mProductionRulesList).boolValue ()
         && mSyntaxComponentName.operator_isEqual (ptr->mSyntaxComponentName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_syntaxComponentListForGrammarAnalysis::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mProductionRulesList.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSyntaxComponentName.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              List '@syntaxComponentListForGrammarAnalysis'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_syntaxComponentListForGrammarAnalysis ("syntaxComponentListForGrammarAnalysis", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_syntaxComponentListForGrammarAnalysis::
internalAppendValues (const GGS_productionRuleListForGrammarAnalysis & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_syntaxComponentListForGrammarAnalysis::
internalPrependValues (const GGS_productionRuleListForGrammarAnalysis & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_syntaxComponentListForGrammarAnalysis::
addAssign_operation (const GGS_productionRuleListForGrammarAnalysis & argument_0,
                                const GGS_lstring & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_syntaxComponentListForGrammarAnalysis GGS_syntaxComponentListForGrammarAnalysis::
operator_concat (const GGS_syntaxComponentListForGrammarAnalysis & inOperand) const {
  GGS_syntaxComponentListForGrammarAnalysis result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_syntaxComponentListForGrammarAnalysis::
dotAssign_operation (const GGS_syntaxComponentListForGrammarAnalysis inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_syntaxComponentListForGrammarAnalysis * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_productionRuleListForGrammarAnalysis  p_0 = p->mProductionRulesList ;
          GGS_lstring  p_1 = p->mSyntaxComponentName ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_syntaxComponentListForGrammarAnalysis::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_productionRuleListForGrammarAnalysis & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_syntaxComponentListForGrammarAnalysis::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mProductionRulesList,
                                ptr->mSyntaxComponentName
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_syntaxComponentListForGrammarAnalysis  GGS_syntaxComponentListForGrammarAnalysis::
constructor_emptyList (void) {
  GGS_syntaxComponentListForGrammarAnalysis result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_syntaxComponentListForGrammarAnalysis  GGS_syntaxComponentListForGrammarAnalysis::
constructor_listWithValue (const GGS_productionRuleListForGrammarAnalysis & argument_0,
                                const GGS_lstring & argument_1) {
  GGS_syntaxComponentListForGrammarAnalysis result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_syntaxComponentListForGrammarAnalysis::
internalSubListWithRange (GGS_syntaxComponentListForGrammarAnalysis & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mProductionRulesList, ptr->mSyntaxComponentName) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_syntaxComponentListForGrammarAnalysis GGS_syntaxComponentListForGrammarAnalysis::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_syntaxComponentListForGrammarAnalysis result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_syntaxComponentListForGrammarAnalysis GGS_syntaxComponentListForGrammarAnalysis::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_syntaxComponentListForGrammarAnalysis result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_syntaxComponentListForGrammarAnalysis::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@syntaxComponentListForGrammarAnalysis", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_syntaxComponentListForGrammarAnalysis::
method_first (C_Compiler & inLexique,
              GGS_productionRuleListForGrammarAnalysis & _out_0,
              GGS_lstring & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mProductionRulesList ;
    _out_1 = ptr->mSyntaxComponentName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_syntaxComponentListForGrammarAnalysis::
method_last (C_Compiler & inLexique,
             GGS_productionRuleListForGrammarAnalysis & _out_0,
             GGS_lstring & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mProductionRulesList ;
    _out_1 = ptr->mSyntaxComponentName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_syntaxComponentListForGrammarAnalysis::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_productionRuleListForGrammarAnalysis & _out_0,
                 GGS_lstring & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mProductionRulesList ;
    _out_1 = ptr->mSyntaxComponentName ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_syntaxComponentListForGrammarAnalysis::
modifier_popLast (C_Compiler & inLexique,
                GGS_productionRuleListForGrammarAnalysis & _out_0,
                GGS_lstring & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mProductionRulesList ;
    _out_1 = ptr->mSyntaxComponentName ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_productionRuleListForGrammarAnalysis  GGS_syntaxComponentListForGrammarAnalysis::
reader_mProductionRulesListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_productionRuleListForGrammarAnalysis  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mProductionRulesList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_syntaxComponentListForGrammarAnalysis::
reader_mSyntaxComponentNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSyntaxComponentName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_syntaxComponentListForGrammarAnalysis::
modifier_setMProductionRulesListAtIndex (C_Compiler & inLexique,
                              const GGS_productionRuleListForGrammarAnalysis  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mProductionRulesList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_syntaxComponentListForGrammarAnalysis::
modifier_setMSyntaxComponentNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSyntaxComponentName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_productionRuleListForGrammarAnalysis  & GGS_syntaxComponentListForGrammarAnalysis::cEnumerator::_mProductionRulesList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mProductionRulesList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_syntaxComponentListForGrammarAnalysis::cEnumerator::_mSyntaxComponentName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mSyntaxComponentName ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_syntaxComponentListForGrammarAnalysis::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_syntaxComponentListForGrammarAnalysis * p = NULL ;
    macroMyNew (p, GGS_syntaxComponentListForGrammarAnalysis (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_syntaxComponentListForGrammarAnalysis GGS_syntaxComponentListForGrammarAnalysis::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_syntaxComponentListForGrammarAnalysis result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_syntaxComponentListForGrammarAnalysis * p = dynamic_cast <const GGS_syntaxComponentListForGrammarAnalysis *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_syntaxComponentListForGrammarAnalysis, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_syntaxComponentListForGrammarAnalysis::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_syntaxComponentListForGrammarAnalysis ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'e_terminalSymbolsMapForGrammarAnalysis'               *
//                                                                           *
//---------------------------------------------------------------------------*

e_terminalSymbolsMapForGrammarAnalysis::e_terminalSymbolsMapForGrammarAnalysis (void) :
mTerminalIndex () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//            class map '@terminalSymbolsMapForGrammarAnalysis'              *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_terminalSymbolsMapForGrammarAnalysis ("terminalSymbolsMapForGrammarAnalysis", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_terminalSymbolsMapForGrammarAnalysis::
elementOf_GGS_terminalSymbolsMapForGrammarAnalysis (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_terminalSymbolsMapForGrammarAnalysis & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_terminalSymbolsMapForGrammarAnalysis::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mTerminalIndex.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_terminalSymbolsMapForGrammarAnalysis::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_terminalSymbolsMapForGrammarAnalysis * ptr = dynamic_cast <const elementOf_GGS_terminalSymbolsMapForGrammarAnalysis *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mTerminalIndex.operator_isEqual (ptr->mInfo.mTerminalIndex)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_terminalSymbolsMapForGrammarAnalysis::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_terminalSymbolsMapForGrammarAnalysis *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_terminalSymbolsMapForGrammarAnalysis * info = (e_terminalSymbolsMapForGrammarAnalysis *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_terminalSymbolsMapForGrammarAnalysis::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_terminalSymbolsMapForGrammarAnalysis *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_terminalSymbolsMapForGrammarAnalysis * info = (e_terminalSymbolsMapForGrammarAnalysis *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_terminalSymbolsMapForGrammarAnalysis GGS_terminalSymbolsMapForGrammarAnalysis::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_terminalSymbolsMapForGrammarAnalysis result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_terminalSymbolsMapForGrammarAnalysis::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_terminalSymbolsMapForGrammarAnalysis info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_terminalSymbolsMapForGrammarAnalysis::
operator_isEqual (const GGS_terminalSymbolsMapForGrammarAnalysis & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_terminalSymbolsMapForGrammarAnalysis::
operator_isNotEqual (const GGS_terminalSymbolsMapForGrammarAnalysis & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_terminalSymbolsMapForGrammarAnalysis::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_terminalSymbolsMapForGrammarAnalysis::
insertElement (C_Compiler & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_uint & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_terminalSymbolsMapForGrammarAnalysis info  ;
    info.mTerminalIndex = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_terminalSymbolsMapForGrammarAnalysis::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_uint   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mTerminalIndex ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_terminalSymbolsMapForGrammarAnalysis::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('m'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE (' '),
  TO_UNICODE ('s'),
  TO_UNICODE ('y'),
  TO_UNICODE ('m'),
  TO_UNICODE ('b'),
  TO_UNICODE ('o'),
  TO_UNICODE ('l'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('$'),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('$'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_terminalSymbolsMapForGrammarAnalysis::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_uint   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_terminalSymbolsMapForGrammarAnalysis::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('m'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE (' '),
  TO_UNICODE ('s'),
  TO_UNICODE ('y'),
  TO_UNICODE ('m'),
  TO_UNICODE ('b'),
  TO_UNICODE ('o'),
  TO_UNICODE ('l'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('$'),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('$'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_terminalSymbolsMapForGrammarAnalysis::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_uint & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_terminalSymbolsMapForGrammarAnalysis GGS_terminalSymbolsMapForGrammarAnalysis::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_terminalSymbolsMapForGrammarAnalysis & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_terminalSymbolsMapForGrammarAnalysis result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_terminalSymbolsMapForGrammarAnalysis GGS_terminalSymbolsMapForGrammarAnalysis::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_terminalSymbolsMapForGrammarAnalysis result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_terminalSymbolsMapForGrammarAnalysis::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @terminalSymbolsMapForGrammarAnalysis " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_terminalSymbolsMapForGrammarAnalysis::cEnumerator::_mTerminalIndex (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mTerminalIndex ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_terminalSymbolsMapForGrammarAnalysis::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_terminalSymbolsMapForGrammarAnalysis * p = NULL ;
    macroMyNew (p, GGS_terminalSymbolsMapForGrammarAnalysis (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_terminalSymbolsMapForGrammarAnalysis GGS_terminalSymbolsMapForGrammarAnalysis::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_terminalSymbolsMapForGrammarAnalysis result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_terminalSymbolsMapForGrammarAnalysis * p = dynamic_cast <const GGS_terminalSymbolsMapForGrammarAnalysis *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_terminalSymbolsMapForGrammarAnalysis, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_terminalSymbolsMapForGrammarAnalysis::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_terminalSymbolsMapForGrammarAnalysis ;
}

//---------------------------------------------------------------------------*

