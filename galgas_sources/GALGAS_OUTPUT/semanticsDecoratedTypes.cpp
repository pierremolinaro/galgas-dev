//---------------------------------------------------------------------------*
//                                                                           *
//                    File 'semanticsDecoratedTypes.cpp'                     *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                       may 22th, 2010, at 10h0'30"                         *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if CURRENT_LIBPM_VERSION != VERSION_OF_LIBPM_USED_BY_GALGAS_COMPILER
  #error "This file has been compiled with a version of GALGAS that uses libpm version VERSION_OF_LIBPM_USED_BY_GALGAS_COMPILER, different than the current version (CURRENT_LIBPM_VERSION) of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "galgas/C_galgas_CLI_Options.h"
#include "semanticsDecoratedTypes.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "semanticsDecoratedTypes.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_semanticExpressionForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_semanticExpressionForGeneration::
cPtr_semanticExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE),
mType (argument_0),
mLocation (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_semanticExpressionForGeneration * GGS_semanticExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_semanticExpressionForGeneration) ;
    return (cPtr_semanticExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_semanticExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@semanticExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_semanticExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_semanticExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_semanticExpressionForGeneration (& typeid (cPtr_semanticExpressionForGeneration), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_semanticExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__semanticExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_semanticExpressionForGeneration'             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_semanticExpressionForGeneration ("semanticExpressionForGeneration", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration::
GGS_semanticExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration::
GGS_semanticExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_semanticExpressionForGeneration GGS_semanticExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_semanticExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_semanticExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_semanticExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_semanticExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_semanticExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapProxy  GGS_semanticExpressionForGeneration::
reader_mType (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_unifiedTypeMapProxy   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_semanticExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_semanticExpressionForGeneration *) mPointer)->mType ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_semanticExpressionForGeneration::
reader_mLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_semanticExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_semanticExpressionForGeneration *) mPointer)->mLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_semanticExpressionForGeneration::actualTypeName (void) const {
  return "semanticExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_semanticExpressionForGeneration::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__semanticExpressionForGeneration ("semanticExpressionForGeneration", & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_semanticExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_semanticExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_semanticExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration GGS_semanticExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_semanticExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_semanticExpressionForGeneration * p = dynamic_cast <const GGS_semanticExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_semanticExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_semanticExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_semanticExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Element of list '@semanticExpressionListForGeneration'           *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_semanticExpressionListForGeneration::
elementOf_GGS_semanticExpressionListForGeneration (const GGS_semanticExpressionForGeneration & argument_0
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mExpression (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_semanticExpressionListForGeneration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_semanticExpressionListForGeneration * ptr = dynamic_cast <const elementOf_GGS_semanticExpressionListForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mExpression.operator_isEqual (ptr->mExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_semanticExpressionListForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mExpression.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               List '@semanticExpressionListForGeneration'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_semanticExpressionListForGeneration ("semanticExpressionListForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_semanticExpressionListForGeneration::
internalAppendValues (const GGS_semanticExpressionForGeneration & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticExpressionListForGeneration::
internalPrependValues (const GGS_semanticExpressionForGeneration & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticExpressionListForGeneration::
addAssign_operation (const GGS_semanticExpressionForGeneration & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionListForGeneration GGS_semanticExpressionListForGeneration::
operator_concat (const GGS_semanticExpressionListForGeneration & inOperand) const {
  GGS_semanticExpressionListForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_semanticExpressionListForGeneration::
dotAssign_operation (const GGS_semanticExpressionListForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_semanticExpressionListForGeneration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_semanticExpressionForGeneration  p_0 = p->mExpression ;
          internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticExpressionListForGeneration::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_semanticExpressionForGeneration & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticExpressionListForGeneration::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mExpression
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionListForGeneration  GGS_semanticExpressionListForGeneration::
constructor_emptyList (void) {
  GGS_semanticExpressionListForGeneration result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionListForGeneration  GGS_semanticExpressionListForGeneration::
constructor_listWithValue (const GGS_semanticExpressionForGeneration & argument_0) {
  GGS_semanticExpressionListForGeneration result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_semanticExpressionListForGeneration::
internalSubListWithRange (GGS_semanticExpressionListForGeneration & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mExpression) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionListForGeneration GGS_semanticExpressionListForGeneration::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_semanticExpressionListForGeneration result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionListForGeneration GGS_semanticExpressionListForGeneration::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_semanticExpressionListForGeneration result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_semanticExpressionListForGeneration::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@semanticExpressionListForGeneration", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticExpressionListForGeneration::
method_first (C_Compiler & inLexique,
              GGS_semanticExpressionForGeneration & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mExpression ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticExpressionListForGeneration::
method_last (C_Compiler & inLexique,
             GGS_semanticExpressionForGeneration & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mExpression ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticExpressionListForGeneration::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_semanticExpressionForGeneration & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mExpression ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticExpressionListForGeneration::
modifier_popLast (C_Compiler & inLexique,
                GGS_semanticExpressionForGeneration & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mExpression ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_semanticExpressionListForGeneration::
reader_mExpressionAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mExpression ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_semanticExpressionListForGeneration::
modifier_setMExpressionAtIndex (C_Compiler & inLexique,
                              const GGS_semanticExpressionForGeneration  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mExpression = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticExpressionForGeneration  & GGS_semanticExpressionListForGeneration::cEnumerator::_mExpression (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mExpression ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_semanticExpressionListForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_semanticExpressionListForGeneration * p = NULL ;
    macroMyNew (p, GGS_semanticExpressionListForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionListForGeneration GGS_semanticExpressionListForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_semanticExpressionListForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_semanticExpressionListForGeneration * p = dynamic_cast <const GGS_semanticExpressionListForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_semanticExpressionListForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_semanticExpressionListForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_semanticExpressionListForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_selfInExpressionForGeneration'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_selfInExpressionForGeneration::
cPtr_selfInExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_string& argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mSelfCppName (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_selfInExpressionForGeneration * GGS_selfInExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_selfInExpressionForGeneration) ;
    return (cPtr_selfInExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_selfInExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_selfInExpressionForGeneration * ptr = dynamic_cast <const cPtr_selfInExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mSelfCppName.operator_isEqual (ptr->mSelfCppName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_selfInExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@selfInExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mSelfCppName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_selfInExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_selfInExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_selfInExpressionForGeneration (& typeid (cPtr_selfInExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_selfInExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__selfInExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_selfInExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_selfInExpressionForGeneration (mType, mLocation, mSelfCppName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_selfInExpressionForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_selfInExpressionForGeneration ("selfInExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_selfInExpressionForGeneration::
GGS_selfInExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_selfInExpressionForGeneration::
GGS_selfInExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_selfInExpressionForGeneration GGS_selfInExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_selfInExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_selfInExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_selfInExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_selfInExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_selfInExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_selfInExpressionForGeneration GGS_selfInExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_string& argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_selfInExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_selfInExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_selfInExpressionForGeneration::
reader_mSelfCppName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_selfInExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_selfInExpressionForGeneration *) mPointer)->mSelfCppName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_selfInExpressionForGeneration::actualTypeName (void) const {
  return "selfInExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__selfInExpressionForGeneration ("selfInExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_selfInExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_selfInExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_selfInExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_selfInExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_selfInExpressionForGeneration GGS_selfInExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_selfInExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_selfInExpressionForGeneration * p = dynamic_cast <const GGS_selfInExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_selfInExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_selfInExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_selfInExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_hereExpressionForGeneration'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_hereExpressionForGeneration::
cPtr_hereExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_hereExpressionForGeneration * GGS_hereExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_hereExpressionForGeneration) ;
    return (cPtr_hereExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_hereExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_hereExpressionForGeneration * ptr = dynamic_cast <const cPtr_hereExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_hereExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@hereExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_hereExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_hereExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_hereExpressionForGeneration (& typeid (cPtr_hereExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_hereExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__hereExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_hereExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_hereExpressionForGeneration (mType, mLocation COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_hereExpressionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_hereExpressionForGeneration ("hereExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_hereExpressionForGeneration::
GGS_hereExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_hereExpressionForGeneration::
GGS_hereExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_hereExpressionForGeneration GGS_hereExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_hereExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_hereExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_hereExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_hereExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_hereExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_hereExpressionForGeneration GGS_hereExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_hereExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_hereExpressionForGeneration (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_hereExpressionForGeneration::actualTypeName (void) const {
  return "hereExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__hereExpressionForGeneration ("hereExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_hereExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_hereExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_hereExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_hereExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_hereExpressionForGeneration GGS_hereExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_hereExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_hereExpressionForGeneration * p = dynamic_cast <const GGS_hereExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_hereExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_hereExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_hereExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_trueExpressionForGeneration'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_trueExpressionForGeneration::
cPtr_trueExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_trueExpressionForGeneration * GGS_trueExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_trueExpressionForGeneration) ;
    return (cPtr_trueExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_trueExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_trueExpressionForGeneration * ptr = dynamic_cast <const cPtr_trueExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_trueExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@trueExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_trueExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_trueExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_trueExpressionForGeneration (& typeid (cPtr_trueExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_trueExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__trueExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_trueExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_trueExpressionForGeneration (mType, mLocation COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_trueExpressionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_trueExpressionForGeneration ("trueExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_trueExpressionForGeneration::
GGS_trueExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_trueExpressionForGeneration::
GGS_trueExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_trueExpressionForGeneration GGS_trueExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_trueExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_trueExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_trueExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_trueExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_trueExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_trueExpressionForGeneration GGS_trueExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_trueExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_trueExpressionForGeneration (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_trueExpressionForGeneration::actualTypeName (void) const {
  return "trueExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__trueExpressionForGeneration ("trueExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_trueExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_trueExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_trueExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_trueExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_trueExpressionForGeneration GGS_trueExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_trueExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_trueExpressionForGeneration * p = dynamic_cast <const GGS_trueExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_trueExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_trueExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_trueExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_falseExpressionForGeneration'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_falseExpressionForGeneration::
cPtr_falseExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_falseExpressionForGeneration * GGS_falseExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_falseExpressionForGeneration) ;
    return (cPtr_falseExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_falseExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_falseExpressionForGeneration * ptr = dynamic_cast <const cPtr_falseExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_falseExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@falseExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_falseExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_falseExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_falseExpressionForGeneration (& typeid (cPtr_falseExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_falseExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__falseExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_falseExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_falseExpressionForGeneration (mType, mLocation COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_falseExpressionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_falseExpressionForGeneration ("falseExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_falseExpressionForGeneration::
GGS_falseExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_falseExpressionForGeneration::
GGS_falseExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_falseExpressionForGeneration GGS_falseExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_falseExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_falseExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_falseExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_falseExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_falseExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_falseExpressionForGeneration GGS_falseExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_falseExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_falseExpressionForGeneration (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_falseExpressionForGeneration::actualTypeName (void) const {
  return "falseExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__falseExpressionForGeneration ("falseExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_falseExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_falseExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_falseExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_falseExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_falseExpressionForGeneration GGS_falseExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_falseExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_falseExpressionForGeneration * p = dynamic_cast <const GGS_falseExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_falseExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_falseExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_falseExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_literalCharExpressionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_literalCharExpressionForGeneration::
cPtr_literalCharExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_char& argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mCharacter (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_literalCharExpressionForGeneration * GGS_literalCharExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_literalCharExpressionForGeneration) ;
    return (cPtr_literalCharExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_literalCharExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_literalCharExpressionForGeneration * ptr = dynamic_cast <const cPtr_literalCharExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mCharacter.operator_isEqual (ptr->mCharacter).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_literalCharExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@literalCharExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mCharacter.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_literalCharExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_literalCharExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_literalCharExpressionForGeneration (& typeid (cPtr_literalCharExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_literalCharExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__literalCharExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_literalCharExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_literalCharExpressionForGeneration (mType, mLocation, mCharacter COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_literalCharExpressionForGeneration'            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_literalCharExpressionForGeneration ("literalCharExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_literalCharExpressionForGeneration::
GGS_literalCharExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_literalCharExpressionForGeneration::
GGS_literalCharExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_literalCharExpressionForGeneration GGS_literalCharExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_literalCharExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_literalCharExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_literalCharExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_literalCharExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_literalCharExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalCharExpressionForGeneration GGS_literalCharExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_char& argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_literalCharExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_literalCharExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_char GGS_literalCharExpressionForGeneration::
reader_mCharacter (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_char  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_literalCharExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_literalCharExpressionForGeneration *) mPointer)->mCharacter ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_literalCharExpressionForGeneration::actualTypeName (void) const {
  return "literalCharExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__literalCharExpressionForGeneration ("literalCharExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_literalCharExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_literalCharExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_literalCharExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_literalCharExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalCharExpressionForGeneration GGS_literalCharExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_literalCharExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_literalCharExpressionForGeneration * p = dynamic_cast <const GGS_literalCharExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_literalCharExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_literalCharExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_literalCharExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            class 'cPtr_literalStringExpressionForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_literalStringExpressionForGeneration::
cPtr_literalStringExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_string& argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mString (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_literalStringExpressionForGeneration * GGS_literalStringExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_literalStringExpressionForGeneration) ;
    return (cPtr_literalStringExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_literalStringExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_literalStringExpressionForGeneration * ptr = dynamic_cast <const cPtr_literalStringExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mString.operator_isEqual (ptr->mString).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_literalStringExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@literalStringExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mString.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_literalStringExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_literalStringExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_literalStringExpressionForGeneration (& typeid (cPtr_literalStringExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_literalStringExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__literalStringExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_literalStringExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_literalStringExpressionForGeneration (mType, mLocation, mString COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         GALGAS class 'GGS_literalStringExpressionForGeneration'           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_literalStringExpressionForGeneration ("literalStringExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_literalStringExpressionForGeneration::
GGS_literalStringExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_literalStringExpressionForGeneration::
GGS_literalStringExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_literalStringExpressionForGeneration GGS_literalStringExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_literalStringExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_literalStringExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_literalStringExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_literalStringExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_literalStringExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalStringExpressionForGeneration GGS_literalStringExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_string& argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_literalStringExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_literalStringExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_literalStringExpressionForGeneration::
reader_mString (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_literalStringExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_literalStringExpressionForGeneration *) mPointer)->mString ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_literalStringExpressionForGeneration::actualTypeName (void) const {
  return "literalStringExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__literalStringExpressionForGeneration ("literalStringExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_literalStringExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_literalStringExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_literalStringExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_literalStringExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalStringExpressionForGeneration GGS_literalStringExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_literalStringExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_literalStringExpressionForGeneration * p = dynamic_cast <const GGS_literalStringExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_literalStringExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_literalStringExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_literalStringExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            class 'cPtr_literalDoubleExpressionForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_literalDoubleExpressionForGeneration::
cPtr_literalDoubleExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_double& argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mValue (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_literalDoubleExpressionForGeneration * GGS_literalDoubleExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_literalDoubleExpressionForGeneration) ;
    return (cPtr_literalDoubleExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_literalDoubleExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_literalDoubleExpressionForGeneration * ptr = dynamic_cast <const cPtr_literalDoubleExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mValue.operator_isEqual (ptr->mValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_literalDoubleExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@literalDoubleExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mValue.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_literalDoubleExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_literalDoubleExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_literalDoubleExpressionForGeneration (& typeid (cPtr_literalDoubleExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_literalDoubleExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__literalDoubleExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_literalDoubleExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_literalDoubleExpressionForGeneration (mType, mLocation, mValue COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         GALGAS class 'GGS_literalDoubleExpressionForGeneration'           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_literalDoubleExpressionForGeneration ("literalDoubleExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_literalDoubleExpressionForGeneration::
GGS_literalDoubleExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_literalDoubleExpressionForGeneration::
GGS_literalDoubleExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_literalDoubleExpressionForGeneration GGS_literalDoubleExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_literalDoubleExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_literalDoubleExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_literalDoubleExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_literalDoubleExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_literalDoubleExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalDoubleExpressionForGeneration GGS_literalDoubleExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_double& argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_literalDoubleExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_literalDoubleExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_double GGS_literalDoubleExpressionForGeneration::
reader_mValue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_double  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_literalDoubleExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_literalDoubleExpressionForGeneration *) mPointer)->mValue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_literalDoubleExpressionForGeneration::actualTypeName (void) const {
  return "literalDoubleExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__literalDoubleExpressionForGeneration ("literalDoubleExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_literalDoubleExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_literalDoubleExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_literalDoubleExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_literalDoubleExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalDoubleExpressionForGeneration GGS_literalDoubleExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_literalDoubleExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_literalDoubleExpressionForGeneration * p = dynamic_cast <const GGS_literalDoubleExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_literalDoubleExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_literalDoubleExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_literalDoubleExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_literalUIntExpressionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_literalUIntExpressionForGeneration::
cPtr_literalUIntExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_uint & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mValue (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_literalUIntExpressionForGeneration * GGS_literalUIntExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_literalUIntExpressionForGeneration) ;
    return (cPtr_literalUIntExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_literalUIntExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_literalUIntExpressionForGeneration * ptr = dynamic_cast <const cPtr_literalUIntExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mValue.operator_isEqual (ptr->mValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_literalUIntExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@literalUIntExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mValue.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_literalUIntExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_literalUIntExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_literalUIntExpressionForGeneration (& typeid (cPtr_literalUIntExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_literalUIntExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__literalUIntExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_literalUIntExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_literalUIntExpressionForGeneration (mType, mLocation, mValue COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_literalUIntExpressionForGeneration'            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_literalUIntExpressionForGeneration ("literalUIntExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_literalUIntExpressionForGeneration::
GGS_literalUIntExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_literalUIntExpressionForGeneration::
GGS_literalUIntExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_literalUIntExpressionForGeneration GGS_literalUIntExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_literalUIntExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_literalUIntExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_literalUIntExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_literalUIntExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_literalUIntExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalUIntExpressionForGeneration GGS_literalUIntExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_uint & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_literalUIntExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_literalUIntExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_literalUIntExpressionForGeneration::
reader_mValue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_literalUIntExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_literalUIntExpressionForGeneration *) mPointer)->mValue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_literalUIntExpressionForGeneration::actualTypeName (void) const {
  return "literalUIntExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__literalUIntExpressionForGeneration ("literalUIntExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_literalUIntExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_literalUIntExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_literalUIntExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_literalUIntExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalUIntExpressionForGeneration GGS_literalUIntExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_literalUIntExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_literalUIntExpressionForGeneration * p = dynamic_cast <const GGS_literalUIntExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_literalUIntExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_literalUIntExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_literalUIntExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            class 'cPtr_literalUInt64ExpressionForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_literalUInt64ExpressionForGeneration::
cPtr_literalUInt64ExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_uint64 & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mValue (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_literalUInt64ExpressionForGeneration * GGS_literalUInt64ExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_literalUInt64ExpressionForGeneration) ;
    return (cPtr_literalUInt64ExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_literalUInt64ExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_literalUInt64ExpressionForGeneration * ptr = dynamic_cast <const cPtr_literalUInt64ExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mValue.operator_isEqual (ptr->mValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_literalUInt64ExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@literalUInt64ExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mValue.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_literalUInt64ExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_literalUInt64ExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_literalUInt64ExpressionForGeneration (& typeid (cPtr_literalUInt64ExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_literalUInt64ExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__literalUInt64ExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_literalUInt64ExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_literalUInt64ExpressionForGeneration (mType, mLocation, mValue COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         GALGAS class 'GGS_literalUInt64ExpressionForGeneration'           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_literalUInt64ExpressionForGeneration ("literalUInt64ExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_literalUInt64ExpressionForGeneration::
GGS_literalUInt64ExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_literalUInt64ExpressionForGeneration::
GGS_literalUInt64ExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_literalUInt64ExpressionForGeneration GGS_literalUInt64ExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_literalUInt64ExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_literalUInt64ExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_literalUInt64ExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_literalUInt64ExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_literalUInt64ExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalUInt64ExpressionForGeneration GGS_literalUInt64ExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_uint64 & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_literalUInt64ExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_literalUInt64ExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint64  GGS_literalUInt64ExpressionForGeneration::
reader_mValue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_literalUInt64ExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_literalUInt64ExpressionForGeneration *) mPointer)->mValue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_literalUInt64ExpressionForGeneration::actualTypeName (void) const {
  return "literalUInt64ExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__literalUInt64ExpressionForGeneration ("literalUInt64ExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_literalUInt64ExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_literalUInt64ExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_literalUInt64ExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_literalUInt64ExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalUInt64ExpressionForGeneration GGS_literalUInt64ExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_literalUInt64ExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_literalUInt64ExpressionForGeneration * p = dynamic_cast <const GGS_literalUInt64ExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_literalUInt64ExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_literalUInt64ExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_literalUInt64ExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_literalSIntExpressionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_literalSIntExpressionForGeneration::
cPtr_literalSIntExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_sint & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mValue (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_literalSIntExpressionForGeneration * GGS_literalSIntExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_literalSIntExpressionForGeneration) ;
    return (cPtr_literalSIntExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_literalSIntExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_literalSIntExpressionForGeneration * ptr = dynamic_cast <const cPtr_literalSIntExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mValue.operator_isEqual (ptr->mValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_literalSIntExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@literalSIntExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mValue.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_literalSIntExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_literalSIntExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_literalSIntExpressionForGeneration (& typeid (cPtr_literalSIntExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_literalSIntExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__literalSIntExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_literalSIntExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_literalSIntExpressionForGeneration (mType, mLocation, mValue COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_literalSIntExpressionForGeneration'            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_literalSIntExpressionForGeneration ("literalSIntExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_literalSIntExpressionForGeneration::
GGS_literalSIntExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_literalSIntExpressionForGeneration::
GGS_literalSIntExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_literalSIntExpressionForGeneration GGS_literalSIntExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_literalSIntExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_literalSIntExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_literalSIntExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_literalSIntExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_literalSIntExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalSIntExpressionForGeneration GGS_literalSIntExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_sint & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_literalSIntExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_literalSIntExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sint  GGS_literalSIntExpressionForGeneration::
reader_mValue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_sint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_literalSIntExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_literalSIntExpressionForGeneration *) mPointer)->mValue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_literalSIntExpressionForGeneration::actualTypeName (void) const {
  return "literalSIntExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__literalSIntExpressionForGeneration ("literalSIntExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_literalSIntExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_literalSIntExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_literalSIntExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_literalSIntExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalSIntExpressionForGeneration GGS_literalSIntExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_literalSIntExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_literalSIntExpressionForGeneration * p = dynamic_cast <const GGS_literalSIntExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_literalSIntExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_literalSIntExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_literalSIntExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            class 'cPtr_literalSInt64ExpressionForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_literalSInt64ExpressionForGeneration::
cPtr_literalSInt64ExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_sint64 & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mValue (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_literalSInt64ExpressionForGeneration * GGS_literalSInt64ExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_literalSInt64ExpressionForGeneration) ;
    return (cPtr_literalSInt64ExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_literalSInt64ExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_literalSInt64ExpressionForGeneration * ptr = dynamic_cast <const cPtr_literalSInt64ExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mValue.operator_isEqual (ptr->mValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_literalSInt64ExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@literalSInt64ExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mValue.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_literalSInt64ExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_literalSInt64ExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_literalSInt64ExpressionForGeneration (& typeid (cPtr_literalSInt64ExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_literalSInt64ExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__literalSInt64ExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_literalSInt64ExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_literalSInt64ExpressionForGeneration (mType, mLocation, mValue COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         GALGAS class 'GGS_literalSInt64ExpressionForGeneration'           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_literalSInt64ExpressionForGeneration ("literalSInt64ExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_literalSInt64ExpressionForGeneration::
GGS_literalSInt64ExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_literalSInt64ExpressionForGeneration::
GGS_literalSInt64ExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_literalSInt64ExpressionForGeneration GGS_literalSInt64ExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_literalSInt64ExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_literalSInt64ExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_literalSInt64ExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_literalSInt64ExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_literalSInt64ExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalSInt64ExpressionForGeneration GGS_literalSInt64ExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_sint64 & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_literalSInt64ExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_literalSInt64ExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sint64  GGS_literalSInt64ExpressionForGeneration::
reader_mValue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_sint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_literalSInt64ExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_literalSInt64ExpressionForGeneration *) mPointer)->mValue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_literalSInt64ExpressionForGeneration::actualTypeName (void) const {
  return "literalSInt64ExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__literalSInt64ExpressionForGeneration ("literalSInt64ExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_literalSInt64ExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_literalSInt64ExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_literalSInt64ExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_literalSInt64ExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalSInt64ExpressionForGeneration GGS_literalSInt64ExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_literalSInt64ExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_literalSInt64ExpressionForGeneration * p = dynamic_cast <const GGS_literalSInt64ExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_literalSInt64ExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_literalSInt64ExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_literalSInt64ExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_constructorExpressionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_constructorExpressionForGeneration::
cPtr_constructorExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_string& argument_2,
                                const GGS_semanticExpressionListForGeneration & argument_3,
                                const GGS_bool& argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mConstructorName (argument_2),
mEffectiveParameterList (argument_3),
mHasCompilerArgument (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_constructorExpressionForGeneration * GGS_constructorExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_constructorExpressionForGeneration) ;
    return (cPtr_constructorExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_constructorExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_constructorExpressionForGeneration * ptr = dynamic_cast <const cPtr_constructorExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mConstructorName.operator_isEqual (ptr->mConstructorName).boolValue ()
         && mEffectiveParameterList.operator_isEqual (ptr->mEffectiveParameterList).boolValue ()
         && mHasCompilerArgument.operator_isEqual (ptr->mHasCompilerArgument).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_constructorExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@constructorExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mConstructorName.reader_description (inIndentation + 1)
           << mEffectiveParameterList.reader_description (inIndentation + 1)
           << mHasCompilerArgument.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_constructorExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_constructorExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_constructorExpressionForGeneration (& typeid (cPtr_constructorExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_constructorExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__constructorExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_constructorExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_constructorExpressionForGeneration (mType, mLocation, mConstructorName, mEffectiveParameterList, mHasCompilerArgument COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_constructorExpressionForGeneration'            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_constructorExpressionForGeneration ("constructorExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_constructorExpressionForGeneration::
GGS_constructorExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_constructorExpressionForGeneration::
GGS_constructorExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_constructorExpressionForGeneration GGS_constructorExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_constructorExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_constructorExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_constructorExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_constructorExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_constructorExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_constructorExpressionForGeneration GGS_constructorExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_string& argument_2,
                 const GGS_semanticExpressionListForGeneration & argument_3,
                 const GGS_bool& argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_constructorExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_constructorExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_constructorExpressionForGeneration::
reader_mConstructorName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_constructorExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_constructorExpressionForGeneration *) mPointer)->mConstructorName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionListForGeneration  GGS_constructorExpressionForGeneration::
reader_mEffectiveParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_constructorExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_constructorExpressionForGeneration *) mPointer)->mEffectiveParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_constructorExpressionForGeneration::
reader_mHasCompilerArgument (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_constructorExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_constructorExpressionForGeneration *) mPointer)->mHasCompilerArgument ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_constructorExpressionForGeneration::actualTypeName (void) const {
  return "constructorExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__constructorExpressionForGeneration ("constructorExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_constructorExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_constructorExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_constructorExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_constructorExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_constructorExpressionForGeneration GGS_constructorExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_constructorExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_constructorExpressionForGeneration * p = dynamic_cast <const GGS_constructorExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_constructorExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_constructorExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_constructorExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'cPtr_readerCallExpressionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_readerCallExpressionForGeneration::
cPtr_readerCallExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_semanticExpressionForGeneration & argument_2,
                                const GGS_string& argument_3,
                                const GGS_semanticExpressionListForGeneration & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mReceiverExpression (argument_2),
mReaderName (argument_3),
mExpressions (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_readerCallExpressionForGeneration * GGS_readerCallExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_readerCallExpressionForGeneration) ;
    return (cPtr_readerCallExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_readerCallExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_readerCallExpressionForGeneration * ptr = dynamic_cast <const cPtr_readerCallExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mReceiverExpression.operator_isEqual (ptr->mReceiverExpression).boolValue ()
         && mReaderName.operator_isEqual (ptr->mReaderName).boolValue ()
         && mExpressions.operator_isEqual (ptr->mExpressions).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_readerCallExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@readerCallExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mReceiverExpression.reader_description (inIndentation + 1)
           << mReaderName.reader_description (inIndentation + 1)
           << mExpressions.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_readerCallExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_readerCallExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_readerCallExpressionForGeneration (& typeid (cPtr_readerCallExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_readerCallExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__readerCallExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_readerCallExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_readerCallExpressionForGeneration (mType, mLocation, mReceiverExpression, mReaderName, mExpressions COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_readerCallExpressionForGeneration'            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_readerCallExpressionForGeneration ("readerCallExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_readerCallExpressionForGeneration::
GGS_readerCallExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_readerCallExpressionForGeneration::
GGS_readerCallExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_readerCallExpressionForGeneration GGS_readerCallExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_readerCallExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_readerCallExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_readerCallExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_readerCallExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_readerCallExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_readerCallExpressionForGeneration GGS_readerCallExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_semanticExpressionForGeneration & argument_2,
                 const GGS_string& argument_3,
                 const GGS_semanticExpressionListForGeneration & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_readerCallExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_readerCallExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_readerCallExpressionForGeneration::
reader_mReceiverExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_readerCallExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_readerCallExpressionForGeneration *) mPointer)->mReceiverExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_readerCallExpressionForGeneration::
reader_mReaderName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_readerCallExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_readerCallExpressionForGeneration *) mPointer)->mReaderName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionListForGeneration  GGS_readerCallExpressionForGeneration::
reader_mExpressions (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_readerCallExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_readerCallExpressionForGeneration *) mPointer)->mExpressions ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_readerCallExpressionForGeneration::actualTypeName (void) const {
  return "readerCallExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__readerCallExpressionForGeneration ("readerCallExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_readerCallExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_readerCallExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_readerCallExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_readerCallExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_readerCallExpressionForGeneration GGS_readerCallExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_readerCallExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_readerCallExpressionForGeneration * p = dynamic_cast <const GGS_readerCallExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_readerCallExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_readerCallExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_readerCallExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_optionValueExpressionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_optionValueExpressionForGeneration::
cPtr_optionValueExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_string& argument_2,
                                const GGS_string& argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mOptionComponentName (argument_2),
mOptionEntryName (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_optionValueExpressionForGeneration * GGS_optionValueExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_optionValueExpressionForGeneration) ;
    return (cPtr_optionValueExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_optionValueExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_optionValueExpressionForGeneration * ptr = dynamic_cast <const cPtr_optionValueExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mOptionComponentName.operator_isEqual (ptr->mOptionComponentName).boolValue ()
         && mOptionEntryName.operator_isEqual (ptr->mOptionEntryName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_optionValueExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@optionValueExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mOptionComponentName.reader_description (inIndentation + 1)
           << mOptionEntryName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_optionValueExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_optionValueExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_optionValueExpressionForGeneration (& typeid (cPtr_optionValueExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_optionValueExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__optionValueExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_optionValueExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_optionValueExpressionForGeneration (mType, mLocation, mOptionComponentName, mOptionEntryName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_optionValueExpressionForGeneration'            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_optionValueExpressionForGeneration ("optionValueExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_optionValueExpressionForGeneration::
GGS_optionValueExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_optionValueExpressionForGeneration::
GGS_optionValueExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_optionValueExpressionForGeneration GGS_optionValueExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_optionValueExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_optionValueExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_optionValueExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_optionValueExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_optionValueExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_optionValueExpressionForGeneration GGS_optionValueExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_string& argument_2,
                 const GGS_string& argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_optionValueExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_optionValueExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_optionValueExpressionForGeneration::
reader_mOptionComponentName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_optionValueExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_optionValueExpressionForGeneration *) mPointer)->mOptionComponentName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_optionValueExpressionForGeneration::
reader_mOptionEntryName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_optionValueExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_optionValueExpressionForGeneration *) mPointer)->mOptionEntryName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_optionValueExpressionForGeneration::actualTypeName (void) const {
  return "optionValueExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__optionValueExpressionForGeneration ("optionValueExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_optionValueExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_optionValueExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_optionValueExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_optionValueExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_optionValueExpressionForGeneration GGS_optionValueExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_optionValueExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_optionValueExpressionForGeneration * p = dynamic_cast <const GGS_optionValueExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_optionValueExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_optionValueExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_optionValueExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'cPtr_optionCharExpressionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_optionCharExpressionForGeneration::
cPtr_optionCharExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_string& argument_2,
                                const GGS_string& argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mOptionComponentName (argument_2),
mOptionEntryName (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_optionCharExpressionForGeneration * GGS_optionCharExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_optionCharExpressionForGeneration) ;
    return (cPtr_optionCharExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_optionCharExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_optionCharExpressionForGeneration * ptr = dynamic_cast <const cPtr_optionCharExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mOptionComponentName.operator_isEqual (ptr->mOptionComponentName).boolValue ()
         && mOptionEntryName.operator_isEqual (ptr->mOptionEntryName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_optionCharExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@optionCharExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mOptionComponentName.reader_description (inIndentation + 1)
           << mOptionEntryName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_optionCharExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_optionCharExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_optionCharExpressionForGeneration (& typeid (cPtr_optionCharExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_optionCharExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__optionCharExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_optionCharExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_optionCharExpressionForGeneration (mType, mLocation, mOptionComponentName, mOptionEntryName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_optionCharExpressionForGeneration'            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_optionCharExpressionForGeneration ("optionCharExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_optionCharExpressionForGeneration::
GGS_optionCharExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_optionCharExpressionForGeneration::
GGS_optionCharExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_optionCharExpressionForGeneration GGS_optionCharExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_optionCharExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_optionCharExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_optionCharExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_optionCharExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_optionCharExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_optionCharExpressionForGeneration GGS_optionCharExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_string& argument_2,
                 const GGS_string& argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_optionCharExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_optionCharExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_optionCharExpressionForGeneration::
reader_mOptionComponentName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_optionCharExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_optionCharExpressionForGeneration *) mPointer)->mOptionComponentName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_optionCharExpressionForGeneration::
reader_mOptionEntryName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_optionCharExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_optionCharExpressionForGeneration *) mPointer)->mOptionEntryName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_optionCharExpressionForGeneration::actualTypeName (void) const {
  return "optionCharExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__optionCharExpressionForGeneration ("optionCharExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_optionCharExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_optionCharExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_optionCharExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_optionCharExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_optionCharExpressionForGeneration GGS_optionCharExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_optionCharExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_optionCharExpressionForGeneration * p = dynamic_cast <const GGS_optionCharExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_optionCharExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_optionCharExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_optionCharExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_optionStringExpressionForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_optionStringExpressionForGeneration::
cPtr_optionStringExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_string& argument_2,
                                const GGS_string& argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mOptionComponentName (argument_2),
mOptionEntryName (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_optionStringExpressionForGeneration * GGS_optionStringExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_optionStringExpressionForGeneration) ;
    return (cPtr_optionStringExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_optionStringExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_optionStringExpressionForGeneration * ptr = dynamic_cast <const cPtr_optionStringExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mOptionComponentName.operator_isEqual (ptr->mOptionComponentName).boolValue ()
         && mOptionEntryName.operator_isEqual (ptr->mOptionEntryName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_optionStringExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@optionStringExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mOptionComponentName.reader_description (inIndentation + 1)
           << mOptionEntryName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_optionStringExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_optionStringExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_optionStringExpressionForGeneration (& typeid (cPtr_optionStringExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_optionStringExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__optionStringExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_optionStringExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_optionStringExpressionForGeneration (mType, mLocation, mOptionComponentName, mOptionEntryName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_optionStringExpressionForGeneration'           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_optionStringExpressionForGeneration ("optionStringExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_optionStringExpressionForGeneration::
GGS_optionStringExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_optionStringExpressionForGeneration::
GGS_optionStringExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_optionStringExpressionForGeneration GGS_optionStringExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_optionStringExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_optionStringExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_optionStringExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_optionStringExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_optionStringExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_optionStringExpressionForGeneration GGS_optionStringExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_string& argument_2,
                 const GGS_string& argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_optionStringExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_optionStringExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_optionStringExpressionForGeneration::
reader_mOptionComponentName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_optionStringExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_optionStringExpressionForGeneration *) mPointer)->mOptionComponentName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_optionStringExpressionForGeneration::
reader_mOptionEntryName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_optionStringExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_optionStringExpressionForGeneration *) mPointer)->mOptionEntryName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_optionStringExpressionForGeneration::actualTypeName (void) const {
  return "optionStringExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__optionStringExpressionForGeneration ("optionStringExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_optionStringExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_optionStringExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_optionStringExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_optionStringExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_optionStringExpressionForGeneration GGS_optionStringExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_optionStringExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_optionStringExpressionForGeneration * p = dynamic_cast <const GGS_optionStringExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_optionStringExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_optionStringExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_optionStringExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            class 'cPtr_optionCommentExpressionForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_optionCommentExpressionForGeneration::
cPtr_optionCommentExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_string& argument_2,
                                const GGS_string& argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mOptionComponentName (argument_2),
mOptionEntryName (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_optionCommentExpressionForGeneration * GGS_optionCommentExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_optionCommentExpressionForGeneration) ;
    return (cPtr_optionCommentExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_optionCommentExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_optionCommentExpressionForGeneration * ptr = dynamic_cast <const cPtr_optionCommentExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mOptionComponentName.operator_isEqual (ptr->mOptionComponentName).boolValue ()
         && mOptionEntryName.operator_isEqual (ptr->mOptionEntryName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_optionCommentExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@optionCommentExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mOptionComponentName.reader_description (inIndentation + 1)
           << mOptionEntryName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_optionCommentExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_optionCommentExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_optionCommentExpressionForGeneration (& typeid (cPtr_optionCommentExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_optionCommentExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__optionCommentExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_optionCommentExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_optionCommentExpressionForGeneration (mType, mLocation, mOptionComponentName, mOptionEntryName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         GALGAS class 'GGS_optionCommentExpressionForGeneration'           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_optionCommentExpressionForGeneration ("optionCommentExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_optionCommentExpressionForGeneration::
GGS_optionCommentExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_optionCommentExpressionForGeneration::
GGS_optionCommentExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_optionCommentExpressionForGeneration GGS_optionCommentExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_optionCommentExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_optionCommentExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_optionCommentExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_optionCommentExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_optionCommentExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_optionCommentExpressionForGeneration GGS_optionCommentExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_string& argument_2,
                 const GGS_string& argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_optionCommentExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_optionCommentExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_optionCommentExpressionForGeneration::
reader_mOptionComponentName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_optionCommentExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_optionCommentExpressionForGeneration *) mPointer)->mOptionComponentName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_optionCommentExpressionForGeneration::
reader_mOptionEntryName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_optionCommentExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_optionCommentExpressionForGeneration *) mPointer)->mOptionEntryName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_optionCommentExpressionForGeneration::actualTypeName (void) const {
  return "optionCommentExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__optionCommentExpressionForGeneration ("optionCommentExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_optionCommentExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_optionCommentExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_optionCommentExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_optionCommentExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_optionCommentExpressionForGeneration GGS_optionCommentExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_optionCommentExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_optionCommentExpressionForGeneration * p = dynamic_cast <const GGS_optionCommentExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_optionCommentExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_optionCommentExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_optionCommentExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_concatExpressionForGeneration'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_concatExpressionForGeneration::
cPtr_concatExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_semanticExpressionForGeneration & argument_2,
                                const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mLeftExpression (argument_2),
mRightExpression (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_concatExpressionForGeneration * GGS_concatExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_concatExpressionForGeneration) ;
    return (cPtr_concatExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_concatExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_concatExpressionForGeneration * ptr = dynamic_cast <const cPtr_concatExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_concatExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@concatExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_concatExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_concatExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_concatExpressionForGeneration (& typeid (cPtr_concatExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_concatExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__concatExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_concatExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_concatExpressionForGeneration (mType, mLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_concatExpressionForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_concatExpressionForGeneration ("concatExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_concatExpressionForGeneration::
GGS_concatExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_concatExpressionForGeneration::
GGS_concatExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_concatExpressionForGeneration GGS_concatExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_concatExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_concatExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_concatExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_concatExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_concatExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_concatExpressionForGeneration GGS_concatExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_semanticExpressionForGeneration & argument_2,
                 const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_concatExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_concatExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_concatExpressionForGeneration::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_concatExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_concatExpressionForGeneration *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_concatExpressionForGeneration::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_concatExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_concatExpressionForGeneration *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_concatExpressionForGeneration::actualTypeName (void) const {
  return "concatExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__concatExpressionForGeneration ("concatExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_concatExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_concatExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_concatExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_concatExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_concatExpressionForGeneration GGS_concatExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_concatExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_concatExpressionForGeneration * p = dynamic_cast <const GGS_concatExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_concatExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_concatExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_concatExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_orExpressionForGeneration'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_orExpressionForGeneration::
cPtr_orExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_semanticExpressionForGeneration & argument_2,
                                const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mLeftExpression (argument_2),
mRightExpression (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_orExpressionForGeneration * GGS_orExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_orExpressionForGeneration) ;
    return (cPtr_orExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_orExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_orExpressionForGeneration * ptr = dynamic_cast <const cPtr_orExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_orExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@orExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_orExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_orExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_orExpressionForGeneration (& typeid (cPtr_orExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_orExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__orExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_orExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_orExpressionForGeneration (mType, mLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_orExpressionForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_orExpressionForGeneration ("orExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_orExpressionForGeneration::
GGS_orExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_orExpressionForGeneration::
GGS_orExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_orExpressionForGeneration GGS_orExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_orExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_orExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_orExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_orExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_orExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_orExpressionForGeneration GGS_orExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_semanticExpressionForGeneration & argument_2,
                 const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_orExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_orExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_orExpressionForGeneration::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_orExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_orExpressionForGeneration *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_orExpressionForGeneration::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_orExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_orExpressionForGeneration *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_orExpressionForGeneration::actualTypeName (void) const {
  return "orExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__orExpressionForGeneration ("orExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_orExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_orExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_orExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_orExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_orExpressionForGeneration GGS_orExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_orExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_orExpressionForGeneration * p = dynamic_cast <const GGS_orExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_orExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_orExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_orExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_xorExpressionForGeneration'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_xorExpressionForGeneration::
cPtr_xorExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_semanticExpressionForGeneration & argument_2,
                                const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mLeftExpression (argument_2),
mRightExpression (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_xorExpressionForGeneration * GGS_xorExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_xorExpressionForGeneration) ;
    return (cPtr_xorExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_xorExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_xorExpressionForGeneration * ptr = dynamic_cast <const cPtr_xorExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_xorExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@xorExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_xorExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_xorExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_xorExpressionForGeneration (& typeid (cPtr_xorExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_xorExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__xorExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_xorExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_xorExpressionForGeneration (mType, mLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_xorExpressionForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_xorExpressionForGeneration ("xorExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_xorExpressionForGeneration::
GGS_xorExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_xorExpressionForGeneration::
GGS_xorExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_xorExpressionForGeneration GGS_xorExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_xorExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_xorExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_xorExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_xorExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_xorExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_xorExpressionForGeneration GGS_xorExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_semanticExpressionForGeneration & argument_2,
                 const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_xorExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_xorExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_xorExpressionForGeneration::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_xorExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_xorExpressionForGeneration *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_xorExpressionForGeneration::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_xorExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_xorExpressionForGeneration *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_xorExpressionForGeneration::actualTypeName (void) const {
  return "xorExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__xorExpressionForGeneration ("xorExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_xorExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_xorExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_xorExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_xorExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_xorExpressionForGeneration GGS_xorExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_xorExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_xorExpressionForGeneration * p = dynamic_cast <const GGS_xorExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_xorExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_xorExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_xorExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_andExpressionForGeneration'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_andExpressionForGeneration::
cPtr_andExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_semanticExpressionForGeneration & argument_2,
                                const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mLeftExpression (argument_2),
mRightExpression (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_andExpressionForGeneration * GGS_andExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_andExpressionForGeneration) ;
    return (cPtr_andExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_andExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_andExpressionForGeneration * ptr = dynamic_cast <const cPtr_andExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_andExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@andExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_andExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_andExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_andExpressionForGeneration (& typeid (cPtr_andExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_andExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__andExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_andExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_andExpressionForGeneration (mType, mLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_andExpressionForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_andExpressionForGeneration ("andExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_andExpressionForGeneration::
GGS_andExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_andExpressionForGeneration::
GGS_andExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_andExpressionForGeneration GGS_andExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_andExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_andExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_andExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_andExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_andExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_andExpressionForGeneration GGS_andExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_semanticExpressionForGeneration & argument_2,
                 const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_andExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_andExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_andExpressionForGeneration::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_andExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_andExpressionForGeneration *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_andExpressionForGeneration::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_andExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_andExpressionForGeneration *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_andExpressionForGeneration::actualTypeName (void) const {
  return "andExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__andExpressionForGeneration ("andExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_andExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_andExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_andExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_andExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_andExpressionForGeneration GGS_andExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_andExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_andExpressionForGeneration * p = dynamic_cast <const GGS_andExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_andExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_andExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_andExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_equalExpressionForGeneration'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_equalExpressionForGeneration::
cPtr_equalExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_semanticExpressionForGeneration & argument_2,
                                const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mLeftExpression (argument_2),
mRightExpression (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_equalExpressionForGeneration * GGS_equalExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_equalExpressionForGeneration) ;
    return (cPtr_equalExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_equalExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_equalExpressionForGeneration * ptr = dynamic_cast <const cPtr_equalExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_equalExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@equalExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_equalExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_equalExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_equalExpressionForGeneration (& typeid (cPtr_equalExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_equalExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__equalExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_equalExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_equalExpressionForGeneration (mType, mLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_equalExpressionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_equalExpressionForGeneration ("equalExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_equalExpressionForGeneration::
GGS_equalExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_equalExpressionForGeneration::
GGS_equalExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_equalExpressionForGeneration GGS_equalExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_equalExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_equalExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_equalExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_equalExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_equalExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_equalExpressionForGeneration GGS_equalExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_semanticExpressionForGeneration & argument_2,
                 const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_equalExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_equalExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_equalExpressionForGeneration::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_equalExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_equalExpressionForGeneration *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_equalExpressionForGeneration::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_equalExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_equalExpressionForGeneration *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_equalExpressionForGeneration::actualTypeName (void) const {
  return "equalExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__equalExpressionForGeneration ("equalExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_equalExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_equalExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_equalExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_equalExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_equalExpressionForGeneration GGS_equalExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_equalExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_equalExpressionForGeneration * p = dynamic_cast <const GGS_equalExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_equalExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_equalExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_equalExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_notEqualExpressionForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_notEqualExpressionForGeneration::
cPtr_notEqualExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_semanticExpressionForGeneration & argument_2,
                                const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mLeftExpression (argument_2),
mRightExpression (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_notEqualExpressionForGeneration * GGS_notEqualExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_notEqualExpressionForGeneration) ;
    return (cPtr_notEqualExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_notEqualExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_notEqualExpressionForGeneration * ptr = dynamic_cast <const cPtr_notEqualExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_notEqualExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@notEqualExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_notEqualExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_notEqualExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_notEqualExpressionForGeneration (& typeid (cPtr_notEqualExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_notEqualExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__notEqualExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_notEqualExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_notEqualExpressionForGeneration (mType, mLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_notEqualExpressionForGeneration'             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_notEqualExpressionForGeneration ("notEqualExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_notEqualExpressionForGeneration::
GGS_notEqualExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_notEqualExpressionForGeneration::
GGS_notEqualExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_notEqualExpressionForGeneration GGS_notEqualExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_notEqualExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_notEqualExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_notEqualExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_notEqualExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_notEqualExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_notEqualExpressionForGeneration GGS_notEqualExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_semanticExpressionForGeneration & argument_2,
                 const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_notEqualExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_notEqualExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_notEqualExpressionForGeneration::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_notEqualExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_notEqualExpressionForGeneration *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_notEqualExpressionForGeneration::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_notEqualExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_notEqualExpressionForGeneration *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_notEqualExpressionForGeneration::actualTypeName (void) const {
  return "notEqualExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__notEqualExpressionForGeneration ("notEqualExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_notEqualExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_notEqualExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_notEqualExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_notEqualExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_notEqualExpressionForGeneration GGS_notEqualExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_notEqualExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_notEqualExpressionForGeneration * p = dynamic_cast <const GGS_notEqualExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_notEqualExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_notEqualExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_notEqualExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_lowerOrEqualExpressionForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lowerOrEqualExpressionForGeneration::
cPtr_lowerOrEqualExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_semanticExpressionForGeneration & argument_2,
                                const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mLeftExpression (argument_2),
mRightExpression (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lowerOrEqualExpressionForGeneration * GGS_lowerOrEqualExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_lowerOrEqualExpressionForGeneration) ;
    return (cPtr_lowerOrEqualExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lowerOrEqualExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lowerOrEqualExpressionForGeneration * ptr = dynamic_cast <const cPtr_lowerOrEqualExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lowerOrEqualExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@lowerOrEqualExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lowerOrEqualExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lowerOrEqualExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lowerOrEqualExpressionForGeneration (& typeid (cPtr_lowerOrEqualExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_lowerOrEqualExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__lowerOrEqualExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lowerOrEqualExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lowerOrEqualExpressionForGeneration (mType, mLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_lowerOrEqualExpressionForGeneration'           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_lowerOrEqualExpressionForGeneration ("lowerOrEqualExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_lowerOrEqualExpressionForGeneration::
GGS_lowerOrEqualExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lowerOrEqualExpressionForGeneration::
GGS_lowerOrEqualExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lowerOrEqualExpressionForGeneration GGS_lowerOrEqualExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lowerOrEqualExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lowerOrEqualExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_lowerOrEqualExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lowerOrEqualExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lowerOrEqualExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lowerOrEqualExpressionForGeneration GGS_lowerOrEqualExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_semanticExpressionForGeneration & argument_2,
                 const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_lowerOrEqualExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_lowerOrEqualExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_lowerOrEqualExpressionForGeneration::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lowerOrEqualExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lowerOrEqualExpressionForGeneration *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_lowerOrEqualExpressionForGeneration::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lowerOrEqualExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lowerOrEqualExpressionForGeneration *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lowerOrEqualExpressionForGeneration::actualTypeName (void) const {
  return "lowerOrEqualExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__lowerOrEqualExpressionForGeneration ("lowerOrEqualExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_lowerOrEqualExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_lowerOrEqualExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_lowerOrEqualExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_lowerOrEqualExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lowerOrEqualExpressionForGeneration GGS_lowerOrEqualExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_lowerOrEqualExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_lowerOrEqualExpressionForGeneration * p = dynamic_cast <const GGS_lowerOrEqualExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_lowerOrEqualExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_lowerOrEqualExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_lowerOrEqualExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            class 'cPtr_greaterOrEqualExpressionForGeneration'             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_greaterOrEqualExpressionForGeneration::
cPtr_greaterOrEqualExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_semanticExpressionForGeneration & argument_2,
                                const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mLeftExpression (argument_2),
mRightExpression (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_greaterOrEqualExpressionForGeneration * GGS_greaterOrEqualExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_greaterOrEqualExpressionForGeneration) ;
    return (cPtr_greaterOrEqualExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_greaterOrEqualExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_greaterOrEqualExpressionForGeneration * ptr = dynamic_cast <const cPtr_greaterOrEqualExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_greaterOrEqualExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@greaterOrEqualExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_greaterOrEqualExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_greaterOrEqualExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_greaterOrEqualExpressionForGeneration (& typeid (cPtr_greaterOrEqualExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_greaterOrEqualExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__greaterOrEqualExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_greaterOrEqualExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_greaterOrEqualExpressionForGeneration (mType, mLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         GALGAS class 'GGS_greaterOrEqualExpressionForGeneration'          *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_greaterOrEqualExpressionForGeneration ("greaterOrEqualExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_greaterOrEqualExpressionForGeneration::
GGS_greaterOrEqualExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_greaterOrEqualExpressionForGeneration::
GGS_greaterOrEqualExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_greaterOrEqualExpressionForGeneration GGS_greaterOrEqualExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_greaterOrEqualExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_greaterOrEqualExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_greaterOrEqualExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_greaterOrEqualExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_greaterOrEqualExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_greaterOrEqualExpressionForGeneration GGS_greaterOrEqualExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_semanticExpressionForGeneration & argument_2,
                 const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_greaterOrEqualExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_greaterOrEqualExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_greaterOrEqualExpressionForGeneration::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_greaterOrEqualExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_greaterOrEqualExpressionForGeneration *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_greaterOrEqualExpressionForGeneration::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_greaterOrEqualExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_greaterOrEqualExpressionForGeneration *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_greaterOrEqualExpressionForGeneration::actualTypeName (void) const {
  return "greaterOrEqualExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__greaterOrEqualExpressionForGeneration ("greaterOrEqualExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_greaterOrEqualExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_greaterOrEqualExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_greaterOrEqualExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_greaterOrEqualExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_greaterOrEqualExpressionForGeneration GGS_greaterOrEqualExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_greaterOrEqualExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_greaterOrEqualExpressionForGeneration * p = dynamic_cast <const GGS_greaterOrEqualExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_greaterOrEqualExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_greaterOrEqualExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_greaterOrEqualExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            class 'cPtr_strictGreaterExpressionForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_strictGreaterExpressionForGeneration::
cPtr_strictGreaterExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_semanticExpressionForGeneration & argument_2,
                                const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mLeftExpression (argument_2),
mRightExpression (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_strictGreaterExpressionForGeneration * GGS_strictGreaterExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_strictGreaterExpressionForGeneration) ;
    return (cPtr_strictGreaterExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_strictGreaterExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_strictGreaterExpressionForGeneration * ptr = dynamic_cast <const cPtr_strictGreaterExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_strictGreaterExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@strictGreaterExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_strictGreaterExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_strictGreaterExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_strictGreaterExpressionForGeneration (& typeid (cPtr_strictGreaterExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_strictGreaterExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__strictGreaterExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_strictGreaterExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_strictGreaterExpressionForGeneration (mType, mLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         GALGAS class 'GGS_strictGreaterExpressionForGeneration'           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_strictGreaterExpressionForGeneration ("strictGreaterExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_strictGreaterExpressionForGeneration::
GGS_strictGreaterExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_strictGreaterExpressionForGeneration::
GGS_strictGreaterExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_strictGreaterExpressionForGeneration GGS_strictGreaterExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_strictGreaterExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_strictGreaterExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_strictGreaterExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_strictGreaterExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_strictGreaterExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_strictGreaterExpressionForGeneration GGS_strictGreaterExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_semanticExpressionForGeneration & argument_2,
                 const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_strictGreaterExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_strictGreaterExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_strictGreaterExpressionForGeneration::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_strictGreaterExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_strictGreaterExpressionForGeneration *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_strictGreaterExpressionForGeneration::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_strictGreaterExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_strictGreaterExpressionForGeneration *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_strictGreaterExpressionForGeneration::actualTypeName (void) const {
  return "strictGreaterExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__strictGreaterExpressionForGeneration ("strictGreaterExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_strictGreaterExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_strictGreaterExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_strictGreaterExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_strictGreaterExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_strictGreaterExpressionForGeneration GGS_strictGreaterExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_strictGreaterExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_strictGreaterExpressionForGeneration * p = dynamic_cast <const GGS_strictGreaterExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_strictGreaterExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_strictGreaterExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_strictGreaterExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_strictLowerExpressionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_strictLowerExpressionForGeneration::
cPtr_strictLowerExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_semanticExpressionForGeneration & argument_2,
                                const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mLeftExpression (argument_2),
mRightExpression (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_strictLowerExpressionForGeneration * GGS_strictLowerExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_strictLowerExpressionForGeneration) ;
    return (cPtr_strictLowerExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_strictLowerExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_strictLowerExpressionForGeneration * ptr = dynamic_cast <const cPtr_strictLowerExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_strictLowerExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@strictLowerExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_strictLowerExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_strictLowerExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_strictLowerExpressionForGeneration (& typeid (cPtr_strictLowerExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_strictLowerExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__strictLowerExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_strictLowerExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_strictLowerExpressionForGeneration (mType, mLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_strictLowerExpressionForGeneration'            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_strictLowerExpressionForGeneration ("strictLowerExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_strictLowerExpressionForGeneration::
GGS_strictLowerExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_strictLowerExpressionForGeneration::
GGS_strictLowerExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_strictLowerExpressionForGeneration GGS_strictLowerExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_strictLowerExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_strictLowerExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_strictLowerExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_strictLowerExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_strictLowerExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_strictLowerExpressionForGeneration GGS_strictLowerExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_semanticExpressionForGeneration & argument_2,
                 const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_strictLowerExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_strictLowerExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_strictLowerExpressionForGeneration::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_strictLowerExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_strictLowerExpressionForGeneration *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_strictLowerExpressionForGeneration::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_strictLowerExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_strictLowerExpressionForGeneration *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_strictLowerExpressionForGeneration::actualTypeName (void) const {
  return "strictLowerExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__strictLowerExpressionForGeneration ("strictLowerExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_strictLowerExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_strictLowerExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_strictLowerExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_strictLowerExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_strictLowerExpressionForGeneration GGS_strictLowerExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_strictLowerExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_strictLowerExpressionForGeneration * p = dynamic_cast <const GGS_strictLowerExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_strictLowerExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_strictLowerExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_strictLowerExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'cPtr_rightShiftExpressionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_rightShiftExpressionForGeneration::
cPtr_rightShiftExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_semanticExpressionForGeneration & argument_2,
                                const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mLeftExpression (argument_2),
mRightExpression (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_rightShiftExpressionForGeneration * GGS_rightShiftExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_rightShiftExpressionForGeneration) ;
    return (cPtr_rightShiftExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_rightShiftExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_rightShiftExpressionForGeneration * ptr = dynamic_cast <const cPtr_rightShiftExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_rightShiftExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@rightShiftExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_rightShiftExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_rightShiftExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_rightShiftExpressionForGeneration (& typeid (cPtr_rightShiftExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_rightShiftExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__rightShiftExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_rightShiftExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_rightShiftExpressionForGeneration (mType, mLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_rightShiftExpressionForGeneration'            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_rightShiftExpressionForGeneration ("rightShiftExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_rightShiftExpressionForGeneration::
GGS_rightShiftExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_rightShiftExpressionForGeneration::
GGS_rightShiftExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_rightShiftExpressionForGeneration GGS_rightShiftExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_rightShiftExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_rightShiftExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_rightShiftExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_rightShiftExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_rightShiftExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_rightShiftExpressionForGeneration GGS_rightShiftExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_semanticExpressionForGeneration & argument_2,
                 const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_rightShiftExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_rightShiftExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_rightShiftExpressionForGeneration::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rightShiftExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rightShiftExpressionForGeneration *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_rightShiftExpressionForGeneration::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rightShiftExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rightShiftExpressionForGeneration *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_rightShiftExpressionForGeneration::actualTypeName (void) const {
  return "rightShiftExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__rightShiftExpressionForGeneration ("rightShiftExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_rightShiftExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_rightShiftExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_rightShiftExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_rightShiftExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_rightShiftExpressionForGeneration GGS_rightShiftExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_rightShiftExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_rightShiftExpressionForGeneration * p = dynamic_cast <const GGS_rightShiftExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_rightShiftExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_rightShiftExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_rightShiftExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'cPtr_leftShiftExpressionForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_leftShiftExpressionForGeneration::
cPtr_leftShiftExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_semanticExpressionForGeneration & argument_2,
                                const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mLeftExpression (argument_2),
mRightExpression (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_leftShiftExpressionForGeneration * GGS_leftShiftExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_leftShiftExpressionForGeneration) ;
    return (cPtr_leftShiftExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_leftShiftExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_leftShiftExpressionForGeneration * ptr = dynamic_cast <const cPtr_leftShiftExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_leftShiftExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@leftShiftExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_leftShiftExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_leftShiftExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_leftShiftExpressionForGeneration (& typeid (cPtr_leftShiftExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_leftShiftExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__leftShiftExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_leftShiftExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_leftShiftExpressionForGeneration (mType, mLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_leftShiftExpressionForGeneration'             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_leftShiftExpressionForGeneration ("leftShiftExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_leftShiftExpressionForGeneration::
GGS_leftShiftExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_leftShiftExpressionForGeneration::
GGS_leftShiftExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_leftShiftExpressionForGeneration GGS_leftShiftExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_leftShiftExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_leftShiftExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_leftShiftExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_leftShiftExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_leftShiftExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_leftShiftExpressionForGeneration GGS_leftShiftExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_semanticExpressionForGeneration & argument_2,
                 const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_leftShiftExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_leftShiftExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_leftShiftExpressionForGeneration::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_leftShiftExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_leftShiftExpressionForGeneration *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_leftShiftExpressionForGeneration::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_leftShiftExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_leftShiftExpressionForGeneration *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_leftShiftExpressionForGeneration::actualTypeName (void) const {
  return "leftShiftExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__leftShiftExpressionForGeneration ("leftShiftExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_leftShiftExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_leftShiftExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_leftShiftExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_leftShiftExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_leftShiftExpressionForGeneration GGS_leftShiftExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_leftShiftExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_leftShiftExpressionForGeneration * p = dynamic_cast <const GGS_leftShiftExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_leftShiftExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_leftShiftExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_leftShiftExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_addExpressionForGeneration'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_addExpressionForGeneration::
cPtr_addExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_semanticExpressionForGeneration & argument_2,
                                const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mLeftExpression (argument_2),
mRightExpression (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_addExpressionForGeneration * GGS_addExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_addExpressionForGeneration) ;
    return (cPtr_addExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_addExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_addExpressionForGeneration * ptr = dynamic_cast <const cPtr_addExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_addExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@addExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_addExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_addExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_addExpressionForGeneration (& typeid (cPtr_addExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_addExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__addExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_addExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_addExpressionForGeneration (mType, mLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_addExpressionForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_addExpressionForGeneration ("addExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_addExpressionForGeneration::
GGS_addExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_addExpressionForGeneration::
GGS_addExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_addExpressionForGeneration GGS_addExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_addExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_addExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_addExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_addExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_addExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_addExpressionForGeneration GGS_addExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_semanticExpressionForGeneration & argument_2,
                 const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_addExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_addExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_addExpressionForGeneration::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_addExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_addExpressionForGeneration *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_addExpressionForGeneration::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_addExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_addExpressionForGeneration *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_addExpressionForGeneration::actualTypeName (void) const {
  return "addExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__addExpressionForGeneration ("addExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_addExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_addExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_addExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_addExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_addExpressionForGeneration GGS_addExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_addExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_addExpressionForGeneration * p = dynamic_cast <const GGS_addExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_addExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_addExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_addExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_subExpressionForGeneration'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_subExpressionForGeneration::
cPtr_subExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_semanticExpressionForGeneration & argument_2,
                                const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mLeftExpression (argument_2),
mRightExpression (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_subExpressionForGeneration * GGS_subExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_subExpressionForGeneration) ;
    return (cPtr_subExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_subExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_subExpressionForGeneration * ptr = dynamic_cast <const cPtr_subExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_subExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@subExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_subExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_subExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_subExpressionForGeneration (& typeid (cPtr_subExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_subExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__subExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_subExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_subExpressionForGeneration (mType, mLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_subExpressionForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_subExpressionForGeneration ("subExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_subExpressionForGeneration::
GGS_subExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_subExpressionForGeneration::
GGS_subExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_subExpressionForGeneration GGS_subExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_subExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_subExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_subExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_subExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_subExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_subExpressionForGeneration GGS_subExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_semanticExpressionForGeneration & argument_2,
                 const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_subExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_subExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_subExpressionForGeneration::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_subExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_subExpressionForGeneration *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_subExpressionForGeneration::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_subExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_subExpressionForGeneration *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_subExpressionForGeneration::actualTypeName (void) const {
  return "subExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__subExpressionForGeneration ("subExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_subExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_subExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_subExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_subExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_subExpressionForGeneration GGS_subExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_subExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_subExpressionForGeneration * p = dynamic_cast <const GGS_subExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_subExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_subExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_subExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            class 'cPtr_multiplicationExpressionForGeneration'             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_multiplicationExpressionForGeneration::
cPtr_multiplicationExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_semanticExpressionForGeneration & argument_2,
                                const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mLeftExpression (argument_2),
mRightExpression (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_multiplicationExpressionForGeneration * GGS_multiplicationExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_multiplicationExpressionForGeneration) ;
    return (cPtr_multiplicationExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_multiplicationExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_multiplicationExpressionForGeneration * ptr = dynamic_cast <const cPtr_multiplicationExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_multiplicationExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@multiplicationExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_multiplicationExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_multiplicationExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_multiplicationExpressionForGeneration (& typeid (cPtr_multiplicationExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_multiplicationExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__multiplicationExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_multiplicationExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_multiplicationExpressionForGeneration (mType, mLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         GALGAS class 'GGS_multiplicationExpressionForGeneration'          *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_multiplicationExpressionForGeneration ("multiplicationExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_multiplicationExpressionForGeneration::
GGS_multiplicationExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_multiplicationExpressionForGeneration::
GGS_multiplicationExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_multiplicationExpressionForGeneration GGS_multiplicationExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_multiplicationExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_multiplicationExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_multiplicationExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_multiplicationExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_multiplicationExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_multiplicationExpressionForGeneration GGS_multiplicationExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_semanticExpressionForGeneration & argument_2,
                 const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_multiplicationExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_multiplicationExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_multiplicationExpressionForGeneration::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_multiplicationExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_multiplicationExpressionForGeneration *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_multiplicationExpressionForGeneration::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_multiplicationExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_multiplicationExpressionForGeneration *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_multiplicationExpressionForGeneration::actualTypeName (void) const {
  return "multiplicationExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__multiplicationExpressionForGeneration ("multiplicationExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_multiplicationExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_multiplicationExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_multiplicationExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_multiplicationExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_multiplicationExpressionForGeneration GGS_multiplicationExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_multiplicationExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_multiplicationExpressionForGeneration * p = dynamic_cast <const GGS_multiplicationExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_multiplicationExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_multiplicationExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_multiplicationExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_divisionExpressionForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_divisionExpressionForGeneration::
cPtr_divisionExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_semanticExpressionForGeneration & argument_2,
                                const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mLeftExpression (argument_2),
mRightExpression (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_divisionExpressionForGeneration * GGS_divisionExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_divisionExpressionForGeneration) ;
    return (cPtr_divisionExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_divisionExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_divisionExpressionForGeneration * ptr = dynamic_cast <const cPtr_divisionExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_divisionExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@divisionExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_divisionExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_divisionExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_divisionExpressionForGeneration (& typeid (cPtr_divisionExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_divisionExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__divisionExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_divisionExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_divisionExpressionForGeneration (mType, mLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_divisionExpressionForGeneration'             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_divisionExpressionForGeneration ("divisionExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_divisionExpressionForGeneration::
GGS_divisionExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_divisionExpressionForGeneration::
GGS_divisionExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_divisionExpressionForGeneration GGS_divisionExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_divisionExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_divisionExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_divisionExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_divisionExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_divisionExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_divisionExpressionForGeneration GGS_divisionExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_semanticExpressionForGeneration & argument_2,
                 const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_divisionExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_divisionExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_divisionExpressionForGeneration::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_divisionExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_divisionExpressionForGeneration *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_divisionExpressionForGeneration::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_divisionExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_divisionExpressionForGeneration *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_divisionExpressionForGeneration::actualTypeName (void) const {
  return "divisionExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__divisionExpressionForGeneration ("divisionExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_divisionExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_divisionExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_divisionExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_divisionExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_divisionExpressionForGeneration GGS_divisionExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_divisionExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_divisionExpressionForGeneration * p = dynamic_cast <const GGS_divisionExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_divisionExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_divisionExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_divisionExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_moduloExpressionForGeneration'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_moduloExpressionForGeneration::
cPtr_moduloExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_semanticExpressionForGeneration & argument_2,
                                const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mLeftExpression (argument_2),
mRightExpression (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_moduloExpressionForGeneration * GGS_moduloExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_moduloExpressionForGeneration) ;
    return (cPtr_moduloExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_moduloExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_moduloExpressionForGeneration * ptr = dynamic_cast <const cPtr_moduloExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_moduloExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@moduloExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_moduloExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_moduloExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_moduloExpressionForGeneration (& typeid (cPtr_moduloExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_moduloExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__moduloExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_moduloExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_moduloExpressionForGeneration (mType, mLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_moduloExpressionForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_moduloExpressionForGeneration ("moduloExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_moduloExpressionForGeneration::
GGS_moduloExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_moduloExpressionForGeneration::
GGS_moduloExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_moduloExpressionForGeneration GGS_moduloExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_moduloExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_moduloExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_moduloExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_moduloExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_moduloExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_moduloExpressionForGeneration GGS_moduloExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_semanticExpressionForGeneration & argument_2,
                 const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_moduloExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_moduloExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_moduloExpressionForGeneration::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_moduloExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_moduloExpressionForGeneration *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_moduloExpressionForGeneration::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_moduloExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_moduloExpressionForGeneration *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_moduloExpressionForGeneration::actualTypeName (void) const {
  return "moduloExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__moduloExpressionForGeneration ("moduloExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_moduloExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_moduloExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_moduloExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_moduloExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_moduloExpressionForGeneration GGS_moduloExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_moduloExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_moduloExpressionForGeneration * p = dynamic_cast <const GGS_moduloExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_moduloExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_moduloExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_moduloExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'cPtr_unaryMinusExpressionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_unaryMinusExpressionForGeneration::
cPtr_unaryMinusExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_semanticExpressionForGeneration & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_unaryMinusExpressionForGeneration * GGS_unaryMinusExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_unaryMinusExpressionForGeneration) ;
    return (cPtr_unaryMinusExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_unaryMinusExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_unaryMinusExpressionForGeneration * ptr = dynamic_cast <const cPtr_unaryMinusExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mExpression.operator_isEqual (ptr->mExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_unaryMinusExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@unaryMinusExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_unaryMinusExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_unaryMinusExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_unaryMinusExpressionForGeneration (& typeid (cPtr_unaryMinusExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_unaryMinusExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__unaryMinusExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_unaryMinusExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_unaryMinusExpressionForGeneration (mType, mLocation, mExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_unaryMinusExpressionForGeneration'            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_unaryMinusExpressionForGeneration ("unaryMinusExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_unaryMinusExpressionForGeneration::
GGS_unaryMinusExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_unaryMinusExpressionForGeneration::
GGS_unaryMinusExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_unaryMinusExpressionForGeneration GGS_unaryMinusExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_unaryMinusExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_unaryMinusExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_unaryMinusExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_unaryMinusExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_unaryMinusExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_unaryMinusExpressionForGeneration GGS_unaryMinusExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_semanticExpressionForGeneration & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_unaryMinusExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_unaryMinusExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_unaryMinusExpressionForGeneration::
reader_mExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_unaryMinusExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_unaryMinusExpressionForGeneration *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_unaryMinusExpressionForGeneration::actualTypeName (void) const {
  return "unaryMinusExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__unaryMinusExpressionForGeneration ("unaryMinusExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_unaryMinusExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_unaryMinusExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_unaryMinusExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_unaryMinusExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_unaryMinusExpressionForGeneration GGS_unaryMinusExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_unaryMinusExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_unaryMinusExpressionForGeneration * p = dynamic_cast <const GGS_unaryMinusExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_unaryMinusExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_unaryMinusExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_unaryMinusExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_notExpressionForGeneration'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_notExpressionForGeneration::
cPtr_notExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_semanticExpressionForGeneration & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_notExpressionForGeneration * GGS_notExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_notExpressionForGeneration) ;
    return (cPtr_notExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_notExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_notExpressionForGeneration * ptr = dynamic_cast <const cPtr_notExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mExpression.operator_isEqual (ptr->mExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_notExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@notExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_notExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_notExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_notExpressionForGeneration (& typeid (cPtr_notExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_notExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__notExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_notExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_notExpressionForGeneration (mType, mLocation, mExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_notExpressionForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_notExpressionForGeneration ("notExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_notExpressionForGeneration::
GGS_notExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_notExpressionForGeneration::
GGS_notExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_notExpressionForGeneration GGS_notExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_notExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_notExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_notExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_notExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_notExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_notExpressionForGeneration GGS_notExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_semanticExpressionForGeneration & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_notExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_notExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_notExpressionForGeneration::
reader_mExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_notExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_notExpressionForGeneration *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_notExpressionForGeneration::actualTypeName (void) const {
  return "notExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__notExpressionForGeneration ("notExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_notExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_notExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_notExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_notExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_notExpressionForGeneration GGS_notExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_notExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_notExpressionForGeneration * p = dynamic_cast <const GGS_notExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_notExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_notExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_notExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'cPtr_complementExpressionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_complementExpressionForGeneration::
cPtr_complementExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_semanticExpressionForGeneration & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_complementExpressionForGeneration * GGS_complementExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_complementExpressionForGeneration) ;
    return (cPtr_complementExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_complementExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_complementExpressionForGeneration * ptr = dynamic_cast <const cPtr_complementExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mExpression.operator_isEqual (ptr->mExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_complementExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@complementExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_complementExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_complementExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_complementExpressionForGeneration (& typeid (cPtr_complementExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_complementExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__complementExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_complementExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_complementExpressionForGeneration (mType, mLocation, mExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_complementExpressionForGeneration'            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_complementExpressionForGeneration ("complementExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_complementExpressionForGeneration::
GGS_complementExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_complementExpressionForGeneration::
GGS_complementExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_complementExpressionForGeneration GGS_complementExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_complementExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_complementExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_complementExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_complementExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_complementExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_complementExpressionForGeneration GGS_complementExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_semanticExpressionForGeneration & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_complementExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_complementExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_complementExpressionForGeneration::
reader_mExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_complementExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_complementExpressionForGeneration *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_complementExpressionForGeneration::actualTypeName (void) const {
  return "complementExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__complementExpressionForGeneration ("complementExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_complementExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_complementExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_complementExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_complementExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_complementExpressionForGeneration GGS_complementExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_complementExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_complementExpressionForGeneration * p = dynamic_cast <const GGS_complementExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_complementExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_complementExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_complementExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_ifExpressionForGeneration'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ifExpressionForGeneration::
cPtr_ifExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_semanticExpressionForGeneration & argument_2,
                                const GGS_semanticExpressionForGeneration & argument_3,
                                const GGS_semanticExpressionForGeneration & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mIfExpression (argument_2),
mThenExpression (argument_3),
mElseExpression (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ifExpressionForGeneration * GGS_ifExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_ifExpressionForGeneration) ;
    return (cPtr_ifExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ifExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ifExpressionForGeneration * ptr = dynamic_cast <const cPtr_ifExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mIfExpression.operator_isEqual (ptr->mIfExpression).boolValue ()
         && mThenExpression.operator_isEqual (ptr->mThenExpression).boolValue ()
         && mElseExpression.operator_isEqual (ptr->mElseExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ifExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@ifExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mIfExpression.reader_description (inIndentation + 1)
           << mThenExpression.reader_description (inIndentation + 1)
           << mElseExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ifExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ifExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ifExpressionForGeneration (& typeid (cPtr_ifExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_ifExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__ifExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_ifExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_ifExpressionForGeneration (mType, mLocation, mIfExpression, mThenExpression, mElseExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_ifExpressionForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_ifExpressionForGeneration ("ifExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_ifExpressionForGeneration::
GGS_ifExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ifExpressionForGeneration::
GGS_ifExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_ifExpressionForGeneration GGS_ifExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ifExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ifExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_ifExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_ifExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ifExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ifExpressionForGeneration GGS_ifExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_semanticExpressionForGeneration & argument_2,
                 const GGS_semanticExpressionForGeneration & argument_3,
                 const GGS_semanticExpressionForGeneration & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_ifExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_ifExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_ifExpressionForGeneration::
reader_mIfExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ifExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ifExpressionForGeneration *) mPointer)->mIfExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_ifExpressionForGeneration::
reader_mThenExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ifExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ifExpressionForGeneration *) mPointer)->mThenExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_ifExpressionForGeneration::
reader_mElseExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ifExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ifExpressionForGeneration *) mPointer)->mElseExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ifExpressionForGeneration::actualTypeName (void) const {
  return "ifExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__ifExpressionForGeneration ("ifExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_ifExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_ifExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_ifExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_ifExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ifExpressionForGeneration GGS_ifExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_ifExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_ifExpressionForGeneration * p = dynamic_cast <const GGS_ifExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_ifExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_ifExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_ifExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_functionCallExpressionForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_functionCallExpressionForGeneration::
cPtr_functionCallExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_string& argument_2,
                                const GGS_semanticExpressionListForGeneration & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mFunctionName (argument_2),
mExpressions (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_functionCallExpressionForGeneration * GGS_functionCallExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_functionCallExpressionForGeneration) ;
    return (cPtr_functionCallExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_functionCallExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_functionCallExpressionForGeneration * ptr = dynamic_cast <const cPtr_functionCallExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mFunctionName.operator_isEqual (ptr->mFunctionName).boolValue ()
         && mExpressions.operator_isEqual (ptr->mExpressions).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_functionCallExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@functionCallExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mFunctionName.reader_description (inIndentation + 1)
           << mExpressions.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_functionCallExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_functionCallExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_functionCallExpressionForGeneration (& typeid (cPtr_functionCallExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_functionCallExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__functionCallExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_functionCallExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_functionCallExpressionForGeneration (mType, mLocation, mFunctionName, mExpressions COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_functionCallExpressionForGeneration'           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_functionCallExpressionForGeneration ("functionCallExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_functionCallExpressionForGeneration::
GGS_functionCallExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_functionCallExpressionForGeneration::
GGS_functionCallExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_functionCallExpressionForGeneration GGS_functionCallExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_functionCallExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_functionCallExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_functionCallExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_functionCallExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_functionCallExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_functionCallExpressionForGeneration GGS_functionCallExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_string& argument_2,
                 const GGS_semanticExpressionListForGeneration & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_functionCallExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_functionCallExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_functionCallExpressionForGeneration::
reader_mFunctionName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_functionCallExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_functionCallExpressionForGeneration *) mPointer)->mFunctionName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionListForGeneration  GGS_functionCallExpressionForGeneration::
reader_mExpressions (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_functionCallExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_functionCallExpressionForGeneration *) mPointer)->mExpressions ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_functionCallExpressionForGeneration::actualTypeName (void) const {
  return "functionCallExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__functionCallExpressionForGeneration ("functionCallExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_functionCallExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_functionCallExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_functionCallExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_functionCallExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_functionCallExpressionForGeneration GGS_functionCallExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_functionCallExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_functionCallExpressionForGeneration * p = dynamic_cast <const GGS_functionCallExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_functionCallExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_functionCallExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_functionCallExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_varInExpressionForGeneration'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_varInExpressionForGeneration::
cPtr_varInExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_string& argument_2,
                                const GGS_lstringlist & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mCppVarName (argument_2),
mStructFieldList (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_varInExpressionForGeneration * GGS_varInExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_varInExpressionForGeneration) ;
    return (cPtr_varInExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_varInExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_varInExpressionForGeneration * ptr = dynamic_cast <const cPtr_varInExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mCppVarName.operator_isEqual (ptr->mCppVarName).boolValue ()
         && mStructFieldList.operator_isEqual (ptr->mStructFieldList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_varInExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@varInExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mCppVarName.reader_description (inIndentation + 1)
           << mStructFieldList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_varInExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_varInExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_varInExpressionForGeneration (& typeid (cPtr_varInExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_varInExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__varInExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_varInExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_varInExpressionForGeneration (mType, mLocation, mCppVarName, mStructFieldList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_varInExpressionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_varInExpressionForGeneration ("varInExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_varInExpressionForGeneration::
GGS_varInExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_varInExpressionForGeneration::
GGS_varInExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_varInExpressionForGeneration GGS_varInExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_varInExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_varInExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_varInExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_varInExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_varInExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_varInExpressionForGeneration GGS_varInExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_string& argument_2,
                 const GGS_lstringlist & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_varInExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_varInExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_varInExpressionForGeneration::
reader_mCppVarName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_varInExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_varInExpressionForGeneration *) mPointer)->mCppVarName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_varInExpressionForGeneration::
reader_mStructFieldList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_varInExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_varInExpressionForGeneration *) mPointer)->mStructFieldList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_varInExpressionForGeneration::actualTypeName (void) const {
  return "varInExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__varInExpressionForGeneration ("varInExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_varInExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_varInExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_varInExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_varInExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_varInExpressionForGeneration GGS_varInExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_varInExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_varInExpressionForGeneration * p = dynamic_cast <const GGS_varInExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_varInExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_varInExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_varInExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Element of list '@formalParameterListForGeneration'             *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_formalParameterListForGeneration::
elementOf_GGS_formalParameterListForGeneration (const GGS_formalArgumentPassingModeAST& argument_0,
                                const GGS_unifiedTypeMapProxy & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_string& argument_3
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mFormalArgumentPassingMode (argument_0),
mFormalArgumentType (argument_1),
mFormalArgumentName (argument_2),
mFormalArgumentCppName (argument_3) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_formalParameterListForGeneration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_formalParameterListForGeneration * ptr = dynamic_cast <const elementOf_GGS_formalParameterListForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mFormalArgumentPassingMode.operator_isEqual (ptr->mFormalArgumentPassingMode).boolValue ()
         && mFormalArgumentType.operator_isEqual (ptr->mFormalArgumentType).boolValue ()
         && mFormalArgumentName.operator_isEqual (ptr->mFormalArgumentName).boolValue ()
         && mFormalArgumentCppName.operator_isEqual (ptr->mFormalArgumentCppName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_formalParameterListForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFormalArgumentPassingMode.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFormalArgumentType.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFormalArgumentName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFormalArgumentCppName.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 List '@formalParameterListForGeneration'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_formalParameterListForGeneration ("formalParameterListForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_formalParameterListForGeneration::
internalAppendValues (const GGS_formalArgumentPassingModeAST& argument_0,
                    const GGS_unifiedTypeMapProxy & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_string& argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_formalParameterListForGeneration::
internalPrependValues (const GGS_formalArgumentPassingModeAST& argument_0,
                    const GGS_unifiedTypeMapProxy & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_string& argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_formalParameterListForGeneration::
addAssign_operation (const GGS_formalArgumentPassingModeAST& argument_0,
                                const GGS_unifiedTypeMapProxy & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_string& argument_3) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()&& argument_3.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_formalParameterListForGeneration GGS_formalParameterListForGeneration::
operator_concat (const GGS_formalParameterListForGeneration & inOperand) const {
  GGS_formalParameterListForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_formalParameterListForGeneration::
dotAssign_operation (const GGS_formalParameterListForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_formalParameterListForGeneration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_formalArgumentPassingModeAST p_0 = p->mFormalArgumentPassingMode ;
          GGS_unifiedTypeMapProxy  p_1 = p->mFormalArgumentType ;
          GGS_lstring  p_2 = p->mFormalArgumentName ;
          GGS_string p_3 = p->mFormalArgumentCppName ;
          internalAppendValues (p_0, p_1, p_2, p_3 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_formalParameterListForGeneration::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_formalArgumentPassingModeAST& argument_0,
                     const GGS_unifiedTypeMapProxy & argument_1,
                     const GGS_lstring & argument_2,
                     const GGS_string& argument_3
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_formalParameterListForGeneration::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mFormalArgumentPassingMode,
                                ptr->mFormalArgumentType,
                                ptr->mFormalArgumentName,
                                ptr->mFormalArgumentCppName
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_formalParameterListForGeneration  GGS_formalParameterListForGeneration::
constructor_emptyList (void) {
  GGS_formalParameterListForGeneration result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameterListForGeneration  GGS_formalParameterListForGeneration::
constructor_listWithValue (const GGS_formalArgumentPassingModeAST& argument_0,
                                const GGS_unifiedTypeMapProxy & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_string& argument_3) {
  GGS_formalParameterListForGeneration result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2, argument_3) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_formalParameterListForGeneration::
internalSubListWithRange (GGS_formalParameterListForGeneration & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mFormalArgumentPassingMode, ptr->mFormalArgumentType, ptr->mFormalArgumentName, ptr->mFormalArgumentCppName) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_formalParameterListForGeneration GGS_formalParameterListForGeneration::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_formalParameterListForGeneration result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameterListForGeneration GGS_formalParameterListForGeneration::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_formalParameterListForGeneration result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_formalParameterListForGeneration::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@formalParameterListForGeneration", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_formalParameterListForGeneration::
method_first (C_Compiler & inLexique,
              GGS_formalArgumentPassingModeAST& _out_0,
              GGS_unifiedTypeMapProxy & _out_1,
              GGS_lstring & _out_2,
              GGS_string& _out_3
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mFormalArgumentPassingMode ;
    _out_1 = ptr->mFormalArgumentType ;
    _out_2 = ptr->mFormalArgumentName ;
    _out_3 = ptr->mFormalArgumentCppName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_formalParameterListForGeneration::
method_last (C_Compiler & inLexique,
             GGS_formalArgumentPassingModeAST& _out_0,
             GGS_unifiedTypeMapProxy & _out_1,
             GGS_lstring & _out_2,
             GGS_string& _out_3
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mFormalArgumentPassingMode ;
    _out_1 = ptr->mFormalArgumentType ;
    _out_2 = ptr->mFormalArgumentName ;
    _out_3 = ptr->mFormalArgumentCppName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_formalParameterListForGeneration::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_formalArgumentPassingModeAST& _out_0,
                 GGS_unifiedTypeMapProxy & _out_1,
                 GGS_lstring & _out_2,
                 GGS_string& _out_3
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mFormalArgumentPassingMode ;
    _out_1 = ptr->mFormalArgumentType ;
    _out_2 = ptr->mFormalArgumentName ;
    _out_3 = ptr->mFormalArgumentCppName ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_formalParameterListForGeneration::
modifier_popLast (C_Compiler & inLexique,
                GGS_formalArgumentPassingModeAST& _out_0,
                GGS_unifiedTypeMapProxy & _out_1,
                GGS_lstring & _out_2,
                GGS_string& _out_3
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mFormalArgumentPassingMode ;
    _out_1 = ptr->mFormalArgumentType ;
    _out_2 = ptr->mFormalArgumentName ;
    _out_3 = ptr->mFormalArgumentCppName ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_formalArgumentPassingModeAST GGS_formalParameterListForGeneration::
reader_mFormalArgumentPassingModeAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_formalArgumentPassingModeAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mFormalArgumentPassingMode ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapProxy  GGS_formalParameterListForGeneration::
reader_mFormalArgumentTypeAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_unifiedTypeMapProxy  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mFormalArgumentType ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_formalParameterListForGeneration::
reader_mFormalArgumentNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mFormalArgumentName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_formalParameterListForGeneration::
reader_mFormalArgumentCppNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_string result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mFormalArgumentCppName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_formalParameterListForGeneration::
modifier_setMFormalArgumentPassingModeAtIndex (C_Compiler & inLexique,
                              const GGS_formalArgumentPassingModeAST & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mFormalArgumentPassingMode = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_formalParameterListForGeneration::
modifier_setMFormalArgumentTypeAtIndex (C_Compiler & inLexique,
                              const GGS_unifiedTypeMapProxy  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mFormalArgumentType = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_formalParameterListForGeneration::
modifier_setMFormalArgumentNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mFormalArgumentName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_formalParameterListForGeneration::
modifier_setMFormalArgumentCppNameAtIndex (C_Compiler & inLexique,
                              const GGS_string & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mFormalArgumentCppName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_formalArgumentPassingModeAST & GGS_formalParameterListForGeneration::cEnumerator::_mFormalArgumentPassingMode (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mFormalArgumentPassingMode ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_unifiedTypeMapProxy  & GGS_formalParameterListForGeneration::cEnumerator::_mFormalArgumentType (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mFormalArgumentType ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_formalParameterListForGeneration::cEnumerator::_mFormalArgumentName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mFormalArgumentName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_formalParameterListForGeneration::cEnumerator::_mFormalArgumentCppName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mFormalArgumentCppName ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_formalParameterListForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_formalParameterListForGeneration * p = NULL ;
    macroMyNew (p, GGS_formalParameterListForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameterListForGeneration GGS_formalParameterListForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_formalParameterListForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_formalParameterListForGeneration * p = dynamic_cast <const GGS_formalParameterListForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_formalParameterListForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_formalParameterListForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_formalParameterListForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         Element of list '@formalInputParameterListForGeneration'          *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_formalInputParameterListForGeneration::
elementOf_GGS_formalInputParameterListForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_bool& argument_2
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mFormalParameterType (argument_0),
mFormalParameterName (argument_1),
mIsUnused (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_formalInputParameterListForGeneration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_formalInputParameterListForGeneration * ptr = dynamic_cast <const elementOf_GGS_formalInputParameterListForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mFormalParameterType.operator_isEqual (ptr->mFormalParameterType).boolValue ()
         && mFormalParameterName.operator_isEqual (ptr->mFormalParameterName).boolValue ()
         && mIsUnused.operator_isEqual (ptr->mIsUnused).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_formalInputParameterListForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFormalParameterType.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFormalParameterName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mIsUnused.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              List '@formalInputParameterListForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_formalInputParameterListForGeneration ("formalInputParameterListForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_formalInputParameterListForGeneration::
internalAppendValues (const GGS_unifiedTypeMapProxy & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_bool& argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_formalInputParameterListForGeneration::
internalPrependValues (const GGS_unifiedTypeMapProxy & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_bool& argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_formalInputParameterListForGeneration::
addAssign_operation (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_bool& argument_2) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_formalInputParameterListForGeneration GGS_formalInputParameterListForGeneration::
operator_concat (const GGS_formalInputParameterListForGeneration & inOperand) const {
  GGS_formalInputParameterListForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_formalInputParameterListForGeneration::
dotAssign_operation (const GGS_formalInputParameterListForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_formalInputParameterListForGeneration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_unifiedTypeMapProxy  p_0 = p->mFormalParameterType ;
          GGS_lstring  p_1 = p->mFormalParameterName ;
          GGS_bool p_2 = p->mIsUnused ;
          internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_formalInputParameterListForGeneration::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_unifiedTypeMapProxy & argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_bool& argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_formalInputParameterListForGeneration::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mFormalParameterType,
                                ptr->mFormalParameterName,
                                ptr->mIsUnused
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_formalInputParameterListForGeneration  GGS_formalInputParameterListForGeneration::
constructor_emptyList (void) {
  GGS_formalInputParameterListForGeneration result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalInputParameterListForGeneration  GGS_formalInputParameterListForGeneration::
constructor_listWithValue (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_bool& argument_2) {
  GGS_formalInputParameterListForGeneration result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_formalInputParameterListForGeneration::
internalSubListWithRange (GGS_formalInputParameterListForGeneration & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mFormalParameterType, ptr->mFormalParameterName, ptr->mIsUnused) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_formalInputParameterListForGeneration GGS_formalInputParameterListForGeneration::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_formalInputParameterListForGeneration result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalInputParameterListForGeneration GGS_formalInputParameterListForGeneration::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_formalInputParameterListForGeneration result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_formalInputParameterListForGeneration::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@formalInputParameterListForGeneration", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_formalInputParameterListForGeneration::
method_first (C_Compiler & inLexique,
              GGS_unifiedTypeMapProxy & _out_0,
              GGS_lstring & _out_1,
              GGS_bool& _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mFormalParameterType ;
    _out_1 = ptr->mFormalParameterName ;
    _out_2 = ptr->mIsUnused ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_formalInputParameterListForGeneration::
method_last (C_Compiler & inLexique,
             GGS_unifiedTypeMapProxy & _out_0,
             GGS_lstring & _out_1,
             GGS_bool& _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mFormalParameterType ;
    _out_1 = ptr->mFormalParameterName ;
    _out_2 = ptr->mIsUnused ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_formalInputParameterListForGeneration::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_unifiedTypeMapProxy & _out_0,
                 GGS_lstring & _out_1,
                 GGS_bool& _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mFormalParameterType ;
    _out_1 = ptr->mFormalParameterName ;
    _out_2 = ptr->mIsUnused ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_formalInputParameterListForGeneration::
modifier_popLast (C_Compiler & inLexique,
                GGS_unifiedTypeMapProxy & _out_0,
                GGS_lstring & _out_1,
                GGS_bool& _out_2
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mFormalParameterType ;
    _out_1 = ptr->mFormalParameterName ;
    _out_2 = ptr->mIsUnused ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapProxy  GGS_formalInputParameterListForGeneration::
reader_mFormalParameterTypeAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_unifiedTypeMapProxy  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mFormalParameterType ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_formalInputParameterListForGeneration::
reader_mFormalParameterNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mFormalParameterName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_formalInputParameterListForGeneration::
reader_mIsUnusedAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mIsUnused ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_formalInputParameterListForGeneration::
modifier_setMFormalParameterTypeAtIndex (C_Compiler & inLexique,
                              const GGS_unifiedTypeMapProxy  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mFormalParameterType = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_formalInputParameterListForGeneration::
modifier_setMFormalParameterNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mFormalParameterName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_formalInputParameterListForGeneration::
modifier_setMIsUnusedAtIndex (C_Compiler & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mIsUnused = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_unifiedTypeMapProxy  & GGS_formalInputParameterListForGeneration::cEnumerator::_mFormalParameterType (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mFormalParameterType ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_formalInputParameterListForGeneration::cEnumerator::_mFormalParameterName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mFormalParameterName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_formalInputParameterListForGeneration::cEnumerator::_mIsUnused (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mIsUnused ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_formalInputParameterListForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_formalInputParameterListForGeneration * p = NULL ;
    macroMyNew (p, GGS_formalInputParameterListForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalInputParameterListForGeneration GGS_formalInputParameterListForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_formalInputParameterListForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_formalInputParameterListForGeneration * p = dynamic_cast <const GGS_formalInputParameterListForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_formalInputParameterListForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_formalInputParameterListForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_formalInputParameterListForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_actualParameterForGeneration'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_actualParameterForGeneration::
cPtr_actualParameterForGeneration (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_actualParameterForGeneration * GGS_actualParameterForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_actualParameterForGeneration) ;
    return (cPtr_actualParameterForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_actualParameterForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@actualParameterForGeneration:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_actualParameterForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_actualParameterForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_actualParameterForGeneration (& typeid (cPtr_actualParameterForGeneration), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_actualParameterForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__actualParameterForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_actualParameterForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_actualParameterForGeneration ("actualParameterForGeneration", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_actualParameterForGeneration::
GGS_actualParameterForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_actualParameterForGeneration::
GGS_actualParameterForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_actualParameterForGeneration GGS_actualParameterForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_actualParameterForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_actualParameterForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_actualParameterForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_actualParameterForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_actualParameterForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_actualParameterForGeneration::actualTypeName (void) const {
  return "actualParameterForGeneration" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_actualParameterForGeneration::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__actualParameterForGeneration ("actualParameterForGeneration", & kTypeDescriptor_GGS_actualParameterForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_actualParameterForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_actualParameterForGeneration * p = NULL ;
    macroMyNew (p, GGS_actualParameterForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameterForGeneration GGS_actualParameterForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_actualParameterForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_actualParameterForGeneration * p = dynamic_cast <const GGS_actualParameterForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_actualParameterForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_actualParameterForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_actualParameterForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_outputActualParameterForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_outputActualParameterForGeneration::
cPtr_outputActualParameterForGeneration (const GGS_semanticExpressionForGeneration & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_actualParameterForGeneration (THERE),
mOutputActualParameterExpression (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_outputActualParameterForGeneration * GGS_outputActualParameterForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_outputActualParameterForGeneration) ;
    return (cPtr_outputActualParameterForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_outputActualParameterForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_outputActualParameterForGeneration * ptr = dynamic_cast <const cPtr_outputActualParameterForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOutputActualParameterExpression.operator_isEqual (ptr->mOutputActualParameterExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_outputActualParameterForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@outputActualParameterForGeneration:"
           << mOutputActualParameterExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_outputActualParameterForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_outputActualParameterForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_outputActualParameterForGeneration (& typeid (cPtr_outputActualParameterForGeneration), & typeid (cPtr_actualParameterForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_outputActualParameterForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__outputActualParameterForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_outputActualParameterForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_outputActualParameterForGeneration (mOutputActualParameterExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_outputActualParameterForGeneration'            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_outputActualParameterForGeneration ("outputActualParameterForGeneration", true, & kTypeDescriptor_GGS_actualParameterForGeneration) ;

//---------------------------------------------------------------------------*

GGS_outputActualParameterForGeneration::
GGS_outputActualParameterForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_outputActualParameterForGeneration::
GGS_outputActualParameterForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_outputActualParameterForGeneration GGS_outputActualParameterForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_outputActualParameterForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_outputActualParameterForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_outputActualParameterForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_outputActualParameterForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_outputActualParameterForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_outputActualParameterForGeneration GGS_outputActualParameterForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_semanticExpressionForGeneration & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_outputActualParameterForGeneration result ;
  macroMyNew (result.mPointer, cPtr_outputActualParameterForGeneration (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_outputActualParameterForGeneration::
reader_mOutputActualParameterExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_outputActualParameterForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_outputActualParameterForGeneration *) mPointer)->mOutputActualParameterExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_outputActualParameterForGeneration::actualTypeName (void) const {
  return "outputActualParameterForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__outputActualParameterForGeneration ("outputActualParameterForGeneration", gClassInfoFor__actualParameterForGeneration, & kTypeDescriptor_GGS_outputActualParameterForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_outputActualParameterForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_outputActualParameterForGeneration * p = NULL ;
    macroMyNew (p, GGS_outputActualParameterForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_outputActualParameterForGeneration GGS_outputActualParameterForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_outputActualParameterForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_outputActualParameterForGeneration * p = dynamic_cast <const GGS_outputActualParameterForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_outputActualParameterForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_outputActualParameterForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_outputActualParameterForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           class 'cPtr_outputInputActualParameterForGeneration'            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_outputInputActualParameterForGeneration::
cPtr_outputInputActualParameterForGeneration (const GGS_string& argument_0,
                                const GGS_lstringlist & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_actualParameterForGeneration (THERE),
mOutputInputVariableCppName (argument_0),
mStructAttributeList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_outputInputActualParameterForGeneration * GGS_outputInputActualParameterForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_outputInputActualParameterForGeneration) ;
    return (cPtr_outputInputActualParameterForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_outputInputActualParameterForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_outputInputActualParameterForGeneration * ptr = dynamic_cast <const cPtr_outputInputActualParameterForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOutputInputVariableCppName.operator_isEqual (ptr->mOutputInputVariableCppName).boolValue ()
         && mStructAttributeList.operator_isEqual (ptr->mStructAttributeList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_outputInputActualParameterForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@outputInputActualParameterForGeneration:"
           << mOutputInputVariableCppName.reader_description (inIndentation + 1)
           << mStructAttributeList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_outputInputActualParameterForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_outputInputActualParameterForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_outputInputActualParameterForGeneration (& typeid (cPtr_outputInputActualParameterForGeneration), & typeid (cPtr_actualParameterForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_outputInputActualParameterForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__outputInputActualParameterForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_outputInputActualParameterForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_outputInputActualParameterForGeneration (mOutputInputVariableCppName, mStructAttributeList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        GALGAS class 'GGS_outputInputActualParameterForGeneration'         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_outputInputActualParameterForGeneration ("outputInputActualParameterForGeneration", true, & kTypeDescriptor_GGS_actualParameterForGeneration) ;

//---------------------------------------------------------------------------*

GGS_outputInputActualParameterForGeneration::
GGS_outputInputActualParameterForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_outputInputActualParameterForGeneration::
GGS_outputInputActualParameterForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_outputInputActualParameterForGeneration GGS_outputInputActualParameterForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_outputInputActualParameterForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_outputInputActualParameterForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_outputInputActualParameterForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_outputInputActualParameterForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_outputInputActualParameterForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_outputInputActualParameterForGeneration GGS_outputInputActualParameterForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0,
                 const GGS_lstringlist & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_outputInputActualParameterForGeneration result ;
  macroMyNew (result.mPointer, cPtr_outputInputActualParameterForGeneration (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_outputInputActualParameterForGeneration::
reader_mOutputInputVariableCppName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_outputInputActualParameterForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_outputInputActualParameterForGeneration *) mPointer)->mOutputInputVariableCppName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_outputInputActualParameterForGeneration::
reader_mStructAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_outputInputActualParameterForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_outputInputActualParameterForGeneration *) mPointer)->mStructAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_outputInputActualParameterForGeneration::actualTypeName (void) const {
  return "outputInputActualParameterForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__outputInputActualParameterForGeneration ("outputInputActualParameterForGeneration", gClassInfoFor__actualParameterForGeneration, & kTypeDescriptor_GGS_outputInputActualParameterForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_outputInputActualParameterForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_outputInputActualParameterForGeneration * p = NULL ;
    macroMyNew (p, GGS_outputInputActualParameterForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_outputInputActualParameterForGeneration GGS_outputInputActualParameterForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_outputInputActualParameterForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_outputInputActualParameterForGeneration * p = dynamic_cast <const GGS_outputInputActualParameterForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_outputInputActualParameterForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_outputInputActualParameterForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_outputInputActualParameterForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'cPtr_inputActualParameterForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_inputActualParameterForGeneration::
cPtr_inputActualParameterForGeneration (const GGS_string& argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_actualParameterForGeneration (THERE),
mInputActualCppName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_inputActualParameterForGeneration * GGS_inputActualParameterForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_inputActualParameterForGeneration) ;
    return (cPtr_inputActualParameterForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_inputActualParameterForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_inputActualParameterForGeneration * ptr = dynamic_cast <const cPtr_inputActualParameterForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInputActualCppName.operator_isEqual (ptr->mInputActualCppName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_inputActualParameterForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@inputActualParameterForGeneration:"
           << mInputActualCppName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_inputActualParameterForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_inputActualParameterForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_inputActualParameterForGeneration (& typeid (cPtr_inputActualParameterForGeneration), & typeid (cPtr_actualParameterForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_inputActualParameterForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__inputActualParameterForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_inputActualParameterForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_inputActualParameterForGeneration (mInputActualCppName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_inputActualParameterForGeneration'            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_inputActualParameterForGeneration ("inputActualParameterForGeneration", true, & kTypeDescriptor_GGS_actualParameterForGeneration) ;

//---------------------------------------------------------------------------*

GGS_inputActualParameterForGeneration::
GGS_inputActualParameterForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_inputActualParameterForGeneration::
GGS_inputActualParameterForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_inputActualParameterForGeneration GGS_inputActualParameterForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_inputActualParameterForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_inputActualParameterForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_inputActualParameterForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_inputActualParameterForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_inputActualParameterForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_inputActualParameterForGeneration GGS_inputActualParameterForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_inputActualParameterForGeneration result ;
  macroMyNew (result.mPointer, cPtr_inputActualParameterForGeneration (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_inputActualParameterForGeneration::
reader_mInputActualCppName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_inputActualParameterForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_inputActualParameterForGeneration *) mPointer)->mInputActualCppName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_inputActualParameterForGeneration::actualTypeName (void) const {
  return "inputActualParameterForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__inputActualParameterForGeneration ("inputActualParameterForGeneration", gClassInfoFor__actualParameterForGeneration, & kTypeDescriptor_GGS_inputActualParameterForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_inputActualParameterForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_inputActualParameterForGeneration * p = NULL ;
    macroMyNew (p, GGS_inputActualParameterForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_inputActualParameterForGeneration GGS_inputActualParameterForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_inputActualParameterForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_inputActualParameterForGeneration * p = dynamic_cast <const GGS_inputActualParameterForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_inputActualParameterForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_inputActualParameterForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_inputActualParameterForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Element of list '@actualParameterListForGeneration'             *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_actualParameterListForGeneration::
elementOf_GGS_actualParameterListForGeneration (const GGS_actualParameterForGeneration & argument_0
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mActualParameter (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_actualParameterListForGeneration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_actualParameterListForGeneration * ptr = dynamic_cast <const elementOf_GGS_actualParameterListForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mActualParameter.operator_isEqual (ptr->mActualParameter).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_actualParameterListForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mActualParameter.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 List '@actualParameterListForGeneration'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_actualParameterListForGeneration ("actualParameterListForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_actualParameterListForGeneration::
internalAppendValues (const GGS_actualParameterForGeneration & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_actualParameterListForGeneration::
internalPrependValues (const GGS_actualParameterForGeneration & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_actualParameterListForGeneration::
addAssign_operation (const GGS_actualParameterForGeneration & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_actualParameterListForGeneration GGS_actualParameterListForGeneration::
operator_concat (const GGS_actualParameterListForGeneration & inOperand) const {
  GGS_actualParameterListForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_actualParameterListForGeneration::
dotAssign_operation (const GGS_actualParameterListForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_actualParameterListForGeneration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_actualParameterForGeneration  p_0 = p->mActualParameter ;
          internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_actualParameterListForGeneration::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_actualParameterForGeneration & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_actualParameterListForGeneration::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mActualParameter
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_actualParameterListForGeneration  GGS_actualParameterListForGeneration::
constructor_emptyList (void) {
  GGS_actualParameterListForGeneration result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameterListForGeneration  GGS_actualParameterListForGeneration::
constructor_listWithValue (const GGS_actualParameterForGeneration & argument_0) {
  GGS_actualParameterListForGeneration result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_actualParameterListForGeneration::
internalSubListWithRange (GGS_actualParameterListForGeneration & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mActualParameter) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_actualParameterListForGeneration GGS_actualParameterListForGeneration::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_actualParameterListForGeneration result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameterListForGeneration GGS_actualParameterListForGeneration::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_actualParameterListForGeneration result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_actualParameterListForGeneration::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@actualParameterListForGeneration", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_actualParameterListForGeneration::
method_first (C_Compiler & inLexique,
              GGS_actualParameterForGeneration & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mActualParameter ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_actualParameterListForGeneration::
method_last (C_Compiler & inLexique,
             GGS_actualParameterForGeneration & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mActualParameter ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_actualParameterListForGeneration::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_actualParameterForGeneration & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mActualParameter ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_actualParameterListForGeneration::
modifier_popLast (C_Compiler & inLexique,
                GGS_actualParameterForGeneration & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mActualParameter ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_actualParameterForGeneration  GGS_actualParameterListForGeneration::
reader_mActualParameterAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_actualParameterForGeneration  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mActualParameter ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_actualParameterListForGeneration::
modifier_setMActualParameterAtIndex (C_Compiler & inLexique,
                              const GGS_actualParameterForGeneration  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mActualParameter = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_actualParameterForGeneration  & GGS_actualParameterListForGeneration::cEnumerator::_mActualParameter (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mActualParameter ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_actualParameterListForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_actualParameterListForGeneration * p = NULL ;
    macroMyNew (p, GGS_actualParameterListForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameterListForGeneration GGS_actualParameterListForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_actualParameterListForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_actualParameterListForGeneration * p = dynamic_cast <const GGS_actualParameterListForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_actualParameterListForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_actualParameterListForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_actualParameterListForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//Element of list '@temporaryInputVariableForRoutineInvocationForGeneration' *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_temporaryInputVariableForRoutineInvocationForGeneration::
elementOf_GGS_temporaryInputVariableForRoutineInvocationForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_string& argument_1
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mType (argument_0),
mCppName (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_temporaryInputVariableForRoutineInvocationForGeneration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_temporaryInputVariableForRoutineInvocationForGeneration * ptr = dynamic_cast <const elementOf_GGS_temporaryInputVariableForRoutineInvocationForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mCppName.operator_isEqual (ptr->mCppName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_temporaryInputVariableForRoutineInvocationForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mType.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mCppName.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//     List '@temporaryInputVariableForRoutineInvocationForGeneration'       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_temporaryInputVariableForRoutineInvocationForGeneration ("temporaryInputVariableForRoutineInvocationForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_temporaryInputVariableForRoutineInvocationForGeneration::
internalAppendValues (const GGS_unifiedTypeMapProxy & argument_0,
                    const GGS_string& argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_temporaryInputVariableForRoutineInvocationForGeneration::
internalPrependValues (const GGS_unifiedTypeMapProxy & argument_0,
                    const GGS_string& argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_temporaryInputVariableForRoutineInvocationForGeneration::
addAssign_operation (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_string& argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_temporaryInputVariableForRoutineInvocationForGeneration GGS_temporaryInputVariableForRoutineInvocationForGeneration::
operator_concat (const GGS_temporaryInputVariableForRoutineInvocationForGeneration & inOperand) const {
  GGS_temporaryInputVariableForRoutineInvocationForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_temporaryInputVariableForRoutineInvocationForGeneration::
dotAssign_operation (const GGS_temporaryInputVariableForRoutineInvocationForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_temporaryInputVariableForRoutineInvocationForGeneration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_unifiedTypeMapProxy  p_0 = p->mType ;
          GGS_string p_1 = p->mCppName ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_temporaryInputVariableForRoutineInvocationForGeneration::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_unifiedTypeMapProxy & argument_0,
                     const GGS_string& argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_temporaryInputVariableForRoutineInvocationForGeneration::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mType,
                                ptr->mCppName
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_temporaryInputVariableForRoutineInvocationForGeneration  GGS_temporaryInputVariableForRoutineInvocationForGeneration::
constructor_emptyList (void) {
  GGS_temporaryInputVariableForRoutineInvocationForGeneration result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_temporaryInputVariableForRoutineInvocationForGeneration  GGS_temporaryInputVariableForRoutineInvocationForGeneration::
constructor_listWithValue (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_string& argument_1) {
  GGS_temporaryInputVariableForRoutineInvocationForGeneration result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_temporaryInputVariableForRoutineInvocationForGeneration::
internalSubListWithRange (GGS_temporaryInputVariableForRoutineInvocationForGeneration & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mType, ptr->mCppName) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_temporaryInputVariableForRoutineInvocationForGeneration GGS_temporaryInputVariableForRoutineInvocationForGeneration::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_temporaryInputVariableForRoutineInvocationForGeneration result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_temporaryInputVariableForRoutineInvocationForGeneration GGS_temporaryInputVariableForRoutineInvocationForGeneration::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_temporaryInputVariableForRoutineInvocationForGeneration result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_temporaryInputVariableForRoutineInvocationForGeneration::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@temporaryInputVariableForRoutineInvocationForGeneration", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_temporaryInputVariableForRoutineInvocationForGeneration::
method_first (C_Compiler & inLexique,
              GGS_unifiedTypeMapProxy & _out_0,
              GGS_string& _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mType ;
    _out_1 = ptr->mCppName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_temporaryInputVariableForRoutineInvocationForGeneration::
method_last (C_Compiler & inLexique,
             GGS_unifiedTypeMapProxy & _out_0,
             GGS_string& _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mType ;
    _out_1 = ptr->mCppName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_temporaryInputVariableForRoutineInvocationForGeneration::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_unifiedTypeMapProxy & _out_0,
                 GGS_string& _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mType ;
    _out_1 = ptr->mCppName ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_temporaryInputVariableForRoutineInvocationForGeneration::
modifier_popLast (C_Compiler & inLexique,
                GGS_unifiedTypeMapProxy & _out_0,
                GGS_string& _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mType ;
    _out_1 = ptr->mCppName ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapProxy  GGS_temporaryInputVariableForRoutineInvocationForGeneration::
reader_mTypeAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_unifiedTypeMapProxy  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mType ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_temporaryInputVariableForRoutineInvocationForGeneration::
reader_mCppNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_string result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mCppName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_temporaryInputVariableForRoutineInvocationForGeneration::
modifier_setMTypeAtIndex (C_Compiler & inLexique,
                              const GGS_unifiedTypeMapProxy  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mType = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_temporaryInputVariableForRoutineInvocationForGeneration::
modifier_setMCppNameAtIndex (C_Compiler & inLexique,
                              const GGS_string & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mCppName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_unifiedTypeMapProxy  & GGS_temporaryInputVariableForRoutineInvocationForGeneration::cEnumerator::_mType (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mType ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_temporaryInputVariableForRoutineInvocationForGeneration::cEnumerator::_mCppName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mCppName ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_temporaryInputVariableForRoutineInvocationForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_temporaryInputVariableForRoutineInvocationForGeneration * p = NULL ;
    macroMyNew (p, GGS_temporaryInputVariableForRoutineInvocationForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_temporaryInputVariableForRoutineInvocationForGeneration GGS_temporaryInputVariableForRoutineInvocationForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_temporaryInputVariableForRoutineInvocationForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_temporaryInputVariableForRoutineInvocationForGeneration * p = dynamic_cast <const GGS_temporaryInputVariableForRoutineInvocationForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_temporaryInputVariableForRoutineInvocationForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_temporaryInputVariableForRoutineInvocationForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_temporaryInputVariableForRoutineInvocationForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'cPtr_semanticInstructionForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_semanticInstructionForGeneration::
cPtr_semanticInstructionForGeneration (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_semanticInstructionForGeneration * GGS_semanticInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_semanticInstructionForGeneration) ;
    return (cPtr_semanticInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_semanticInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@semanticInstructionForGeneration:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_semanticInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_semanticInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_semanticInstructionForGeneration (& typeid (cPtr_semanticInstructionForGeneration), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_semanticInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__semanticInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_semanticInstructionForGeneration'             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_semanticInstructionForGeneration ("semanticInstructionForGeneration", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_semanticInstructionForGeneration::
GGS_semanticInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionForGeneration::
GGS_semanticInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_semanticInstructionForGeneration GGS_semanticInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_semanticInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_semanticInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_semanticInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_semanticInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_semanticInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_semanticInstructionForGeneration::actualTypeName (void) const {
  return "semanticInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_semanticInstructionForGeneration::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__semanticInstructionForGeneration ("semanticInstructionForGeneration", & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_semanticInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_semanticInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_semanticInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionForGeneration GGS_semanticInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_semanticInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_semanticInstructionForGeneration * p = dynamic_cast <const GGS_semanticInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_semanticInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_semanticInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_semanticInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         Element of list '@semanticInstructionListForGeneration'           *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_semanticInstructionListForGeneration::
elementOf_GGS_semanticInstructionListForGeneration (const GGS_semanticInstructionForGeneration & argument_0
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mInstruction (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_semanticInstructionListForGeneration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_semanticInstructionListForGeneration * ptr = dynamic_cast <const elementOf_GGS_semanticInstructionListForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstruction.operator_isEqual (ptr->mInstruction).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_semanticInstructionListForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstruction.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               List '@semanticInstructionListForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_semanticInstructionListForGeneration ("semanticInstructionListForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_semanticInstructionListForGeneration::
internalAppendValues (const GGS_semanticInstructionForGeneration & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionListForGeneration::
internalPrependValues (const GGS_semanticInstructionForGeneration & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionListForGeneration::
addAssign_operation (const GGS_semanticInstructionForGeneration & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration GGS_semanticInstructionListForGeneration::
operator_concat (const GGS_semanticInstructionListForGeneration & inOperand) const {
  GGS_semanticInstructionListForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionListForGeneration::
dotAssign_operation (const GGS_semanticInstructionListForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_semanticInstructionListForGeneration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_semanticInstructionForGeneration  p_0 = p->mInstruction ;
          internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionListForGeneration::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_semanticInstructionForGeneration & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionListForGeneration::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mInstruction
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration  GGS_semanticInstructionListForGeneration::
constructor_emptyList (void) {
  GGS_semanticInstructionListForGeneration result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration  GGS_semanticInstructionListForGeneration::
constructor_listWithValue (const GGS_semanticInstructionForGeneration & argument_0) {
  GGS_semanticInstructionListForGeneration result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionListForGeneration::
internalSubListWithRange (GGS_semanticInstructionListForGeneration & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mInstruction) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration GGS_semanticInstructionListForGeneration::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_semanticInstructionListForGeneration result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration GGS_semanticInstructionListForGeneration::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_semanticInstructionListForGeneration result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_semanticInstructionListForGeneration::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@semanticInstructionListForGeneration", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionListForGeneration::
method_first (C_Compiler & inLexique,
              GGS_semanticInstructionForGeneration & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInstruction ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionListForGeneration::
method_last (C_Compiler & inLexique,
             GGS_semanticInstructionForGeneration & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInstruction ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionListForGeneration::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_semanticInstructionForGeneration & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInstruction ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionListForGeneration::
modifier_popLast (C_Compiler & inLexique,
                GGS_semanticInstructionForGeneration & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInstruction ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionForGeneration  GGS_semanticInstructionListForGeneration::
reader_mInstructionAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticInstructionForGeneration  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstruction ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionListForGeneration::
modifier_setMInstructionAtIndex (C_Compiler & inLexique,
                              const GGS_semanticInstructionForGeneration  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstruction = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticInstructionForGeneration  & GGS_semanticInstructionListForGeneration::cEnumerator::_mInstruction (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mInstruction ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_semanticInstructionListForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_semanticInstructionListForGeneration * p = NULL ;
    macroMyNew (p, GGS_semanticInstructionListForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration GGS_semanticInstructionListForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_semanticInstructionListForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_semanticInstructionListForGeneration * p = dynamic_cast <const GGS_semanticInstructionListForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_semanticInstructionListForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_semanticInstructionListForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_semanticInstructionListForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'cPtr_semanticDeclarationForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_semanticDeclarationForGeneration::
cPtr_semanticDeclarationForGeneration (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_semanticDeclarationForGeneration * GGS_semanticDeclarationForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_semanticDeclarationForGeneration) ;
    return (cPtr_semanticDeclarationForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_semanticDeclarationForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@semanticDeclarationForGeneration:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_semanticDeclarationForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_semanticDeclarationForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_semanticDeclarationForGeneration (& typeid (cPtr_semanticDeclarationForGeneration), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_semanticDeclarationForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__semanticDeclarationForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_semanticDeclarationForGeneration'             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_semanticDeclarationForGeneration ("semanticDeclarationForGeneration", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_semanticDeclarationForGeneration::
GGS_semanticDeclarationForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationForGeneration::
GGS_semanticDeclarationForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_semanticDeclarationForGeneration GGS_semanticDeclarationForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_semanticDeclarationForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_semanticDeclarationForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_semanticDeclarationForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_semanticDeclarationForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_semanticDeclarationForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_semanticDeclarationForGeneration::actualTypeName (void) const {
  return "semanticDeclarationForGeneration" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_semanticDeclarationForGeneration::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__semanticDeclarationForGeneration ("semanticDeclarationForGeneration", & kTypeDescriptor_GGS_semanticDeclarationForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_semanticDeclarationForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_semanticDeclarationForGeneration * p = NULL ;
    macroMyNew (p, GGS_semanticDeclarationForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationForGeneration GGS_semanticDeclarationForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_semanticDeclarationForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_semanticDeclarationForGeneration * p = dynamic_cast <const GGS_semanticDeclarationForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_semanticDeclarationForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_semanticDeclarationForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_semanticDeclarationForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         Element of list '@semanticDeclarationListForGeneration'           *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_semanticDeclarationListForGeneration::
elementOf_GGS_semanticDeclarationListForGeneration (const GGS_semanticDeclarationForGeneration & argument_0
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mDeclaration (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_semanticDeclarationListForGeneration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_semanticDeclarationListForGeneration * ptr = dynamic_cast <const elementOf_GGS_semanticDeclarationListForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mDeclaration.operator_isEqual (ptr->mDeclaration).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_semanticDeclarationListForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mDeclaration.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               List '@semanticDeclarationListForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_semanticDeclarationListForGeneration ("semanticDeclarationListForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationListForGeneration::
internalAppendValues (const GGS_semanticDeclarationForGeneration & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationListForGeneration::
internalPrependValues (const GGS_semanticDeclarationForGeneration & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationListForGeneration::
addAssign_operation (const GGS_semanticDeclarationForGeneration & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationListForGeneration GGS_semanticDeclarationListForGeneration::
operator_concat (const GGS_semanticDeclarationListForGeneration & inOperand) const {
  GGS_semanticDeclarationListForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationListForGeneration::
dotAssign_operation (const GGS_semanticDeclarationListForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_semanticDeclarationListForGeneration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_semanticDeclarationForGeneration  p_0 = p->mDeclaration ;
          internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationListForGeneration::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_semanticDeclarationForGeneration & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationListForGeneration::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mDeclaration
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationListForGeneration  GGS_semanticDeclarationListForGeneration::
constructor_emptyList (void) {
  GGS_semanticDeclarationListForGeneration result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationListForGeneration  GGS_semanticDeclarationListForGeneration::
constructor_listWithValue (const GGS_semanticDeclarationForGeneration & argument_0) {
  GGS_semanticDeclarationListForGeneration result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationListForGeneration::
internalSubListWithRange (GGS_semanticDeclarationListForGeneration & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mDeclaration) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationListForGeneration GGS_semanticDeclarationListForGeneration::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_semanticDeclarationListForGeneration result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationListForGeneration GGS_semanticDeclarationListForGeneration::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_semanticDeclarationListForGeneration result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_semanticDeclarationListForGeneration::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@semanticDeclarationListForGeneration", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationListForGeneration::
method_first (C_Compiler & inLexique,
              GGS_semanticDeclarationForGeneration & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mDeclaration ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationListForGeneration::
method_last (C_Compiler & inLexique,
             GGS_semanticDeclarationForGeneration & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mDeclaration ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationListForGeneration::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_semanticDeclarationForGeneration & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mDeclaration ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationListForGeneration::
modifier_popLast (C_Compiler & inLexique,
                GGS_semanticDeclarationForGeneration & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mDeclaration ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationForGeneration  GGS_semanticDeclarationListForGeneration::
reader_mDeclarationAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticDeclarationForGeneration  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mDeclaration ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationListForGeneration::
modifier_setMDeclarationAtIndex (C_Compiler & inLexique,
                              const GGS_semanticDeclarationForGeneration  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mDeclaration = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticDeclarationForGeneration  & GGS_semanticDeclarationListForGeneration::cEnumerator::_mDeclaration (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mDeclaration ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_semanticDeclarationListForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_semanticDeclarationListForGeneration * p = NULL ;
    macroMyNew (p, GGS_semanticDeclarationListForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationListForGeneration GGS_semanticDeclarationListForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_semanticDeclarationListForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_semanticDeclarationListForGeneration * p = dynamic_cast <const GGS_semanticDeclarationListForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_semanticDeclarationListForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_semanticDeclarationListForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_semanticDeclarationListForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_semanticTypeForGeneration'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_semanticTypeForGeneration::
cPtr_semanticTypeForGeneration (const GGS_unifiedTypeMapProxy & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_semanticDeclarationForGeneration (THERE),
mTypeIndex (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_semanticTypeForGeneration * GGS_semanticTypeForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_semanticTypeForGeneration) ;
    return (cPtr_semanticTypeForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_semanticTypeForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@semanticTypeForGeneration:"
           << mTypeIndex.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_semanticTypeForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_semanticTypeForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_semanticTypeForGeneration (& typeid (cPtr_semanticTypeForGeneration), & typeid (cPtr_semanticDeclarationForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_semanticTypeForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__semanticTypeForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_semanticTypeForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_semanticTypeForGeneration ("semanticTypeForGeneration", true, & kTypeDescriptor_GGS_semanticDeclarationForGeneration) ;

//---------------------------------------------------------------------------*

GGS_semanticTypeForGeneration::
GGS_semanticTypeForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_semanticTypeForGeneration::
GGS_semanticTypeForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_semanticTypeForGeneration GGS_semanticTypeForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_semanticTypeForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_semanticTypeForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_semanticTypeForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_semanticTypeForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_semanticTypeForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapProxy  GGS_semanticTypeForGeneration::
reader_mTypeIndex (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_unifiedTypeMapProxy   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_semanticTypeForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_semanticTypeForGeneration *) mPointer)->mTypeIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_semanticTypeForGeneration::actualTypeName (void) const {
  return "semanticTypeForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__semanticTypeForGeneration ("semanticTypeForGeneration", gClassInfoFor__semanticDeclarationForGeneration, & kTypeDescriptor_GGS_semanticTypeForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_semanticTypeForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_semanticTypeForGeneration * p = NULL ;
    macroMyNew (p, GGS_semanticTypeForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticTypeForGeneration GGS_semanticTypeForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_semanticTypeForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_semanticTypeForGeneration * p = dynamic_cast <const GGS_semanticTypeForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_semanticTypeForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_semanticTypeForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_semanticTypeForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          class 'cPtr_routinePrototypeDeclarationForGeneration'            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_routinePrototypeDeclarationForGeneration::
cPtr_routinePrototypeDeclarationForGeneration (const GGS_string& argument_0,
                                const GGS_formalParameterListForGeneration & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticDeclarationForGeneration (THERE),
mRoutineName (argument_0),
mFormalArgumentList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_routinePrototypeDeclarationForGeneration * GGS_routinePrototypeDeclarationForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_routinePrototypeDeclarationForGeneration) ;
    return (cPtr_routinePrototypeDeclarationForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_routinePrototypeDeclarationForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_routinePrototypeDeclarationForGeneration * ptr = dynamic_cast <const cPtr_routinePrototypeDeclarationForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mRoutineName.operator_isEqual (ptr->mRoutineName).boolValue ()
         && mFormalArgumentList.operator_isEqual (ptr->mFormalArgumentList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_routinePrototypeDeclarationForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@routinePrototypeDeclarationForGeneration:"
           << mRoutineName.reader_description (inIndentation + 1)
           << mFormalArgumentList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_routinePrototypeDeclarationForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_routinePrototypeDeclarationForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_routinePrototypeDeclarationForGeneration (& typeid (cPtr_routinePrototypeDeclarationForGeneration), & typeid (cPtr_semanticDeclarationForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_routinePrototypeDeclarationForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__routinePrototypeDeclarationForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_routinePrototypeDeclarationForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_routinePrototypeDeclarationForGeneration (mRoutineName, mFormalArgumentList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//       GALGAS class 'GGS_routinePrototypeDeclarationForGeneration'         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_routinePrototypeDeclarationForGeneration ("routinePrototypeDeclarationForGeneration", true, & kTypeDescriptor_GGS_semanticDeclarationForGeneration) ;

//---------------------------------------------------------------------------*

GGS_routinePrototypeDeclarationForGeneration::
GGS_routinePrototypeDeclarationForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_routinePrototypeDeclarationForGeneration::
GGS_routinePrototypeDeclarationForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_routinePrototypeDeclarationForGeneration GGS_routinePrototypeDeclarationForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_routinePrototypeDeclarationForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_routinePrototypeDeclarationForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_routinePrototypeDeclarationForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_routinePrototypeDeclarationForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_routinePrototypeDeclarationForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_routinePrototypeDeclarationForGeneration GGS_routinePrototypeDeclarationForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0,
                 const GGS_formalParameterListForGeneration & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_routinePrototypeDeclarationForGeneration result ;
  macroMyNew (result.mPointer, cPtr_routinePrototypeDeclarationForGeneration (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_routinePrototypeDeclarationForGeneration::
reader_mRoutineName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_routinePrototypeDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_routinePrototypeDeclarationForGeneration *) mPointer)->mRoutineName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameterListForGeneration  GGS_routinePrototypeDeclarationForGeneration::
reader_mFormalArgumentList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_formalParameterListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_routinePrototypeDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_routinePrototypeDeclarationForGeneration *) mPointer)->mFormalArgumentList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_routinePrototypeDeclarationForGeneration::actualTypeName (void) const {
  return "routinePrototypeDeclarationForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__routinePrototypeDeclarationForGeneration ("routinePrototypeDeclarationForGeneration", gClassInfoFor__semanticDeclarationForGeneration, & kTypeDescriptor_GGS_routinePrototypeDeclarationForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_routinePrototypeDeclarationForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_routinePrototypeDeclarationForGeneration * p = NULL ;
    macroMyNew (p, GGS_routinePrototypeDeclarationForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_routinePrototypeDeclarationForGeneration GGS_routinePrototypeDeclarationForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_routinePrototypeDeclarationForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_routinePrototypeDeclarationForGeneration * p = dynamic_cast <const GGS_routinePrototypeDeclarationForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_routinePrototypeDeclarationForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_routinePrototypeDeclarationForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_routinePrototypeDeclarationForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_routineImplementationForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_routineImplementationForGeneration::
cPtr_routineImplementationForGeneration (const GGS_string& argument_0,
                                const GGS_formalParameterListForGeneration & argument_1,
                                const GGS_semanticInstructionListForGeneration & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_routinePrototypeDeclarationForGeneration (argument_0, argument_1 COMMA_THERE),
mRoutineInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_routineImplementationForGeneration * GGS_routineImplementationForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_routineImplementationForGeneration) ;
    return (cPtr_routineImplementationForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_routineImplementationForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_routineImplementationForGeneration * ptr = dynamic_cast <const cPtr_routineImplementationForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mRoutineName.operator_isEqual (ptr->mRoutineName).boolValue ()
         && mFormalArgumentList.operator_isEqual (ptr->mFormalArgumentList).boolValue ()
         && mRoutineInstructionList.operator_isEqual (ptr->mRoutineInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_routineImplementationForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@routineImplementationForGeneration:"
           << mRoutineName.reader_description (inIndentation + 1)
           << mFormalArgumentList.reader_description (inIndentation + 1)
           << mRoutineInstructionList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_routineImplementationForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_routineImplementationForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_routineImplementationForGeneration (& typeid (cPtr_routineImplementationForGeneration), & typeid (cPtr_routinePrototypeDeclarationForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_routineImplementationForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__routineImplementationForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_routineImplementationForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_routineImplementationForGeneration (mRoutineName, mFormalArgumentList, mRoutineInstructionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_routineImplementationForGeneration'            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_routineImplementationForGeneration ("routineImplementationForGeneration", true, & kTypeDescriptor_GGS_routinePrototypeDeclarationForGeneration) ;

//---------------------------------------------------------------------------*

GGS_routineImplementationForGeneration::
GGS_routineImplementationForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_routineImplementationForGeneration::
GGS_routineImplementationForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_routineImplementationForGeneration GGS_routineImplementationForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_routineImplementationForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_routineImplementationForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_routineImplementationForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_routineImplementationForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_routineImplementationForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_routineImplementationForGeneration GGS_routineImplementationForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0,
                 const GGS_formalParameterListForGeneration & argument_1,
                 const GGS_semanticInstructionListForGeneration & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_routineImplementationForGeneration result ;
  macroMyNew (result.mPointer, cPtr_routineImplementationForGeneration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration  GGS_routineImplementationForGeneration::
reader_mRoutineInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_routineImplementationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_routineImplementationForGeneration *) mPointer)->mRoutineInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_routineImplementationForGeneration::actualTypeName (void) const {
  return "routineImplementationForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__routineImplementationForGeneration ("routineImplementationForGeneration", gClassInfoFor__routinePrototypeDeclarationForGeneration, & kTypeDescriptor_GGS_routineImplementationForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_routineImplementationForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_routineImplementationForGeneration * p = NULL ;
    macroMyNew (p, GGS_routineImplementationForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_routineImplementationForGeneration GGS_routineImplementationForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_routineImplementationForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_routineImplementationForGeneration * p = dynamic_cast <const GGS_routineImplementationForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_routineImplementationForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_routineImplementationForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_routineImplementationForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'cPtr_functionDeclarationForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_functionDeclarationForGeneration::
cPtr_functionDeclarationForGeneration (const GGS_lstring & argument_0,
                                const GGS_formalInputParameterListForGeneration & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_unifiedTypeMapProxy & argument_3,
                                const GGS_semanticInstructionListForGeneration & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_semanticDeclarationForGeneration (THERE),
mFunctionName (argument_0),
mFormalParameterList (argument_1),
mResultVariableName (argument_2),
mReturnType (argument_3),
mFunctionInstructionList (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_functionDeclarationForGeneration * GGS_functionDeclarationForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_functionDeclarationForGeneration) ;
    return (cPtr_functionDeclarationForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_functionDeclarationForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_functionDeclarationForGeneration * ptr = dynamic_cast <const cPtr_functionDeclarationForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mFunctionName.operator_isEqual (ptr->mFunctionName).boolValue ()
         && mFormalParameterList.operator_isEqual (ptr->mFormalParameterList).boolValue ()
         && mResultVariableName.operator_isEqual (ptr->mResultVariableName).boolValue ()
         && mReturnType.operator_isEqual (ptr->mReturnType).boolValue ()
         && mFunctionInstructionList.operator_isEqual (ptr->mFunctionInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_functionDeclarationForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@functionDeclarationForGeneration:"
           << mFunctionName.reader_description (inIndentation + 1)
           << mFormalParameterList.reader_description (inIndentation + 1)
           << mResultVariableName.reader_description (inIndentation + 1)
           << mReturnType.reader_description (inIndentation + 1)
           << mFunctionInstructionList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_functionDeclarationForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_functionDeclarationForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_functionDeclarationForGeneration (& typeid (cPtr_functionDeclarationForGeneration), & typeid (cPtr_semanticDeclarationForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_functionDeclarationForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__functionDeclarationForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_functionDeclarationForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_functionDeclarationForGeneration (mFunctionName, mFormalParameterList, mResultVariableName, mReturnType, mFunctionInstructionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_functionDeclarationForGeneration'             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_functionDeclarationForGeneration ("functionDeclarationForGeneration", true, & kTypeDescriptor_GGS_semanticDeclarationForGeneration) ;

//---------------------------------------------------------------------------*

GGS_functionDeclarationForGeneration::
GGS_functionDeclarationForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_functionDeclarationForGeneration::
GGS_functionDeclarationForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_functionDeclarationForGeneration GGS_functionDeclarationForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_functionDeclarationForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_functionDeclarationForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_functionDeclarationForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_functionDeclarationForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_functionDeclarationForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_functionDeclarationForGeneration GGS_functionDeclarationForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_formalInputParameterListForGeneration & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_unifiedTypeMapProxy & argument_3,
                 const GGS_semanticInstructionListForGeneration & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_functionDeclarationForGeneration result ;
  macroMyNew (result.mPointer, cPtr_functionDeclarationForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_functionDeclarationForGeneration::
reader_mFunctionName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_functionDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_functionDeclarationForGeneration *) mPointer)->mFunctionName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalInputParameterListForGeneration  GGS_functionDeclarationForGeneration::
reader_mFormalParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_formalInputParameterListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_functionDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_functionDeclarationForGeneration *) mPointer)->mFormalParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_functionDeclarationForGeneration::
reader_mResultVariableName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_functionDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_functionDeclarationForGeneration *) mPointer)->mResultVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapProxy  GGS_functionDeclarationForGeneration::
reader_mReturnType (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_unifiedTypeMapProxy   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_functionDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_functionDeclarationForGeneration *) mPointer)->mReturnType ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration  GGS_functionDeclarationForGeneration::
reader_mFunctionInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_functionDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_functionDeclarationForGeneration *) mPointer)->mFunctionInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_functionDeclarationForGeneration::actualTypeName (void) const {
  return "functionDeclarationForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__functionDeclarationForGeneration ("functionDeclarationForGeneration", gClassInfoFor__semanticDeclarationForGeneration, & kTypeDescriptor_GGS_functionDeclarationForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_functionDeclarationForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_functionDeclarationForGeneration * p = NULL ;
    macroMyNew (p, GGS_functionDeclarationForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_functionDeclarationForGeneration GGS_functionDeclarationForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_functionDeclarationForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_functionDeclarationForGeneration * p = dynamic_cast <const GGS_functionDeclarationForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_functionDeclarationForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_functionDeclarationForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_functionDeclarationForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            class 'cPtr_localVariableDeclarationForGeneration'             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_localVariableDeclarationForGeneration::
cPtr_localVariableDeclarationForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_string& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (THERE),
mVariableType (argument_0),
mCppVariableName (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_localVariableDeclarationForGeneration * GGS_localVariableDeclarationForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_localVariableDeclarationForGeneration) ;
    return (cPtr_localVariableDeclarationForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_localVariableDeclarationForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_localVariableDeclarationForGeneration * ptr = dynamic_cast <const cPtr_localVariableDeclarationForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mVariableType.operator_isEqual (ptr->mVariableType).boolValue ()
         && mCppVariableName.operator_isEqual (ptr->mCppVariableName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_localVariableDeclarationForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@localVariableDeclarationForGeneration:"
           << mVariableType.reader_description (inIndentation + 1)
           << mCppVariableName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_localVariableDeclarationForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_localVariableDeclarationForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_localVariableDeclarationForGeneration (& typeid (cPtr_localVariableDeclarationForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_localVariableDeclarationForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__localVariableDeclarationForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_localVariableDeclarationForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_localVariableDeclarationForGeneration (mVariableType, mCppVariableName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         GALGAS class 'GGS_localVariableDeclarationForGeneration'          *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_localVariableDeclarationForGeneration ("localVariableDeclarationForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_localVariableDeclarationForGeneration::
GGS_localVariableDeclarationForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_localVariableDeclarationForGeneration::
GGS_localVariableDeclarationForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_localVariableDeclarationForGeneration GGS_localVariableDeclarationForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_localVariableDeclarationForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_localVariableDeclarationForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_localVariableDeclarationForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_localVariableDeclarationForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_localVariableDeclarationForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_localVariableDeclarationForGeneration GGS_localVariableDeclarationForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_string& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_localVariableDeclarationForGeneration result ;
  macroMyNew (result.mPointer, cPtr_localVariableDeclarationForGeneration (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapProxy  GGS_localVariableDeclarationForGeneration::
reader_mVariableType (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_unifiedTypeMapProxy   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableDeclarationForGeneration *) mPointer)->mVariableType ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_localVariableDeclarationForGeneration::
reader_mCppVariableName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableDeclarationForGeneration *) mPointer)->mCppVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_localVariableDeclarationForGeneration::actualTypeName (void) const {
  return "localVariableDeclarationForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__localVariableDeclarationForGeneration ("localVariableDeclarationForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_localVariableDeclarationForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_localVariableDeclarationForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_localVariableDeclarationForGeneration * p = NULL ;
    macroMyNew (p, GGS_localVariableDeclarationForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_localVariableDeclarationForGeneration GGS_localVariableDeclarationForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_localVariableDeclarationForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_localVariableDeclarationForGeneration * p = dynamic_cast <const GGS_localVariableDeclarationForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_localVariableDeclarationForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_localVariableDeclarationForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_localVariableDeclarationForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//class 'cPtr_localVariableOrConstantDeclarationWithSourceExpressionForGeneration'*
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_localVariableOrConstantDeclarationWithSourceExpressionForGeneration::
cPtr_localVariableOrConstantDeclarationWithSourceExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_bool& argument_1,
                                const GGS_string& argument_2,
                                const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (THERE),
mTargetType (argument_0),
mIsConstant (argument_1),
mCppVariableName (argument_2),
mSourceExpression (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_localVariableOrConstantDeclarationWithSourceExpressionForGeneration * GGS_localVariableOrConstantDeclarationWithSourceExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_localVariableOrConstantDeclarationWithSourceExpressionForGeneration) ;
    return (cPtr_localVariableOrConstantDeclarationWithSourceExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_localVariableOrConstantDeclarationWithSourceExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_localVariableOrConstantDeclarationWithSourceExpressionForGeneration * ptr = dynamic_cast <const cPtr_localVariableOrConstantDeclarationWithSourceExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTargetType.operator_isEqual (ptr->mTargetType).boolValue ()
         && mIsConstant.operator_isEqual (ptr->mIsConstant).boolValue ()
         && mCppVariableName.operator_isEqual (ptr->mCppVariableName).boolValue ()
         && mSourceExpression.operator_isEqual (ptr->mSourceExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_localVariableOrConstantDeclarationWithSourceExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@localVariableOrConstantDeclarationWithSourceExpressionForGeneration:"
           << mTargetType.reader_description (inIndentation + 1)
           << mIsConstant.reader_description (inIndentation + 1)
           << mCppVariableName.reader_description (inIndentation + 1)
           << mSourceExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_localVariableOrConstantDeclarationWithSourceExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_localVariableOrConstantDeclarationWithSourceExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_localVariableOrConstantDeclarationWithSourceExpressionForGeneration (& typeid (cPtr_localVariableOrConstantDeclarationWithSourceExpressionForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_localVariableOrConstantDeclarationWithSourceExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__localVariableOrConstantDeclarationWithSourceExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_localVariableOrConstantDeclarationWithSourceExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_localVariableOrConstantDeclarationWithSourceExpressionForGeneration (mTargetType, mIsConstant, mCppVariableName, mSourceExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//GALGAS class 'GGS_localVariableOrConstantDeclarationWithSourceExpressionForGeneration'*
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_localVariableOrConstantDeclarationWithSourceExpressionForGeneration ("localVariableOrConstantDeclarationWithSourceExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_localVariableOrConstantDeclarationWithSourceExpressionForGeneration::
GGS_localVariableOrConstantDeclarationWithSourceExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_localVariableOrConstantDeclarationWithSourceExpressionForGeneration::
GGS_localVariableOrConstantDeclarationWithSourceExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_localVariableOrConstantDeclarationWithSourceExpressionForGeneration GGS_localVariableOrConstantDeclarationWithSourceExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_localVariableOrConstantDeclarationWithSourceExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_localVariableOrConstantDeclarationWithSourceExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_localVariableOrConstantDeclarationWithSourceExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_localVariableOrConstantDeclarationWithSourceExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_localVariableOrConstantDeclarationWithSourceExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_localVariableOrConstantDeclarationWithSourceExpressionForGeneration GGS_localVariableOrConstantDeclarationWithSourceExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_bool& argument_1,
                 const GGS_string& argument_2,
                 const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_localVariableOrConstantDeclarationWithSourceExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_localVariableOrConstantDeclarationWithSourceExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapProxy  GGS_localVariableOrConstantDeclarationWithSourceExpressionForGeneration::
reader_mTargetType (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_unifiedTypeMapProxy   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableOrConstantDeclarationWithSourceExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableOrConstantDeclarationWithSourceExpressionForGeneration *) mPointer)->mTargetType ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_localVariableOrConstantDeclarationWithSourceExpressionForGeneration::
reader_mIsConstant (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableOrConstantDeclarationWithSourceExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableOrConstantDeclarationWithSourceExpressionForGeneration *) mPointer)->mIsConstant ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_localVariableOrConstantDeclarationWithSourceExpressionForGeneration::
reader_mCppVariableName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableOrConstantDeclarationWithSourceExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableOrConstantDeclarationWithSourceExpressionForGeneration *) mPointer)->mCppVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_localVariableOrConstantDeclarationWithSourceExpressionForGeneration::
reader_mSourceExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableOrConstantDeclarationWithSourceExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableOrConstantDeclarationWithSourceExpressionForGeneration *) mPointer)->mSourceExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_localVariableOrConstantDeclarationWithSourceExpressionForGeneration::actualTypeName (void) const {
  return "localVariableOrConstantDeclarationWithSourceExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__localVariableOrConstantDeclarationWithSourceExpressionForGeneration ("localVariableOrConstantDeclarationWithSourceExpressionForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_localVariableOrConstantDeclarationWithSourceExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_localVariableOrConstantDeclarationWithSourceExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_localVariableOrConstantDeclarationWithSourceExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_localVariableOrConstantDeclarationWithSourceExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_localVariableOrConstantDeclarationWithSourceExpressionForGeneration GGS_localVariableOrConstantDeclarationWithSourceExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_localVariableOrConstantDeclarationWithSourceExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_localVariableOrConstantDeclarationWithSourceExpressionForGeneration * p = dynamic_cast <const GGS_localVariableOrConstantDeclarationWithSourceExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_localVariableOrConstantDeclarationWithSourceExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_localVariableOrConstantDeclarationWithSourceExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_localVariableOrConstantDeclarationWithSourceExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//class 'cPtr_localVariableOrConstantDeclarationWithConstructorCallForGeneration'*
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_localVariableOrConstantDeclarationWithConstructorCallForGeneration::
cPtr_localVariableOrConstantDeclarationWithConstructorCallForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_bool& argument_1,
                                const GGS_string& argument_2,
                                const GGS_string& argument_3,
                                const GGS_semanticExpressionListForGeneration & argument_4,
                                const GGS_bool& argument_5
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (THERE),
mTargetType (argument_0),
mIsConstant (argument_1),
mCppVariableName (argument_2),
mConstructorName (argument_3),
mConstructorArguments (argument_4),
mHasCompilerArgument (argument_5) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_localVariableOrConstantDeclarationWithConstructorCallForGeneration * GGS_localVariableOrConstantDeclarationWithConstructorCallForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_localVariableOrConstantDeclarationWithConstructorCallForGeneration) ;
    return (cPtr_localVariableOrConstantDeclarationWithConstructorCallForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_localVariableOrConstantDeclarationWithConstructorCallForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_localVariableOrConstantDeclarationWithConstructorCallForGeneration * ptr = dynamic_cast <const cPtr_localVariableOrConstantDeclarationWithConstructorCallForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTargetType.operator_isEqual (ptr->mTargetType).boolValue ()
         && mIsConstant.operator_isEqual (ptr->mIsConstant).boolValue ()
         && mCppVariableName.operator_isEqual (ptr->mCppVariableName).boolValue ()
         && mConstructorName.operator_isEqual (ptr->mConstructorName).boolValue ()
         && mConstructorArguments.operator_isEqual (ptr->mConstructorArguments).boolValue ()
         && mHasCompilerArgument.operator_isEqual (ptr->mHasCompilerArgument).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_localVariableOrConstantDeclarationWithConstructorCallForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@localVariableOrConstantDeclarationWithConstructorCallForGeneration:"
           << mTargetType.reader_description (inIndentation + 1)
           << mIsConstant.reader_description (inIndentation + 1)
           << mCppVariableName.reader_description (inIndentation + 1)
           << mConstructorName.reader_description (inIndentation + 1)
           << mConstructorArguments.reader_description (inIndentation + 1)
           << mHasCompilerArgument.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_localVariableOrConstantDeclarationWithConstructorCallForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_localVariableOrConstantDeclarationWithConstructorCallForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_localVariableOrConstantDeclarationWithConstructorCallForGeneration (& typeid (cPtr_localVariableOrConstantDeclarationWithConstructorCallForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_localVariableOrConstantDeclarationWithConstructorCallForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__localVariableOrConstantDeclarationWithConstructorCallForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_localVariableOrConstantDeclarationWithConstructorCallForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_localVariableOrConstantDeclarationWithConstructorCallForGeneration (mTargetType, mIsConstant, mCppVariableName, mConstructorName, mConstructorArguments, mHasCompilerArgument COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//GALGAS class 'GGS_localVariableOrConstantDeclarationWithConstructorCallForGeneration'*
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_localVariableOrConstantDeclarationWithConstructorCallForGeneration ("localVariableOrConstantDeclarationWithConstructorCallForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_localVariableOrConstantDeclarationWithConstructorCallForGeneration::
GGS_localVariableOrConstantDeclarationWithConstructorCallForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_localVariableOrConstantDeclarationWithConstructorCallForGeneration::
GGS_localVariableOrConstantDeclarationWithConstructorCallForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_localVariableOrConstantDeclarationWithConstructorCallForGeneration GGS_localVariableOrConstantDeclarationWithConstructorCallForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_localVariableOrConstantDeclarationWithConstructorCallForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_localVariableOrConstantDeclarationWithConstructorCallForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_localVariableOrConstantDeclarationWithConstructorCallForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_localVariableOrConstantDeclarationWithConstructorCallForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_localVariableOrConstantDeclarationWithConstructorCallForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_localVariableOrConstantDeclarationWithConstructorCallForGeneration GGS_localVariableOrConstantDeclarationWithConstructorCallForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_bool& argument_1,
                 const GGS_string& argument_2,
                 const GGS_string& argument_3,
                 const GGS_semanticExpressionListForGeneration & argument_4,
                 const GGS_bool& argument_5
                                COMMA_LOCATION_ARGS) {
  GGS_localVariableOrConstantDeclarationWithConstructorCallForGeneration result ;
  macroMyNew (result.mPointer, cPtr_localVariableOrConstantDeclarationWithConstructorCallForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapProxy  GGS_localVariableOrConstantDeclarationWithConstructorCallForGeneration::
reader_mTargetType (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_unifiedTypeMapProxy   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableOrConstantDeclarationWithConstructorCallForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableOrConstantDeclarationWithConstructorCallForGeneration *) mPointer)->mTargetType ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_localVariableOrConstantDeclarationWithConstructorCallForGeneration::
reader_mIsConstant (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableOrConstantDeclarationWithConstructorCallForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableOrConstantDeclarationWithConstructorCallForGeneration *) mPointer)->mIsConstant ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_localVariableOrConstantDeclarationWithConstructorCallForGeneration::
reader_mCppVariableName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableOrConstantDeclarationWithConstructorCallForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableOrConstantDeclarationWithConstructorCallForGeneration *) mPointer)->mCppVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_localVariableOrConstantDeclarationWithConstructorCallForGeneration::
reader_mConstructorName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableOrConstantDeclarationWithConstructorCallForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableOrConstantDeclarationWithConstructorCallForGeneration *) mPointer)->mConstructorName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionListForGeneration  GGS_localVariableOrConstantDeclarationWithConstructorCallForGeneration::
reader_mConstructorArguments (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableOrConstantDeclarationWithConstructorCallForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableOrConstantDeclarationWithConstructorCallForGeneration *) mPointer)->mConstructorArguments ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_localVariableOrConstantDeclarationWithConstructorCallForGeneration::
reader_mHasCompilerArgument (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableOrConstantDeclarationWithConstructorCallForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableOrConstantDeclarationWithConstructorCallForGeneration *) mPointer)->mHasCompilerArgument ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_localVariableOrConstantDeclarationWithConstructorCallForGeneration::actualTypeName (void) const {
  return "localVariableOrConstantDeclarationWithConstructorCallForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__localVariableOrConstantDeclarationWithConstructorCallForGeneration ("localVariableOrConstantDeclarationWithConstructorCallForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_localVariableOrConstantDeclarationWithConstructorCallForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_localVariableOrConstantDeclarationWithConstructorCallForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_localVariableOrConstantDeclarationWithConstructorCallForGeneration * p = NULL ;
    macroMyNew (p, GGS_localVariableOrConstantDeclarationWithConstructorCallForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_localVariableOrConstantDeclarationWithConstructorCallForGeneration GGS_localVariableOrConstantDeclarationWithConstructorCallForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_localVariableOrConstantDeclarationWithConstructorCallForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_localVariableOrConstantDeclarationWithConstructorCallForGeneration * p = dynamic_cast <const GGS_localVariableOrConstantDeclarationWithConstructorCallForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_localVariableOrConstantDeclarationWithConstructorCallForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_localVariableOrConstantDeclarationWithConstructorCallForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_localVariableOrConstantDeclarationWithConstructorCallForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_assignmentInstructionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_assignmentInstructionForGeneration::
cPtr_assignmentInstructionForGeneration (const GGS_string& argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_semanticExpressionForGeneration & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (THERE),
mTargetCppName (argument_0),
mStructAttributeList (argument_1),
mSourceExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_assignmentInstructionForGeneration * GGS_assignmentInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_assignmentInstructionForGeneration) ;
    return (cPtr_assignmentInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_assignmentInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_assignmentInstructionForGeneration * ptr = dynamic_cast <const cPtr_assignmentInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTargetCppName.operator_isEqual (ptr->mTargetCppName).boolValue ()
         && mStructAttributeList.operator_isEqual (ptr->mStructAttributeList).boolValue ()
         && mSourceExpression.operator_isEqual (ptr->mSourceExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_assignmentInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@assignmentInstructionForGeneration:"
           << mTargetCppName.reader_description (inIndentation + 1)
           << mStructAttributeList.reader_description (inIndentation + 1)
           << mSourceExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_assignmentInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_assignmentInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_assignmentInstructionForGeneration (& typeid (cPtr_assignmentInstructionForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_assignmentInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__assignmentInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_assignmentInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_assignmentInstructionForGeneration (mTargetCppName, mStructAttributeList, mSourceExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_assignmentInstructionForGeneration'            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_assignmentInstructionForGeneration ("assignmentInstructionForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_assignmentInstructionForGeneration::
GGS_assignmentInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_assignmentInstructionForGeneration::
GGS_assignmentInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_assignmentInstructionForGeneration GGS_assignmentInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_assignmentInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_assignmentInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_assignmentInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_assignmentInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_assignmentInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_assignmentInstructionForGeneration GGS_assignmentInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0,
                 const GGS_lstringlist & argument_1,
                 const GGS_semanticExpressionForGeneration & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_assignmentInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_assignmentInstructionForGeneration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_assignmentInstructionForGeneration::
reader_mTargetCppName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_assignmentInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_assignmentInstructionForGeneration *) mPointer)->mTargetCppName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_assignmentInstructionForGeneration::
reader_mStructAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_assignmentInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_assignmentInstructionForGeneration *) mPointer)->mStructAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_assignmentInstructionForGeneration::
reader_mSourceExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_assignmentInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_assignmentInstructionForGeneration *) mPointer)->mSourceExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_assignmentInstructionForGeneration::actualTypeName (void) const {
  return "assignmentInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__assignmentInstructionForGeneration ("assignmentInstructionForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_assignmentInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_assignmentInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_assignmentInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_assignmentInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_assignmentInstructionForGeneration GGS_assignmentInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_assignmentInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_assignmentInstructionForGeneration * p = dynamic_cast <const GGS_assignmentInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_assignmentInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_assignmentInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_assignmentInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_dropInstructionForGeneration'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_dropInstructionForGeneration::
cPtr_dropInstructionForGeneration (const GGS_stringlist & argument_0,
                                const GGS_string& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (THERE),
mDropList (argument_0),
mComment (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_dropInstructionForGeneration * GGS_dropInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_dropInstructionForGeneration) ;
    return (cPtr_dropInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_dropInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_dropInstructionForGeneration * ptr = dynamic_cast <const cPtr_dropInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mDropList.operator_isEqual (ptr->mDropList).boolValue ()
         && mComment.operator_isEqual (ptr->mComment).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_dropInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@dropInstructionForGeneration:"
           << mDropList.reader_description (inIndentation + 1)
           << mComment.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_dropInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_dropInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_dropInstructionForGeneration (& typeid (cPtr_dropInstructionForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_dropInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__dropInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_dropInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_dropInstructionForGeneration (mDropList, mComment COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_dropInstructionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_dropInstructionForGeneration ("dropInstructionForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_dropInstructionForGeneration::
GGS_dropInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_dropInstructionForGeneration::
GGS_dropInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_dropInstructionForGeneration GGS_dropInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_dropInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_dropInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_dropInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_dropInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_dropInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_dropInstructionForGeneration GGS_dropInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_stringlist & argument_0,
                 const GGS_string& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_dropInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_dropInstructionForGeneration (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringlist  GGS_dropInstructionForGeneration::
reader_mDropList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_stringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_dropInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_dropInstructionForGeneration *) mPointer)->mDropList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_dropInstructionForGeneration::
reader_mComment (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_dropInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_dropInstructionForGeneration *) mPointer)->mComment ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_dropInstructionForGeneration::actualTypeName (void) const {
  return "dropInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__dropInstructionForGeneration ("dropInstructionForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_dropInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_dropInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_dropInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_dropInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_dropInstructionForGeneration GGS_dropInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_dropInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_dropInstructionForGeneration * p = dynamic_cast <const GGS_dropInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_dropInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_dropInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_dropInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_appendInstructionForGeneration'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_appendInstructionForGeneration::
cPtr_appendInstructionForGeneration (const GGS_location & argument_0,
                                const GGS_string& argument_1,
                                const GGS_lstringlist & argument_2,
                                const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (THERE),
mInstructionLocation (argument_0),
mTargetVariableCppName (argument_1),
mStructAttributeList (argument_2),
mSourceExpression (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_appendInstructionForGeneration * GGS_appendInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_appendInstructionForGeneration) ;
    return (cPtr_appendInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_appendInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_appendInstructionForGeneration * ptr = dynamic_cast <const cPtr_appendInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mTargetVariableCppName.operator_isEqual (ptr->mTargetVariableCppName).boolValue ()
         && mStructAttributeList.operator_isEqual (ptr->mStructAttributeList).boolValue ()
         && mSourceExpression.operator_isEqual (ptr->mSourceExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_appendInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@appendInstructionForGeneration:"
           << mInstructionLocation.reader_description (inIndentation + 1)
           << mTargetVariableCppName.reader_description (inIndentation + 1)
           << mStructAttributeList.reader_description (inIndentation + 1)
           << mSourceExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_appendInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_appendInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_appendInstructionForGeneration (& typeid (cPtr_appendInstructionForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_appendInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__appendInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_appendInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_appendInstructionForGeneration (mInstructionLocation, mTargetVariableCppName, mStructAttributeList, mSourceExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_appendInstructionForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_appendInstructionForGeneration ("appendInstructionForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_appendInstructionForGeneration::
GGS_appendInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_appendInstructionForGeneration::
GGS_appendInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_appendInstructionForGeneration GGS_appendInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_appendInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_appendInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_appendInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_appendInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_appendInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_appendInstructionForGeneration GGS_appendInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_string& argument_1,
                 const GGS_lstringlist & argument_2,
                 const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_appendInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_appendInstructionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_appendInstructionForGeneration::
reader_mInstructionLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_appendInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_appendInstructionForGeneration *) mPointer)->mInstructionLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_appendInstructionForGeneration::
reader_mTargetVariableCppName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_appendInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_appendInstructionForGeneration *) mPointer)->mTargetVariableCppName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_appendInstructionForGeneration::
reader_mStructAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_appendInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_appendInstructionForGeneration *) mPointer)->mStructAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_appendInstructionForGeneration::
reader_mSourceExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_appendInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_appendInstructionForGeneration *) mPointer)->mSourceExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_appendInstructionForGeneration::actualTypeName (void) const {
  return "appendInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__appendInstructionForGeneration ("appendInstructionForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_appendInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_appendInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_appendInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_appendInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_appendInstructionForGeneration GGS_appendInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_appendInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_appendInstructionForGeneration * p = dynamic_cast <const GGS_appendInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_appendInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_appendInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_appendInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_sendInstructionForGeneration'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_sendInstructionForGeneration::
cPtr_sendInstructionForGeneration (const GGS_semanticExpressionForGeneration & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (THERE),
mSourceExpression (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_sendInstructionForGeneration * GGS_sendInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_sendInstructionForGeneration) ;
    return (cPtr_sendInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_sendInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_sendInstructionForGeneration * ptr = dynamic_cast <const cPtr_sendInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mSourceExpression.operator_isEqual (ptr->mSourceExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_sendInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@sendInstructionForGeneration:"
           << mSourceExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_sendInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_sendInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_sendInstructionForGeneration (& typeid (cPtr_sendInstructionForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_sendInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__sendInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_sendInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_sendInstructionForGeneration (mSourceExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_sendInstructionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_sendInstructionForGeneration ("sendInstructionForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_sendInstructionForGeneration::
GGS_sendInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_sendInstructionForGeneration::
GGS_sendInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_sendInstructionForGeneration GGS_sendInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_sendInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_sendInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_sendInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_sendInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_sendInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sendInstructionForGeneration GGS_sendInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_semanticExpressionForGeneration & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_sendInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_sendInstructionForGeneration (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_sendInstructionForGeneration::
reader_mSourceExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sendInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sendInstructionForGeneration *) mPointer)->mSourceExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_sendInstructionForGeneration::actualTypeName (void) const {
  return "sendInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__sendInstructionForGeneration ("sendInstructionForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_sendInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_sendInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_sendInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_sendInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sendInstructionForGeneration GGS_sendInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_sendInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_sendInstructionForGeneration * p = dynamic_cast <const GGS_sendInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_sendInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_sendInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_sendInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//  Element of list '@foreachInstructionEnumeratedObjectListForGeneration'   *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_foreachInstructionEnumeratedObjectListForGeneration::
elementOf_GGS_foreachInstructionEnumeratedObjectListForGeneration (const GGS_bool& argument_0,
                                const GGS_semanticExpressionForGeneration & argument_1,
                                const GGS_string& argument_2
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mIsAscending (argument_0),
mEnumeratedExpression (argument_1),
mEnumeratorCppName (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_foreachInstructionEnumeratedObjectListForGeneration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_foreachInstructionEnumeratedObjectListForGeneration * ptr = dynamic_cast <const elementOf_GGS_foreachInstructionEnumeratedObjectListForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mIsAscending.operator_isEqual (ptr->mIsAscending).boolValue ()
         && mEnumeratedExpression.operator_isEqual (ptr->mEnumeratedExpression).boolValue ()
         && mEnumeratorCppName.operator_isEqual (ptr->mEnumeratorCppName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_foreachInstructionEnumeratedObjectListForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mIsAscending.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEnumeratedExpression.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEnumeratorCppName.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//       List '@foreachInstructionEnumeratedObjectListForGeneration'         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_foreachInstructionEnumeratedObjectListForGeneration ("foreachInstructionEnumeratedObjectListForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListForGeneration::
internalAppendValues (const GGS_bool& argument_0,
                    const GGS_semanticExpressionForGeneration & argument_1,
                    const GGS_string& argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListForGeneration::
internalPrependValues (const GGS_bool& argument_0,
                    const GGS_semanticExpressionForGeneration & argument_1,
                    const GGS_string& argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListForGeneration::
addAssign_operation (const GGS_bool& argument_0,
                                const GGS_semanticExpressionForGeneration & argument_1,
                                const GGS_string& argument_2) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectListForGeneration GGS_foreachInstructionEnumeratedObjectListForGeneration::
operator_concat (const GGS_foreachInstructionEnumeratedObjectListForGeneration & inOperand) const {
  GGS_foreachInstructionEnumeratedObjectListForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListForGeneration::
dotAssign_operation (const GGS_foreachInstructionEnumeratedObjectListForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_foreachInstructionEnumeratedObjectListForGeneration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_bool p_0 = p->mIsAscending ;
          GGS_semanticExpressionForGeneration  p_1 = p->mEnumeratedExpression ;
          GGS_string p_2 = p->mEnumeratorCppName ;
          internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListForGeneration::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_bool& argument_0,
                     const GGS_semanticExpressionForGeneration & argument_1,
                     const GGS_string& argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListForGeneration::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mIsAscending,
                                ptr->mEnumeratedExpression,
                                ptr->mEnumeratorCppName
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectListForGeneration  GGS_foreachInstructionEnumeratedObjectListForGeneration::
constructor_emptyList (void) {
  GGS_foreachInstructionEnumeratedObjectListForGeneration result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectListForGeneration  GGS_foreachInstructionEnumeratedObjectListForGeneration::
constructor_listWithValue (const GGS_bool& argument_0,
                                const GGS_semanticExpressionForGeneration & argument_1,
                                const GGS_string& argument_2) {
  GGS_foreachInstructionEnumeratedObjectListForGeneration result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListForGeneration::
internalSubListWithRange (GGS_foreachInstructionEnumeratedObjectListForGeneration & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mIsAscending, ptr->mEnumeratedExpression, ptr->mEnumeratorCppName) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectListForGeneration GGS_foreachInstructionEnumeratedObjectListForGeneration::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_foreachInstructionEnumeratedObjectListForGeneration result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectListForGeneration GGS_foreachInstructionEnumeratedObjectListForGeneration::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_foreachInstructionEnumeratedObjectListForGeneration result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_foreachInstructionEnumeratedObjectListForGeneration::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@foreachInstructionEnumeratedObjectListForGeneration", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListForGeneration::
method_first (C_Compiler & inLexique,
              GGS_bool& _out_0,
              GGS_semanticExpressionForGeneration & _out_1,
              GGS_string& _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mIsAscending ;
    _out_1 = ptr->mEnumeratedExpression ;
    _out_2 = ptr->mEnumeratorCppName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListForGeneration::
method_last (C_Compiler & inLexique,
             GGS_bool& _out_0,
             GGS_semanticExpressionForGeneration & _out_1,
             GGS_string& _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mIsAscending ;
    _out_1 = ptr->mEnumeratedExpression ;
    _out_2 = ptr->mEnumeratorCppName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListForGeneration::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_bool& _out_0,
                 GGS_semanticExpressionForGeneration & _out_1,
                 GGS_string& _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mIsAscending ;
    _out_1 = ptr->mEnumeratedExpression ;
    _out_2 = ptr->mEnumeratorCppName ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListForGeneration::
modifier_popLast (C_Compiler & inLexique,
                GGS_bool& _out_0,
                GGS_semanticExpressionForGeneration & _out_1,
                GGS_string& _out_2
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mIsAscending ;
    _out_1 = ptr->mEnumeratedExpression ;
    _out_2 = ptr->mEnumeratorCppName ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_bool GGS_foreachInstructionEnumeratedObjectListForGeneration::
reader_mIsAscendingAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mIsAscending ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_foreachInstructionEnumeratedObjectListForGeneration::
reader_mEnumeratedExpressionAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mEnumeratedExpression ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_foreachInstructionEnumeratedObjectListForGeneration::
reader_mEnumeratorCppNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_string result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mEnumeratorCppName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListForGeneration::
modifier_setMIsAscendingAtIndex (C_Compiler & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mIsAscending = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListForGeneration::
modifier_setMEnumeratedExpressionAtIndex (C_Compiler & inLexique,
                              const GGS_semanticExpressionForGeneration  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mEnumeratedExpression = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListForGeneration::
modifier_setMEnumeratorCppNameAtIndex (C_Compiler & inLexique,
                              const GGS_string & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mEnumeratorCppName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_foreachInstructionEnumeratedObjectListForGeneration::cEnumerator::_mIsAscending (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mIsAscending ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticExpressionForGeneration  & GGS_foreachInstructionEnumeratedObjectListForGeneration::cEnumerator::_mEnumeratedExpression (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mEnumeratedExpression ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_foreachInstructionEnumeratedObjectListForGeneration::cEnumerator::_mEnumeratorCppName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mEnumeratorCppName ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_foreachInstructionEnumeratedObjectListForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_foreachInstructionEnumeratedObjectListForGeneration * p = NULL ;
    macroMyNew (p, GGS_foreachInstructionEnumeratedObjectListForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectListForGeneration GGS_foreachInstructionEnumeratedObjectListForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_foreachInstructionEnumeratedObjectListForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_foreachInstructionEnumeratedObjectListForGeneration * p = dynamic_cast <const GGS_foreachInstructionEnumeratedObjectListForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_foreachInstructionEnumeratedObjectListForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_foreachInstructionEnumeratedObjectListForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_foreachInstructionEnumeratedObjectListForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_foreachInstructionForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_foreachInstructionForGeneration::
cPtr_foreachInstructionForGeneration (const GGS_location & argument_0,
                                const GGS_foreachInstructionEnumeratedObjectListForGeneration & argument_1,
                                const GGS_string& argument_2,
                                const GGS_semanticExpressionForGeneration & argument_3,
                                const GGS_semanticInstructionListForGeneration & argument_4,
                                const GGS_semanticInstructionListForGeneration & argument_5,
                                const GGS_semanticInstructionListForGeneration & argument_6,
                                const GGS_semanticInstructionListForGeneration & argument_7
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (THERE),
mInstructionLocation (argument_0),
mEnumeratedObjectList (argument_1),
mIndexVariableCppName (argument_2),
mWhileExpression (argument_3),
mBeforeInstructionList (argument_4),
mBetweenInstructionList (argument_5),
mDoInstructionList (argument_6),
mAfterInstructionList (argument_7) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_foreachInstructionForGeneration * GGS_foreachInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_foreachInstructionForGeneration) ;
    return (cPtr_foreachInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_foreachInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_foreachInstructionForGeneration * ptr = dynamic_cast <const cPtr_foreachInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mEnumeratedObjectList.operator_isEqual (ptr->mEnumeratedObjectList).boolValue ()
         && mIndexVariableCppName.operator_isEqual (ptr->mIndexVariableCppName).boolValue ()
         && mWhileExpression.operator_isEqual (ptr->mWhileExpression).boolValue ()
         && mBeforeInstructionList.operator_isEqual (ptr->mBeforeInstructionList).boolValue ()
         && mBetweenInstructionList.operator_isEqual (ptr->mBetweenInstructionList).boolValue ()
         && mDoInstructionList.operator_isEqual (ptr->mDoInstructionList).boolValue ()
         && mAfterInstructionList.operator_isEqual (ptr->mAfterInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_foreachInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@foreachInstructionForGeneration:"
           << mInstructionLocation.reader_description (inIndentation + 1)
           << mEnumeratedObjectList.reader_description (inIndentation + 1)
           << mIndexVariableCppName.reader_description (inIndentation + 1)
           << mWhileExpression.reader_description (inIndentation + 1)
           << mBeforeInstructionList.reader_description (inIndentation + 1)
           << mBetweenInstructionList.reader_description (inIndentation + 1)
           << mDoInstructionList.reader_description (inIndentation + 1)
           << mAfterInstructionList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_foreachInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_foreachInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_foreachInstructionForGeneration (& typeid (cPtr_foreachInstructionForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_foreachInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__foreachInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_foreachInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_foreachInstructionForGeneration (mInstructionLocation, mEnumeratedObjectList, mIndexVariableCppName, mWhileExpression, mBeforeInstructionList, mBetweenInstructionList, mDoInstructionList, mAfterInstructionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_foreachInstructionForGeneration'             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_foreachInstructionForGeneration ("foreachInstructionForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_foreachInstructionForGeneration::
GGS_foreachInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionForGeneration::
GGS_foreachInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_foreachInstructionForGeneration GGS_foreachInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_foreachInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_foreachInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_foreachInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_foreachInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_foreachInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionForGeneration GGS_foreachInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_foreachInstructionEnumeratedObjectListForGeneration & argument_1,
                 const GGS_string& argument_2,
                 const GGS_semanticExpressionForGeneration & argument_3,
                 const GGS_semanticInstructionListForGeneration & argument_4,
                 const GGS_semanticInstructionListForGeneration & argument_5,
                 const GGS_semanticInstructionListForGeneration & argument_6,
                 const GGS_semanticInstructionListForGeneration & argument_7
                                COMMA_LOCATION_ARGS) {
  GGS_foreachInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_foreachInstructionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_foreachInstructionForGeneration::
reader_mInstructionLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstructionForGeneration *) mPointer)->mInstructionLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectListForGeneration  GGS_foreachInstructionForGeneration::
reader_mEnumeratedObjectList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_foreachInstructionEnumeratedObjectListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstructionForGeneration *) mPointer)->mEnumeratedObjectList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_foreachInstructionForGeneration::
reader_mIndexVariableCppName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstructionForGeneration *) mPointer)->mIndexVariableCppName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_foreachInstructionForGeneration::
reader_mWhileExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstructionForGeneration *) mPointer)->mWhileExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration  GGS_foreachInstructionForGeneration::
reader_mBeforeInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstructionForGeneration *) mPointer)->mBeforeInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration  GGS_foreachInstructionForGeneration::
reader_mBetweenInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstructionForGeneration *) mPointer)->mBetweenInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration  GGS_foreachInstructionForGeneration::
reader_mDoInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstructionForGeneration *) mPointer)->mDoInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration  GGS_foreachInstructionForGeneration::
reader_mAfterInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstructionForGeneration *) mPointer)->mAfterInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_foreachInstructionForGeneration::actualTypeName (void) const {
  return "foreachInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__foreachInstructionForGeneration ("foreachInstructionForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_foreachInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_foreachInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_foreachInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_foreachInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionForGeneration GGS_foreachInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_foreachInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_foreachInstructionForGeneration * p = dynamic_cast <const GGS_foreachInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_foreachInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_foreachInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_foreachInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_ifInstructionForGeneration'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ifInstructionForGeneration::
cPtr_ifInstructionForGeneration (const GGS_location & argument_0,
                                const GGS_semanticExpressionForGeneration & argument_1,
                                const GGS_semanticInstructionListForGeneration & argument_2,
                                const GGS_semanticInstructionListForGeneration & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (THERE),
mInstructionLocation (argument_0),
mIFexpression (argument_1),
m_then_instructionList (argument_2),
m_else_instructionList (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ifInstructionForGeneration * GGS_ifInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_ifInstructionForGeneration) ;
    return (cPtr_ifInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ifInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ifInstructionForGeneration * ptr = dynamic_cast <const cPtr_ifInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mIFexpression.operator_isEqual (ptr->mIFexpression).boolValue ()
         && m_then_instructionList.operator_isEqual (ptr->m_then_instructionList).boolValue ()
         && m_else_instructionList.operator_isEqual (ptr->m_else_instructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ifInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@ifInstructionForGeneration:"
           << mInstructionLocation.reader_description (inIndentation + 1)
           << mIFexpression.reader_description (inIndentation + 1)
           << m_then_instructionList.reader_description (inIndentation + 1)
           << m_else_instructionList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ifInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ifInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ifInstructionForGeneration (& typeid (cPtr_ifInstructionForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_ifInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__ifInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_ifInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_ifInstructionForGeneration (mInstructionLocation, mIFexpression, m_then_instructionList, m_else_instructionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_ifInstructionForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_ifInstructionForGeneration ("ifInstructionForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_ifInstructionForGeneration::
GGS_ifInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ifInstructionForGeneration::
GGS_ifInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_ifInstructionForGeneration GGS_ifInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ifInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ifInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_ifInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_ifInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ifInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ifInstructionForGeneration GGS_ifInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionForGeneration & argument_1,
                 const GGS_semanticInstructionListForGeneration & argument_2,
                 const GGS_semanticInstructionListForGeneration & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_ifInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_ifInstructionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_ifInstructionForGeneration::
reader_mInstructionLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ifInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ifInstructionForGeneration *) mPointer)->mInstructionLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_ifInstructionForGeneration::
reader_mIFexpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ifInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ifInstructionForGeneration *) mPointer)->mIFexpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration  GGS_ifInstructionForGeneration::
reader_m_then_instructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ifInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ifInstructionForGeneration *) mPointer)->m_then_instructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration  GGS_ifInstructionForGeneration::
reader_m_else_instructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ifInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ifInstructionForGeneration *) mPointer)->m_else_instructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ifInstructionForGeneration::actualTypeName (void) const {
  return "ifInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__ifInstructionForGeneration ("ifInstructionForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_ifInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_ifInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_ifInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_ifInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ifInstructionForGeneration GGS_ifInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_ifInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_ifInstructionForGeneration * p = dynamic_cast <const GGS_ifInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_ifInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_ifInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_ifInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_errorInstructionForGeneration'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_errorInstructionForGeneration::
cPtr_errorInstructionForGeneration (const GGS_location & argument_0,
                                const GGS_semanticExpressionForGeneration & argument_1,
                                const GGS_bool& argument_2,
                                const GGS_semanticExpressionForGeneration & argument_3,
                                const GGS_stringlist & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (THERE),
mInstructionLocation (argument_0),
mReceiverExpression (argument_1),
mUseLocationReader (argument_2),
mErrorExpression (argument_3),
mBuiltVariableCppNameList (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_errorInstructionForGeneration * GGS_errorInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_errorInstructionForGeneration) ;
    return (cPtr_errorInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_errorInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_errorInstructionForGeneration * ptr = dynamic_cast <const cPtr_errorInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mReceiverExpression.operator_isEqual (ptr->mReceiverExpression).boolValue ()
         && mUseLocationReader.operator_isEqual (ptr->mUseLocationReader).boolValue ()
         && mErrorExpression.operator_isEqual (ptr->mErrorExpression).boolValue ()
         && mBuiltVariableCppNameList.operator_isEqual (ptr->mBuiltVariableCppNameList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_errorInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@errorInstructionForGeneration:"
           << mInstructionLocation.reader_description (inIndentation + 1)
           << mReceiverExpression.reader_description (inIndentation + 1)
           << mUseLocationReader.reader_description (inIndentation + 1)
           << mErrorExpression.reader_description (inIndentation + 1)
           << mBuiltVariableCppNameList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_errorInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_errorInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_errorInstructionForGeneration (& typeid (cPtr_errorInstructionForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_errorInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__errorInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_errorInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_errorInstructionForGeneration (mInstructionLocation, mReceiverExpression, mUseLocationReader, mErrorExpression, mBuiltVariableCppNameList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_errorInstructionForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_errorInstructionForGeneration ("errorInstructionForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_errorInstructionForGeneration::
GGS_errorInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_errorInstructionForGeneration::
GGS_errorInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_errorInstructionForGeneration GGS_errorInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_errorInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_errorInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_errorInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_errorInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_errorInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_errorInstructionForGeneration GGS_errorInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionForGeneration & argument_1,
                 const GGS_bool& argument_2,
                 const GGS_semanticExpressionForGeneration & argument_3,
                 const GGS_stringlist & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_errorInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_errorInstructionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_errorInstructionForGeneration::
reader_mInstructionLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_errorInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_errorInstructionForGeneration *) mPointer)->mInstructionLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_errorInstructionForGeneration::
reader_mReceiverExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_errorInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_errorInstructionForGeneration *) mPointer)->mReceiverExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_errorInstructionForGeneration::
reader_mUseLocationReader (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_errorInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_errorInstructionForGeneration *) mPointer)->mUseLocationReader ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_errorInstructionForGeneration::
reader_mErrorExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_errorInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_errorInstructionForGeneration *) mPointer)->mErrorExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringlist  GGS_errorInstructionForGeneration::
reader_mBuiltVariableCppNameList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_stringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_errorInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_errorInstructionForGeneration *) mPointer)->mBuiltVariableCppNameList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_errorInstructionForGeneration::actualTypeName (void) const {
  return "errorInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__errorInstructionForGeneration ("errorInstructionForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_errorInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_errorInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_errorInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_errorInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_errorInstructionForGeneration GGS_errorInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_errorInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_errorInstructionForGeneration * p = dynamic_cast <const GGS_errorInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_errorInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_errorInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_errorInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_warningInstructionForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_warningInstructionForGeneration::
cPtr_warningInstructionForGeneration (const GGS_location & argument_0,
                                const GGS_semanticExpressionForGeneration & argument_1,
                                const GGS_bool& argument_2,
                                const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (THERE),
mInstructionLocation (argument_0),
mReceiverExpression (argument_1),
mUseLocationReader (argument_2),
mWarningExpression (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_warningInstructionForGeneration * GGS_warningInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_warningInstructionForGeneration) ;
    return (cPtr_warningInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_warningInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_warningInstructionForGeneration * ptr = dynamic_cast <const cPtr_warningInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mReceiverExpression.operator_isEqual (ptr->mReceiverExpression).boolValue ()
         && mUseLocationReader.operator_isEqual (ptr->mUseLocationReader).boolValue ()
         && mWarningExpression.operator_isEqual (ptr->mWarningExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_warningInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@warningInstructionForGeneration:"
           << mInstructionLocation.reader_description (inIndentation + 1)
           << mReceiverExpression.reader_description (inIndentation + 1)
           << mUseLocationReader.reader_description (inIndentation + 1)
           << mWarningExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_warningInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_warningInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_warningInstructionForGeneration (& typeid (cPtr_warningInstructionForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_warningInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__warningInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_warningInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_warningInstructionForGeneration (mInstructionLocation, mReceiverExpression, mUseLocationReader, mWarningExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_warningInstructionForGeneration'             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_warningInstructionForGeneration ("warningInstructionForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_warningInstructionForGeneration::
GGS_warningInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_warningInstructionForGeneration::
GGS_warningInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_warningInstructionForGeneration GGS_warningInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_warningInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_warningInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_warningInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_warningInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_warningInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_warningInstructionForGeneration GGS_warningInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionForGeneration & argument_1,
                 const GGS_bool& argument_2,
                 const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_warningInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_warningInstructionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_warningInstructionForGeneration::
reader_mInstructionLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_warningInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_warningInstructionForGeneration *) mPointer)->mInstructionLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_warningInstructionForGeneration::
reader_mReceiverExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_warningInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_warningInstructionForGeneration *) mPointer)->mReceiverExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_warningInstructionForGeneration::
reader_mUseLocationReader (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_warningInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_warningInstructionForGeneration *) mPointer)->mUseLocationReader ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_warningInstructionForGeneration::
reader_mWarningExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_warningInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_warningInstructionForGeneration *) mPointer)->mWarningExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_warningInstructionForGeneration::actualTypeName (void) const {
  return "warningInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__warningInstructionForGeneration ("warningInstructionForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_warningInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_warningInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_warningInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_warningInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_warningInstructionForGeneration GGS_warningInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_warningInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_warningInstructionForGeneration * p = dynamic_cast <const GGS_warningInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_warningInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_warningInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_warningInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_routineCallInstructionForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_routineCallInstructionForGeneration::
cPtr_routineCallInstructionForGeneration (const GGS_lstring & argument_0,
                                const GGS_actualParameterListForGeneration & argument_1,
                                const GGS_temporaryInputVariableForRoutineInvocationForGeneration & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (THERE),
mRoutineName (argument_0),
mActualParameterList (argument_1),
mTemporaryInputVariableList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_routineCallInstructionForGeneration * GGS_routineCallInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_routineCallInstructionForGeneration) ;
    return (cPtr_routineCallInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_routineCallInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_routineCallInstructionForGeneration * ptr = dynamic_cast <const cPtr_routineCallInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mRoutineName.operator_isEqual (ptr->mRoutineName).boolValue ()
         && mActualParameterList.operator_isEqual (ptr->mActualParameterList).boolValue ()
         && mTemporaryInputVariableList.operator_isEqual (ptr->mTemporaryInputVariableList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_routineCallInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@routineCallInstructionForGeneration:"
           << mRoutineName.reader_description (inIndentation + 1)
           << mActualParameterList.reader_description (inIndentation + 1)
           << mTemporaryInputVariableList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_routineCallInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_routineCallInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_routineCallInstructionForGeneration (& typeid (cPtr_routineCallInstructionForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_routineCallInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__routineCallInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_routineCallInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_routineCallInstructionForGeneration (mRoutineName, mActualParameterList, mTemporaryInputVariableList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_routineCallInstructionForGeneration'           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_routineCallInstructionForGeneration ("routineCallInstructionForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_routineCallInstructionForGeneration::
GGS_routineCallInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_routineCallInstructionForGeneration::
GGS_routineCallInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_routineCallInstructionForGeneration GGS_routineCallInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_routineCallInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_routineCallInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_routineCallInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_routineCallInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_routineCallInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_routineCallInstructionForGeneration GGS_routineCallInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_actualParameterListForGeneration & argument_1,
                 const GGS_temporaryInputVariableForRoutineInvocationForGeneration & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_routineCallInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_routineCallInstructionForGeneration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_routineCallInstructionForGeneration::
reader_mRoutineName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_routineCallInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_routineCallInstructionForGeneration *) mPointer)->mRoutineName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameterListForGeneration  GGS_routineCallInstructionForGeneration::
reader_mActualParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_actualParameterListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_routineCallInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_routineCallInstructionForGeneration *) mPointer)->mActualParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_temporaryInputVariableForRoutineInvocationForGeneration  GGS_routineCallInstructionForGeneration::
reader_mTemporaryInputVariableList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_temporaryInputVariableForRoutineInvocationForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_routineCallInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_routineCallInstructionForGeneration *) mPointer)->mTemporaryInputVariableList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_routineCallInstructionForGeneration::actualTypeName (void) const {
  return "routineCallInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__routineCallInstructionForGeneration ("routineCallInstructionForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_routineCallInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_routineCallInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_routineCallInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_routineCallInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_routineCallInstructionForGeneration GGS_routineCallInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_routineCallInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_routineCallInstructionForGeneration * p = dynamic_cast <const GGS_routineCallInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_routineCallInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_routineCallInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_routineCallInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_typeMethodInstructionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeMethodInstructionForGeneration::
cPtr_typeMethodInstructionForGeneration (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_actualParameterListForGeneration & argument_2,
                                const GGS_bool& argument_3,
                                const GGS_temporaryInputVariableForRoutineInvocationForGeneration & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (THERE),
mTypeName (argument_0),
mMethodName (argument_1),
mActualParameterList (argument_2),
mHasCompilerArgument (argument_3),
mTemporaryInputVariableList (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeMethodInstructionForGeneration * GGS_typeMethodInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeMethodInstructionForGeneration) ;
    return (cPtr_typeMethodInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeMethodInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeMethodInstructionForGeneration * ptr = dynamic_cast <const cPtr_typeMethodInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTypeName.operator_isEqual (ptr->mTypeName).boolValue ()
         && mMethodName.operator_isEqual (ptr->mMethodName).boolValue ()
         && mActualParameterList.operator_isEqual (ptr->mActualParameterList).boolValue ()
         && mHasCompilerArgument.operator_isEqual (ptr->mHasCompilerArgument).boolValue ()
         && mTemporaryInputVariableList.operator_isEqual (ptr->mTemporaryInputVariableList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeMethodInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeMethodInstructionForGeneration:"
           << mTypeName.reader_description (inIndentation + 1)
           << mMethodName.reader_description (inIndentation + 1)
           << mActualParameterList.reader_description (inIndentation + 1)
           << mHasCompilerArgument.reader_description (inIndentation + 1)
           << mTemporaryInputVariableList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeMethodInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeMethodInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeMethodInstructionForGeneration (& typeid (cPtr_typeMethodInstructionForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeMethodInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__typeMethodInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeMethodInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeMethodInstructionForGeneration (mTypeName, mMethodName, mActualParameterList, mHasCompilerArgument, mTemporaryInputVariableList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_typeMethodInstructionForGeneration'            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeMethodInstructionForGeneration ("typeMethodInstructionForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_typeMethodInstructionForGeneration::
GGS_typeMethodInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeMethodInstructionForGeneration::
GGS_typeMethodInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeMethodInstructionForGeneration GGS_typeMethodInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeMethodInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeMethodInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_typeMethodInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeMethodInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeMethodInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeMethodInstructionForGeneration GGS_typeMethodInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_actualParameterListForGeneration & argument_2,
                 const GGS_bool& argument_3,
                 const GGS_temporaryInputVariableForRoutineInvocationForGeneration & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_typeMethodInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_typeMethodInstructionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeMethodInstructionForGeneration::
reader_mTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMethodInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMethodInstructionForGeneration *) mPointer)->mTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeMethodInstructionForGeneration::
reader_mMethodName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMethodInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMethodInstructionForGeneration *) mPointer)->mMethodName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameterListForGeneration  GGS_typeMethodInstructionForGeneration::
reader_mActualParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_actualParameterListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMethodInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMethodInstructionForGeneration *) mPointer)->mActualParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeMethodInstructionForGeneration::
reader_mHasCompilerArgument (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMethodInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMethodInstructionForGeneration *) mPointer)->mHasCompilerArgument ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_temporaryInputVariableForRoutineInvocationForGeneration  GGS_typeMethodInstructionForGeneration::
reader_mTemporaryInputVariableList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_temporaryInputVariableForRoutineInvocationForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMethodInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMethodInstructionForGeneration *) mPointer)->mTemporaryInputVariableList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeMethodInstructionForGeneration::actualTypeName (void) const {
  return "typeMethodInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeMethodInstructionForGeneration ("typeMethodInstructionForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_typeMethodInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeMethodInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeMethodInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_typeMethodInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeMethodInstructionForGeneration GGS_typeMethodInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeMethodInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeMethodInstructionForGeneration * p = dynamic_cast <const GGS_typeMethodInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeMethodInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeMethodInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeMethodInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_methodCallInstructionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_methodCallInstructionForGeneration::
cPtr_methodCallInstructionForGeneration (const GGS_location & argument_0,
                                const GGS_semanticExpressionForGeneration & argument_1,
                                const GGS_string& argument_2,
                                const GGS_actualParameterListForGeneration & argument_3,
                                const GGS_bool& argument_4,
                                const GGS_temporaryInputVariableForRoutineInvocationForGeneration & argument_5
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (THERE),
mInstructionLocation (argument_0),
mReceiverExpression (argument_1),
mMethodName (argument_2),
mActualParameterList (argument_3),
mHasCompilerArgument (argument_4),
mTemporaryInputVariableList (argument_5) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_methodCallInstructionForGeneration * GGS_methodCallInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_methodCallInstructionForGeneration) ;
    return (cPtr_methodCallInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_methodCallInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_methodCallInstructionForGeneration * ptr = dynamic_cast <const cPtr_methodCallInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mReceiverExpression.operator_isEqual (ptr->mReceiverExpression).boolValue ()
         && mMethodName.operator_isEqual (ptr->mMethodName).boolValue ()
         && mActualParameterList.operator_isEqual (ptr->mActualParameterList).boolValue ()
         && mHasCompilerArgument.operator_isEqual (ptr->mHasCompilerArgument).boolValue ()
         && mTemporaryInputVariableList.operator_isEqual (ptr->mTemporaryInputVariableList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_methodCallInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@methodCallInstructionForGeneration:"
           << mInstructionLocation.reader_description (inIndentation + 1)
           << mReceiverExpression.reader_description (inIndentation + 1)
           << mMethodName.reader_description (inIndentation + 1)
           << mActualParameterList.reader_description (inIndentation + 1)
           << mHasCompilerArgument.reader_description (inIndentation + 1)
           << mTemporaryInputVariableList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_methodCallInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_methodCallInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_methodCallInstructionForGeneration (& typeid (cPtr_methodCallInstructionForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_methodCallInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__methodCallInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_methodCallInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_methodCallInstructionForGeneration (mInstructionLocation, mReceiverExpression, mMethodName, mActualParameterList, mHasCompilerArgument, mTemporaryInputVariableList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_methodCallInstructionForGeneration'            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_methodCallInstructionForGeneration ("methodCallInstructionForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_methodCallInstructionForGeneration::
GGS_methodCallInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_methodCallInstructionForGeneration::
GGS_methodCallInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_methodCallInstructionForGeneration GGS_methodCallInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_methodCallInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_methodCallInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_methodCallInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_methodCallInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_methodCallInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_methodCallInstructionForGeneration GGS_methodCallInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionForGeneration & argument_1,
                 const GGS_string& argument_2,
                 const GGS_actualParameterListForGeneration & argument_3,
                 const GGS_bool& argument_4,
                 const GGS_temporaryInputVariableForRoutineInvocationForGeneration & argument_5
                                COMMA_LOCATION_ARGS) {
  GGS_methodCallInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_methodCallInstructionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_methodCallInstructionForGeneration::
reader_mInstructionLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_methodCallInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_methodCallInstructionForGeneration *) mPointer)->mInstructionLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_methodCallInstructionForGeneration::
reader_mReceiverExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_methodCallInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_methodCallInstructionForGeneration *) mPointer)->mReceiverExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_methodCallInstructionForGeneration::
reader_mMethodName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_methodCallInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_methodCallInstructionForGeneration *) mPointer)->mMethodName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameterListForGeneration  GGS_methodCallInstructionForGeneration::
reader_mActualParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_actualParameterListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_methodCallInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_methodCallInstructionForGeneration *) mPointer)->mActualParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_methodCallInstructionForGeneration::
reader_mHasCompilerArgument (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_methodCallInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_methodCallInstructionForGeneration *) mPointer)->mHasCompilerArgument ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_temporaryInputVariableForRoutineInvocationForGeneration  GGS_methodCallInstructionForGeneration::
reader_mTemporaryInputVariableList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_temporaryInputVariableForRoutineInvocationForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_methodCallInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_methodCallInstructionForGeneration *) mPointer)->mTemporaryInputVariableList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_methodCallInstructionForGeneration::actualTypeName (void) const {
  return "methodCallInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__methodCallInstructionForGeneration ("methodCallInstructionForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_methodCallInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_methodCallInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_methodCallInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_methodCallInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_methodCallInstructionForGeneration GGS_methodCallInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_methodCallInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_methodCallInstructionForGeneration * p = dynamic_cast <const GGS_methodCallInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_methodCallInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_methodCallInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_methodCallInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            class 'cPtr_modifierCallInstructionForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_modifierCallInstructionForGeneration::
cPtr_modifierCallInstructionForGeneration (const GGS_string& argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_actualParameterListForGeneration & argument_3,
                                const GGS_bool& argument_4,
                                const GGS_temporaryInputVariableForRoutineInvocationForGeneration & argument_5
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (THERE),
mReceiverCppName (argument_0),
mReceiverStructAttributes (argument_1),
mModifierName (argument_2),
mActualParameterList (argument_3),
mHasCompilerArgument (argument_4),
mTemporaryInputVariableList (argument_5) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_modifierCallInstructionForGeneration * GGS_modifierCallInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_modifierCallInstructionForGeneration) ;
    return (cPtr_modifierCallInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_modifierCallInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_modifierCallInstructionForGeneration * ptr = dynamic_cast <const cPtr_modifierCallInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mReceiverCppName.operator_isEqual (ptr->mReceiverCppName).boolValue ()
         && mReceiverStructAttributes.operator_isEqual (ptr->mReceiverStructAttributes).boolValue ()
         && mModifierName.operator_isEqual (ptr->mModifierName).boolValue ()
         && mActualParameterList.operator_isEqual (ptr->mActualParameterList).boolValue ()
         && mHasCompilerArgument.operator_isEqual (ptr->mHasCompilerArgument).boolValue ()
         && mTemporaryInputVariableList.operator_isEqual (ptr->mTemporaryInputVariableList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_modifierCallInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@modifierCallInstructionForGeneration:"
           << mReceiverCppName.reader_description (inIndentation + 1)
           << mReceiverStructAttributes.reader_description (inIndentation + 1)
           << mModifierName.reader_description (inIndentation + 1)
           << mActualParameterList.reader_description (inIndentation + 1)
           << mHasCompilerArgument.reader_description (inIndentation + 1)
           << mTemporaryInputVariableList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_modifierCallInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_modifierCallInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_modifierCallInstructionForGeneration (& typeid (cPtr_modifierCallInstructionForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_modifierCallInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__modifierCallInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_modifierCallInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_modifierCallInstructionForGeneration (mReceiverCppName, mReceiverStructAttributes, mModifierName, mActualParameterList, mHasCompilerArgument, mTemporaryInputVariableList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         GALGAS class 'GGS_modifierCallInstructionForGeneration'           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_modifierCallInstructionForGeneration ("modifierCallInstructionForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_modifierCallInstructionForGeneration::
GGS_modifierCallInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_modifierCallInstructionForGeneration::
GGS_modifierCallInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_modifierCallInstructionForGeneration GGS_modifierCallInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_modifierCallInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_modifierCallInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_modifierCallInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_modifierCallInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_modifierCallInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_modifierCallInstructionForGeneration GGS_modifierCallInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0,
                 const GGS_lstringlist & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_actualParameterListForGeneration & argument_3,
                 const GGS_bool& argument_4,
                 const GGS_temporaryInputVariableForRoutineInvocationForGeneration & argument_5
                                COMMA_LOCATION_ARGS) {
  GGS_modifierCallInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_modifierCallInstructionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_modifierCallInstructionForGeneration::
reader_mReceiverCppName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_modifierCallInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_modifierCallInstructionForGeneration *) mPointer)->mReceiverCppName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_modifierCallInstructionForGeneration::
reader_mReceiverStructAttributes (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_modifierCallInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_modifierCallInstructionForGeneration *) mPointer)->mReceiverStructAttributes ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_modifierCallInstructionForGeneration::
reader_mModifierName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_modifierCallInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_modifierCallInstructionForGeneration *) mPointer)->mModifierName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameterListForGeneration  GGS_modifierCallInstructionForGeneration::
reader_mActualParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_actualParameterListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_modifierCallInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_modifierCallInstructionForGeneration *) mPointer)->mActualParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_modifierCallInstructionForGeneration::
reader_mHasCompilerArgument (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_modifierCallInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_modifierCallInstructionForGeneration *) mPointer)->mHasCompilerArgument ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_temporaryInputVariableForRoutineInvocationForGeneration  GGS_modifierCallInstructionForGeneration::
reader_mTemporaryInputVariableList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_temporaryInputVariableForRoutineInvocationForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_modifierCallInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_modifierCallInstructionForGeneration *) mPointer)->mTemporaryInputVariableList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_modifierCallInstructionForGeneration::actualTypeName (void) const {
  return "modifierCallInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__modifierCallInstructionForGeneration ("modifierCallInstructionForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_modifierCallInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_modifierCallInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_modifierCallInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_modifierCallInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_modifierCallInstructionForGeneration GGS_modifierCallInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_modifierCallInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_modifierCallInstructionForGeneration * p = dynamic_cast <const GGS_modifierCallInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_modifierCallInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_modifierCallInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_modifierCallInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        Element of list '@castInstructionBranchListForGeneration'          *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_castInstructionBranchListForGeneration::
elementOf_GGS_castInstructionBranchListForGeneration (const GGS_bool& argument_0,
                                const GGS_unifiedTypeMapProxy & argument_1,
                                const GGS_semanticInstructionListForGeneration & argument_2
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mUseKindOfClass (argument_0),
mType (argument_1),
mInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_castInstructionBranchListForGeneration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_castInstructionBranchListForGeneration * ptr = dynamic_cast <const elementOf_GGS_castInstructionBranchListForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mUseKindOfClass.operator_isEqual (ptr->mUseKindOfClass).boolValue ()
         && mType.operator_isEqual (ptr->mType).boolValue ()
         && mInstructionList.operator_isEqual (ptr->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_castInstructionBranchListForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mUseKindOfClass.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mType.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              List '@castInstructionBranchListForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_castInstructionBranchListForGeneration ("castInstructionBranchListForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListForGeneration::
internalAppendValues (const GGS_bool& argument_0,
                    const GGS_unifiedTypeMapProxy & argument_1,
                    const GGS_semanticInstructionListForGeneration & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListForGeneration::
internalPrependValues (const GGS_bool& argument_0,
                    const GGS_unifiedTypeMapProxy & argument_1,
                    const GGS_semanticInstructionListForGeneration & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListForGeneration::
addAssign_operation (const GGS_bool& argument_0,
                                const GGS_unifiedTypeMapProxy & argument_1,
                                const GGS_semanticInstructionListForGeneration & argument_2) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_castInstructionBranchListForGeneration GGS_castInstructionBranchListForGeneration::
operator_concat (const GGS_castInstructionBranchListForGeneration & inOperand) const {
  GGS_castInstructionBranchListForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListForGeneration::
dotAssign_operation (const GGS_castInstructionBranchListForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_castInstructionBranchListForGeneration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_bool p_0 = p->mUseKindOfClass ;
          GGS_unifiedTypeMapProxy  p_1 = p->mType ;
          GGS_semanticInstructionListForGeneration  p_2 = p->mInstructionList ;
          internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListForGeneration::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_bool& argument_0,
                     const GGS_unifiedTypeMapProxy & argument_1,
                     const GGS_semanticInstructionListForGeneration & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListForGeneration::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mUseKindOfClass,
                                ptr->mType,
                                ptr->mInstructionList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_castInstructionBranchListForGeneration  GGS_castInstructionBranchListForGeneration::
constructor_emptyList (void) {
  GGS_castInstructionBranchListForGeneration result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_castInstructionBranchListForGeneration  GGS_castInstructionBranchListForGeneration::
constructor_listWithValue (const GGS_bool& argument_0,
                                const GGS_unifiedTypeMapProxy & argument_1,
                                const GGS_semanticInstructionListForGeneration & argument_2) {
  GGS_castInstructionBranchListForGeneration result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListForGeneration::
internalSubListWithRange (GGS_castInstructionBranchListForGeneration & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mUseKindOfClass, ptr->mType, ptr->mInstructionList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_castInstructionBranchListForGeneration GGS_castInstructionBranchListForGeneration::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_castInstructionBranchListForGeneration result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_castInstructionBranchListForGeneration GGS_castInstructionBranchListForGeneration::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_castInstructionBranchListForGeneration result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_castInstructionBranchListForGeneration::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@castInstructionBranchListForGeneration", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListForGeneration::
method_first (C_Compiler & inLexique,
              GGS_bool& _out_0,
              GGS_unifiedTypeMapProxy & _out_1,
              GGS_semanticInstructionListForGeneration & _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mUseKindOfClass ;
    _out_1 = ptr->mType ;
    _out_2 = ptr->mInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListForGeneration::
method_last (C_Compiler & inLexique,
             GGS_bool& _out_0,
             GGS_unifiedTypeMapProxy & _out_1,
             GGS_semanticInstructionListForGeneration & _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mUseKindOfClass ;
    _out_1 = ptr->mType ;
    _out_2 = ptr->mInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListForGeneration::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_bool& _out_0,
                 GGS_unifiedTypeMapProxy & _out_1,
                 GGS_semanticInstructionListForGeneration & _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mUseKindOfClass ;
    _out_1 = ptr->mType ;
    _out_2 = ptr->mInstructionList ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListForGeneration::
modifier_popLast (C_Compiler & inLexique,
                GGS_bool& _out_0,
                GGS_unifiedTypeMapProxy & _out_1,
                GGS_semanticInstructionListForGeneration & _out_2
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mUseKindOfClass ;
    _out_1 = ptr->mType ;
    _out_2 = ptr->mInstructionList ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_bool GGS_castInstructionBranchListForGeneration::
reader_mUseKindOfClassAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mUseKindOfClass ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapProxy  GGS_castInstructionBranchListForGeneration::
reader_mTypeAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_unifiedTypeMapProxy  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mType ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration  GGS_castInstructionBranchListForGeneration::
reader_mInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticInstructionListForGeneration  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListForGeneration::
modifier_setMUseKindOfClassAtIndex (C_Compiler & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mUseKindOfClass = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListForGeneration::
modifier_setMTypeAtIndex (C_Compiler & inLexique,
                              const GGS_unifiedTypeMapProxy  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mType = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListForGeneration::
modifier_setMInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_semanticInstructionListForGeneration  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_castInstructionBranchListForGeneration::cEnumerator::_mUseKindOfClass (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mUseKindOfClass ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_unifiedTypeMapProxy  & GGS_castInstructionBranchListForGeneration::cEnumerator::_mType (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mType ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticInstructionListForGeneration  & GGS_castInstructionBranchListForGeneration::cEnumerator::_mInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mInstructionList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_castInstructionBranchListForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_castInstructionBranchListForGeneration * p = NULL ;
    macroMyNew (p, GGS_castInstructionBranchListForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_castInstructionBranchListForGeneration GGS_castInstructionBranchListForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_castInstructionBranchListForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_castInstructionBranchListForGeneration * p = dynamic_cast <const GGS_castInstructionBranchListForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_castInstructionBranchListForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_castInstructionBranchListForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_castInstructionBranchListForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           class 'cPtr_structuredCastInstructionForGeneration'             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_structuredCastInstructionForGeneration::
cPtr_structuredCastInstructionForGeneration (const GGS_semanticExpressionForGeneration & argument_0,
                                const GGS_castInstructionBranchListForGeneration & argument_1,
                                const GGS_semanticInstructionListForGeneration & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (THERE),
mExpression (argument_0),
mCastBranchList (argument_1),
mElseInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_structuredCastInstructionForGeneration * GGS_structuredCastInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_structuredCastInstructionForGeneration) ;
    return (cPtr_structuredCastInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_structuredCastInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_structuredCastInstructionForGeneration * ptr = dynamic_cast <const cPtr_structuredCastInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mExpression.operator_isEqual (ptr->mExpression).boolValue ()
         && mCastBranchList.operator_isEqual (ptr->mCastBranchList).boolValue ()
         && mElseInstructionList.operator_isEqual (ptr->mElseInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_structuredCastInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@structuredCastInstructionForGeneration:"
           << mExpression.reader_description (inIndentation + 1)
           << mCastBranchList.reader_description (inIndentation + 1)
           << mElseInstructionList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_structuredCastInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_structuredCastInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_structuredCastInstructionForGeneration (& typeid (cPtr_structuredCastInstructionForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_structuredCastInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__structuredCastInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_structuredCastInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_structuredCastInstructionForGeneration (mExpression, mCastBranchList, mElseInstructionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        GALGAS class 'GGS_structuredCastInstructionForGeneration'          *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_structuredCastInstructionForGeneration ("structuredCastInstructionForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_structuredCastInstructionForGeneration::
GGS_structuredCastInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_structuredCastInstructionForGeneration::
GGS_structuredCastInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_structuredCastInstructionForGeneration GGS_structuredCastInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_structuredCastInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_structuredCastInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_structuredCastInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_structuredCastInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_structuredCastInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_structuredCastInstructionForGeneration GGS_structuredCastInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_semanticExpressionForGeneration & argument_0,
                 const GGS_castInstructionBranchListForGeneration & argument_1,
                 const GGS_semanticInstructionListForGeneration & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_structuredCastInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_structuredCastInstructionForGeneration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_structuredCastInstructionForGeneration::
reader_mExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_structuredCastInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_structuredCastInstructionForGeneration *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_castInstructionBranchListForGeneration  GGS_structuredCastInstructionForGeneration::
reader_mCastBranchList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_castInstructionBranchListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_structuredCastInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_structuredCastInstructionForGeneration *) mPointer)->mCastBranchList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration  GGS_structuredCastInstructionForGeneration::
reader_mElseInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_structuredCastInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_structuredCastInstructionForGeneration *) mPointer)->mElseInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_structuredCastInstructionForGeneration::actualTypeName (void) const {
  return "structuredCastInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__structuredCastInstructionForGeneration ("structuredCastInstructionForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_structuredCastInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_structuredCastInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_structuredCastInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_structuredCastInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_structuredCastInstructionForGeneration GGS_structuredCastInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_structuredCastInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_structuredCastInstructionForGeneration * p = dynamic_cast <const GGS_structuredCastInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_structuredCastInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_structuredCastInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_structuredCastInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'cPtr_addAssignInstructionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_addAssignInstructionForGeneration::
cPtr_addAssignInstructionForGeneration (const GGS_string& argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_semanticExpressionListForGeneration & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (THERE),
mReceiverCppName (argument_0),
mStructAttributeList (argument_1),
mExpressionList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_addAssignInstructionForGeneration * GGS_addAssignInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_addAssignInstructionForGeneration) ;
    return (cPtr_addAssignInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_addAssignInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_addAssignInstructionForGeneration * ptr = dynamic_cast <const cPtr_addAssignInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mReceiverCppName.operator_isEqual (ptr->mReceiverCppName).boolValue ()
         && mStructAttributeList.operator_isEqual (ptr->mStructAttributeList).boolValue ()
         && mExpressionList.operator_isEqual (ptr->mExpressionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_addAssignInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@addAssignInstructionForGeneration:"
           << mReceiverCppName.reader_description (inIndentation + 1)
           << mStructAttributeList.reader_description (inIndentation + 1)
           << mExpressionList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_addAssignInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_addAssignInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_addAssignInstructionForGeneration (& typeid (cPtr_addAssignInstructionForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_addAssignInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__addAssignInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_addAssignInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_addAssignInstructionForGeneration (mReceiverCppName, mStructAttributeList, mExpressionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_addAssignInstructionForGeneration'            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_addAssignInstructionForGeneration ("addAssignInstructionForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_addAssignInstructionForGeneration::
GGS_addAssignInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_addAssignInstructionForGeneration::
GGS_addAssignInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_addAssignInstructionForGeneration GGS_addAssignInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_addAssignInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_addAssignInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_addAssignInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_addAssignInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_addAssignInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_addAssignInstructionForGeneration GGS_addAssignInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0,
                 const GGS_lstringlist & argument_1,
                 const GGS_semanticExpressionListForGeneration & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_addAssignInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_addAssignInstructionForGeneration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_addAssignInstructionForGeneration::
reader_mReceiverCppName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_addAssignInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_addAssignInstructionForGeneration *) mPointer)->mReceiverCppName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_addAssignInstructionForGeneration::
reader_mStructAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_addAssignInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_addAssignInstructionForGeneration *) mPointer)->mStructAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionListForGeneration  GGS_addAssignInstructionForGeneration::
reader_mExpressionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_addAssignInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_addAssignInstructionForGeneration *) mPointer)->mExpressionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_addAssignInstructionForGeneration::actualTypeName (void) const {
  return "addAssignInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__addAssignInstructionForGeneration ("addAssignInstructionForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_addAssignInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_addAssignInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_addAssignInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_addAssignInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_addAssignInstructionForGeneration GGS_addAssignInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_addAssignInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_addAssignInstructionForGeneration * p = dynamic_cast <const GGS_addAssignInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_addAssignInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_addAssignInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_addAssignInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'cPtr_incrementInstructionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_incrementInstructionForGeneration::
cPtr_incrementInstructionForGeneration (const GGS_string& argument_0,
                                const GGS_lstringlist & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (THERE),
mReceiverCppName (argument_0),
mStructAttributeList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_incrementInstructionForGeneration * GGS_incrementInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_incrementInstructionForGeneration) ;
    return (cPtr_incrementInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_incrementInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_incrementInstructionForGeneration * ptr = dynamic_cast <const cPtr_incrementInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mReceiverCppName.operator_isEqual (ptr->mReceiverCppName).boolValue ()
         && mStructAttributeList.operator_isEqual (ptr->mStructAttributeList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_incrementInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@incrementInstructionForGeneration:"
           << mReceiverCppName.reader_description (inIndentation + 1)
           << mStructAttributeList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_incrementInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_incrementInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_incrementInstructionForGeneration (& typeid (cPtr_incrementInstructionForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_incrementInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__incrementInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_incrementInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_incrementInstructionForGeneration (mReceiverCppName, mStructAttributeList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_incrementInstructionForGeneration'            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_incrementInstructionForGeneration ("incrementInstructionForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_incrementInstructionForGeneration::
GGS_incrementInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_incrementInstructionForGeneration::
GGS_incrementInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_incrementInstructionForGeneration GGS_incrementInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_incrementInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_incrementInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_incrementInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_incrementInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_incrementInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_incrementInstructionForGeneration GGS_incrementInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0,
                 const GGS_lstringlist & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_incrementInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_incrementInstructionForGeneration (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_incrementInstructionForGeneration::
reader_mReceiverCppName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_incrementInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_incrementInstructionForGeneration *) mPointer)->mReceiverCppName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_incrementInstructionForGeneration::
reader_mStructAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_incrementInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_incrementInstructionForGeneration *) mPointer)->mStructAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_incrementInstructionForGeneration::actualTypeName (void) const {
  return "incrementInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__incrementInstructionForGeneration ("incrementInstructionForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_incrementInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_incrementInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_incrementInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_incrementInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_incrementInstructionForGeneration GGS_incrementInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_incrementInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_incrementInstructionForGeneration * p = dynamic_cast <const GGS_incrementInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_incrementInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_incrementInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_incrementInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'cPtr_decrementInstructionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_decrementInstructionForGeneration::
cPtr_decrementInstructionForGeneration (const GGS_string& argument_0,
                                const GGS_lstringlist & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (THERE),
mReceiverCppName (argument_0),
mStructAttributeList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_decrementInstructionForGeneration * GGS_decrementInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_decrementInstructionForGeneration) ;
    return (cPtr_decrementInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_decrementInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_decrementInstructionForGeneration * ptr = dynamic_cast <const cPtr_decrementInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mReceiverCppName.operator_isEqual (ptr->mReceiverCppName).boolValue ()
         && mStructAttributeList.operator_isEqual (ptr->mStructAttributeList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_decrementInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@decrementInstructionForGeneration:"
           << mReceiverCppName.reader_description (inIndentation + 1)
           << mStructAttributeList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_decrementInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_decrementInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_decrementInstructionForGeneration (& typeid (cPtr_decrementInstructionForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_decrementInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__decrementInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_decrementInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_decrementInstructionForGeneration (mReceiverCppName, mStructAttributeList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_decrementInstructionForGeneration'            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_decrementInstructionForGeneration ("decrementInstructionForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_decrementInstructionForGeneration::
GGS_decrementInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_decrementInstructionForGeneration::
GGS_decrementInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_decrementInstructionForGeneration GGS_decrementInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_decrementInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_decrementInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_decrementInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_decrementInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_decrementInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_decrementInstructionForGeneration GGS_decrementInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0,
                 const GGS_lstringlist & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_decrementInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_decrementInstructionForGeneration (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_decrementInstructionForGeneration::
reader_mReceiverCppName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_decrementInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_decrementInstructionForGeneration *) mPointer)->mReceiverCppName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_decrementInstructionForGeneration::
reader_mStructAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_decrementInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_decrementInstructionForGeneration *) mPointer)->mStructAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_decrementInstructionForGeneration::actualTypeName (void) const {
  return "decrementInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__decrementInstructionForGeneration ("decrementInstructionForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_decrementInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_decrementInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_decrementInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_decrementInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_decrementInstructionForGeneration GGS_decrementInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_decrementInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_decrementInstructionForGeneration * p = dynamic_cast <const GGS_decrementInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_decrementInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_decrementInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_decrementInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_loopInstructionForGeneration'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_loopInstructionForGeneration::
cPtr_loopInstructionForGeneration (const GGS_location & argument_0,
                                const GGS_semanticExpressionForGeneration & argument_1,
                                const GGS_semanticInstructionListForGeneration & argument_2,
                                const GGS_semanticExpressionForGeneration & argument_3,
                                const GGS_semanticInstructionListForGeneration & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (THERE),
mInstructionLocation (argument_0),
mVariantExpression (argument_1),
mFirstInstructions (argument_2),
mLoopExpression (argument_3),
mSecondInstructions (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_loopInstructionForGeneration * GGS_loopInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_loopInstructionForGeneration) ;
    return (cPtr_loopInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_loopInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_loopInstructionForGeneration * ptr = dynamic_cast <const cPtr_loopInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mVariantExpression.operator_isEqual (ptr->mVariantExpression).boolValue ()
         && mFirstInstructions.operator_isEqual (ptr->mFirstInstructions).boolValue ()
         && mLoopExpression.operator_isEqual (ptr->mLoopExpression).boolValue ()
         && mSecondInstructions.operator_isEqual (ptr->mSecondInstructions).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_loopInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@loopInstructionForGeneration:"
           << mInstructionLocation.reader_description (inIndentation + 1)
           << mVariantExpression.reader_description (inIndentation + 1)
           << mFirstInstructions.reader_description (inIndentation + 1)
           << mLoopExpression.reader_description (inIndentation + 1)
           << mSecondInstructions.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_loopInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_loopInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_loopInstructionForGeneration (& typeid (cPtr_loopInstructionForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_loopInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__loopInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_loopInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_loopInstructionForGeneration (mInstructionLocation, mVariantExpression, mFirstInstructions, mLoopExpression, mSecondInstructions COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_loopInstructionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_loopInstructionForGeneration ("loopInstructionForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_loopInstructionForGeneration::
GGS_loopInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_loopInstructionForGeneration::
GGS_loopInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_loopInstructionForGeneration GGS_loopInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_loopInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_loopInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_loopInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_loopInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_loopInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_loopInstructionForGeneration GGS_loopInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionForGeneration & argument_1,
                 const GGS_semanticInstructionListForGeneration & argument_2,
                 const GGS_semanticExpressionForGeneration & argument_3,
                 const GGS_semanticInstructionListForGeneration & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_loopInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_loopInstructionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_loopInstructionForGeneration::
reader_mInstructionLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_loopInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_loopInstructionForGeneration *) mPointer)->mInstructionLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_loopInstructionForGeneration::
reader_mVariantExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_loopInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_loopInstructionForGeneration *) mPointer)->mVariantExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration  GGS_loopInstructionForGeneration::
reader_mFirstInstructions (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_loopInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_loopInstructionForGeneration *) mPointer)->mFirstInstructions ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_loopInstructionForGeneration::
reader_mLoopExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_loopInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_loopInstructionForGeneration *) mPointer)->mLoopExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration  GGS_loopInstructionForGeneration::
reader_mSecondInstructions (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_loopInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_loopInstructionForGeneration *) mPointer)->mSecondInstructions ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_loopInstructionForGeneration::actualTypeName (void) const {
  return "loopInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__loopInstructionForGeneration ("loopInstructionForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_loopInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_loopInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_loopInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_loopInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_loopInstructionForGeneration GGS_loopInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_loopInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_loopInstructionForGeneration * p = dynamic_cast <const GGS_loopInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_loopInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_loopInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_loopInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_messageInstructionForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_messageInstructionForGeneration::
cPtr_messageInstructionForGeneration (const GGS_semanticExpressionForGeneration & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (THERE),
mExpression (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_messageInstructionForGeneration * GGS_messageInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_messageInstructionForGeneration) ;
    return (cPtr_messageInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_messageInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_messageInstructionForGeneration * ptr = dynamic_cast <const cPtr_messageInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mExpression.operator_isEqual (ptr->mExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_messageInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@messageInstructionForGeneration:"
           << mExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_messageInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_messageInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_messageInstructionForGeneration (& typeid (cPtr_messageInstructionForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_messageInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__messageInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_messageInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_messageInstructionForGeneration (mExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_messageInstructionForGeneration'             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_messageInstructionForGeneration ("messageInstructionForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_messageInstructionForGeneration::
GGS_messageInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_messageInstructionForGeneration::
GGS_messageInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_messageInstructionForGeneration GGS_messageInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_messageInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_messageInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_messageInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_messageInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_messageInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_messageInstructionForGeneration GGS_messageInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_semanticExpressionForGeneration & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_messageInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_messageInstructionForGeneration (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_messageInstructionForGeneration::
reader_mExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_messageInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_messageInstructionForGeneration *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_messageInstructionForGeneration::actualTypeName (void) const {
  return "messageInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__messageInstructionForGeneration ("messageInstructionForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_messageInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_messageInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_messageInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_messageInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_messageInstructionForGeneration GGS_messageInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_messageInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_messageInstructionForGeneration * p = dynamic_cast <const GGS_messageInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_messageInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_messageInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_messageInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_logInstructionForGeneration'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_logInstructionForGeneration::
cPtr_logInstructionForGeneration (const GGS_lstring & argument_0,
                                const GGS_semanticExpressionForGeneration & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (THERE),
mLogMessage (argument_0),
mLogExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_logInstructionForGeneration * GGS_logInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_logInstructionForGeneration) ;
    return (cPtr_logInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_logInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_logInstructionForGeneration * ptr = dynamic_cast <const cPtr_logInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLogMessage.operator_isEqual (ptr->mLogMessage).boolValue ()
         && mLogExpression.operator_isEqual (ptr->mLogExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_logInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@logInstructionForGeneration:"
           << mLogMessage.reader_description (inIndentation + 1)
           << mLogExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_logInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_logInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_logInstructionForGeneration (& typeid (cPtr_logInstructionForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_logInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__logInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_logInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_logInstructionForGeneration (mLogMessage, mLogExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_logInstructionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_logInstructionForGeneration ("logInstructionForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_logInstructionForGeneration::
GGS_logInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_logInstructionForGeneration::
GGS_logInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_logInstructionForGeneration GGS_logInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_logInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_logInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_logInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_logInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_logInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_logInstructionForGeneration GGS_logInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_semanticExpressionForGeneration & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_logInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_logInstructionForGeneration (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_logInstructionForGeneration::
reader_mLogMessage (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_logInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_logInstructionForGeneration *) mPointer)->mLogMessage ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_logInstructionForGeneration::
reader_mLogExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_logInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_logInstructionForGeneration *) mPointer)->mLogExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_logInstructionForGeneration::actualTypeName (void) const {
  return "logInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__logInstructionForGeneration ("logInstructionForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_logInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_logInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_logInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_logInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_logInstructionForGeneration GGS_logInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_logInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_logInstructionForGeneration * p = dynamic_cast <const GGS_logInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_logInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_logInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_logInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_grammarInstructionForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_grammarInstructionForGeneration::
cPtr_grammarInstructionForGeneration (const GGS_string& argument_0,
                                const GGS_string& argument_1,
                                const GGS_semanticExpressionForGeneration & argument_2,
                                const GGS_bool& argument_3,
                                const GGS_actualParameterListForGeneration & argument_4,
                                const GGS_temporaryInputVariableForRoutineInvocationForGeneration & argument_5
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (THERE),
mGrammarComponentName (argument_0),
mLabelName (argument_1),
mSourceExpression (argument_2),
mSourceExpressionIsFile (argument_3),
mActualParameterList (argument_4),
mTemporaryInputVariableList (argument_5) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_grammarInstructionForGeneration * GGS_grammarInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_grammarInstructionForGeneration) ;
    return (cPtr_grammarInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_grammarInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_grammarInstructionForGeneration * ptr = dynamic_cast <const cPtr_grammarInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mGrammarComponentName.operator_isEqual (ptr->mGrammarComponentName).boolValue ()
         && mLabelName.operator_isEqual (ptr->mLabelName).boolValue ()
         && mSourceExpression.operator_isEqual (ptr->mSourceExpression).boolValue ()
         && mSourceExpressionIsFile.operator_isEqual (ptr->mSourceExpressionIsFile).boolValue ()
         && mActualParameterList.operator_isEqual (ptr->mActualParameterList).boolValue ()
         && mTemporaryInputVariableList.operator_isEqual (ptr->mTemporaryInputVariableList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_grammarInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@grammarInstructionForGeneration:"
           << mGrammarComponentName.reader_description (inIndentation + 1)
           << mLabelName.reader_description (inIndentation + 1)
           << mSourceExpression.reader_description (inIndentation + 1)
           << mSourceExpressionIsFile.reader_description (inIndentation + 1)
           << mActualParameterList.reader_description (inIndentation + 1)
           << mTemporaryInputVariableList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_grammarInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_grammarInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_grammarInstructionForGeneration (& typeid (cPtr_grammarInstructionForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_grammarInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__grammarInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_grammarInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_grammarInstructionForGeneration (mGrammarComponentName, mLabelName, mSourceExpression, mSourceExpressionIsFile, mActualParameterList, mTemporaryInputVariableList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_grammarInstructionForGeneration'             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_grammarInstructionForGeneration ("grammarInstructionForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_grammarInstructionForGeneration::
GGS_grammarInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_grammarInstructionForGeneration::
GGS_grammarInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_grammarInstructionForGeneration GGS_grammarInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_grammarInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_grammarInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_grammarInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_grammarInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_grammarInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_grammarInstructionForGeneration GGS_grammarInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0,
                 const GGS_string& argument_1,
                 const GGS_semanticExpressionForGeneration & argument_2,
                 const GGS_bool& argument_3,
                 const GGS_actualParameterListForGeneration & argument_4,
                 const GGS_temporaryInputVariableForRoutineInvocationForGeneration & argument_5
                                COMMA_LOCATION_ARGS) {
  GGS_grammarInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_grammarInstructionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_grammarInstructionForGeneration::
reader_mGrammarComponentName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_grammarInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_grammarInstructionForGeneration *) mPointer)->mGrammarComponentName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_grammarInstructionForGeneration::
reader_mLabelName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_grammarInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_grammarInstructionForGeneration *) mPointer)->mLabelName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_grammarInstructionForGeneration::
reader_mSourceExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_grammarInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_grammarInstructionForGeneration *) mPointer)->mSourceExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_grammarInstructionForGeneration::
reader_mSourceExpressionIsFile (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_grammarInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_grammarInstructionForGeneration *) mPointer)->mSourceExpressionIsFile ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameterListForGeneration  GGS_grammarInstructionForGeneration::
reader_mActualParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_actualParameterListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_grammarInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_grammarInstructionForGeneration *) mPointer)->mActualParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_temporaryInputVariableForRoutineInvocationForGeneration  GGS_grammarInstructionForGeneration::
reader_mTemporaryInputVariableList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_temporaryInputVariableForRoutineInvocationForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_grammarInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_grammarInstructionForGeneration *) mPointer)->mTemporaryInputVariableList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_grammarInstructionForGeneration::actualTypeName (void) const {
  return "grammarInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__grammarInstructionForGeneration ("grammarInstructionForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_grammarInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_grammarInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_grammarInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_grammarInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_grammarInstructionForGeneration GGS_grammarInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_grammarInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_grammarInstructionForGeneration * p = dynamic_cast <const GGS_grammarInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_grammarInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_grammarInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_grammarInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            class 'cPtr_readWriteWithInstructionForGeneration'             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_readWriteWithInstructionForGeneration::
cPtr_readWriteWithInstructionForGeneration (const GGS_string& argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_string& argument_2,
                                const GGS_semanticExpressionForGeneration & argument_3,
                                const GGS_semanticInstructionListForGeneration & argument_4,
                                const GGS_semanticInstructionListForGeneration & argument_5
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (THERE),
mReceiverVariableCppName (argument_0),
mStructAttributeList (argument_1),
mAccessName (argument_2),
mKeyExpression (argument_3),
mDoBranchInstructions (argument_4),
mElseBranchInstructions (argument_5) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_readWriteWithInstructionForGeneration * GGS_readWriteWithInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_readWriteWithInstructionForGeneration) ;
    return (cPtr_readWriteWithInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_readWriteWithInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_readWriteWithInstructionForGeneration * ptr = dynamic_cast <const cPtr_readWriteWithInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mReceiverVariableCppName.operator_isEqual (ptr->mReceiverVariableCppName).boolValue ()
         && mStructAttributeList.operator_isEqual (ptr->mStructAttributeList).boolValue ()
         && mAccessName.operator_isEqual (ptr->mAccessName).boolValue ()
         && mKeyExpression.operator_isEqual (ptr->mKeyExpression).boolValue ()
         && mDoBranchInstructions.operator_isEqual (ptr->mDoBranchInstructions).boolValue ()
         && mElseBranchInstructions.operator_isEqual (ptr->mElseBranchInstructions).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_readWriteWithInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@readWriteWithInstructionForGeneration:"
           << mReceiverVariableCppName.reader_description (inIndentation + 1)
           << mStructAttributeList.reader_description (inIndentation + 1)
           << mAccessName.reader_description (inIndentation + 1)
           << mKeyExpression.reader_description (inIndentation + 1)
           << mDoBranchInstructions.reader_description (inIndentation + 1)
           << mElseBranchInstructions.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_readWriteWithInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_readWriteWithInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_readWriteWithInstructionForGeneration (& typeid (cPtr_readWriteWithInstructionForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_readWriteWithInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__readWriteWithInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_readWriteWithInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_readWriteWithInstructionForGeneration (mReceiverVariableCppName, mStructAttributeList, mAccessName, mKeyExpression, mDoBranchInstructions, mElseBranchInstructions COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         GALGAS class 'GGS_readWriteWithInstructionForGeneration'          *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_readWriteWithInstructionForGeneration ("readWriteWithInstructionForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_readWriteWithInstructionForGeneration::
GGS_readWriteWithInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_readWriteWithInstructionForGeneration::
GGS_readWriteWithInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_readWriteWithInstructionForGeneration GGS_readWriteWithInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_readWriteWithInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_readWriteWithInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_readWriteWithInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_readWriteWithInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_readWriteWithInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_readWriteWithInstructionForGeneration GGS_readWriteWithInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0,
                 const GGS_lstringlist & argument_1,
                 const GGS_string& argument_2,
                 const GGS_semanticExpressionForGeneration & argument_3,
                 const GGS_semanticInstructionListForGeneration & argument_4,
                 const GGS_semanticInstructionListForGeneration & argument_5
                                COMMA_LOCATION_ARGS) {
  GGS_readWriteWithInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_readWriteWithInstructionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_readWriteWithInstructionForGeneration::
reader_mReceiverVariableCppName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_readWriteWithInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_readWriteWithInstructionForGeneration *) mPointer)->mReceiverVariableCppName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_readWriteWithInstructionForGeneration::
reader_mStructAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_readWriteWithInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_readWriteWithInstructionForGeneration *) mPointer)->mStructAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_readWriteWithInstructionForGeneration::
reader_mAccessName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_readWriteWithInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_readWriteWithInstructionForGeneration *) mPointer)->mAccessName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_readWriteWithInstructionForGeneration::
reader_mKeyExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_readWriteWithInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_readWriteWithInstructionForGeneration *) mPointer)->mKeyExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration  GGS_readWriteWithInstructionForGeneration::
reader_mDoBranchInstructions (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_readWriteWithInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_readWriteWithInstructionForGeneration *) mPointer)->mDoBranchInstructions ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration  GGS_readWriteWithInstructionForGeneration::
reader_mElseBranchInstructions (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_readWriteWithInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_readWriteWithInstructionForGeneration *) mPointer)->mElseBranchInstructions ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_readWriteWithInstructionForGeneration::actualTypeName (void) const {
  return "readWriteWithInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__readWriteWithInstructionForGeneration ("readWriteWithInstructionForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_readWriteWithInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_readWriteWithInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_readWriteWithInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_readWriteWithInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_readWriteWithInstructionForGeneration GGS_readWriteWithInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_readWriteWithInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_readWriteWithInstructionForGeneration * p = dynamic_cast <const GGS_readWriteWithInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_readWriteWithInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_readWriteWithInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_readWriteWithInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_mapTypeForGeneration'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_mapTypeForGeneration::
cPtr_mapTypeForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typedAttributeList & argument_2,
                                const GGS_insertMethodListAST & argument_3,
                                const GGS_mapSearchMethodListAST & argument_4,
                                const GGS_mapRemoveMethodListAST & argument_5,
                                const GGS_bool& argument_6
                                COMMA_LOCATION_ARGS)
:cPtr_semanticTypeForGeneration (argument_0 COMMA_THERE),
mMapTypeName (argument_1),
mTypedAttributeList (argument_2),
mInsertMethodList (argument_3),
mSearchMethodList (argument_4),
mRemoveMethodList (argument_5),
mHasInsertOrReplaceModifier (argument_6) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_mapTypeForGeneration * GGS_mapTypeForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_mapTypeForGeneration) ;
    return (cPtr_mapTypeForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_mapTypeForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_mapTypeForGeneration * ptr = dynamic_cast <const cPtr_mapTypeForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTypeIndex.operator_isEqual (ptr->mTypeIndex).boolValue ()
         && mMapTypeName.operator_isEqual (ptr->mMapTypeName).boolValue ()
         && mTypedAttributeList.operator_isEqual (ptr->mTypedAttributeList).boolValue ()
         && mInsertMethodList.operator_isEqual (ptr->mInsertMethodList).boolValue ()
         && mSearchMethodList.operator_isEqual (ptr->mSearchMethodList).boolValue ()
         && mRemoveMethodList.operator_isEqual (ptr->mRemoveMethodList).boolValue ()
         && mHasInsertOrReplaceModifier.operator_isEqual (ptr->mHasInsertOrReplaceModifier).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_mapTypeForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@mapTypeForGeneration:"
           << mTypeIndex.reader_description (inIndentation + 1)
           << mMapTypeName.reader_description (inIndentation + 1)
           << mTypedAttributeList.reader_description (inIndentation + 1)
           << mInsertMethodList.reader_description (inIndentation + 1)
           << mSearchMethodList.reader_description (inIndentation + 1)
           << mRemoveMethodList.reader_description (inIndentation + 1)
           << mHasInsertOrReplaceModifier.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_mapTypeForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_mapTypeForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_mapTypeForGeneration (& typeid (cPtr_mapTypeForGeneration), & typeid (cPtr_semanticTypeForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_mapTypeForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__mapTypeForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_mapTypeForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_mapTypeForGeneration (mTypeIndex, mMapTypeName, mTypedAttributeList, mInsertMethodList, mSearchMethodList, mRemoveMethodList, mHasInsertOrReplaceModifier COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_mapTypeForGeneration'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_mapTypeForGeneration ("mapTypeForGeneration", true, & kTypeDescriptor_GGS_semanticTypeForGeneration) ;

//---------------------------------------------------------------------------*

GGS_mapTypeForGeneration::
GGS_mapTypeForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_mapTypeForGeneration::
GGS_mapTypeForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_mapTypeForGeneration GGS_mapTypeForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_mapTypeForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_mapTypeForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_mapTypeForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_mapTypeForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_mapTypeForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapTypeForGeneration GGS_mapTypeForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_typedAttributeList & argument_2,
                 const GGS_insertMethodListAST & argument_3,
                 const GGS_mapSearchMethodListAST & argument_4,
                 const GGS_mapRemoveMethodListAST & argument_5,
                 const GGS_bool& argument_6
                                COMMA_LOCATION_ARGS) {
  GGS_mapTypeForGeneration result ;
  macroMyNew (result.mPointer, cPtr_mapTypeForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapTypeForGeneration::
reader_mMapTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapTypeForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapTypeForGeneration *) mPointer)->mMapTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typedAttributeList  GGS_mapTypeForGeneration::
reader_mTypedAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typedAttributeList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapTypeForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapTypeForGeneration *) mPointer)->mTypedAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_insertMethodListAST  GGS_mapTypeForGeneration::
reader_mInsertMethodList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_insertMethodListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapTypeForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapTypeForGeneration *) mPointer)->mInsertMethodList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapSearchMethodListAST  GGS_mapTypeForGeneration::
reader_mSearchMethodList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_mapSearchMethodListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapTypeForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapTypeForGeneration *) mPointer)->mSearchMethodList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapRemoveMethodListAST  GGS_mapTypeForGeneration::
reader_mRemoveMethodList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_mapRemoveMethodListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapTypeForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapTypeForGeneration *) mPointer)->mRemoveMethodList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_mapTypeForGeneration::
reader_mHasInsertOrReplaceModifier (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapTypeForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapTypeForGeneration *) mPointer)->mHasInsertOrReplaceModifier ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_mapTypeForGeneration::actualTypeName (void) const {
  return "mapTypeForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__mapTypeForGeneration ("mapTypeForGeneration", gClassInfoFor__semanticTypeForGeneration, & kTypeDescriptor_GGS_mapTypeForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_mapTypeForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_mapTypeForGeneration * p = NULL ;
    macroMyNew (p, GGS_mapTypeForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapTypeForGeneration GGS_mapTypeForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_mapTypeForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_mapTypeForGeneration * p = dynamic_cast <const GGS_mapTypeForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_mapTypeForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_mapTypeForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_mapTypeForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_mapProxyTypeForGeneration'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_mapProxyTypeForGeneration::
cPtr_mapProxyTypeForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_unifiedTypeMapProxy & argument_1,
                                const GGS_typedAttributeList & argument_2,
                                const GGS_mapSearchMethodListAST & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticTypeForGeneration (argument_0 COMMA_THERE),
mAssociatedMapTypeProxy (argument_1),
mAssociatedMapTypedAttributeList (argument_2),
mSearchMethodList (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_mapProxyTypeForGeneration * GGS_mapProxyTypeForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_mapProxyTypeForGeneration) ;
    return (cPtr_mapProxyTypeForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_mapProxyTypeForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_mapProxyTypeForGeneration * ptr = dynamic_cast <const cPtr_mapProxyTypeForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTypeIndex.operator_isEqual (ptr->mTypeIndex).boolValue ()
         && mAssociatedMapTypeProxy.operator_isEqual (ptr->mAssociatedMapTypeProxy).boolValue ()
         && mAssociatedMapTypedAttributeList.operator_isEqual (ptr->mAssociatedMapTypedAttributeList).boolValue ()
         && mSearchMethodList.operator_isEqual (ptr->mSearchMethodList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_mapProxyTypeForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@mapProxyTypeForGeneration:"
           << mTypeIndex.reader_description (inIndentation + 1)
           << mAssociatedMapTypeProxy.reader_description (inIndentation + 1)
           << mAssociatedMapTypedAttributeList.reader_description (inIndentation + 1)
           << mSearchMethodList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_mapProxyTypeForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_mapProxyTypeForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_mapProxyTypeForGeneration (& typeid (cPtr_mapProxyTypeForGeneration), & typeid (cPtr_semanticTypeForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_mapProxyTypeForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__mapProxyTypeForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_mapProxyTypeForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_mapProxyTypeForGeneration (mTypeIndex, mAssociatedMapTypeProxy, mAssociatedMapTypedAttributeList, mSearchMethodList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_mapProxyTypeForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_mapProxyTypeForGeneration ("mapProxyTypeForGeneration", true, & kTypeDescriptor_GGS_semanticTypeForGeneration) ;

//---------------------------------------------------------------------------*

GGS_mapProxyTypeForGeneration::
GGS_mapProxyTypeForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_mapProxyTypeForGeneration::
GGS_mapProxyTypeForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_mapProxyTypeForGeneration GGS_mapProxyTypeForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_mapProxyTypeForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_mapProxyTypeForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_mapProxyTypeForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_mapProxyTypeForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_mapProxyTypeForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapProxyTypeForGeneration GGS_mapProxyTypeForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_unifiedTypeMapProxy & argument_1,
                 const GGS_typedAttributeList & argument_2,
                 const GGS_mapSearchMethodListAST & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_mapProxyTypeForGeneration result ;
  macroMyNew (result.mPointer, cPtr_mapProxyTypeForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapProxy  GGS_mapProxyTypeForGeneration::
reader_mAssociatedMapTypeProxy (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_unifiedTypeMapProxy   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapProxyTypeForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapProxyTypeForGeneration *) mPointer)->mAssociatedMapTypeProxy ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typedAttributeList  GGS_mapProxyTypeForGeneration::
reader_mAssociatedMapTypedAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typedAttributeList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapProxyTypeForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapProxyTypeForGeneration *) mPointer)->mAssociatedMapTypedAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapSearchMethodListAST  GGS_mapProxyTypeForGeneration::
reader_mSearchMethodList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_mapSearchMethodListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapProxyTypeForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapProxyTypeForGeneration *) mPointer)->mSearchMethodList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_mapProxyTypeForGeneration::actualTypeName (void) const {
  return "mapProxyTypeForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__mapProxyTypeForGeneration ("mapProxyTypeForGeneration", gClassInfoFor__semanticTypeForGeneration, & kTypeDescriptor_GGS_mapProxyTypeForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_mapProxyTypeForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_mapProxyTypeForGeneration * p = NULL ;
    macroMyNew (p, GGS_mapProxyTypeForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapProxyTypeForGeneration GGS_mapProxyTypeForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_mapProxyTypeForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_mapProxyTypeForGeneration * p = dynamic_cast <const GGS_mapProxyTypeForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_mapProxyTypeForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_mapProxyTypeForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_mapProxyTypeForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//       Element of list '@abstractMethodDefinitionListForGeneration'        *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_abstractMethodDefinitionListForGeneration::
elementOf_GGS_abstractMethodDefinitionListForGeneration (const GGS_bool& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_formalParameterListForGeneration & argument_2
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mIsOverriding (argument_0),
mMethodName (argument_1),
mSignature (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_abstractMethodDefinitionListForGeneration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_abstractMethodDefinitionListForGeneration * ptr = dynamic_cast <const elementOf_GGS_abstractMethodDefinitionListForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mIsOverriding.operator_isEqual (ptr->mIsOverriding).boolValue ()
         && mMethodName.operator_isEqual (ptr->mMethodName).boolValue ()
         && mSignature.operator_isEqual (ptr->mSignature).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_abstractMethodDefinitionListForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mIsOverriding.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMethodName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSignature.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            List '@abstractMethodDefinitionListForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_abstractMethodDefinitionListForGeneration ("abstractMethodDefinitionListForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionListForGeneration::
internalAppendValues (const GGS_bool& argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_formalParameterListForGeneration & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionListForGeneration::
internalPrependValues (const GGS_bool& argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_formalParameterListForGeneration & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionListForGeneration::
addAssign_operation (const GGS_bool& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_formalParameterListForGeneration & argument_2) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_abstractMethodDefinitionListForGeneration GGS_abstractMethodDefinitionListForGeneration::
operator_concat (const GGS_abstractMethodDefinitionListForGeneration & inOperand) const {
  GGS_abstractMethodDefinitionListForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionListForGeneration::
dotAssign_operation (const GGS_abstractMethodDefinitionListForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_abstractMethodDefinitionListForGeneration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_bool p_0 = p->mIsOverriding ;
          GGS_lstring  p_1 = p->mMethodName ;
          GGS_formalParameterListForGeneration  p_2 = p->mSignature ;
          internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionListForGeneration::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_bool& argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_formalParameterListForGeneration & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionListForGeneration::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mIsOverriding,
                                ptr->mMethodName,
                                ptr->mSignature
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_abstractMethodDefinitionListForGeneration  GGS_abstractMethodDefinitionListForGeneration::
constructor_emptyList (void) {
  GGS_abstractMethodDefinitionListForGeneration result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_abstractMethodDefinitionListForGeneration  GGS_abstractMethodDefinitionListForGeneration::
constructor_listWithValue (const GGS_bool& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_formalParameterListForGeneration & argument_2) {
  GGS_abstractMethodDefinitionListForGeneration result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionListForGeneration::
internalSubListWithRange (GGS_abstractMethodDefinitionListForGeneration & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mIsOverriding, ptr->mMethodName, ptr->mSignature) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_abstractMethodDefinitionListForGeneration GGS_abstractMethodDefinitionListForGeneration::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_abstractMethodDefinitionListForGeneration result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_abstractMethodDefinitionListForGeneration GGS_abstractMethodDefinitionListForGeneration::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_abstractMethodDefinitionListForGeneration result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_abstractMethodDefinitionListForGeneration::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@abstractMethodDefinitionListForGeneration", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionListForGeneration::
method_first (C_Compiler & inLexique,
              GGS_bool& _out_0,
              GGS_lstring & _out_1,
              GGS_formalParameterListForGeneration & _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mIsOverriding ;
    _out_1 = ptr->mMethodName ;
    _out_2 = ptr->mSignature ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionListForGeneration::
method_last (C_Compiler & inLexique,
             GGS_bool& _out_0,
             GGS_lstring & _out_1,
             GGS_formalParameterListForGeneration & _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mIsOverriding ;
    _out_1 = ptr->mMethodName ;
    _out_2 = ptr->mSignature ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionListForGeneration::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_bool& _out_0,
                 GGS_lstring & _out_1,
                 GGS_formalParameterListForGeneration & _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mIsOverriding ;
    _out_1 = ptr->mMethodName ;
    _out_2 = ptr->mSignature ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionListForGeneration::
modifier_popLast (C_Compiler & inLexique,
                GGS_bool& _out_0,
                GGS_lstring & _out_1,
                GGS_formalParameterListForGeneration & _out_2
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mIsOverriding ;
    _out_1 = ptr->mMethodName ;
    _out_2 = ptr->mSignature ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_bool GGS_abstractMethodDefinitionListForGeneration::
reader_mIsOverridingAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mIsOverriding ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_abstractMethodDefinitionListForGeneration::
reader_mMethodNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mMethodName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameterListForGeneration  GGS_abstractMethodDefinitionListForGeneration::
reader_mSignatureAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_formalParameterListForGeneration  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSignature ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionListForGeneration::
modifier_setMIsOverridingAtIndex (C_Compiler & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mIsOverriding = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionListForGeneration::
modifier_setMMethodNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mMethodName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionListForGeneration::
modifier_setMSignatureAtIndex (C_Compiler & inLexique,
                              const GGS_formalParameterListForGeneration  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSignature = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_abstractMethodDefinitionListForGeneration::cEnumerator::_mIsOverriding (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mIsOverriding ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_abstractMethodDefinitionListForGeneration::cEnumerator::_mMethodName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mMethodName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_formalParameterListForGeneration  & GGS_abstractMethodDefinitionListForGeneration::cEnumerator::_mSignature (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mSignature ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_abstractMethodDefinitionListForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_abstractMethodDefinitionListForGeneration * p = NULL ;
    macroMyNew (p, GGS_abstractMethodDefinitionListForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_abstractMethodDefinitionListForGeneration GGS_abstractMethodDefinitionListForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_abstractMethodDefinitionListForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_abstractMethodDefinitionListForGeneration * p = dynamic_cast <const GGS_abstractMethodDefinitionListForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_abstractMethodDefinitionListForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_abstractMethodDefinitionListForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_abstractMethodDefinitionListForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Element of list '@methodDefinitionListForGeneration'            *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_methodDefinitionListForGeneration::
elementOf_GGS_methodDefinitionListForGeneration (const GGS_bool& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_formalParameterListForGeneration & argument_2,
                                const GGS_semanticInstructionListForGeneration & argument_3
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mIsOverriding (argument_0),
mMethodName (argument_1),
mSignature (argument_2),
mInstructionList (argument_3) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_methodDefinitionListForGeneration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_methodDefinitionListForGeneration * ptr = dynamic_cast <const elementOf_GGS_methodDefinitionListForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mIsOverriding.operator_isEqual (ptr->mIsOverriding).boolValue ()
         && mMethodName.operator_isEqual (ptr->mMethodName).boolValue ()
         && mSignature.operator_isEqual (ptr->mSignature).boolValue ()
         && mInstructionList.operator_isEqual (ptr->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_methodDefinitionListForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mIsOverriding.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMethodName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSignature.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                List '@methodDefinitionListForGeneration'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_methodDefinitionListForGeneration ("methodDefinitionListForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_methodDefinitionListForGeneration::
internalAppendValues (const GGS_bool& argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_formalParameterListForGeneration & argument_2,
                    const GGS_semanticInstructionListForGeneration & argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionListForGeneration::
internalPrependValues (const GGS_bool& argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_formalParameterListForGeneration & argument_2,
                    const GGS_semanticInstructionListForGeneration & argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionListForGeneration::
addAssign_operation (const GGS_bool& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_formalParameterListForGeneration & argument_2,
                                const GGS_semanticInstructionListForGeneration & argument_3) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()&& argument_3.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_methodDefinitionListForGeneration GGS_methodDefinitionListForGeneration::
operator_concat (const GGS_methodDefinitionListForGeneration & inOperand) const {
  GGS_methodDefinitionListForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionListForGeneration::
dotAssign_operation (const GGS_methodDefinitionListForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_methodDefinitionListForGeneration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_bool p_0 = p->mIsOverriding ;
          GGS_lstring  p_1 = p->mMethodName ;
          GGS_formalParameterListForGeneration  p_2 = p->mSignature ;
          GGS_semanticInstructionListForGeneration  p_3 = p->mInstructionList ;
          internalAppendValues (p_0, p_1, p_2, p_3 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionListForGeneration::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_bool& argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_formalParameterListForGeneration & argument_2,
                     const GGS_semanticInstructionListForGeneration & argument_3
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionListForGeneration::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mIsOverriding,
                                ptr->mMethodName,
                                ptr->mSignature,
                                ptr->mInstructionList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_methodDefinitionListForGeneration  GGS_methodDefinitionListForGeneration::
constructor_emptyList (void) {
  GGS_methodDefinitionListForGeneration result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_methodDefinitionListForGeneration  GGS_methodDefinitionListForGeneration::
constructor_listWithValue (const GGS_bool& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_formalParameterListForGeneration & argument_2,
                                const GGS_semanticInstructionListForGeneration & argument_3) {
  GGS_methodDefinitionListForGeneration result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2, argument_3) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionListForGeneration::
internalSubListWithRange (GGS_methodDefinitionListForGeneration & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mIsOverriding, ptr->mMethodName, ptr->mSignature, ptr->mInstructionList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_methodDefinitionListForGeneration GGS_methodDefinitionListForGeneration::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_methodDefinitionListForGeneration result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_methodDefinitionListForGeneration GGS_methodDefinitionListForGeneration::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_methodDefinitionListForGeneration result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_methodDefinitionListForGeneration::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@methodDefinitionListForGeneration", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionListForGeneration::
method_first (C_Compiler & inLexique,
              GGS_bool& _out_0,
              GGS_lstring & _out_1,
              GGS_formalParameterListForGeneration & _out_2,
              GGS_semanticInstructionListForGeneration & _out_3
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mIsOverriding ;
    _out_1 = ptr->mMethodName ;
    _out_2 = ptr->mSignature ;
    _out_3 = ptr->mInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionListForGeneration::
method_last (C_Compiler & inLexique,
             GGS_bool& _out_0,
             GGS_lstring & _out_1,
             GGS_formalParameterListForGeneration & _out_2,
             GGS_semanticInstructionListForGeneration & _out_3
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mIsOverriding ;
    _out_1 = ptr->mMethodName ;
    _out_2 = ptr->mSignature ;
    _out_3 = ptr->mInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionListForGeneration::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_bool& _out_0,
                 GGS_lstring & _out_1,
                 GGS_formalParameterListForGeneration & _out_2,
                 GGS_semanticInstructionListForGeneration & _out_3
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mIsOverriding ;
    _out_1 = ptr->mMethodName ;
    _out_2 = ptr->mSignature ;
    _out_3 = ptr->mInstructionList ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionListForGeneration::
modifier_popLast (C_Compiler & inLexique,
                GGS_bool& _out_0,
                GGS_lstring & _out_1,
                GGS_formalParameterListForGeneration & _out_2,
                GGS_semanticInstructionListForGeneration & _out_3
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mIsOverriding ;
    _out_1 = ptr->mMethodName ;
    _out_2 = ptr->mSignature ;
    _out_3 = ptr->mInstructionList ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_bool GGS_methodDefinitionListForGeneration::
reader_mIsOverridingAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mIsOverriding ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_methodDefinitionListForGeneration::
reader_mMethodNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mMethodName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameterListForGeneration  GGS_methodDefinitionListForGeneration::
reader_mSignatureAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_formalParameterListForGeneration  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSignature ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration  GGS_methodDefinitionListForGeneration::
reader_mInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticInstructionListForGeneration  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionListForGeneration::
modifier_setMIsOverridingAtIndex (C_Compiler & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mIsOverriding = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionListForGeneration::
modifier_setMMethodNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mMethodName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionListForGeneration::
modifier_setMSignatureAtIndex (C_Compiler & inLexique,
                              const GGS_formalParameterListForGeneration  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSignature = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionListForGeneration::
modifier_setMInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_semanticInstructionListForGeneration  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_methodDefinitionListForGeneration::cEnumerator::_mIsOverriding (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mIsOverriding ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_methodDefinitionListForGeneration::cEnumerator::_mMethodName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mMethodName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_formalParameterListForGeneration  & GGS_methodDefinitionListForGeneration::cEnumerator::_mSignature (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mSignature ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticInstructionListForGeneration  & GGS_methodDefinitionListForGeneration::cEnumerator::_mInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mInstructionList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_methodDefinitionListForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_methodDefinitionListForGeneration * p = NULL ;
    macroMyNew (p, GGS_methodDefinitionListForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_methodDefinitionListForGeneration GGS_methodDefinitionListForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_methodDefinitionListForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_methodDefinitionListForGeneration * p = dynamic_cast <const GGS_methodDefinitionListForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_methodDefinitionListForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_methodDefinitionListForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_methodDefinitionListForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_classTypeForGeneration'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_classTypeForGeneration::
cPtr_classTypeForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_bool& argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_unifiedTypeMapProxy & argument_3,
                                const GGS_typedAttributeList & argument_4,
                                const GGS_typedAttributeList & argument_5,
                                const GGS_abstractMethodDefinitionListForGeneration & argument_6,
                                const GGS_methodDefinitionListForGeneration & argument_7
                                COMMA_LOCATION_ARGS)
:cPtr_semanticTypeForGeneration (argument_0 COMMA_THERE),
mIsAbstract (argument_1),
mClassTypeName (argument_2),
mSuperClass (argument_3),
mAllTypedAttributeList (argument_4),
mTypedAttributeList (argument_5),
mAbstractMethodList (argument_6),
mMethodList (argument_7) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_classTypeForGeneration * GGS_classTypeForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_classTypeForGeneration) ;
    return (cPtr_classTypeForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_classTypeForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_classTypeForGeneration * ptr = dynamic_cast <const cPtr_classTypeForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTypeIndex.operator_isEqual (ptr->mTypeIndex).boolValue ()
         && mIsAbstract.operator_isEqual (ptr->mIsAbstract).boolValue ()
         && mClassTypeName.operator_isEqual (ptr->mClassTypeName).boolValue ()
         && mSuperClass.operator_isEqual (ptr->mSuperClass).boolValue ()
         && mAllTypedAttributeList.operator_isEqual (ptr->mAllTypedAttributeList).boolValue ()
         && mTypedAttributeList.operator_isEqual (ptr->mTypedAttributeList).boolValue ()
         && mAbstractMethodList.operator_isEqual (ptr->mAbstractMethodList).boolValue ()
         && mMethodList.operator_isEqual (ptr->mMethodList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_classTypeForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@classTypeForGeneration:"
           << mTypeIndex.reader_description (inIndentation + 1)
           << mIsAbstract.reader_description (inIndentation + 1)
           << mClassTypeName.reader_description (inIndentation + 1)
           << mSuperClass.reader_description (inIndentation + 1)
           << mAllTypedAttributeList.reader_description (inIndentation + 1)
           << mTypedAttributeList.reader_description (inIndentation + 1)
           << mAbstractMethodList.reader_description (inIndentation + 1)
           << mMethodList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_classTypeForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_classTypeForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_classTypeForGeneration (& typeid (cPtr_classTypeForGeneration), & typeid (cPtr_semanticTypeForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_classTypeForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__classTypeForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_classTypeForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_classTypeForGeneration (mTypeIndex, mIsAbstract, mClassTypeName, mSuperClass, mAllTypedAttributeList, mTypedAttributeList, mAbstractMethodList, mMethodList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_classTypeForGeneration'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_classTypeForGeneration ("classTypeForGeneration", true, & kTypeDescriptor_GGS_semanticTypeForGeneration) ;

//---------------------------------------------------------------------------*

GGS_classTypeForGeneration::
GGS_classTypeForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_classTypeForGeneration::
GGS_classTypeForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_classTypeForGeneration GGS_classTypeForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_classTypeForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_classTypeForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_classTypeForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_classTypeForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_classTypeForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_classTypeForGeneration GGS_classTypeForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_bool& argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_unifiedTypeMapProxy & argument_3,
                 const GGS_typedAttributeList & argument_4,
                 const GGS_typedAttributeList & argument_5,
                 const GGS_abstractMethodDefinitionListForGeneration & argument_6,
                 const GGS_methodDefinitionListForGeneration & argument_7
                                COMMA_LOCATION_ARGS) {
  GGS_classTypeForGeneration result ;
  macroMyNew (result.mPointer, cPtr_classTypeForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_classTypeForGeneration::
reader_mIsAbstract (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classTypeForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classTypeForGeneration *) mPointer)->mIsAbstract ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_classTypeForGeneration::
reader_mClassTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classTypeForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classTypeForGeneration *) mPointer)->mClassTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapProxy  GGS_classTypeForGeneration::
reader_mSuperClass (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_unifiedTypeMapProxy   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classTypeForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classTypeForGeneration *) mPointer)->mSuperClass ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typedAttributeList  GGS_classTypeForGeneration::
reader_mAllTypedAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typedAttributeList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classTypeForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classTypeForGeneration *) mPointer)->mAllTypedAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typedAttributeList  GGS_classTypeForGeneration::
reader_mTypedAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typedAttributeList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classTypeForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classTypeForGeneration *) mPointer)->mTypedAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_abstractMethodDefinitionListForGeneration  GGS_classTypeForGeneration::
reader_mAbstractMethodList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_abstractMethodDefinitionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classTypeForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classTypeForGeneration *) mPointer)->mAbstractMethodList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_methodDefinitionListForGeneration  GGS_classTypeForGeneration::
reader_mMethodList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_methodDefinitionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classTypeForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classTypeForGeneration *) mPointer)->mMethodList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_classTypeForGeneration::actualTypeName (void) const {
  return "classTypeForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__classTypeForGeneration ("classTypeForGeneration", gClassInfoFor__semanticTypeForGeneration, & kTypeDescriptor_GGS_classTypeForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_classTypeForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_classTypeForGeneration * p = NULL ;
    macroMyNew (p, GGS_classTypeForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_classTypeForGeneration GGS_classTypeForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_classTypeForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_classTypeForGeneration * p = dynamic_cast <const GGS_classTypeForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_classTypeForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_classTypeForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_classTypeForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_listmapTypeForGeneration'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_listmapTypeForGeneration::
cPtr_listmapTypeForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_unifiedTypeMapProxy & argument_1,
                                const GGS_typedAttributeList & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticTypeForGeneration (argument_0 COMMA_THERE),
mAssociatedListTypeIndex (argument_1),
mAssociatedListTypedAttributeList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_listmapTypeForGeneration * GGS_listmapTypeForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_listmapTypeForGeneration) ;
    return (cPtr_listmapTypeForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_listmapTypeForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_listmapTypeForGeneration * ptr = dynamic_cast <const cPtr_listmapTypeForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTypeIndex.operator_isEqual (ptr->mTypeIndex).boolValue ()
         && mAssociatedListTypeIndex.operator_isEqual (ptr->mAssociatedListTypeIndex).boolValue ()
         && mAssociatedListTypedAttributeList.operator_isEqual (ptr->mAssociatedListTypedAttributeList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_listmapTypeForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@listmapTypeForGeneration:"
           << mTypeIndex.reader_description (inIndentation + 1)
           << mAssociatedListTypeIndex.reader_description (inIndentation + 1)
           << mAssociatedListTypedAttributeList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_listmapTypeForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_listmapTypeForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_listmapTypeForGeneration (& typeid (cPtr_listmapTypeForGeneration), & typeid (cPtr_semanticTypeForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_listmapTypeForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__listmapTypeForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_listmapTypeForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_listmapTypeForGeneration (mTypeIndex, mAssociatedListTypeIndex, mAssociatedListTypedAttributeList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_listmapTypeForGeneration'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_listmapTypeForGeneration ("listmapTypeForGeneration", true, & kTypeDescriptor_GGS_semanticTypeForGeneration) ;

//---------------------------------------------------------------------------*

GGS_listmapTypeForGeneration::
GGS_listmapTypeForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_listmapTypeForGeneration::
GGS_listmapTypeForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_listmapTypeForGeneration GGS_listmapTypeForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_listmapTypeForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_listmapTypeForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_listmapTypeForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_listmapTypeForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_listmapTypeForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_listmapTypeForGeneration GGS_listmapTypeForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_unifiedTypeMapProxy & argument_1,
                 const GGS_typedAttributeList & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_listmapTypeForGeneration result ;
  macroMyNew (result.mPointer, cPtr_listmapTypeForGeneration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapProxy  GGS_listmapTypeForGeneration::
reader_mAssociatedListTypeIndex (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_unifiedTypeMapProxy   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_listmapTypeForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_listmapTypeForGeneration *) mPointer)->mAssociatedListTypeIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typedAttributeList  GGS_listmapTypeForGeneration::
reader_mAssociatedListTypedAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typedAttributeList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_listmapTypeForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_listmapTypeForGeneration *) mPointer)->mAssociatedListTypedAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_listmapTypeForGeneration::actualTypeName (void) const {
  return "listmapTypeForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__listmapTypeForGeneration ("listmapTypeForGeneration", gClassInfoFor__semanticTypeForGeneration, & kTypeDescriptor_GGS_listmapTypeForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_listmapTypeForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_listmapTypeForGeneration * p = NULL ;
    macroMyNew (p, GGS_listmapTypeForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_listmapTypeForGeneration GGS_listmapTypeForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_listmapTypeForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_listmapTypeForGeneration * p = dynamic_cast <const GGS_listmapTypeForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_listmapTypeForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_listmapTypeForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_listmapTypeForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_primitiveTypeForGeneration'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_primitiveTypeForGeneration::
cPtr_primitiveTypeForGeneration (const GGS_unifiedTypeMapProxy & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_semanticTypeForGeneration (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_primitiveTypeForGeneration * GGS_primitiveTypeForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_primitiveTypeForGeneration) ;
    return (cPtr_primitiveTypeForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_primitiveTypeForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_primitiveTypeForGeneration * ptr = dynamic_cast <const cPtr_primitiveTypeForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTypeIndex.operator_isEqual (ptr->mTypeIndex).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_primitiveTypeForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@primitiveTypeForGeneration:"
           << mTypeIndex.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_primitiveTypeForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_primitiveTypeForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_primitiveTypeForGeneration (& typeid (cPtr_primitiveTypeForGeneration), & typeid (cPtr_semanticTypeForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_primitiveTypeForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__primitiveTypeForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_primitiveTypeForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_primitiveTypeForGeneration (mTypeIndex COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_primitiveTypeForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_primitiveTypeForGeneration ("primitiveTypeForGeneration", true, & kTypeDescriptor_GGS_semanticTypeForGeneration) ;

//---------------------------------------------------------------------------*

GGS_primitiveTypeForGeneration::
GGS_primitiveTypeForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_primitiveTypeForGeneration::
GGS_primitiveTypeForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_primitiveTypeForGeneration GGS_primitiveTypeForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_primitiveTypeForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_primitiveTypeForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_primitiveTypeForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_primitiveTypeForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_primitiveTypeForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_primitiveTypeForGeneration GGS_primitiveTypeForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_primitiveTypeForGeneration result ;
  macroMyNew (result.mPointer, cPtr_primitiveTypeForGeneration (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_primitiveTypeForGeneration::actualTypeName (void) const {
  return "primitiveTypeForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__primitiveTypeForGeneration ("primitiveTypeForGeneration", gClassInfoFor__semanticTypeForGeneration, & kTypeDescriptor_GGS_primitiveTypeForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_primitiveTypeForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_primitiveTypeForGeneration * p = NULL ;
    macroMyNew (p, GGS_primitiveTypeForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_primitiveTypeForGeneration GGS_primitiveTypeForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_primitiveTypeForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_primitiveTypeForGeneration * p = dynamic_cast <const GGS_primitiveTypeForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_primitiveTypeForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_primitiveTypeForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_primitiveTypeForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_genericTypeForGeneration'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_genericTypeForGeneration::
cPtr_genericTypeForGeneration (const GGS_unifiedTypeMapProxy & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_semanticTypeForGeneration (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_genericTypeForGeneration * GGS_genericTypeForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_genericTypeForGeneration) ;
    return (cPtr_genericTypeForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_genericTypeForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_genericTypeForGeneration * ptr = dynamic_cast <const cPtr_genericTypeForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTypeIndex.operator_isEqual (ptr->mTypeIndex).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_genericTypeForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@genericTypeForGeneration:"
           << mTypeIndex.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_genericTypeForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_genericTypeForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_genericTypeForGeneration (& typeid (cPtr_genericTypeForGeneration), & typeid (cPtr_semanticTypeForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_genericTypeForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__genericTypeForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_genericTypeForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_genericTypeForGeneration (mTypeIndex COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_genericTypeForGeneration'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_genericTypeForGeneration ("genericTypeForGeneration", true, & kTypeDescriptor_GGS_semanticTypeForGeneration) ;

//---------------------------------------------------------------------------*

GGS_genericTypeForGeneration::
GGS_genericTypeForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_genericTypeForGeneration::
GGS_genericTypeForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_genericTypeForGeneration GGS_genericTypeForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_genericTypeForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_genericTypeForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_genericTypeForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_genericTypeForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_genericTypeForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_genericTypeForGeneration GGS_genericTypeForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_genericTypeForGeneration result ;
  macroMyNew (result.mPointer, cPtr_genericTypeForGeneration (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_genericTypeForGeneration::actualTypeName (void) const {
  return "genericTypeForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__genericTypeForGeneration ("genericTypeForGeneration", gClassInfoFor__semanticTypeForGeneration, & kTypeDescriptor_GGS_genericTypeForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_genericTypeForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_genericTypeForGeneration * p = NULL ;
    macroMyNew (p, GGS_genericTypeForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_genericTypeForGeneration GGS_genericTypeForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_genericTypeForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_genericTypeForGeneration * p = dynamic_cast <const GGS_genericTypeForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_genericTypeForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_genericTypeForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_genericTypeForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_listTypeForGeneration'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_listTypeForGeneration::
cPtr_listTypeForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_typedAttributeList & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticTypeForGeneration (argument_0 COMMA_THERE),
mTypedAttributeList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_listTypeForGeneration * GGS_listTypeForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_listTypeForGeneration) ;
    return (cPtr_listTypeForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_listTypeForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_listTypeForGeneration * ptr = dynamic_cast <const cPtr_listTypeForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTypeIndex.operator_isEqual (ptr->mTypeIndex).boolValue ()
         && mTypedAttributeList.operator_isEqual (ptr->mTypedAttributeList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_listTypeForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@listTypeForGeneration:"
           << mTypeIndex.reader_description (inIndentation + 1)
           << mTypedAttributeList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_listTypeForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_listTypeForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_listTypeForGeneration (& typeid (cPtr_listTypeForGeneration), & typeid (cPtr_semanticTypeForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_listTypeForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__listTypeForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_listTypeForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_listTypeForGeneration (mTypeIndex, mTypedAttributeList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_listTypeForGeneration'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_listTypeForGeneration ("listTypeForGeneration", true, & kTypeDescriptor_GGS_semanticTypeForGeneration) ;

//---------------------------------------------------------------------------*

GGS_listTypeForGeneration::
GGS_listTypeForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_listTypeForGeneration::
GGS_listTypeForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_listTypeForGeneration GGS_listTypeForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_listTypeForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_listTypeForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_listTypeForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_listTypeForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_listTypeForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_listTypeForGeneration GGS_listTypeForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_typedAttributeList & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_listTypeForGeneration result ;
  macroMyNew (result.mPointer, cPtr_listTypeForGeneration (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typedAttributeList  GGS_listTypeForGeneration::
reader_mTypedAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typedAttributeList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_listTypeForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_listTypeForGeneration *) mPointer)->mTypedAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_listTypeForGeneration::actualTypeName (void) const {
  return "listTypeForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__listTypeForGeneration ("listTypeForGeneration", gClassInfoFor__semanticTypeForGeneration, & kTypeDescriptor_GGS_listTypeForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_listTypeForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_listTypeForGeneration * p = NULL ;
    macroMyNew (p, GGS_listTypeForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_listTypeForGeneration GGS_listTypeForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_listTypeForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_listTypeForGeneration * p = dynamic_cast <const GGS_listTypeForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_listTypeForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_listTypeForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_listTypeForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_structTypeForGeneration'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_structTypeForGeneration::
cPtr_structTypeForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_typedAttributeList & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticTypeForGeneration (argument_0 COMMA_THERE),
mTypedAttributeList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_structTypeForGeneration * GGS_structTypeForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_structTypeForGeneration) ;
    return (cPtr_structTypeForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_structTypeForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_structTypeForGeneration * ptr = dynamic_cast <const cPtr_structTypeForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTypeIndex.operator_isEqual (ptr->mTypeIndex).boolValue ()
         && mTypedAttributeList.operator_isEqual (ptr->mTypedAttributeList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_structTypeForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@structTypeForGeneration:"
           << mTypeIndex.reader_description (inIndentation + 1)
           << mTypedAttributeList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_structTypeForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_structTypeForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_structTypeForGeneration (& typeid (cPtr_structTypeForGeneration), & typeid (cPtr_semanticTypeForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_structTypeForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__structTypeForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_structTypeForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_structTypeForGeneration (mTypeIndex, mTypedAttributeList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_structTypeForGeneration'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_structTypeForGeneration ("structTypeForGeneration", true, & kTypeDescriptor_GGS_semanticTypeForGeneration) ;

//---------------------------------------------------------------------------*

GGS_structTypeForGeneration::
GGS_structTypeForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_structTypeForGeneration::
GGS_structTypeForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_structTypeForGeneration GGS_structTypeForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_structTypeForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_structTypeForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_structTypeForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_structTypeForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_structTypeForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_structTypeForGeneration GGS_structTypeForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_typedAttributeList & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_structTypeForGeneration result ;
  macroMyNew (result.mPointer, cPtr_structTypeForGeneration (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typedAttributeList  GGS_structTypeForGeneration::
reader_mTypedAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typedAttributeList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_structTypeForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_structTypeForGeneration *) mPointer)->mTypedAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_structTypeForGeneration::actualTypeName (void) const {
  return "structTypeForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__structTypeForGeneration ("structTypeForGeneration", gClassInfoFor__semanticTypeForGeneration, & kTypeDescriptor_GGS_structTypeForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_structTypeForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_structTypeForGeneration * p = NULL ;
    macroMyNew (p, GGS_structTypeForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_structTypeForGeneration GGS_structTypeForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_structTypeForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_structTypeForGeneration * p = dynamic_cast <const GGS_structTypeForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_structTypeForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_structTypeForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_structTypeForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Element of list '@sortDescriptorListForGeneration'             *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_sortDescriptorListForGeneration::
elementOf_GGS_sortDescriptorListForGeneration (const GGS_uint & argument_0,
                                const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mAttributeIndex (argument_0),
mAscendingOrder (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_sortDescriptorListForGeneration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_sortDescriptorListForGeneration * ptr = dynamic_cast <const elementOf_GGS_sortDescriptorListForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mAttributeIndex.operator_isEqual (ptr->mAttributeIndex).boolValue ()
         && mAscendingOrder.operator_isEqual (ptr->mAscendingOrder).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_sortDescriptorListForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAttributeIndex.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAscendingOrder.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 List '@sortDescriptorListForGeneration'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_sortDescriptorListForGeneration ("sortDescriptorListForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_sortDescriptorListForGeneration::
internalAppendValues (const GGS_uint & argument_0,
                    const GGS_bool& argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_sortDescriptorListForGeneration::
internalPrependValues (const GGS_uint & argument_0,
                    const GGS_bool& argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_sortDescriptorListForGeneration::
addAssign_operation (const GGS_uint & argument_0,
                                const GGS_bool& argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_sortDescriptorListForGeneration GGS_sortDescriptorListForGeneration::
operator_concat (const GGS_sortDescriptorListForGeneration & inOperand) const {
  GGS_sortDescriptorListForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_sortDescriptorListForGeneration::
dotAssign_operation (const GGS_sortDescriptorListForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_sortDescriptorListForGeneration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_uint  p_0 = p->mAttributeIndex ;
          GGS_bool p_1 = p->mAscendingOrder ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_sortDescriptorListForGeneration::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_uint & argument_0,
                     const GGS_bool& argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_sortDescriptorListForGeneration::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mAttributeIndex,
                                ptr->mAscendingOrder
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_sortDescriptorListForGeneration  GGS_sortDescriptorListForGeneration::
constructor_emptyList (void) {
  GGS_sortDescriptorListForGeneration result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sortDescriptorListForGeneration  GGS_sortDescriptorListForGeneration::
constructor_listWithValue (const GGS_uint & argument_0,
                                const GGS_bool& argument_1) {
  GGS_sortDescriptorListForGeneration result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_sortDescriptorListForGeneration::
internalSubListWithRange (GGS_sortDescriptorListForGeneration & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mAttributeIndex, ptr->mAscendingOrder) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_sortDescriptorListForGeneration GGS_sortDescriptorListForGeneration::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_sortDescriptorListForGeneration result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sortDescriptorListForGeneration GGS_sortDescriptorListForGeneration::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_sortDescriptorListForGeneration result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_sortDescriptorListForGeneration::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@sortDescriptorListForGeneration", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_sortDescriptorListForGeneration::
method_first (C_Compiler & inLexique,
              GGS_uint & _out_0,
              GGS_bool& _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAttributeIndex ;
    _out_1 = ptr->mAscendingOrder ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_sortDescriptorListForGeneration::
method_last (C_Compiler & inLexique,
             GGS_uint & _out_0,
             GGS_bool& _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAttributeIndex ;
    _out_1 = ptr->mAscendingOrder ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_sortDescriptorListForGeneration::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_uint & _out_0,
                 GGS_bool& _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAttributeIndex ;
    _out_1 = ptr->mAscendingOrder ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_sortDescriptorListForGeneration::
modifier_popLast (C_Compiler & inLexique,
                GGS_uint & _out_0,
                GGS_bool& _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAttributeIndex ;
    _out_1 = ptr->mAscendingOrder ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_sortDescriptorListForGeneration::
reader_mAttributeIndexAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_uint  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mAttributeIndex ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_sortDescriptorListForGeneration::
reader_mAscendingOrderAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mAscendingOrder ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_sortDescriptorListForGeneration::
modifier_setMAttributeIndexAtIndex (C_Compiler & inLexique,
                              const GGS_uint  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mAttributeIndex = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_sortDescriptorListForGeneration::
modifier_setMAscendingOrderAtIndex (C_Compiler & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mAscendingOrder = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_sortDescriptorListForGeneration::cEnumerator::_mAttributeIndex (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mAttributeIndex ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_sortDescriptorListForGeneration::cEnumerator::_mAscendingOrder (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mAscendingOrder ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_sortDescriptorListForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_sortDescriptorListForGeneration * p = NULL ;
    macroMyNew (p, GGS_sortDescriptorListForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sortDescriptorListForGeneration GGS_sortDescriptorListForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_sortDescriptorListForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_sortDescriptorListForGeneration * p = dynamic_cast <const GGS_sortDescriptorListForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_sortDescriptorListForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_sortDescriptorListForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_sortDescriptorListForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_sortedListTypeForGeneration'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_sortedListTypeForGeneration::
cPtr_sortedListTypeForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_typedAttributeList & argument_1,
                                const GGS_sortDescriptorListForGeneration & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticTypeForGeneration (argument_0 COMMA_THERE),
mTypedAttributeList (argument_1),
mSortDescriptorList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_sortedListTypeForGeneration * GGS_sortedListTypeForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_sortedListTypeForGeneration) ;
    return (cPtr_sortedListTypeForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_sortedListTypeForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_sortedListTypeForGeneration * ptr = dynamic_cast <const cPtr_sortedListTypeForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTypeIndex.operator_isEqual (ptr->mTypeIndex).boolValue ()
         && mTypedAttributeList.operator_isEqual (ptr->mTypedAttributeList).boolValue ()
         && mSortDescriptorList.operator_isEqual (ptr->mSortDescriptorList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_sortedListTypeForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@sortedListTypeForGeneration:"
           << mTypeIndex.reader_description (inIndentation + 1)
           << mTypedAttributeList.reader_description (inIndentation + 1)
           << mSortDescriptorList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_sortedListTypeForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_sortedListTypeForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_sortedListTypeForGeneration (& typeid (cPtr_sortedListTypeForGeneration), & typeid (cPtr_semanticTypeForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_sortedListTypeForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__sortedListTypeForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_sortedListTypeForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_sortedListTypeForGeneration (mTypeIndex, mTypedAttributeList, mSortDescriptorList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_sortedListTypeForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_sortedListTypeForGeneration ("sortedListTypeForGeneration", true, & kTypeDescriptor_GGS_semanticTypeForGeneration) ;

//---------------------------------------------------------------------------*

GGS_sortedListTypeForGeneration::
GGS_sortedListTypeForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_sortedListTypeForGeneration::
GGS_sortedListTypeForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_sortedListTypeForGeneration GGS_sortedListTypeForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_sortedListTypeForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_sortedListTypeForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_sortedListTypeForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_sortedListTypeForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_sortedListTypeForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sortedListTypeForGeneration GGS_sortedListTypeForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_typedAttributeList & argument_1,
                 const GGS_sortDescriptorListForGeneration & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_sortedListTypeForGeneration result ;
  macroMyNew (result.mPointer, cPtr_sortedListTypeForGeneration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typedAttributeList  GGS_sortedListTypeForGeneration::
reader_mTypedAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typedAttributeList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sortedListTypeForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sortedListTypeForGeneration *) mPointer)->mTypedAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sortDescriptorListForGeneration  GGS_sortedListTypeForGeneration::
reader_mSortDescriptorList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_sortDescriptorListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sortedListTypeForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sortedListTypeForGeneration *) mPointer)->mSortDescriptorList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_sortedListTypeForGeneration::actualTypeName (void) const {
  return "sortedListTypeForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__sortedListTypeForGeneration ("sortedListTypeForGeneration", gClassInfoFor__semanticTypeForGeneration, & kTypeDescriptor_GGS_sortedListTypeForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_sortedListTypeForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_sortedListTypeForGeneration * p = NULL ;
    macroMyNew (p, GGS_sortedListTypeForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sortedListTypeForGeneration GGS_sortedListTypeForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_sortedListTypeForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_sortedListTypeForGeneration * p = dynamic_cast <const GGS_sortedListTypeForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_sortedListTypeForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_sortedListTypeForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_sortedListTypeForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//     Element of list '@enumMessageAssociationSortedListForGeneration'      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_enumMessageAssociationSortedListForGeneration::
elementOf_GGS_enumMessageAssociationSortedListForGeneration (const GGS_uint & argument_0,
                                const GGS_string& argument_1,
                                const GGS_string& argument_2):
mConstantIndex (argument_0),
mConstantName (argument_1),
mMessage (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_enumMessageAssociationSortedListForGeneration::
isEqualToObject (const cSortedListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_enumMessageAssociationSortedListForGeneration * ptr = dynamic_cast <const elementOf_GGS_enumMessageAssociationSortedListForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mConstantIndex.operator_isEqual (ptr->mConstantIndex).boolValue ()
         && mConstantName.operator_isEqual (ptr->mConstantName).boolValue ()
         && mMessage.operator_isEqual (ptr->mMessage).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

PMSInt32 elementOf_GGS_enumMessageAssociationSortedListForGeneration::
compareForSorting (const cSortedListElement * inOperand) const {
  const elementOf_GGS_enumMessageAssociationSortedListForGeneration * operand = (const elementOf_GGS_enumMessageAssociationSortedListForGeneration *) inOperand ;
  PMSInt32 result = mConstantIndex.genericObjectCompare (operand->mConstantIndex) ;
  return result ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_enumMessageAssociationSortedListForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mConstantIndex.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mConstantName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMessage.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//       Sorted list '@enumMessageAssociationSortedListForGeneration'        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_enumMessageAssociationSortedListForGeneration ("enumMessageAssociationSortedListForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

GGS_enumMessageAssociationSortedListForGeneration::GGS_enumMessageAssociationSortedListForGeneration (void): AC_GGS_sortedlist () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_enumMessageAssociationSortedListForGeneration::
GGS_enumMessageAssociationSortedListForGeneration (const GGS_enumMessageAssociationSortedListForGeneration & inSource): AC_GGS_sortedlist (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_enumMessageAssociationSortedListForGeneration::
operator_isEqual (const GGS_enumMessageAssociationSortedListForGeneration & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_enumMessageAssociationSortedListForGeneration::
operator_isNotEqual (const GGS_enumMessageAssociationSortedListForGeneration & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationSortedListForGeneration::
internalAppendValues (const GGS_uint & argument_0,
                    const GGS_string& argument_1,
                    const GGS_string& argument_2) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationSortedListForGeneration::
addAssign_operation (const GGS_uint & argument_0,
                                const GGS_string& argument_1,
                                const GGS_string& argument_2) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

GGS_enumMessageAssociationSortedListForGeneration GGS_enumMessageAssociationSortedListForGeneration::
operator_concat (const GGS_enumMessageAssociationSortedListForGeneration & inOperand) const {
  GGS_enumMessageAssociationSortedListForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationSortedListForGeneration::
dotAssign_operation (const GGS_enumMessageAssociationSortedListForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      *this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_enumMessageAssociationSortedListForGeneration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_uint  p_0 = p->mConstantIndex ;
          GGS_string p_1 = p->mConstantName ;
          GGS_string p_2 = p->mMessage ;
          internalAppendValues (p_0, p_1, p_2) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationSortedListForGeneration::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mConstantIndex,
                                ptr->mConstantName,
                                ptr->mMessage) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_enumMessageAssociationSortedListForGeneration  GGS_enumMessageAssociationSortedListForGeneration::
constructor_emptySortedList (void) {
  GGS_enumMessageAssociationSortedListForGeneration result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMessageAssociationSortedListForGeneration  GGS_enumMessageAssociationSortedListForGeneration::
constructor_sortedListWithValue (const GGS_uint & argument_0,
                           const GGS_string& argument_1,
                           const GGS_string& argument_2) {
  GGS_enumMessageAssociationSortedListForGeneration result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_enumMessageAssociationSortedListForGeneration::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@enumMessageAssociationSortedListForGeneration", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationSortedListForGeneration::
method_smallest (C_Compiler & inLexique,
                 GGS_uint & _out_0,
                 GGS_string& _out_1,
                 GGS_string& _out_2
                 COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mConstantIndex ;
    _out_1 = ptr->mConstantName ;
    _out_2 = ptr->mMessage ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationSortedListForGeneration::
method_greatest (C_Compiler & inLexique,
             GGS_uint & _out_0,
             GGS_string& _out_1,
             GGS_string& _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'greatest' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mConstantIndex ;
    _out_1 = ptr->mConstantName ;
    _out_2 = ptr->mMessage ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationSortedListForGeneration::
modifier_popSmallest (C_Compiler & inLexique,
                 GGS_uint & _out_0,
                 GGS_string& _out_1,
                 GGS_string& _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popSmallest' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mConstantIndex ;
    _out_1 = ptr->mConstantName ;
    _out_2 = ptr->mMessage ;
    insulateList () ;
    _internalRemoveSmallest () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationSortedListForGeneration::
modifier_popGreatest (C_Compiler & inLexique,
                GGS_uint & _out_0,
                GGS_string& _out_1,
                GGS_string& _out_2
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popGreatest' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mConstantIndex ;
    _out_1 = ptr->mConstantName ;
    _out_2 = ptr->mMessage ;
    insulateList () ;
    _internalRemoveGreatest () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_enumMessageAssociationSortedListForGeneration::cEnumerator::_mConstantIndex (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mConstantIndex ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_enumMessageAssociationSortedListForGeneration::cEnumerator::_mConstantName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mConstantName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_enumMessageAssociationSortedListForGeneration::cEnumerator::_mMessage (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mMessage ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_enumMessageAssociationSortedListForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_enumMessageAssociationSortedListForGeneration * p = NULL ;
    macroMyNew (p, GGS_enumMessageAssociationSortedListForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMessageAssociationSortedListForGeneration GGS_enumMessageAssociationSortedListForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_enumMessageAssociationSortedListForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_enumMessageAssociationSortedListForGeneration * p = dynamic_cast <const GGS_enumMessageAssociationSortedListForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_enumMessageAssociationSortedListForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_enumMessageAssociationSortedListForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_enumMessageAssociationSortedListForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@enumMessageListForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_enumMessageListForGeneration::
elementOf_GGS_enumMessageListForGeneration (const GGS_string& argument_0,
                                const GGS_enumMessageAssociationSortedListForGeneration & argument_1
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mEnumMessageName (argument_0),
mMessageAssociationList (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_enumMessageListForGeneration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_enumMessageListForGeneration * ptr = dynamic_cast <const elementOf_GGS_enumMessageListForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mEnumMessageName.operator_isEqual (ptr->mEnumMessageName).boolValue ()
         && mMessageAssociationList.operator_isEqual (ptr->mMessageAssociationList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_enumMessageListForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEnumMessageName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMessageAssociationList.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@enumMessageListForGeneration'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_enumMessageListForGeneration ("enumMessageListForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_enumMessageListForGeneration::
internalAppendValues (const GGS_string& argument_0,
                    const GGS_enumMessageAssociationSortedListForGeneration & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageListForGeneration::
internalPrependValues (const GGS_string& argument_0,
                    const GGS_enumMessageAssociationSortedListForGeneration & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageListForGeneration::
addAssign_operation (const GGS_string& argument_0,
                                const GGS_enumMessageAssociationSortedListForGeneration & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_enumMessageListForGeneration GGS_enumMessageListForGeneration::
operator_concat (const GGS_enumMessageListForGeneration & inOperand) const {
  GGS_enumMessageListForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageListForGeneration::
dotAssign_operation (const GGS_enumMessageListForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_enumMessageListForGeneration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_string p_0 = p->mEnumMessageName ;
          GGS_enumMessageAssociationSortedListForGeneration  p_1 = p->mMessageAssociationList ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageListForGeneration::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_string& argument_0,
                     const GGS_enumMessageAssociationSortedListForGeneration & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageListForGeneration::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mEnumMessageName,
                                ptr->mMessageAssociationList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_enumMessageListForGeneration  GGS_enumMessageListForGeneration::
constructor_emptyList (void) {
  GGS_enumMessageListForGeneration result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMessageListForGeneration  GGS_enumMessageListForGeneration::
constructor_listWithValue (const GGS_string& argument_0,
                                const GGS_enumMessageAssociationSortedListForGeneration & argument_1) {
  GGS_enumMessageListForGeneration result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageListForGeneration::
internalSubListWithRange (GGS_enumMessageListForGeneration & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mEnumMessageName, ptr->mMessageAssociationList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_enumMessageListForGeneration GGS_enumMessageListForGeneration::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_enumMessageListForGeneration result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMessageListForGeneration GGS_enumMessageListForGeneration::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_enumMessageListForGeneration result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_enumMessageListForGeneration::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@enumMessageListForGeneration", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageListForGeneration::
method_first (C_Compiler & inLexique,
              GGS_string& _out_0,
              GGS_enumMessageAssociationSortedListForGeneration & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mEnumMessageName ;
    _out_1 = ptr->mMessageAssociationList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageListForGeneration::
method_last (C_Compiler & inLexique,
             GGS_string& _out_0,
             GGS_enumMessageAssociationSortedListForGeneration & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mEnumMessageName ;
    _out_1 = ptr->mMessageAssociationList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageListForGeneration::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_string& _out_0,
                 GGS_enumMessageAssociationSortedListForGeneration & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mEnumMessageName ;
    _out_1 = ptr->mMessageAssociationList ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageListForGeneration::
modifier_popLast (C_Compiler & inLexique,
                GGS_string& _out_0,
                GGS_enumMessageAssociationSortedListForGeneration & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mEnumMessageName ;
    _out_1 = ptr->mMessageAssociationList ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_string GGS_enumMessageListForGeneration::
reader_mEnumMessageNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_string result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mEnumMessageName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMessageAssociationSortedListForGeneration  GGS_enumMessageListForGeneration::
reader_mMessageAssociationListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_enumMessageAssociationSortedListForGeneration  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mMessageAssociationList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageListForGeneration::
modifier_setMEnumMessageNameAtIndex (C_Compiler & inLexique,
                              const GGS_string & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mEnumMessageName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageListForGeneration::
modifier_setMMessageAssociationListAtIndex (C_Compiler & inLexique,
                              const GGS_enumMessageAssociationSortedListForGeneration  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mMessageAssociationList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_enumMessageListForGeneration::cEnumerator::_mEnumMessageName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mEnumMessageName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_enumMessageAssociationSortedListForGeneration  & GGS_enumMessageListForGeneration::cEnumerator::_mMessageAssociationList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mMessageAssociationList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_enumMessageListForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_enumMessageListForGeneration * p = NULL ;
    macroMyNew (p, GGS_enumMessageListForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMessageListForGeneration GGS_enumMessageListForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_enumMessageListForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_enumMessageListForGeneration * p = dynamic_cast <const GGS_enumMessageListForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_enumMessageListForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_enumMessageListForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_enumMessageListForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_enumTypeForGeneration'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_enumTypeForGeneration::
cPtr_enumTypeForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_stringlist & argument_1,
                                const GGS_enumMessageListForGeneration & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticTypeForGeneration (argument_0 COMMA_THERE),
mConstantList (argument_1),
mEnumMessageList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_enumTypeForGeneration * GGS_enumTypeForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_enumTypeForGeneration) ;
    return (cPtr_enumTypeForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_enumTypeForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_enumTypeForGeneration * ptr = dynamic_cast <const cPtr_enumTypeForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTypeIndex.operator_isEqual (ptr->mTypeIndex).boolValue ()
         && mConstantList.operator_isEqual (ptr->mConstantList).boolValue ()
         && mEnumMessageList.operator_isEqual (ptr->mEnumMessageList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_enumTypeForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@enumTypeForGeneration:"
           << mTypeIndex.reader_description (inIndentation + 1)
           << mConstantList.reader_description (inIndentation + 1)
           << mEnumMessageList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_enumTypeForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_enumTypeForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_enumTypeForGeneration (& typeid (cPtr_enumTypeForGeneration), & typeid (cPtr_semanticTypeForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_enumTypeForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__enumTypeForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_enumTypeForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_enumTypeForGeneration (mTypeIndex, mConstantList, mEnumMessageList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_enumTypeForGeneration'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_enumTypeForGeneration ("enumTypeForGeneration", true, & kTypeDescriptor_GGS_semanticTypeForGeneration) ;

//---------------------------------------------------------------------------*

GGS_enumTypeForGeneration::
GGS_enumTypeForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_enumTypeForGeneration::
GGS_enumTypeForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_enumTypeForGeneration GGS_enumTypeForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_enumTypeForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_enumTypeForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_enumTypeForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_enumTypeForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_enumTypeForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumTypeForGeneration GGS_enumTypeForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_stringlist & argument_1,
                 const GGS_enumMessageListForGeneration & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_enumTypeForGeneration result ;
  macroMyNew (result.mPointer, cPtr_enumTypeForGeneration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringlist  GGS_enumTypeForGeneration::
reader_mConstantList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_stringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumTypeForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumTypeForGeneration *) mPointer)->mConstantList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMessageListForGeneration  GGS_enumTypeForGeneration::
reader_mEnumMessageList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_enumMessageListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumTypeForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumTypeForGeneration *) mPointer)->mEnumMessageList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_enumTypeForGeneration::actualTypeName (void) const {
  return "enumTypeForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__enumTypeForGeneration ("enumTypeForGeneration", gClassInfoFor__semanticTypeForGeneration, & kTypeDescriptor_GGS_enumTypeForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_enumTypeForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_enumTypeForGeneration * p = NULL ;
    macroMyNew (p, GGS_enumTypeForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumTypeForGeneration GGS_enumTypeForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_enumTypeForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_enumTypeForGeneration * p = dynamic_cast <const GGS_enumTypeForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_enumTypeForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_enumTypeForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_enumTypeForGeneration ;
}

//---------------------------------------------------------------------------*

