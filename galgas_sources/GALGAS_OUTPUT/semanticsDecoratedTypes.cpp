//---------------------------------------------------------------------------*
//                                                                           *
//                    File 'semanticsDecoratedTypes.cpp'                     *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                      march 15th, 2010, at 12h3'59"                        *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "galgas/C_galgas_CLI_Options.h"
#include "semanticsDecoratedTypes.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "semanticsDecoratedTypes.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'cPtr_semanticDeclarationForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_semanticDeclarationForGeneration::
cPtr_semanticDeclarationForGeneration (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_semanticDeclarationForGeneration * GGS_semanticDeclarationForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_semanticDeclarationForGeneration) ;
    return (cPtr_semanticDeclarationForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_semanticDeclarationForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@semanticDeclarationForGeneration:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_semanticDeclarationForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_semanticDeclarationForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_semanticDeclarationForGeneration (& typeid (cPtr_semanticDeclarationForGeneration), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_semanticDeclarationForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__semanticDeclarationForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_semanticDeclarationForGeneration'             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_semanticDeclarationForGeneration ("semanticDeclarationForGeneration", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_semanticDeclarationForGeneration::
GGS_semanticDeclarationForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationForGeneration::
GGS_semanticDeclarationForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_semanticDeclarationForGeneration GGS_semanticDeclarationForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_semanticDeclarationForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_semanticDeclarationForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_semanticDeclarationForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_semanticDeclarationForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_semanticDeclarationForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_semanticDeclarationForGeneration::actualTypeName (void) const {
  return "semanticDeclarationForGeneration" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_semanticDeclarationForGeneration::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__semanticDeclarationForGeneration ("semanticDeclarationForGeneration", & kTypeDescriptor_GGS_semanticDeclarationForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_semanticDeclarationForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_semanticDeclarationForGeneration * p = NULL ;
    macroMyNew (p, GGS_semanticDeclarationForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationForGeneration GGS_semanticDeclarationForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_semanticDeclarationForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_semanticDeclarationForGeneration * p = dynamic_cast <const GGS_semanticDeclarationForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_semanticDeclarationForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_semanticDeclarationForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_semanticDeclarationForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         Element of list '@semanticDeclarationListForGeneration'           *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_semanticDeclarationListForGeneration::
elementOf_GGS_semanticDeclarationListForGeneration (const GGS_semanticDeclarationForGeneration & argument_0
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mDeclaration (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_semanticDeclarationListForGeneration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_semanticDeclarationListForGeneration * ptr = dynamic_cast <const elementOf_GGS_semanticDeclarationListForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mDeclaration.operator_isEqual (ptr->mDeclaration).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_semanticDeclarationListForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mDeclaration.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               List '@semanticDeclarationListForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_semanticDeclarationListForGeneration ("semanticDeclarationListForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationListForGeneration::
internalAppendValues (const GGS_semanticDeclarationForGeneration & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationListForGeneration::
internalPrependValues (const GGS_semanticDeclarationForGeneration & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationListForGeneration::
addAssign_operation (const GGS_semanticDeclarationForGeneration & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationListForGeneration GGS_semanticDeclarationListForGeneration::
operator_concat (const GGS_semanticDeclarationListForGeneration & inOperand) const {
  GGS_semanticDeclarationListForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationListForGeneration::
dotAssign_operation (const GGS_semanticDeclarationListForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_semanticDeclarationListForGeneration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_semanticDeclarationForGeneration  p_0 = p->mDeclaration ;
          internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationListForGeneration::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_semanticDeclarationForGeneration & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationListForGeneration::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mDeclaration
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationListForGeneration  GGS_semanticDeclarationListForGeneration::
constructor_emptyList (void) {
  GGS_semanticDeclarationListForGeneration result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationListForGeneration  GGS_semanticDeclarationListForGeneration::
constructor_listWithValue (const GGS_semanticDeclarationForGeneration & argument_0) {
  GGS_semanticDeclarationListForGeneration result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationListForGeneration::
internalSubListWithRange (GGS_semanticDeclarationListForGeneration & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mDeclaration) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationListForGeneration GGS_semanticDeclarationListForGeneration::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_semanticDeclarationListForGeneration result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationListForGeneration GGS_semanticDeclarationListForGeneration::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_semanticDeclarationListForGeneration result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_semanticDeclarationListForGeneration::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@semanticDeclarationListForGeneration", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationListForGeneration::
method_first (C_Compiler & inLexique,
              GGS_semanticDeclarationForGeneration & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mDeclaration ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationListForGeneration::
method_last (C_Compiler & inLexique,
             GGS_semanticDeclarationForGeneration & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mDeclaration ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationListForGeneration::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_semanticDeclarationForGeneration & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mDeclaration ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationListForGeneration::
modifier_popLast (C_Compiler & inLexique,
                GGS_semanticDeclarationForGeneration & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mDeclaration ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationForGeneration  GGS_semanticDeclarationListForGeneration::
reader_mDeclarationAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticDeclarationForGeneration  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mDeclaration ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationListForGeneration::
modifier_setMDeclarationAtIndex (C_Compiler & inLexique,
                              const GGS_semanticDeclarationForGeneration  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mDeclaration = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticDeclarationForGeneration  & GGS_semanticDeclarationListForGeneration::cEnumerator::_mDeclaration (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mDeclaration ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_semanticDeclarationListForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_semanticDeclarationListForGeneration * p = NULL ;
    macroMyNew (p, GGS_semanticDeclarationListForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationListForGeneration GGS_semanticDeclarationListForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_semanticDeclarationListForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_semanticDeclarationListForGeneration * p = dynamic_cast <const GGS_semanticDeclarationListForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_semanticDeclarationListForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_semanticDeclarationListForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_semanticDeclarationListForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_semanticTypeForGeneration'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_semanticTypeForGeneration::
cPtr_semanticTypeForGeneration (const GGS_unifiedTypeMapIndex & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_semanticDeclarationForGeneration (THERE),
mTypeIndex (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_semanticTypeForGeneration * GGS_semanticTypeForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_semanticTypeForGeneration) ;
    return (cPtr_semanticTypeForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_semanticTypeForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@semanticTypeForGeneration:"
           << mTypeIndex.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_semanticTypeForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_semanticTypeForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_semanticTypeForGeneration (& typeid (cPtr_semanticTypeForGeneration), & typeid (cPtr_semanticDeclarationForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_semanticTypeForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__semanticTypeForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_semanticTypeForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_semanticTypeForGeneration ("semanticTypeForGeneration", true, & kTypeDescriptor_GGS_semanticDeclarationForGeneration) ;

//---------------------------------------------------------------------------*

GGS_semanticTypeForGeneration::
GGS_semanticTypeForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_semanticTypeForGeneration::
GGS_semanticTypeForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_semanticTypeForGeneration GGS_semanticTypeForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_semanticTypeForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_semanticTypeForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_semanticTypeForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_semanticTypeForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_semanticTypeForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapIndex  GGS_semanticTypeForGeneration::
reader_mTypeIndex (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_unifiedTypeMapIndex   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_semanticTypeForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_semanticTypeForGeneration *) mPointer)->mTypeIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_semanticTypeForGeneration::actualTypeName (void) const {
  return "semanticTypeForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__semanticTypeForGeneration ("semanticTypeForGeneration", gClassInfoFor__semanticDeclarationForGeneration, & kTypeDescriptor_GGS_semanticTypeForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_semanticTypeForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_semanticTypeForGeneration * p = NULL ;
    macroMyNew (p, GGS_semanticTypeForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticTypeForGeneration GGS_semanticTypeForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_semanticTypeForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_semanticTypeForGeneration * p = dynamic_cast <const GGS_semanticTypeForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_semanticTypeForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_semanticTypeForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_semanticTypeForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_primitiveTypeForGeneration'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_primitiveTypeForGeneration::
cPtr_primitiveTypeForGeneration (const GGS_unifiedTypeMapIndex & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_semanticTypeForGeneration (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_primitiveTypeForGeneration * GGS_primitiveTypeForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_primitiveTypeForGeneration) ;
    return (cPtr_primitiveTypeForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_primitiveTypeForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_primitiveTypeForGeneration * ptr = dynamic_cast <const cPtr_primitiveTypeForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTypeIndex.operator_isEqual (ptr->mTypeIndex).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_primitiveTypeForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@primitiveTypeForGeneration:"
           << mTypeIndex.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_primitiveTypeForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_primitiveTypeForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_primitiveTypeForGeneration (& typeid (cPtr_primitiveTypeForGeneration), & typeid (cPtr_semanticTypeForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_primitiveTypeForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__primitiveTypeForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_primitiveTypeForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_primitiveTypeForGeneration (mTypeIndex COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_primitiveTypeForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_primitiveTypeForGeneration ("primitiveTypeForGeneration", true, & kTypeDescriptor_GGS_semanticTypeForGeneration) ;

//---------------------------------------------------------------------------*

GGS_primitiveTypeForGeneration::
GGS_primitiveTypeForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_primitiveTypeForGeneration::
GGS_primitiveTypeForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_primitiveTypeForGeneration GGS_primitiveTypeForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_primitiveTypeForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_primitiveTypeForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_primitiveTypeForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_primitiveTypeForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_primitiveTypeForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_primitiveTypeForGeneration GGS_primitiveTypeForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapIndex & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_primitiveTypeForGeneration result ;
  macroMyNew (result.mPointer, cPtr_primitiveTypeForGeneration (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_primitiveTypeForGeneration::actualTypeName (void) const {
  return "primitiveTypeForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__primitiveTypeForGeneration ("primitiveTypeForGeneration", gClassInfoFor__semanticTypeForGeneration, & kTypeDescriptor_GGS_primitiveTypeForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_primitiveTypeForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_primitiveTypeForGeneration * p = NULL ;
    macroMyNew (p, GGS_primitiveTypeForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_primitiveTypeForGeneration GGS_primitiveTypeForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_primitiveTypeForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_primitiveTypeForGeneration * p = dynamic_cast <const GGS_primitiveTypeForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_primitiveTypeForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_primitiveTypeForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_primitiveTypeForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_listTypeForGeneration'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_listTypeForGeneration::
cPtr_listTypeForGeneration (const GGS_unifiedTypeMapIndex & argument_0,
                                const GGS_typedAttributeList & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticTypeForGeneration (argument_0 COMMA_THERE),
mTypedAttributeList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_listTypeForGeneration * GGS_listTypeForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_listTypeForGeneration) ;
    return (cPtr_listTypeForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_listTypeForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_listTypeForGeneration * ptr = dynamic_cast <const cPtr_listTypeForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTypeIndex.operator_isEqual (ptr->mTypeIndex).boolValue ()
         && mTypedAttributeList.operator_isEqual (ptr->mTypedAttributeList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_listTypeForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@listTypeForGeneration:"
           << mTypeIndex.reader_description (inIndentation + 1)
           << mTypedAttributeList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_listTypeForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_listTypeForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_listTypeForGeneration (& typeid (cPtr_listTypeForGeneration), & typeid (cPtr_semanticTypeForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_listTypeForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__listTypeForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_listTypeForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_listTypeForGeneration (mTypeIndex, mTypedAttributeList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_listTypeForGeneration'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_listTypeForGeneration ("listTypeForGeneration", true, & kTypeDescriptor_GGS_semanticTypeForGeneration) ;

//---------------------------------------------------------------------------*

GGS_listTypeForGeneration::
GGS_listTypeForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_listTypeForGeneration::
GGS_listTypeForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_listTypeForGeneration GGS_listTypeForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_listTypeForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_listTypeForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_listTypeForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_listTypeForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_listTypeForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_listTypeForGeneration GGS_listTypeForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapIndex & argument_0,
                 const GGS_typedAttributeList & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_listTypeForGeneration result ;
  macroMyNew (result.mPointer, cPtr_listTypeForGeneration (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typedAttributeList  GGS_listTypeForGeneration::
reader_mTypedAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typedAttributeList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_listTypeForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_listTypeForGeneration *) mPointer)->mTypedAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_listTypeForGeneration::actualTypeName (void) const {
  return "listTypeForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__listTypeForGeneration ("listTypeForGeneration", gClassInfoFor__semanticTypeForGeneration, & kTypeDescriptor_GGS_listTypeForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_listTypeForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_listTypeForGeneration * p = NULL ;
    macroMyNew (p, GGS_listTypeForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_listTypeForGeneration GGS_listTypeForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_listTypeForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_listTypeForGeneration * p = dynamic_cast <const GGS_listTypeForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_listTypeForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_listTypeForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_listTypeForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_structDeclarationForGeneration'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_structDeclarationForGeneration::
cPtr_structDeclarationForGeneration (const GGS_unifiedTypeMapIndex & argument_0,
                                const GGS_typedAttributeList & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticTypeForGeneration (argument_0 COMMA_THERE),
mCurrentTypedAttributeList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_structDeclarationForGeneration * GGS_structDeclarationForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_structDeclarationForGeneration) ;
    return (cPtr_structDeclarationForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_structDeclarationForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_structDeclarationForGeneration * ptr = dynamic_cast <const cPtr_structDeclarationForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTypeIndex.operator_isEqual (ptr->mTypeIndex).boolValue ()
         && mCurrentTypedAttributeList.operator_isEqual (ptr->mCurrentTypedAttributeList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_structDeclarationForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@structDeclarationForGeneration:"
           << mTypeIndex.reader_description (inIndentation + 1)
           << mCurrentTypedAttributeList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_structDeclarationForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_structDeclarationForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_structDeclarationForGeneration (& typeid (cPtr_structDeclarationForGeneration), & typeid (cPtr_semanticTypeForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_structDeclarationForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__structDeclarationForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_structDeclarationForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_structDeclarationForGeneration (mTypeIndex, mCurrentTypedAttributeList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_structDeclarationForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_structDeclarationForGeneration ("structDeclarationForGeneration", true, & kTypeDescriptor_GGS_semanticTypeForGeneration) ;

//---------------------------------------------------------------------------*

GGS_structDeclarationForGeneration::
GGS_structDeclarationForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_structDeclarationForGeneration::
GGS_structDeclarationForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_structDeclarationForGeneration GGS_structDeclarationForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_structDeclarationForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_structDeclarationForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_structDeclarationForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_structDeclarationForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_structDeclarationForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_structDeclarationForGeneration GGS_structDeclarationForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapIndex & argument_0,
                 const GGS_typedAttributeList & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_structDeclarationForGeneration result ;
  macroMyNew (result.mPointer, cPtr_structDeclarationForGeneration (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typedAttributeList  GGS_structDeclarationForGeneration::
reader_mCurrentTypedAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typedAttributeList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_structDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_structDeclarationForGeneration *) mPointer)->mCurrentTypedAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_structDeclarationForGeneration::actualTypeName (void) const {
  return "structDeclarationForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__structDeclarationForGeneration ("structDeclarationForGeneration", gClassInfoFor__semanticTypeForGeneration, & kTypeDescriptor_GGS_structDeclarationForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_structDeclarationForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_structDeclarationForGeneration * p = NULL ;
    macroMyNew (p, GGS_structDeclarationForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_structDeclarationForGeneration GGS_structDeclarationForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_structDeclarationForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_structDeclarationForGeneration * p = dynamic_cast <const GGS_structDeclarationForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_structDeclarationForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_structDeclarationForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_structDeclarationForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        Element of list '@enumMessageAssociationListForGeneration'         *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_enumMessageAssociationListForGeneration::
elementOf_GGS_enumMessageAssociationListForGeneration (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mConstantName (argument_0),
mMessage (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_enumMessageAssociationListForGeneration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_enumMessageAssociationListForGeneration * ptr = dynamic_cast <const elementOf_GGS_enumMessageAssociationListForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mConstantName.operator_isEqual (ptr->mConstantName).boolValue ()
         && mMessage.operator_isEqual (ptr->mMessage).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_enumMessageAssociationListForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mConstantName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMessage.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             List '@enumMessageAssociationListForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_enumMessageAssociationListForGeneration ("enumMessageAssociationListForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationListForGeneration::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationListForGeneration::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationListForGeneration::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_enumMessageAssociationListForGeneration GGS_enumMessageAssociationListForGeneration::
operator_concat (const GGS_enumMessageAssociationListForGeneration & inOperand) const {
  GGS_enumMessageAssociationListForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationListForGeneration::
dotAssign_operation (const GGS_enumMessageAssociationListForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_enumMessageAssociationListForGeneration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mConstantName ;
          GGS_lstring  p_1 = p->mMessage ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationListForGeneration::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationListForGeneration::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mConstantName,
                                ptr->mMessage
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_enumMessageAssociationListForGeneration  GGS_enumMessageAssociationListForGeneration::
constructor_emptyList (void) {
  GGS_enumMessageAssociationListForGeneration result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMessageAssociationListForGeneration  GGS_enumMessageAssociationListForGeneration::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  GGS_enumMessageAssociationListForGeneration result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationListForGeneration::
internalSubListWithRange (GGS_enumMessageAssociationListForGeneration & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mConstantName, ptr->mMessage) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_enumMessageAssociationListForGeneration GGS_enumMessageAssociationListForGeneration::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_enumMessageAssociationListForGeneration result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMessageAssociationListForGeneration GGS_enumMessageAssociationListForGeneration::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_enumMessageAssociationListForGeneration result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_enumMessageAssociationListForGeneration::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@enumMessageAssociationListForGeneration", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationListForGeneration::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mConstantName ;
    _out_1 = ptr->mMessage ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationListForGeneration::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mConstantName ;
    _out_1 = ptr->mMessage ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationListForGeneration::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mConstantName ;
    _out_1 = ptr->mMessage ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationListForGeneration::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mConstantName ;
    _out_1 = ptr->mMessage ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_enumMessageAssociationListForGeneration::
reader_mConstantNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mConstantName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_enumMessageAssociationListForGeneration::
reader_mMessageAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mMessage ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationListForGeneration::
modifier_setMConstantNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mConstantName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationListForGeneration::
modifier_setMMessageAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mMessage = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_enumMessageAssociationListForGeneration::cEnumerator::_mConstantName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mConstantName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_enumMessageAssociationListForGeneration::cEnumerator::_mMessage (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mMessage ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_enumMessageAssociationListForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_enumMessageAssociationListForGeneration * p = NULL ;
    macroMyNew (p, GGS_enumMessageAssociationListForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMessageAssociationListForGeneration GGS_enumMessageAssociationListForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_enumMessageAssociationListForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_enumMessageAssociationListForGeneration * p = dynamic_cast <const GGS_enumMessageAssociationListForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_enumMessageAssociationListForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_enumMessageAssociationListForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_enumMessageAssociationListForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@enumMessageListForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_enumMessageListForGeneration::
elementOf_GGS_enumMessageListForGeneration (const GGS_lstring & argument_0,
                                const GGS_enumMessageAssociationListForGeneration & argument_1
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mEnumMessageName (argument_0),
mMessageAssociationList (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_enumMessageListForGeneration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_enumMessageListForGeneration * ptr = dynamic_cast <const elementOf_GGS_enumMessageListForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mEnumMessageName.operator_isEqual (ptr->mEnumMessageName).boolValue ()
         && mMessageAssociationList.operator_isEqual (ptr->mMessageAssociationList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_enumMessageListForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEnumMessageName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMessageAssociationList.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@enumMessageListForGeneration'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_enumMessageListForGeneration ("enumMessageListForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_enumMessageListForGeneration::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_enumMessageAssociationListForGeneration & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageListForGeneration::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_enumMessageAssociationListForGeneration & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageListForGeneration::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_enumMessageAssociationListForGeneration & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_enumMessageListForGeneration GGS_enumMessageListForGeneration::
operator_concat (const GGS_enumMessageListForGeneration & inOperand) const {
  GGS_enumMessageListForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageListForGeneration::
dotAssign_operation (const GGS_enumMessageListForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_enumMessageListForGeneration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mEnumMessageName ;
          GGS_enumMessageAssociationListForGeneration  p_1 = p->mMessageAssociationList ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageListForGeneration::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_enumMessageAssociationListForGeneration & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageListForGeneration::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mEnumMessageName,
                                ptr->mMessageAssociationList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_enumMessageListForGeneration  GGS_enumMessageListForGeneration::
constructor_emptyList (void) {
  GGS_enumMessageListForGeneration result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMessageListForGeneration  GGS_enumMessageListForGeneration::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_enumMessageAssociationListForGeneration & argument_1) {
  GGS_enumMessageListForGeneration result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageListForGeneration::
internalSubListWithRange (GGS_enumMessageListForGeneration & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mEnumMessageName, ptr->mMessageAssociationList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_enumMessageListForGeneration GGS_enumMessageListForGeneration::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_enumMessageListForGeneration result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMessageListForGeneration GGS_enumMessageListForGeneration::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_enumMessageListForGeneration result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_enumMessageListForGeneration::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@enumMessageListForGeneration", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageListForGeneration::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_enumMessageAssociationListForGeneration & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mEnumMessageName ;
    _out_1 = ptr->mMessageAssociationList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageListForGeneration::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_enumMessageAssociationListForGeneration & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mEnumMessageName ;
    _out_1 = ptr->mMessageAssociationList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageListForGeneration::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_enumMessageAssociationListForGeneration & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mEnumMessageName ;
    _out_1 = ptr->mMessageAssociationList ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageListForGeneration::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_enumMessageAssociationListForGeneration & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mEnumMessageName ;
    _out_1 = ptr->mMessageAssociationList ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_enumMessageListForGeneration::
reader_mEnumMessageNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mEnumMessageName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMessageAssociationListForGeneration  GGS_enumMessageListForGeneration::
reader_mMessageAssociationListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_enumMessageAssociationListForGeneration  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mMessageAssociationList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageListForGeneration::
modifier_setMEnumMessageNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mEnumMessageName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageListForGeneration::
modifier_setMMessageAssociationListAtIndex (C_Compiler & inLexique,
                              const GGS_enumMessageAssociationListForGeneration  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mMessageAssociationList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_enumMessageListForGeneration::cEnumerator::_mEnumMessageName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mEnumMessageName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_enumMessageAssociationListForGeneration  & GGS_enumMessageListForGeneration::cEnumerator::_mMessageAssociationList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mMessageAssociationList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_enumMessageListForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_enumMessageListForGeneration * p = NULL ;
    macroMyNew (p, GGS_enumMessageListForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMessageListForGeneration GGS_enumMessageListForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_enumMessageListForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_enumMessageListForGeneration * p = dynamic_cast <const GGS_enumMessageListForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_enumMessageListForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_enumMessageListForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_enumMessageListForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_enumDeclarationForGeneration'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_enumDeclarationForGeneration::
cPtr_enumDeclarationForGeneration (const GGS_lstring & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_enumMessageListForGeneration & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticDeclarationForGeneration (THERE),
mEnumTypeName (argument_0),
mConstantList (argument_1),
mEnumMessageList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_enumDeclarationForGeneration * GGS_enumDeclarationForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_enumDeclarationForGeneration) ;
    return (cPtr_enumDeclarationForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_enumDeclarationForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_enumDeclarationForGeneration * ptr = dynamic_cast <const cPtr_enumDeclarationForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mEnumTypeName.operator_isEqual (ptr->mEnumTypeName).boolValue ()
         && mConstantList.operator_isEqual (ptr->mConstantList).boolValue ()
         && mEnumMessageList.operator_isEqual (ptr->mEnumMessageList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_enumDeclarationForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@enumDeclarationForGeneration:"
           << mEnumTypeName.reader_description (inIndentation + 1)
           << mConstantList.reader_description (inIndentation + 1)
           << mEnumMessageList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_enumDeclarationForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_enumDeclarationForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_enumDeclarationForGeneration (& typeid (cPtr_enumDeclarationForGeneration), & typeid (cPtr_semanticDeclarationForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_enumDeclarationForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__enumDeclarationForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_enumDeclarationForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_enumDeclarationForGeneration (mEnumTypeName, mConstantList, mEnumMessageList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_enumDeclarationForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_enumDeclarationForGeneration ("enumDeclarationForGeneration", true, & kTypeDescriptor_GGS_semanticDeclarationForGeneration) ;

//---------------------------------------------------------------------------*

GGS_enumDeclarationForGeneration::
GGS_enumDeclarationForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_enumDeclarationForGeneration::
GGS_enumDeclarationForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_enumDeclarationForGeneration GGS_enumDeclarationForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_enumDeclarationForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_enumDeclarationForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_enumDeclarationForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_enumDeclarationForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_enumDeclarationForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumDeclarationForGeneration GGS_enumDeclarationForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstringlist & argument_1,
                 const GGS_enumMessageListForGeneration & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_enumDeclarationForGeneration result ;
  macroMyNew (result.mPointer, cPtr_enumDeclarationForGeneration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_enumDeclarationForGeneration::
reader_mEnumTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumDeclarationForGeneration *) mPointer)->mEnumTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_enumDeclarationForGeneration::
reader_mConstantList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumDeclarationForGeneration *) mPointer)->mConstantList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMessageListForGeneration  GGS_enumDeclarationForGeneration::
reader_mEnumMessageList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_enumMessageListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumDeclarationForGeneration *) mPointer)->mEnumMessageList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_enumDeclarationForGeneration::actualTypeName (void) const {
  return "enumDeclarationForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__enumDeclarationForGeneration ("enumDeclarationForGeneration", gClassInfoFor__semanticDeclarationForGeneration, & kTypeDescriptor_GGS_enumDeclarationForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_enumDeclarationForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_enumDeclarationForGeneration * p = NULL ;
    macroMyNew (p, GGS_enumDeclarationForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumDeclarationForGeneration GGS_enumDeclarationForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_enumDeclarationForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_enumDeclarationForGeneration * p = dynamic_cast <const GGS_enumDeclarationForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_enumDeclarationForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_enumDeclarationForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_enumDeclarationForGeneration ;
}

//---------------------------------------------------------------------------*

