//---------------------------------------------------------------------------*
//                                                                           *
//                    File 'semanticsDecoratedTypes.cpp'                     *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                      march 9th, 2010, at 18h25'45"                        *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "galgas/C_galgas_CLI_Options.h"
#include "semanticsDecoratedTypes.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "semanticsDecoratedTypes.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_semanticExpressionForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_semanticExpressionForGeneration::
cPtr_semanticExpressionForGeneration (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_semanticExpressionForGeneration * GGS_semanticExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_semanticExpressionForGeneration) ;
    return (cPtr_semanticExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_semanticExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@semanticExpressionForGeneration:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_semanticExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_semanticExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_semanticExpressionForGeneration (& typeid (cPtr_semanticExpressionForGeneration), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_semanticExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__semanticExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_semanticExpressionForGeneration'             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_semanticExpressionForGeneration ("semanticExpressionForGeneration", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration::
GGS_semanticExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration::
GGS_semanticExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_semanticExpressionForGeneration GGS_semanticExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_semanticExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_semanticExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_semanticExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_semanticExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_semanticExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_semanticExpressionForGeneration::actualTypeName (void) const {
  return "semanticExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_semanticExpressionForGeneration::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__semanticExpressionForGeneration ("semanticExpressionForGeneration", & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_semanticExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_semanticExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_semanticExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration GGS_semanticExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_semanticExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_semanticExpressionForGeneration * p = dynamic_cast <const GGS_semanticExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_semanticExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_semanticExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_semanticExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Element of list '@semanticExpressionListForGeneration'           *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_semanticExpressionListForGeneration::
elementOf_GGS_semanticExpressionListForGeneration (const GGS_semanticExpressionForGeneration & argument_0
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mExpression (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_semanticExpressionListForGeneration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_semanticExpressionListForGeneration * ptr = dynamic_cast <const elementOf_GGS_semanticExpressionListForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mExpression.operator_isEqual (ptr->mExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_semanticExpressionListForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mExpression.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               List '@semanticExpressionListForGeneration'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_semanticExpressionListForGeneration ("semanticExpressionListForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_semanticExpressionListForGeneration::
internalAppendValues (const GGS_semanticExpressionForGeneration & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticExpressionListForGeneration::
internalPrependValues (const GGS_semanticExpressionForGeneration & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticExpressionListForGeneration::
addAssign_operation (const GGS_semanticExpressionForGeneration & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionListForGeneration GGS_semanticExpressionListForGeneration::
operator_concat (const GGS_semanticExpressionListForGeneration & inOperand) const {
  GGS_semanticExpressionListForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_semanticExpressionListForGeneration::
dotAssign_operation (const GGS_semanticExpressionListForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_semanticExpressionListForGeneration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_semanticExpressionForGeneration  p_0 = p->mExpression ;
          internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticExpressionListForGeneration::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_semanticExpressionForGeneration & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticExpressionListForGeneration::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mExpression
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionListForGeneration  GGS_semanticExpressionListForGeneration::
constructor_emptyList (void) {
  GGS_semanticExpressionListForGeneration result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionListForGeneration  GGS_semanticExpressionListForGeneration::
constructor_listWithValue (const GGS_semanticExpressionForGeneration & argument_0) {
  GGS_semanticExpressionListForGeneration result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_semanticExpressionListForGeneration::
internalSubListWithRange (GGS_semanticExpressionListForGeneration & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mExpression) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionListForGeneration GGS_semanticExpressionListForGeneration::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_semanticExpressionListForGeneration result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionListForGeneration GGS_semanticExpressionListForGeneration::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_semanticExpressionListForGeneration result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_semanticExpressionListForGeneration::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@semanticExpressionListForGeneration", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticExpressionListForGeneration::
method_first (C_Compiler & inLexique,
              GGS_semanticExpressionForGeneration & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mExpression ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticExpressionListForGeneration::
method_last (C_Compiler & inLexique,
             GGS_semanticExpressionForGeneration & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mExpression ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticExpressionListForGeneration::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_semanticExpressionForGeneration & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mExpression ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticExpressionListForGeneration::
modifier_popLast (C_Compiler & inLexique,
                GGS_semanticExpressionForGeneration & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mExpression ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_semanticExpressionListForGeneration::
reader_mExpressionAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mExpression ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_semanticExpressionListForGeneration::
modifier_setMExpressionAtIndex (C_Compiler & inLexique,
                              const GGS_semanticExpressionForGeneration  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mExpression = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticExpressionForGeneration  & GGS_semanticExpressionListForGeneration::cEnumerator::_mExpression (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mExpression ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_semanticExpressionListForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_semanticExpressionListForGeneration * p = NULL ;
    macroMyNew (p, GGS_semanticExpressionListForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionListForGeneration GGS_semanticExpressionListForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_semanticExpressionListForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_semanticExpressionListForGeneration * p = dynamic_cast <const GGS_semanticExpressionListForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_semanticExpressionListForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_semanticExpressionListForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_semanticExpressionListForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           class 'cPtr_outSemanticExpressionListForGeneration'             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_outSemanticExpressionListForGeneration::
cPtr_outSemanticExpressionListForGeneration (const GGS_semanticExpressionListForGeneration & argument_0,
                                const GGS_location & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE),
mExpression (argument_0),
mEndOfExpressionLocation (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_outSemanticExpressionListForGeneration * GGS_outSemanticExpressionListForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_outSemanticExpressionListForGeneration) ;
    return (cPtr_outSemanticExpressionListForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_outSemanticExpressionListForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_outSemanticExpressionListForGeneration * ptr = dynamic_cast <const cPtr_outSemanticExpressionListForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mExpression.operator_isEqual (ptr->mExpression).boolValue ()
         && mEndOfExpressionLocation.operator_isEqual (ptr->mEndOfExpressionLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_outSemanticExpressionListForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@outSemanticExpressionListForGeneration:"
           << mExpression.reader_description (inIndentation + 1)
           << mEndOfExpressionLocation.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_outSemanticExpressionListForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_outSemanticExpressionListForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_outSemanticExpressionListForGeneration (& typeid (cPtr_outSemanticExpressionListForGeneration), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_outSemanticExpressionListForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__outSemanticExpressionListForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_outSemanticExpressionListForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_outSemanticExpressionListForGeneration (mExpression, mEndOfExpressionLocation COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        GALGAS class 'GGS_outSemanticExpressionListForGeneration'          *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_outSemanticExpressionListForGeneration ("outSemanticExpressionListForGeneration", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_outSemanticExpressionListForGeneration::
GGS_outSemanticExpressionListForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_outSemanticExpressionListForGeneration::
GGS_outSemanticExpressionListForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_outSemanticExpressionListForGeneration GGS_outSemanticExpressionListForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_outSemanticExpressionListForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_outSemanticExpressionListForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_outSemanticExpressionListForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_outSemanticExpressionListForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_outSemanticExpressionListForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_outSemanticExpressionListForGeneration GGS_outSemanticExpressionListForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_semanticExpressionListForGeneration & argument_0,
                 const GGS_location & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_outSemanticExpressionListForGeneration result ;
  macroMyNew (result.mPointer, cPtr_outSemanticExpressionListForGeneration (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionListForGeneration  GGS_outSemanticExpressionListForGeneration::
reader_mExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_outSemanticExpressionListForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_outSemanticExpressionListForGeneration *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_outSemanticExpressionListForGeneration::
reader_mEndOfExpressionLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_outSemanticExpressionListForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_outSemanticExpressionListForGeneration *) mPointer)->mEndOfExpressionLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_outSemanticExpressionListForGeneration::actualTypeName (void) const {
  return "outSemanticExpressionListForGeneration" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_outSemanticExpressionListForGeneration::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__outSemanticExpressionListForGeneration ("outSemanticExpressionListForGeneration", & kTypeDescriptor_GGS_outSemanticExpressionListForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_outSemanticExpressionListForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_outSemanticExpressionListForGeneration * p = NULL ;
    macroMyNew (p, GGS_outSemanticExpressionListForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_outSemanticExpressionListForGeneration GGS_outSemanticExpressionListForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_outSemanticExpressionListForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_outSemanticExpressionListForGeneration * p = dynamic_cast <const GGS_outSemanticExpressionListForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_outSemanticExpressionListForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_outSemanticExpressionListForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_outSemanticExpressionListForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_selfInExpressionForGeneration'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_selfInExpressionForGeneration::
cPtr_selfInExpressionForGeneration (LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_selfInExpressionForGeneration * GGS_selfInExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_selfInExpressionForGeneration) ;
    return (cPtr_selfInExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_selfInExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_selfInExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@selfInExpressionForGeneration:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_selfInExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_selfInExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_selfInExpressionForGeneration (& typeid (cPtr_selfInExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_selfInExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__selfInExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_selfInExpressionForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_selfInExpressionForGeneration ("selfInExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_selfInExpressionForGeneration::
GGS_selfInExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_selfInExpressionForGeneration::
GGS_selfInExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_selfInExpressionForGeneration GGS_selfInExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_selfInExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_selfInExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_selfInExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_selfInExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_selfInExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_selfInExpressionForGeneration * gSingleton_selfInExpressionForGeneration = NULL ;

//---------------------------------------------------------------------------*

GGS_selfInExpressionForGeneration GGS_selfInExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_selfInExpressionForGeneration result ;
  if (NULL == gSingleton_selfInExpressionForGeneration) {
    macroMyNew (gSingleton_selfInExpressionForGeneration, cPtr_selfInExpressionForGeneration (THERE)) ;
    macroRetainObject (gSingleton_selfInExpressionForGeneration) ;
  }
  macroAssignObject (result.mPointer, gSingleton_selfInExpressionForGeneration) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_selfInExpressionForGeneration::actualTypeName (void) const {
  return "selfInExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__selfInExpressionForGeneration ("selfInExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_selfInExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_selfInExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_selfInExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_selfInExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_selfInExpressionForGeneration GGS_selfInExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_selfInExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_selfInExpressionForGeneration * p = dynamic_cast <const GGS_selfInExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_selfInExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_selfInExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_selfInExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_hereExpressionForGeneration'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_hereExpressionForGeneration::
cPtr_hereExpressionForGeneration (LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_hereExpressionForGeneration * GGS_hereExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_hereExpressionForGeneration) ;
    return (cPtr_hereExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_hereExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_hereExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@hereExpressionForGeneration:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_hereExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_hereExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_hereExpressionForGeneration (& typeid (cPtr_hereExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_hereExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__hereExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_hereExpressionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_hereExpressionForGeneration ("hereExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_hereExpressionForGeneration::
GGS_hereExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_hereExpressionForGeneration::
GGS_hereExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_hereExpressionForGeneration GGS_hereExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_hereExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_hereExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_hereExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_hereExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_hereExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_hereExpressionForGeneration * gSingleton_hereExpressionForGeneration = NULL ;

//---------------------------------------------------------------------------*

GGS_hereExpressionForGeneration GGS_hereExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_hereExpressionForGeneration result ;
  if (NULL == gSingleton_hereExpressionForGeneration) {
    macroMyNew (gSingleton_hereExpressionForGeneration, cPtr_hereExpressionForGeneration (THERE)) ;
    macroRetainObject (gSingleton_hereExpressionForGeneration) ;
  }
  macroAssignObject (result.mPointer, gSingleton_hereExpressionForGeneration) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_hereExpressionForGeneration::actualTypeName (void) const {
  return "hereExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__hereExpressionForGeneration ("hereExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_hereExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_hereExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_hereExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_hereExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_hereExpressionForGeneration GGS_hereExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_hereExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_hereExpressionForGeneration * p = dynamic_cast <const GGS_hereExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_hereExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_hereExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_hereExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_trueExpressionForGeneration'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_trueExpressionForGeneration::
cPtr_trueExpressionForGeneration (LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_trueExpressionForGeneration * GGS_trueExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_trueExpressionForGeneration) ;
    return (cPtr_trueExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_trueExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_trueExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@trueExpressionForGeneration:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_trueExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_trueExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_trueExpressionForGeneration (& typeid (cPtr_trueExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_trueExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__trueExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_trueExpressionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_trueExpressionForGeneration ("trueExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_trueExpressionForGeneration::
GGS_trueExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_trueExpressionForGeneration::
GGS_trueExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_trueExpressionForGeneration GGS_trueExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_trueExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_trueExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_trueExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_trueExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_trueExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_trueExpressionForGeneration * gSingleton_trueExpressionForGeneration = NULL ;

//---------------------------------------------------------------------------*

GGS_trueExpressionForGeneration GGS_trueExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_trueExpressionForGeneration result ;
  if (NULL == gSingleton_trueExpressionForGeneration) {
    macroMyNew (gSingleton_trueExpressionForGeneration, cPtr_trueExpressionForGeneration (THERE)) ;
    macroRetainObject (gSingleton_trueExpressionForGeneration) ;
  }
  macroAssignObject (result.mPointer, gSingleton_trueExpressionForGeneration) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_trueExpressionForGeneration::actualTypeName (void) const {
  return "trueExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__trueExpressionForGeneration ("trueExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_trueExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_trueExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_trueExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_trueExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_trueExpressionForGeneration GGS_trueExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_trueExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_trueExpressionForGeneration * p = dynamic_cast <const GGS_trueExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_trueExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_trueExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_trueExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_falseExpressionForGeneration'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_falseExpressionForGeneration::
cPtr_falseExpressionForGeneration (LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_falseExpressionForGeneration * GGS_falseExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_falseExpressionForGeneration) ;
    return (cPtr_falseExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_falseExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_falseExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@falseExpressionForGeneration:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_falseExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_falseExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_falseExpressionForGeneration (& typeid (cPtr_falseExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_falseExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__falseExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_falseExpressionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_falseExpressionForGeneration ("falseExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_falseExpressionForGeneration::
GGS_falseExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_falseExpressionForGeneration::
GGS_falseExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_falseExpressionForGeneration GGS_falseExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_falseExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_falseExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_falseExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_falseExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_falseExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_falseExpressionForGeneration * gSingleton_falseExpressionForGeneration = NULL ;

//---------------------------------------------------------------------------*

GGS_falseExpressionForGeneration GGS_falseExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_falseExpressionForGeneration result ;
  if (NULL == gSingleton_falseExpressionForGeneration) {
    macroMyNew (gSingleton_falseExpressionForGeneration, cPtr_falseExpressionForGeneration (THERE)) ;
    macroRetainObject (gSingleton_falseExpressionForGeneration) ;
  }
  macroAssignObject (result.mPointer, gSingleton_falseExpressionForGeneration) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_falseExpressionForGeneration::actualTypeName (void) const {
  return "falseExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__falseExpressionForGeneration ("falseExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_falseExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_falseExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_falseExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_falseExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_falseExpressionForGeneration GGS_falseExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_falseExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_falseExpressionForGeneration * p = dynamic_cast <const GGS_falseExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_falseExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_falseExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_falseExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_literalCharExpressionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_literalCharExpressionForGeneration::
cPtr_literalCharExpressionForGeneration (const GGS_lchar & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (THERE),
mCharacter (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_literalCharExpressionForGeneration * GGS_literalCharExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_literalCharExpressionForGeneration) ;
    return (cPtr_literalCharExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_literalCharExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_literalCharExpressionForGeneration * ptr = dynamic_cast <const cPtr_literalCharExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mCharacter.operator_isEqual (ptr->mCharacter).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_literalCharExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@literalCharExpressionForGeneration:"
           << mCharacter.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_literalCharExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_literalCharExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_literalCharExpressionForGeneration (& typeid (cPtr_literalCharExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_literalCharExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__literalCharExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_literalCharExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_literalCharExpressionForGeneration (mCharacter COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_literalCharExpressionForGeneration'            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_literalCharExpressionForGeneration ("literalCharExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_literalCharExpressionForGeneration::
GGS_literalCharExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_literalCharExpressionForGeneration::
GGS_literalCharExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_literalCharExpressionForGeneration GGS_literalCharExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_literalCharExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_literalCharExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_literalCharExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_literalCharExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_literalCharExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalCharExpressionForGeneration GGS_literalCharExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lchar & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_literalCharExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_literalCharExpressionForGeneration (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lchar  GGS_literalCharExpressionForGeneration::
reader_mCharacter (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lchar   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_literalCharExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_literalCharExpressionForGeneration *) mPointer)->mCharacter ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_literalCharExpressionForGeneration::actualTypeName (void) const {
  return "literalCharExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__literalCharExpressionForGeneration ("literalCharExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_literalCharExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_literalCharExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_literalCharExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_literalCharExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalCharExpressionForGeneration GGS_literalCharExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_literalCharExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_literalCharExpressionForGeneration * p = dynamic_cast <const GGS_literalCharExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_literalCharExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_literalCharExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_literalCharExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            class 'cPtr_literalStringExpressionForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_literalStringExpressionForGeneration::
cPtr_literalStringExpressionForGeneration (const GGS_stringlist & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (THERE),
mStringSequence (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_literalStringExpressionForGeneration * GGS_literalStringExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_literalStringExpressionForGeneration) ;
    return (cPtr_literalStringExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_literalStringExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_literalStringExpressionForGeneration * ptr = dynamic_cast <const cPtr_literalStringExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStringSequence.operator_isEqual (ptr->mStringSequence).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_literalStringExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@literalStringExpressionForGeneration:"
           << mStringSequence.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_literalStringExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_literalStringExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_literalStringExpressionForGeneration (& typeid (cPtr_literalStringExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_literalStringExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__literalStringExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_literalStringExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_literalStringExpressionForGeneration (mStringSequence COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         GALGAS class 'GGS_literalStringExpressionForGeneration'           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_literalStringExpressionForGeneration ("literalStringExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_literalStringExpressionForGeneration::
GGS_literalStringExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_literalStringExpressionForGeneration::
GGS_literalStringExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_literalStringExpressionForGeneration GGS_literalStringExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_literalStringExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_literalStringExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_literalStringExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_literalStringExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_literalStringExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalStringExpressionForGeneration GGS_literalStringExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_stringlist & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_literalStringExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_literalStringExpressionForGeneration (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringlist  GGS_literalStringExpressionForGeneration::
reader_mStringSequence (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_stringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_literalStringExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_literalStringExpressionForGeneration *) mPointer)->mStringSequence ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_literalStringExpressionForGeneration::actualTypeName (void) const {
  return "literalStringExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__literalStringExpressionForGeneration ("literalStringExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_literalStringExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_literalStringExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_literalStringExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_literalStringExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalStringExpressionForGeneration GGS_literalStringExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_literalStringExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_literalStringExpressionForGeneration * p = dynamic_cast <const GGS_literalStringExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_literalStringExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_literalStringExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_literalStringExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            class 'cPtr_literalDoubleExpressionForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_literalDoubleExpressionForGeneration::
cPtr_literalDoubleExpressionForGeneration (const GGS_ldouble & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (THERE),
mValue (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_literalDoubleExpressionForGeneration * GGS_literalDoubleExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_literalDoubleExpressionForGeneration) ;
    return (cPtr_literalDoubleExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_literalDoubleExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_literalDoubleExpressionForGeneration * ptr = dynamic_cast <const cPtr_literalDoubleExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mValue.operator_isEqual (ptr->mValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_literalDoubleExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@literalDoubleExpressionForGeneration:"
           << mValue.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_literalDoubleExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_literalDoubleExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_literalDoubleExpressionForGeneration (& typeid (cPtr_literalDoubleExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_literalDoubleExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__literalDoubleExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_literalDoubleExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_literalDoubleExpressionForGeneration (mValue COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         GALGAS class 'GGS_literalDoubleExpressionForGeneration'           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_literalDoubleExpressionForGeneration ("literalDoubleExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_literalDoubleExpressionForGeneration::
GGS_literalDoubleExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_literalDoubleExpressionForGeneration::
GGS_literalDoubleExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_literalDoubleExpressionForGeneration GGS_literalDoubleExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_literalDoubleExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_literalDoubleExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_literalDoubleExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_literalDoubleExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_literalDoubleExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalDoubleExpressionForGeneration GGS_literalDoubleExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_ldouble & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_literalDoubleExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_literalDoubleExpressionForGeneration (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ldouble  GGS_literalDoubleExpressionForGeneration::
reader_mValue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_ldouble   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_literalDoubleExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_literalDoubleExpressionForGeneration *) mPointer)->mValue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_literalDoubleExpressionForGeneration::actualTypeName (void) const {
  return "literalDoubleExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__literalDoubleExpressionForGeneration ("literalDoubleExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_literalDoubleExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_literalDoubleExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_literalDoubleExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_literalDoubleExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalDoubleExpressionForGeneration GGS_literalDoubleExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_literalDoubleExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_literalDoubleExpressionForGeneration * p = dynamic_cast <const GGS_literalDoubleExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_literalDoubleExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_literalDoubleExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_literalDoubleExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_literalUIntExpressionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_literalUIntExpressionForGeneration::
cPtr_literalUIntExpressionForGeneration (const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (THERE),
mValue (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_literalUIntExpressionForGeneration * GGS_literalUIntExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_literalUIntExpressionForGeneration) ;
    return (cPtr_literalUIntExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_literalUIntExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_literalUIntExpressionForGeneration * ptr = dynamic_cast <const cPtr_literalUIntExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mValue.operator_isEqual (ptr->mValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_literalUIntExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@literalUIntExpressionForGeneration:"
           << mValue.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_literalUIntExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_literalUIntExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_literalUIntExpressionForGeneration (& typeid (cPtr_literalUIntExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_literalUIntExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__literalUIntExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_literalUIntExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_literalUIntExpressionForGeneration (mValue COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_literalUIntExpressionForGeneration'            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_literalUIntExpressionForGeneration ("literalUIntExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_literalUIntExpressionForGeneration::
GGS_literalUIntExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_literalUIntExpressionForGeneration::
GGS_literalUIntExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_literalUIntExpressionForGeneration GGS_literalUIntExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_literalUIntExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_literalUIntExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_literalUIntExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_literalUIntExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_literalUIntExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalUIntExpressionForGeneration GGS_literalUIntExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_literalUIntExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_literalUIntExpressionForGeneration (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_literalUIntExpressionForGeneration::
reader_mValue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_literalUIntExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_literalUIntExpressionForGeneration *) mPointer)->mValue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_literalUIntExpressionForGeneration::actualTypeName (void) const {
  return "literalUIntExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__literalUIntExpressionForGeneration ("literalUIntExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_literalUIntExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_literalUIntExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_literalUIntExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_literalUIntExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalUIntExpressionForGeneration GGS_literalUIntExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_literalUIntExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_literalUIntExpressionForGeneration * p = dynamic_cast <const GGS_literalUIntExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_literalUIntExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_literalUIntExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_literalUIntExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            class 'cPtr_literalUInt64ExpressionForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_literalUInt64ExpressionForGeneration::
cPtr_literalUInt64ExpressionForGeneration (const GGS_luint64 & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (THERE),
mValue (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_literalUInt64ExpressionForGeneration * GGS_literalUInt64ExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_literalUInt64ExpressionForGeneration) ;
    return (cPtr_literalUInt64ExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_literalUInt64ExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_literalUInt64ExpressionForGeneration * ptr = dynamic_cast <const cPtr_literalUInt64ExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mValue.operator_isEqual (ptr->mValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_literalUInt64ExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@literalUInt64ExpressionForGeneration:"
           << mValue.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_literalUInt64ExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_literalUInt64ExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_literalUInt64ExpressionForGeneration (& typeid (cPtr_literalUInt64ExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_literalUInt64ExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__literalUInt64ExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_literalUInt64ExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_literalUInt64ExpressionForGeneration (mValue COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         GALGAS class 'GGS_literalUInt64ExpressionForGeneration'           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_literalUInt64ExpressionForGeneration ("literalUInt64ExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_literalUInt64ExpressionForGeneration::
GGS_literalUInt64ExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_literalUInt64ExpressionForGeneration::
GGS_literalUInt64ExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_literalUInt64ExpressionForGeneration GGS_literalUInt64ExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_literalUInt64ExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_literalUInt64ExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_literalUInt64ExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_literalUInt64ExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_literalUInt64ExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalUInt64ExpressionForGeneration GGS_literalUInt64ExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_luint64 & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_literalUInt64ExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_literalUInt64ExpressionForGeneration (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint64  GGS_literalUInt64ExpressionForGeneration::
reader_mValue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_literalUInt64ExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_literalUInt64ExpressionForGeneration *) mPointer)->mValue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_literalUInt64ExpressionForGeneration::actualTypeName (void) const {
  return "literalUInt64ExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__literalUInt64ExpressionForGeneration ("literalUInt64ExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_literalUInt64ExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_literalUInt64ExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_literalUInt64ExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_literalUInt64ExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalUInt64ExpressionForGeneration GGS_literalUInt64ExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_literalUInt64ExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_literalUInt64ExpressionForGeneration * p = dynamic_cast <const GGS_literalUInt64ExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_literalUInt64ExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_literalUInt64ExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_literalUInt64ExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_literalSIntExpressionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_literalSIntExpressionForGeneration::
cPtr_literalSIntExpressionForGeneration (const GGS_lsint & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (THERE),
mValue (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_literalSIntExpressionForGeneration * GGS_literalSIntExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_literalSIntExpressionForGeneration) ;
    return (cPtr_literalSIntExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_literalSIntExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_literalSIntExpressionForGeneration * ptr = dynamic_cast <const cPtr_literalSIntExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mValue.operator_isEqual (ptr->mValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_literalSIntExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@literalSIntExpressionForGeneration:"
           << mValue.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_literalSIntExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_literalSIntExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_literalSIntExpressionForGeneration (& typeid (cPtr_literalSIntExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_literalSIntExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__literalSIntExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_literalSIntExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_literalSIntExpressionForGeneration (mValue COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_literalSIntExpressionForGeneration'            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_literalSIntExpressionForGeneration ("literalSIntExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_literalSIntExpressionForGeneration::
GGS_literalSIntExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_literalSIntExpressionForGeneration::
GGS_literalSIntExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_literalSIntExpressionForGeneration GGS_literalSIntExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_literalSIntExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_literalSIntExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_literalSIntExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_literalSIntExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_literalSIntExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalSIntExpressionForGeneration GGS_literalSIntExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lsint & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_literalSIntExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_literalSIntExpressionForGeneration (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lsint  GGS_literalSIntExpressionForGeneration::
reader_mValue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lsint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_literalSIntExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_literalSIntExpressionForGeneration *) mPointer)->mValue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_literalSIntExpressionForGeneration::actualTypeName (void) const {
  return "literalSIntExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__literalSIntExpressionForGeneration ("literalSIntExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_literalSIntExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_literalSIntExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_literalSIntExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_literalSIntExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalSIntExpressionForGeneration GGS_literalSIntExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_literalSIntExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_literalSIntExpressionForGeneration * p = dynamic_cast <const GGS_literalSIntExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_literalSIntExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_literalSIntExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_literalSIntExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            class 'cPtr_literalSInt64ExpressionForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_literalSInt64ExpressionForGeneration::
cPtr_literalSInt64ExpressionForGeneration (const GGS_lsint64 & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (THERE),
mValue (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_literalSInt64ExpressionForGeneration * GGS_literalSInt64ExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_literalSInt64ExpressionForGeneration) ;
    return (cPtr_literalSInt64ExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_literalSInt64ExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_literalSInt64ExpressionForGeneration * ptr = dynamic_cast <const cPtr_literalSInt64ExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mValue.operator_isEqual (ptr->mValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_literalSInt64ExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@literalSInt64ExpressionForGeneration:"
           << mValue.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_literalSInt64ExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_literalSInt64ExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_literalSInt64ExpressionForGeneration (& typeid (cPtr_literalSInt64ExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_literalSInt64ExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__literalSInt64ExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_literalSInt64ExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_literalSInt64ExpressionForGeneration (mValue COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         GALGAS class 'GGS_literalSInt64ExpressionForGeneration'           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_literalSInt64ExpressionForGeneration ("literalSInt64ExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_literalSInt64ExpressionForGeneration::
GGS_literalSInt64ExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_literalSInt64ExpressionForGeneration::
GGS_literalSInt64ExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_literalSInt64ExpressionForGeneration GGS_literalSInt64ExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_literalSInt64ExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_literalSInt64ExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_literalSInt64ExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_literalSInt64ExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_literalSInt64ExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalSInt64ExpressionForGeneration GGS_literalSInt64ExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lsint64 & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_literalSInt64ExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_literalSInt64ExpressionForGeneration (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lsint64  GGS_literalSInt64ExpressionForGeneration::
reader_mValue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lsint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_literalSInt64ExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_literalSInt64ExpressionForGeneration *) mPointer)->mValue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_literalSInt64ExpressionForGeneration::actualTypeName (void) const {
  return "literalSInt64ExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__literalSInt64ExpressionForGeneration ("literalSInt64ExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_literalSInt64ExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_literalSInt64ExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_literalSInt64ExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_literalSInt64ExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalSInt64ExpressionForGeneration GGS_literalSInt64ExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_literalSInt64ExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_literalSInt64ExpressionForGeneration * p = dynamic_cast <const GGS_literalSInt64ExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_literalSInt64ExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_literalSInt64ExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_literalSInt64ExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_constructorExpressionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_constructorExpressionForGeneration::
cPtr_constructorExpressionForGeneration (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_outSemanticExpressionListForGeneration & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (THERE),
mTypeName (argument_0),
mConstructorName (argument_1),
mExpressions (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_constructorExpressionForGeneration * GGS_constructorExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_constructorExpressionForGeneration) ;
    return (cPtr_constructorExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_constructorExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_constructorExpressionForGeneration * ptr = dynamic_cast <const cPtr_constructorExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTypeName.operator_isEqual (ptr->mTypeName).boolValue ()
         && mConstructorName.operator_isEqual (ptr->mConstructorName).boolValue ()
         && mExpressions.operator_isEqual (ptr->mExpressions).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_constructorExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@constructorExpressionForGeneration:"
           << mTypeName.reader_description (inIndentation + 1)
           << mConstructorName.reader_description (inIndentation + 1)
           << mExpressions.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_constructorExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_constructorExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_constructorExpressionForGeneration (& typeid (cPtr_constructorExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_constructorExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__constructorExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_constructorExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_constructorExpressionForGeneration (mTypeName, mConstructorName, mExpressions COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_constructorExpressionForGeneration'            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_constructorExpressionForGeneration ("constructorExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_constructorExpressionForGeneration::
GGS_constructorExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_constructorExpressionForGeneration::
GGS_constructorExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_constructorExpressionForGeneration GGS_constructorExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_constructorExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_constructorExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_constructorExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_constructorExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_constructorExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_constructorExpressionForGeneration GGS_constructorExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_outSemanticExpressionListForGeneration & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_constructorExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_constructorExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_constructorExpressionForGeneration::
reader_mTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_constructorExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_constructorExpressionForGeneration *) mPointer)->mTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_constructorExpressionForGeneration::
reader_mConstructorName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_constructorExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_constructorExpressionForGeneration *) mPointer)->mConstructorName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_outSemanticExpressionListForGeneration  GGS_constructorExpressionForGeneration::
reader_mExpressions (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_outSemanticExpressionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_constructorExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_constructorExpressionForGeneration *) mPointer)->mExpressions ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_constructorExpressionForGeneration::actualTypeName (void) const {
  return "constructorExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__constructorExpressionForGeneration ("constructorExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_constructorExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_constructorExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_constructorExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_constructorExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_constructorExpressionForGeneration GGS_constructorExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_constructorExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_constructorExpressionForGeneration * p = dynamic_cast <const GGS_constructorExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_constructorExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_constructorExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_constructorExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'cPtr_readerCallExpressionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_readerCallExpressionForGeneration::
cPtr_readerCallExpressionForGeneration (const GGS_semanticExpressionForGeneration & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_outSemanticExpressionListForGeneration & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (THERE),
mReceiver (argument_0),
mReaderName (argument_1),
mExpressions (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_readerCallExpressionForGeneration * GGS_readerCallExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_readerCallExpressionForGeneration) ;
    return (cPtr_readerCallExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_readerCallExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_readerCallExpressionForGeneration * ptr = dynamic_cast <const cPtr_readerCallExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mReceiver.operator_isEqual (ptr->mReceiver).boolValue ()
         && mReaderName.operator_isEqual (ptr->mReaderName).boolValue ()
         && mExpressions.operator_isEqual (ptr->mExpressions).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_readerCallExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@readerCallExpressionForGeneration:"
           << mReceiver.reader_description (inIndentation + 1)
           << mReaderName.reader_description (inIndentation + 1)
           << mExpressions.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_readerCallExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_readerCallExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_readerCallExpressionForGeneration (& typeid (cPtr_readerCallExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_readerCallExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__readerCallExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_readerCallExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_readerCallExpressionForGeneration (mReceiver, mReaderName, mExpressions COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_readerCallExpressionForGeneration'            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_readerCallExpressionForGeneration ("readerCallExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_readerCallExpressionForGeneration::
GGS_readerCallExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_readerCallExpressionForGeneration::
GGS_readerCallExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_readerCallExpressionForGeneration GGS_readerCallExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_readerCallExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_readerCallExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_readerCallExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_readerCallExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_readerCallExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_readerCallExpressionForGeneration GGS_readerCallExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_semanticExpressionForGeneration & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_outSemanticExpressionListForGeneration & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_readerCallExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_readerCallExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_readerCallExpressionForGeneration::
reader_mReceiver (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_readerCallExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_readerCallExpressionForGeneration *) mPointer)->mReceiver ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_readerCallExpressionForGeneration::
reader_mReaderName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_readerCallExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_readerCallExpressionForGeneration *) mPointer)->mReaderName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_outSemanticExpressionListForGeneration  GGS_readerCallExpressionForGeneration::
reader_mExpressions (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_outSemanticExpressionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_readerCallExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_readerCallExpressionForGeneration *) mPointer)->mExpressions ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_readerCallExpressionForGeneration::actualTypeName (void) const {
  return "readerCallExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__readerCallExpressionForGeneration ("readerCallExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_readerCallExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_readerCallExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_readerCallExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_readerCallExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_readerCallExpressionForGeneration GGS_readerCallExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_readerCallExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_readerCallExpressionForGeneration * p = dynamic_cast <const GGS_readerCallExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_readerCallExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_readerCallExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_readerCallExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_optionExpressionForGeneration'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_optionExpressionForGeneration::
cPtr_optionExpressionForGeneration (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (THERE),
mOptionComponentName (argument_0),
mOptionEntryName (argument_1),
mOptionReaderName (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_optionExpressionForGeneration * GGS_optionExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_optionExpressionForGeneration) ;
    return (cPtr_optionExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_optionExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_optionExpressionForGeneration * ptr = dynamic_cast <const cPtr_optionExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOptionComponentName.operator_isEqual (ptr->mOptionComponentName).boolValue ()
         && mOptionEntryName.operator_isEqual (ptr->mOptionEntryName).boolValue ()
         && mOptionReaderName.operator_isEqual (ptr->mOptionReaderName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_optionExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@optionExpressionForGeneration:"
           << mOptionComponentName.reader_description (inIndentation + 1)
           << mOptionEntryName.reader_description (inIndentation + 1)
           << mOptionReaderName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_optionExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_optionExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_optionExpressionForGeneration (& typeid (cPtr_optionExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_optionExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__optionExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_optionExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_optionExpressionForGeneration (mOptionComponentName, mOptionEntryName, mOptionReaderName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_optionExpressionForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_optionExpressionForGeneration ("optionExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_optionExpressionForGeneration::
GGS_optionExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_optionExpressionForGeneration::
GGS_optionExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_optionExpressionForGeneration GGS_optionExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_optionExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_optionExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_optionExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_optionExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_optionExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_optionExpressionForGeneration GGS_optionExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_optionExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_optionExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_optionExpressionForGeneration::
reader_mOptionComponentName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_optionExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_optionExpressionForGeneration *) mPointer)->mOptionComponentName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_optionExpressionForGeneration::
reader_mOptionEntryName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_optionExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_optionExpressionForGeneration *) mPointer)->mOptionEntryName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_optionExpressionForGeneration::
reader_mOptionReaderName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_optionExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_optionExpressionForGeneration *) mPointer)->mOptionReaderName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_optionExpressionForGeneration::actualTypeName (void) const {
  return "optionExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__optionExpressionForGeneration ("optionExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_optionExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_optionExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_optionExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_optionExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_optionExpressionForGeneration GGS_optionExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_optionExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_optionExpressionForGeneration * p = dynamic_cast <const GGS_optionExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_optionExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_optionExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_optionExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_concatExpressionForGeneration'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_concatExpressionForGeneration::
cPtr_concatExpressionForGeneration (const GGS_location & argument_0,
                                const GGS_semanticExpressionForGeneration & argument_1,
                                const GGS_semanticExpressionForGeneration & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_concatExpressionForGeneration * GGS_concatExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_concatExpressionForGeneration) ;
    return (cPtr_concatExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_concatExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_concatExpressionForGeneration * ptr = dynamic_cast <const cPtr_concatExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_concatExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@concatExpressionForGeneration:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_concatExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_concatExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_concatExpressionForGeneration (& typeid (cPtr_concatExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_concatExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__concatExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_concatExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_concatExpressionForGeneration (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_concatExpressionForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_concatExpressionForGeneration ("concatExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_concatExpressionForGeneration::
GGS_concatExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_concatExpressionForGeneration::
GGS_concatExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_concatExpressionForGeneration GGS_concatExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_concatExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_concatExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_concatExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_concatExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_concatExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_concatExpressionForGeneration GGS_concatExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionForGeneration & argument_1,
                 const GGS_semanticExpressionForGeneration & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_concatExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_concatExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_concatExpressionForGeneration::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_concatExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_concatExpressionForGeneration *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_concatExpressionForGeneration::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_concatExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_concatExpressionForGeneration *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_concatExpressionForGeneration::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_concatExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_concatExpressionForGeneration *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_concatExpressionForGeneration::actualTypeName (void) const {
  return "concatExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__concatExpressionForGeneration ("concatExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_concatExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_concatExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_concatExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_concatExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_concatExpressionForGeneration GGS_concatExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_concatExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_concatExpressionForGeneration * p = dynamic_cast <const GGS_concatExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_concatExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_concatExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_concatExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_orExpressionForGeneration'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_orExpressionForGeneration::
cPtr_orExpressionForGeneration (const GGS_location & argument_0,
                                const GGS_semanticExpressionForGeneration & argument_1,
                                const GGS_semanticExpressionForGeneration & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_orExpressionForGeneration * GGS_orExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_orExpressionForGeneration) ;
    return (cPtr_orExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_orExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_orExpressionForGeneration * ptr = dynamic_cast <const cPtr_orExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_orExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@orExpressionForGeneration:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_orExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_orExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_orExpressionForGeneration (& typeid (cPtr_orExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_orExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__orExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_orExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_orExpressionForGeneration (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_orExpressionForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_orExpressionForGeneration ("orExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_orExpressionForGeneration::
GGS_orExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_orExpressionForGeneration::
GGS_orExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_orExpressionForGeneration GGS_orExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_orExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_orExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_orExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_orExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_orExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_orExpressionForGeneration GGS_orExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionForGeneration & argument_1,
                 const GGS_semanticExpressionForGeneration & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_orExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_orExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_orExpressionForGeneration::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_orExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_orExpressionForGeneration *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_orExpressionForGeneration::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_orExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_orExpressionForGeneration *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_orExpressionForGeneration::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_orExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_orExpressionForGeneration *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_orExpressionForGeneration::actualTypeName (void) const {
  return "orExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__orExpressionForGeneration ("orExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_orExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_orExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_orExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_orExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_orExpressionForGeneration GGS_orExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_orExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_orExpressionForGeneration * p = dynamic_cast <const GGS_orExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_orExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_orExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_orExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_xorExpressionForGeneration'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_xorExpressionForGeneration::
cPtr_xorExpressionForGeneration (const GGS_location & argument_0,
                                const GGS_semanticExpressionForGeneration & argument_1,
                                const GGS_semanticExpressionForGeneration & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_xorExpressionForGeneration * GGS_xorExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_xorExpressionForGeneration) ;
    return (cPtr_xorExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_xorExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_xorExpressionForGeneration * ptr = dynamic_cast <const cPtr_xorExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_xorExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@xorExpressionForGeneration:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_xorExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_xorExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_xorExpressionForGeneration (& typeid (cPtr_xorExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_xorExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__xorExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_xorExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_xorExpressionForGeneration (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_xorExpressionForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_xorExpressionForGeneration ("xorExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_xorExpressionForGeneration::
GGS_xorExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_xorExpressionForGeneration::
GGS_xorExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_xorExpressionForGeneration GGS_xorExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_xorExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_xorExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_xorExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_xorExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_xorExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_xorExpressionForGeneration GGS_xorExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionForGeneration & argument_1,
                 const GGS_semanticExpressionForGeneration & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_xorExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_xorExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_xorExpressionForGeneration::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_xorExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_xorExpressionForGeneration *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_xorExpressionForGeneration::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_xorExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_xorExpressionForGeneration *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_xorExpressionForGeneration::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_xorExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_xorExpressionForGeneration *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_xorExpressionForGeneration::actualTypeName (void) const {
  return "xorExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__xorExpressionForGeneration ("xorExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_xorExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_xorExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_xorExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_xorExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_xorExpressionForGeneration GGS_xorExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_xorExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_xorExpressionForGeneration * p = dynamic_cast <const GGS_xorExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_xorExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_xorExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_xorExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_andExpressionForGeneration'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_andExpressionForGeneration::
cPtr_andExpressionForGeneration (const GGS_location & argument_0,
                                const GGS_semanticExpressionForGeneration & argument_1,
                                const GGS_semanticExpressionForGeneration & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_andExpressionForGeneration * GGS_andExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_andExpressionForGeneration) ;
    return (cPtr_andExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_andExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_andExpressionForGeneration * ptr = dynamic_cast <const cPtr_andExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_andExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@andExpressionForGeneration:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_andExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_andExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_andExpressionForGeneration (& typeid (cPtr_andExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_andExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__andExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_andExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_andExpressionForGeneration (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_andExpressionForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_andExpressionForGeneration ("andExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_andExpressionForGeneration::
GGS_andExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_andExpressionForGeneration::
GGS_andExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_andExpressionForGeneration GGS_andExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_andExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_andExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_andExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_andExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_andExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_andExpressionForGeneration GGS_andExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionForGeneration & argument_1,
                 const GGS_semanticExpressionForGeneration & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_andExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_andExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_andExpressionForGeneration::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_andExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_andExpressionForGeneration *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_andExpressionForGeneration::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_andExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_andExpressionForGeneration *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_andExpressionForGeneration::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_andExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_andExpressionForGeneration *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_andExpressionForGeneration::actualTypeName (void) const {
  return "andExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__andExpressionForGeneration ("andExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_andExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_andExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_andExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_andExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_andExpressionForGeneration GGS_andExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_andExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_andExpressionForGeneration * p = dynamic_cast <const GGS_andExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_andExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_andExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_andExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_equalExpressionForGeneration'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_equalExpressionForGeneration::
cPtr_equalExpressionForGeneration (const GGS_location & argument_0,
                                const GGS_semanticExpressionForGeneration & argument_1,
                                const GGS_semanticExpressionForGeneration & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_equalExpressionForGeneration * GGS_equalExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_equalExpressionForGeneration) ;
    return (cPtr_equalExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_equalExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_equalExpressionForGeneration * ptr = dynamic_cast <const cPtr_equalExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_equalExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@equalExpressionForGeneration:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_equalExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_equalExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_equalExpressionForGeneration (& typeid (cPtr_equalExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_equalExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__equalExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_equalExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_equalExpressionForGeneration (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_equalExpressionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_equalExpressionForGeneration ("equalExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_equalExpressionForGeneration::
GGS_equalExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_equalExpressionForGeneration::
GGS_equalExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_equalExpressionForGeneration GGS_equalExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_equalExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_equalExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_equalExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_equalExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_equalExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_equalExpressionForGeneration GGS_equalExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionForGeneration & argument_1,
                 const GGS_semanticExpressionForGeneration & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_equalExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_equalExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_equalExpressionForGeneration::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_equalExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_equalExpressionForGeneration *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_equalExpressionForGeneration::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_equalExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_equalExpressionForGeneration *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_equalExpressionForGeneration::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_equalExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_equalExpressionForGeneration *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_equalExpressionForGeneration::actualTypeName (void) const {
  return "equalExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__equalExpressionForGeneration ("equalExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_equalExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_equalExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_equalExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_equalExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_equalExpressionForGeneration GGS_equalExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_equalExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_equalExpressionForGeneration * p = dynamic_cast <const GGS_equalExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_equalExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_equalExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_equalExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_notEqualExpressionForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_notEqualExpressionForGeneration::
cPtr_notEqualExpressionForGeneration (const GGS_location & argument_0,
                                const GGS_semanticExpressionForGeneration & argument_1,
                                const GGS_semanticExpressionForGeneration & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_notEqualExpressionForGeneration * GGS_notEqualExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_notEqualExpressionForGeneration) ;
    return (cPtr_notEqualExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_notEqualExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_notEqualExpressionForGeneration * ptr = dynamic_cast <const cPtr_notEqualExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_notEqualExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@notEqualExpressionForGeneration:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_notEqualExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_notEqualExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_notEqualExpressionForGeneration (& typeid (cPtr_notEqualExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_notEqualExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__notEqualExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_notEqualExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_notEqualExpressionForGeneration (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_notEqualExpressionForGeneration'             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_notEqualExpressionForGeneration ("notEqualExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_notEqualExpressionForGeneration::
GGS_notEqualExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_notEqualExpressionForGeneration::
GGS_notEqualExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_notEqualExpressionForGeneration GGS_notEqualExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_notEqualExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_notEqualExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_notEqualExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_notEqualExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_notEqualExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_notEqualExpressionForGeneration GGS_notEqualExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionForGeneration & argument_1,
                 const GGS_semanticExpressionForGeneration & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_notEqualExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_notEqualExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_notEqualExpressionForGeneration::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_notEqualExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_notEqualExpressionForGeneration *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_notEqualExpressionForGeneration::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_notEqualExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_notEqualExpressionForGeneration *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_notEqualExpressionForGeneration::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_notEqualExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_notEqualExpressionForGeneration *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_notEqualExpressionForGeneration::actualTypeName (void) const {
  return "notEqualExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__notEqualExpressionForGeneration ("notEqualExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_notEqualExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_notEqualExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_notEqualExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_notEqualExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_notEqualExpressionForGeneration GGS_notEqualExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_notEqualExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_notEqualExpressionForGeneration * p = dynamic_cast <const GGS_notEqualExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_notEqualExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_notEqualExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_notEqualExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_lowerOrEqualExpressionForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lowerOrEqualExpressionForGeneration::
cPtr_lowerOrEqualExpressionForGeneration (const GGS_location & argument_0,
                                const GGS_semanticExpressionForGeneration & argument_1,
                                const GGS_semanticExpressionForGeneration & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lowerOrEqualExpressionForGeneration * GGS_lowerOrEqualExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_lowerOrEqualExpressionForGeneration) ;
    return (cPtr_lowerOrEqualExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lowerOrEqualExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lowerOrEqualExpressionForGeneration * ptr = dynamic_cast <const cPtr_lowerOrEqualExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lowerOrEqualExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@lowerOrEqualExpressionForGeneration:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lowerOrEqualExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lowerOrEqualExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lowerOrEqualExpressionForGeneration (& typeid (cPtr_lowerOrEqualExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_lowerOrEqualExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__lowerOrEqualExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lowerOrEqualExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lowerOrEqualExpressionForGeneration (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_lowerOrEqualExpressionForGeneration'           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_lowerOrEqualExpressionForGeneration ("lowerOrEqualExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_lowerOrEqualExpressionForGeneration::
GGS_lowerOrEqualExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lowerOrEqualExpressionForGeneration::
GGS_lowerOrEqualExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lowerOrEqualExpressionForGeneration GGS_lowerOrEqualExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lowerOrEqualExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lowerOrEqualExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_lowerOrEqualExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lowerOrEqualExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lowerOrEqualExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lowerOrEqualExpressionForGeneration GGS_lowerOrEqualExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionForGeneration & argument_1,
                 const GGS_semanticExpressionForGeneration & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_lowerOrEqualExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_lowerOrEqualExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_lowerOrEqualExpressionForGeneration::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lowerOrEqualExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lowerOrEqualExpressionForGeneration *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_lowerOrEqualExpressionForGeneration::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lowerOrEqualExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lowerOrEqualExpressionForGeneration *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_lowerOrEqualExpressionForGeneration::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lowerOrEqualExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lowerOrEqualExpressionForGeneration *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lowerOrEqualExpressionForGeneration::actualTypeName (void) const {
  return "lowerOrEqualExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__lowerOrEqualExpressionForGeneration ("lowerOrEqualExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_lowerOrEqualExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_lowerOrEqualExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_lowerOrEqualExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_lowerOrEqualExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lowerOrEqualExpressionForGeneration GGS_lowerOrEqualExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_lowerOrEqualExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_lowerOrEqualExpressionForGeneration * p = dynamic_cast <const GGS_lowerOrEqualExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_lowerOrEqualExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_lowerOrEqualExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_lowerOrEqualExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            class 'cPtr_greaterOrEqualExpressionForGeneration'             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_greaterOrEqualExpressionForGeneration::
cPtr_greaterOrEqualExpressionForGeneration (const GGS_location & argument_0,
                                const GGS_semanticExpressionForGeneration & argument_1,
                                const GGS_semanticExpressionForGeneration & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_greaterOrEqualExpressionForGeneration * GGS_greaterOrEqualExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_greaterOrEqualExpressionForGeneration) ;
    return (cPtr_greaterOrEqualExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_greaterOrEqualExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_greaterOrEqualExpressionForGeneration * ptr = dynamic_cast <const cPtr_greaterOrEqualExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_greaterOrEqualExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@greaterOrEqualExpressionForGeneration:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_greaterOrEqualExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_greaterOrEqualExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_greaterOrEqualExpressionForGeneration (& typeid (cPtr_greaterOrEqualExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_greaterOrEqualExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__greaterOrEqualExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_greaterOrEqualExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_greaterOrEqualExpressionForGeneration (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         GALGAS class 'GGS_greaterOrEqualExpressionForGeneration'          *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_greaterOrEqualExpressionForGeneration ("greaterOrEqualExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_greaterOrEqualExpressionForGeneration::
GGS_greaterOrEqualExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_greaterOrEqualExpressionForGeneration::
GGS_greaterOrEqualExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_greaterOrEqualExpressionForGeneration GGS_greaterOrEqualExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_greaterOrEqualExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_greaterOrEqualExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_greaterOrEqualExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_greaterOrEqualExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_greaterOrEqualExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_greaterOrEqualExpressionForGeneration GGS_greaterOrEqualExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionForGeneration & argument_1,
                 const GGS_semanticExpressionForGeneration & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_greaterOrEqualExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_greaterOrEqualExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_greaterOrEqualExpressionForGeneration::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_greaterOrEqualExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_greaterOrEqualExpressionForGeneration *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_greaterOrEqualExpressionForGeneration::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_greaterOrEqualExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_greaterOrEqualExpressionForGeneration *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_greaterOrEqualExpressionForGeneration::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_greaterOrEqualExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_greaterOrEqualExpressionForGeneration *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_greaterOrEqualExpressionForGeneration::actualTypeName (void) const {
  return "greaterOrEqualExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__greaterOrEqualExpressionForGeneration ("greaterOrEqualExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_greaterOrEqualExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_greaterOrEqualExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_greaterOrEqualExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_greaterOrEqualExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_greaterOrEqualExpressionForGeneration GGS_greaterOrEqualExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_greaterOrEqualExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_greaterOrEqualExpressionForGeneration * p = dynamic_cast <const GGS_greaterOrEqualExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_greaterOrEqualExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_greaterOrEqualExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_greaterOrEqualExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            class 'cPtr_strictGreaterExpressionForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_strictGreaterExpressionForGeneration::
cPtr_strictGreaterExpressionForGeneration (const GGS_location & argument_0,
                                const GGS_semanticExpressionForGeneration & argument_1,
                                const GGS_semanticExpressionForGeneration & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_strictGreaterExpressionForGeneration * GGS_strictGreaterExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_strictGreaterExpressionForGeneration) ;
    return (cPtr_strictGreaterExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_strictGreaterExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_strictGreaterExpressionForGeneration * ptr = dynamic_cast <const cPtr_strictGreaterExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_strictGreaterExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@strictGreaterExpressionForGeneration:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_strictGreaterExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_strictGreaterExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_strictGreaterExpressionForGeneration (& typeid (cPtr_strictGreaterExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_strictGreaterExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__strictGreaterExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_strictGreaterExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_strictGreaterExpressionForGeneration (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         GALGAS class 'GGS_strictGreaterExpressionForGeneration'           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_strictGreaterExpressionForGeneration ("strictGreaterExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_strictGreaterExpressionForGeneration::
GGS_strictGreaterExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_strictGreaterExpressionForGeneration::
GGS_strictGreaterExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_strictGreaterExpressionForGeneration GGS_strictGreaterExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_strictGreaterExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_strictGreaterExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_strictGreaterExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_strictGreaterExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_strictGreaterExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_strictGreaterExpressionForGeneration GGS_strictGreaterExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionForGeneration & argument_1,
                 const GGS_semanticExpressionForGeneration & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_strictGreaterExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_strictGreaterExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_strictGreaterExpressionForGeneration::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_strictGreaterExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_strictGreaterExpressionForGeneration *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_strictGreaterExpressionForGeneration::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_strictGreaterExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_strictGreaterExpressionForGeneration *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_strictGreaterExpressionForGeneration::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_strictGreaterExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_strictGreaterExpressionForGeneration *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_strictGreaterExpressionForGeneration::actualTypeName (void) const {
  return "strictGreaterExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__strictGreaterExpressionForGeneration ("strictGreaterExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_strictGreaterExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_strictGreaterExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_strictGreaterExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_strictGreaterExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_strictGreaterExpressionForGeneration GGS_strictGreaterExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_strictGreaterExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_strictGreaterExpressionForGeneration * p = dynamic_cast <const GGS_strictGreaterExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_strictGreaterExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_strictGreaterExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_strictGreaterExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_strictLowerExpressionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_strictLowerExpressionForGeneration::
cPtr_strictLowerExpressionForGeneration (const GGS_location & argument_0,
                                const GGS_semanticExpressionForGeneration & argument_1,
                                const GGS_semanticExpressionForGeneration & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_strictLowerExpressionForGeneration * GGS_strictLowerExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_strictLowerExpressionForGeneration) ;
    return (cPtr_strictLowerExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_strictLowerExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_strictLowerExpressionForGeneration * ptr = dynamic_cast <const cPtr_strictLowerExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_strictLowerExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@strictLowerExpressionForGeneration:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_strictLowerExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_strictLowerExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_strictLowerExpressionForGeneration (& typeid (cPtr_strictLowerExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_strictLowerExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__strictLowerExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_strictLowerExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_strictLowerExpressionForGeneration (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_strictLowerExpressionForGeneration'            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_strictLowerExpressionForGeneration ("strictLowerExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_strictLowerExpressionForGeneration::
GGS_strictLowerExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_strictLowerExpressionForGeneration::
GGS_strictLowerExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_strictLowerExpressionForGeneration GGS_strictLowerExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_strictLowerExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_strictLowerExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_strictLowerExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_strictLowerExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_strictLowerExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_strictLowerExpressionForGeneration GGS_strictLowerExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionForGeneration & argument_1,
                 const GGS_semanticExpressionForGeneration & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_strictLowerExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_strictLowerExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_strictLowerExpressionForGeneration::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_strictLowerExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_strictLowerExpressionForGeneration *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_strictLowerExpressionForGeneration::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_strictLowerExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_strictLowerExpressionForGeneration *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_strictLowerExpressionForGeneration::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_strictLowerExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_strictLowerExpressionForGeneration *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_strictLowerExpressionForGeneration::actualTypeName (void) const {
  return "strictLowerExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__strictLowerExpressionForGeneration ("strictLowerExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_strictLowerExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_strictLowerExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_strictLowerExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_strictLowerExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_strictLowerExpressionForGeneration GGS_strictLowerExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_strictLowerExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_strictLowerExpressionForGeneration * p = dynamic_cast <const GGS_strictLowerExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_strictLowerExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_strictLowerExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_strictLowerExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'cPtr_rightShiftExpressionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_rightShiftExpressionForGeneration::
cPtr_rightShiftExpressionForGeneration (const GGS_location & argument_0,
                                const GGS_semanticExpressionForGeneration & argument_1,
                                const GGS_semanticExpressionForGeneration & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_rightShiftExpressionForGeneration * GGS_rightShiftExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_rightShiftExpressionForGeneration) ;
    return (cPtr_rightShiftExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_rightShiftExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_rightShiftExpressionForGeneration * ptr = dynamic_cast <const cPtr_rightShiftExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_rightShiftExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@rightShiftExpressionForGeneration:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_rightShiftExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_rightShiftExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_rightShiftExpressionForGeneration (& typeid (cPtr_rightShiftExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_rightShiftExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__rightShiftExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_rightShiftExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_rightShiftExpressionForGeneration (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_rightShiftExpressionForGeneration'            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_rightShiftExpressionForGeneration ("rightShiftExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_rightShiftExpressionForGeneration::
GGS_rightShiftExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_rightShiftExpressionForGeneration::
GGS_rightShiftExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_rightShiftExpressionForGeneration GGS_rightShiftExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_rightShiftExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_rightShiftExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_rightShiftExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_rightShiftExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_rightShiftExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_rightShiftExpressionForGeneration GGS_rightShiftExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionForGeneration & argument_1,
                 const GGS_semanticExpressionForGeneration & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_rightShiftExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_rightShiftExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_rightShiftExpressionForGeneration::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rightShiftExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rightShiftExpressionForGeneration *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_rightShiftExpressionForGeneration::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rightShiftExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rightShiftExpressionForGeneration *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_rightShiftExpressionForGeneration::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rightShiftExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rightShiftExpressionForGeneration *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_rightShiftExpressionForGeneration::actualTypeName (void) const {
  return "rightShiftExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__rightShiftExpressionForGeneration ("rightShiftExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_rightShiftExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_rightShiftExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_rightShiftExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_rightShiftExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_rightShiftExpressionForGeneration GGS_rightShiftExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_rightShiftExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_rightShiftExpressionForGeneration * p = dynamic_cast <const GGS_rightShiftExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_rightShiftExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_rightShiftExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_rightShiftExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'cPtr_leftShiftExpressionForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_leftShiftExpressionForGeneration::
cPtr_leftShiftExpressionForGeneration (const GGS_location & argument_0,
                                const GGS_semanticExpressionForGeneration & argument_1,
                                const GGS_semanticExpressionForGeneration & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_leftShiftExpressionForGeneration * GGS_leftShiftExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_leftShiftExpressionForGeneration) ;
    return (cPtr_leftShiftExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_leftShiftExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_leftShiftExpressionForGeneration * ptr = dynamic_cast <const cPtr_leftShiftExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_leftShiftExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@leftShiftExpressionForGeneration:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_leftShiftExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_leftShiftExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_leftShiftExpressionForGeneration (& typeid (cPtr_leftShiftExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_leftShiftExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__leftShiftExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_leftShiftExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_leftShiftExpressionForGeneration (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_leftShiftExpressionForGeneration'             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_leftShiftExpressionForGeneration ("leftShiftExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_leftShiftExpressionForGeneration::
GGS_leftShiftExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_leftShiftExpressionForGeneration::
GGS_leftShiftExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_leftShiftExpressionForGeneration GGS_leftShiftExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_leftShiftExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_leftShiftExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_leftShiftExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_leftShiftExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_leftShiftExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_leftShiftExpressionForGeneration GGS_leftShiftExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionForGeneration & argument_1,
                 const GGS_semanticExpressionForGeneration & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_leftShiftExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_leftShiftExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_leftShiftExpressionForGeneration::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_leftShiftExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_leftShiftExpressionForGeneration *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_leftShiftExpressionForGeneration::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_leftShiftExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_leftShiftExpressionForGeneration *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_leftShiftExpressionForGeneration::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_leftShiftExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_leftShiftExpressionForGeneration *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_leftShiftExpressionForGeneration::actualTypeName (void) const {
  return "leftShiftExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__leftShiftExpressionForGeneration ("leftShiftExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_leftShiftExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_leftShiftExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_leftShiftExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_leftShiftExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_leftShiftExpressionForGeneration GGS_leftShiftExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_leftShiftExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_leftShiftExpressionForGeneration * p = dynamic_cast <const GGS_leftShiftExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_leftShiftExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_leftShiftExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_leftShiftExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_addExpressionForGeneration'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_addExpressionForGeneration::
cPtr_addExpressionForGeneration (const GGS_location & argument_0,
                                const GGS_semanticExpressionForGeneration & argument_1,
                                const GGS_semanticExpressionForGeneration & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_addExpressionForGeneration * GGS_addExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_addExpressionForGeneration) ;
    return (cPtr_addExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_addExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_addExpressionForGeneration * ptr = dynamic_cast <const cPtr_addExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_addExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@addExpressionForGeneration:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_addExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_addExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_addExpressionForGeneration (& typeid (cPtr_addExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_addExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__addExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_addExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_addExpressionForGeneration (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_addExpressionForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_addExpressionForGeneration ("addExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_addExpressionForGeneration::
GGS_addExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_addExpressionForGeneration::
GGS_addExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_addExpressionForGeneration GGS_addExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_addExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_addExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_addExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_addExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_addExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_addExpressionForGeneration GGS_addExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionForGeneration & argument_1,
                 const GGS_semanticExpressionForGeneration & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_addExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_addExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_addExpressionForGeneration::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_addExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_addExpressionForGeneration *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_addExpressionForGeneration::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_addExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_addExpressionForGeneration *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_addExpressionForGeneration::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_addExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_addExpressionForGeneration *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_addExpressionForGeneration::actualTypeName (void) const {
  return "addExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__addExpressionForGeneration ("addExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_addExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_addExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_addExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_addExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_addExpressionForGeneration GGS_addExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_addExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_addExpressionForGeneration * p = dynamic_cast <const GGS_addExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_addExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_addExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_addExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_subExpressionForGeneration'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_subExpressionForGeneration::
cPtr_subExpressionForGeneration (const GGS_location & argument_0,
                                const GGS_semanticExpressionForGeneration & argument_1,
                                const GGS_semanticExpressionForGeneration & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_subExpressionForGeneration * GGS_subExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_subExpressionForGeneration) ;
    return (cPtr_subExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_subExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_subExpressionForGeneration * ptr = dynamic_cast <const cPtr_subExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_subExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@subExpressionForGeneration:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_subExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_subExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_subExpressionForGeneration (& typeid (cPtr_subExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_subExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__subExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_subExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_subExpressionForGeneration (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_subExpressionForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_subExpressionForGeneration ("subExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_subExpressionForGeneration::
GGS_subExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_subExpressionForGeneration::
GGS_subExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_subExpressionForGeneration GGS_subExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_subExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_subExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_subExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_subExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_subExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_subExpressionForGeneration GGS_subExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionForGeneration & argument_1,
                 const GGS_semanticExpressionForGeneration & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_subExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_subExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_subExpressionForGeneration::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_subExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_subExpressionForGeneration *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_subExpressionForGeneration::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_subExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_subExpressionForGeneration *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_subExpressionForGeneration::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_subExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_subExpressionForGeneration *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_subExpressionForGeneration::actualTypeName (void) const {
  return "subExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__subExpressionForGeneration ("subExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_subExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_subExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_subExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_subExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_subExpressionForGeneration GGS_subExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_subExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_subExpressionForGeneration * p = dynamic_cast <const GGS_subExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_subExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_subExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_subExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            class 'cPtr_multiplicationExpressionForGeneration'             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_multiplicationExpressionForGeneration::
cPtr_multiplicationExpressionForGeneration (const GGS_location & argument_0,
                                const GGS_semanticExpressionForGeneration & argument_1,
                                const GGS_semanticExpressionForGeneration & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_multiplicationExpressionForGeneration * GGS_multiplicationExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_multiplicationExpressionForGeneration) ;
    return (cPtr_multiplicationExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_multiplicationExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_multiplicationExpressionForGeneration * ptr = dynamic_cast <const cPtr_multiplicationExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_multiplicationExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@multiplicationExpressionForGeneration:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_multiplicationExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_multiplicationExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_multiplicationExpressionForGeneration (& typeid (cPtr_multiplicationExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_multiplicationExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__multiplicationExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_multiplicationExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_multiplicationExpressionForGeneration (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         GALGAS class 'GGS_multiplicationExpressionForGeneration'          *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_multiplicationExpressionForGeneration ("multiplicationExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_multiplicationExpressionForGeneration::
GGS_multiplicationExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_multiplicationExpressionForGeneration::
GGS_multiplicationExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_multiplicationExpressionForGeneration GGS_multiplicationExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_multiplicationExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_multiplicationExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_multiplicationExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_multiplicationExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_multiplicationExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_multiplicationExpressionForGeneration GGS_multiplicationExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionForGeneration & argument_1,
                 const GGS_semanticExpressionForGeneration & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_multiplicationExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_multiplicationExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_multiplicationExpressionForGeneration::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_multiplicationExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_multiplicationExpressionForGeneration *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_multiplicationExpressionForGeneration::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_multiplicationExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_multiplicationExpressionForGeneration *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_multiplicationExpressionForGeneration::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_multiplicationExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_multiplicationExpressionForGeneration *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_multiplicationExpressionForGeneration::actualTypeName (void) const {
  return "multiplicationExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__multiplicationExpressionForGeneration ("multiplicationExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_multiplicationExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_multiplicationExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_multiplicationExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_multiplicationExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_multiplicationExpressionForGeneration GGS_multiplicationExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_multiplicationExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_multiplicationExpressionForGeneration * p = dynamic_cast <const GGS_multiplicationExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_multiplicationExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_multiplicationExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_multiplicationExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_divisionExpressionForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_divisionExpressionForGeneration::
cPtr_divisionExpressionForGeneration (const GGS_location & argument_0,
                                const GGS_semanticExpressionForGeneration & argument_1,
                                const GGS_semanticExpressionForGeneration & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_divisionExpressionForGeneration * GGS_divisionExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_divisionExpressionForGeneration) ;
    return (cPtr_divisionExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_divisionExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_divisionExpressionForGeneration * ptr = dynamic_cast <const cPtr_divisionExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_divisionExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@divisionExpressionForGeneration:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_divisionExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_divisionExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_divisionExpressionForGeneration (& typeid (cPtr_divisionExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_divisionExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__divisionExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_divisionExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_divisionExpressionForGeneration (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_divisionExpressionForGeneration'             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_divisionExpressionForGeneration ("divisionExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_divisionExpressionForGeneration::
GGS_divisionExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_divisionExpressionForGeneration::
GGS_divisionExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_divisionExpressionForGeneration GGS_divisionExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_divisionExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_divisionExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_divisionExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_divisionExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_divisionExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_divisionExpressionForGeneration GGS_divisionExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionForGeneration & argument_1,
                 const GGS_semanticExpressionForGeneration & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_divisionExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_divisionExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_divisionExpressionForGeneration::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_divisionExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_divisionExpressionForGeneration *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_divisionExpressionForGeneration::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_divisionExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_divisionExpressionForGeneration *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_divisionExpressionForGeneration::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_divisionExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_divisionExpressionForGeneration *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_divisionExpressionForGeneration::actualTypeName (void) const {
  return "divisionExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__divisionExpressionForGeneration ("divisionExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_divisionExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_divisionExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_divisionExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_divisionExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_divisionExpressionForGeneration GGS_divisionExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_divisionExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_divisionExpressionForGeneration * p = dynamic_cast <const GGS_divisionExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_divisionExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_divisionExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_divisionExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_moduloExpressionForGeneration'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_moduloExpressionForGeneration::
cPtr_moduloExpressionForGeneration (const GGS_location & argument_0,
                                const GGS_semanticExpressionForGeneration & argument_1,
                                const GGS_semanticExpressionForGeneration & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_moduloExpressionForGeneration * GGS_moduloExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_moduloExpressionForGeneration) ;
    return (cPtr_moduloExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_moduloExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_moduloExpressionForGeneration * ptr = dynamic_cast <const cPtr_moduloExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_moduloExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@moduloExpressionForGeneration:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_moduloExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_moduloExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_moduloExpressionForGeneration (& typeid (cPtr_moduloExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_moduloExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__moduloExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_moduloExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_moduloExpressionForGeneration (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_moduloExpressionForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_moduloExpressionForGeneration ("moduloExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_moduloExpressionForGeneration::
GGS_moduloExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_moduloExpressionForGeneration::
GGS_moduloExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_moduloExpressionForGeneration GGS_moduloExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_moduloExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_moduloExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_moduloExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_moduloExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_moduloExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_moduloExpressionForGeneration GGS_moduloExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionForGeneration & argument_1,
                 const GGS_semanticExpressionForGeneration & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_moduloExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_moduloExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_moduloExpressionForGeneration::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_moduloExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_moduloExpressionForGeneration *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_moduloExpressionForGeneration::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_moduloExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_moduloExpressionForGeneration *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_moduloExpressionForGeneration::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_moduloExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_moduloExpressionForGeneration *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_moduloExpressionForGeneration::actualTypeName (void) const {
  return "moduloExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__moduloExpressionForGeneration ("moduloExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_moduloExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_moduloExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_moduloExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_moduloExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_moduloExpressionForGeneration GGS_moduloExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_moduloExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_moduloExpressionForGeneration * p = dynamic_cast <const GGS_moduloExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_moduloExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_moduloExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_moduloExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'cPtr_unaryMinusExpressionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_unaryMinusExpressionForGeneration::
cPtr_unaryMinusExpressionForGeneration (const GGS_location & argument_0,
                                const GGS_semanticExpressionForGeneration & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (THERE),
mOperatorLocation (argument_0),
mExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_unaryMinusExpressionForGeneration * GGS_unaryMinusExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_unaryMinusExpressionForGeneration) ;
    return (cPtr_unaryMinusExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_unaryMinusExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_unaryMinusExpressionForGeneration * ptr = dynamic_cast <const cPtr_unaryMinusExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mExpression.operator_isEqual (ptr->mExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_unaryMinusExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@unaryMinusExpressionForGeneration:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_unaryMinusExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_unaryMinusExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_unaryMinusExpressionForGeneration (& typeid (cPtr_unaryMinusExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_unaryMinusExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__unaryMinusExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_unaryMinusExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_unaryMinusExpressionForGeneration (mOperatorLocation, mExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_unaryMinusExpressionForGeneration'            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_unaryMinusExpressionForGeneration ("unaryMinusExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_unaryMinusExpressionForGeneration::
GGS_unaryMinusExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_unaryMinusExpressionForGeneration::
GGS_unaryMinusExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_unaryMinusExpressionForGeneration GGS_unaryMinusExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_unaryMinusExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_unaryMinusExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_unaryMinusExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_unaryMinusExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_unaryMinusExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_unaryMinusExpressionForGeneration GGS_unaryMinusExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionForGeneration & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_unaryMinusExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_unaryMinusExpressionForGeneration (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_unaryMinusExpressionForGeneration::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_unaryMinusExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_unaryMinusExpressionForGeneration *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_unaryMinusExpressionForGeneration::
reader_mExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_unaryMinusExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_unaryMinusExpressionForGeneration *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_unaryMinusExpressionForGeneration::actualTypeName (void) const {
  return "unaryMinusExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__unaryMinusExpressionForGeneration ("unaryMinusExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_unaryMinusExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_unaryMinusExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_unaryMinusExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_unaryMinusExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_unaryMinusExpressionForGeneration GGS_unaryMinusExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_unaryMinusExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_unaryMinusExpressionForGeneration * p = dynamic_cast <const GGS_unaryMinusExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_unaryMinusExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_unaryMinusExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_unaryMinusExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_notExpressionForGeneration'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_notExpressionForGeneration::
cPtr_notExpressionForGeneration (const GGS_location & argument_0,
                                const GGS_semanticExpressionForGeneration & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (THERE),
mOperatorLocation (argument_0),
mExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_notExpressionForGeneration * GGS_notExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_notExpressionForGeneration) ;
    return (cPtr_notExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_notExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_notExpressionForGeneration * ptr = dynamic_cast <const cPtr_notExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mExpression.operator_isEqual (ptr->mExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_notExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@notExpressionForGeneration:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_notExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_notExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_notExpressionForGeneration (& typeid (cPtr_notExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_notExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__notExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_notExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_notExpressionForGeneration (mOperatorLocation, mExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_notExpressionForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_notExpressionForGeneration ("notExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_notExpressionForGeneration::
GGS_notExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_notExpressionForGeneration::
GGS_notExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_notExpressionForGeneration GGS_notExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_notExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_notExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_notExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_notExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_notExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_notExpressionForGeneration GGS_notExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionForGeneration & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_notExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_notExpressionForGeneration (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_notExpressionForGeneration::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_notExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_notExpressionForGeneration *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_notExpressionForGeneration::
reader_mExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_notExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_notExpressionForGeneration *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_notExpressionForGeneration::actualTypeName (void) const {
  return "notExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__notExpressionForGeneration ("notExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_notExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_notExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_notExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_notExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_notExpressionForGeneration GGS_notExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_notExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_notExpressionForGeneration * p = dynamic_cast <const GGS_notExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_notExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_notExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_notExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_negateExpressionForGeneration'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_negateExpressionForGeneration::
cPtr_negateExpressionForGeneration (const GGS_location & argument_0,
                                const GGS_semanticExpressionForGeneration & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (THERE),
mOperatorLocation (argument_0),
mExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_negateExpressionForGeneration * GGS_negateExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_negateExpressionForGeneration) ;
    return (cPtr_negateExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_negateExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_negateExpressionForGeneration * ptr = dynamic_cast <const cPtr_negateExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mExpression.operator_isEqual (ptr->mExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_negateExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@negateExpressionForGeneration:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_negateExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_negateExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_negateExpressionForGeneration (& typeid (cPtr_negateExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_negateExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__negateExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_negateExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_negateExpressionForGeneration (mOperatorLocation, mExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_negateExpressionForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_negateExpressionForGeneration ("negateExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_negateExpressionForGeneration::
GGS_negateExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_negateExpressionForGeneration::
GGS_negateExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_negateExpressionForGeneration GGS_negateExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_negateExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_negateExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_negateExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_negateExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_negateExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_negateExpressionForGeneration GGS_negateExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionForGeneration & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_negateExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_negateExpressionForGeneration (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_negateExpressionForGeneration::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_negateExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_negateExpressionForGeneration *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_negateExpressionForGeneration::
reader_mExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_negateExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_negateExpressionForGeneration *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_negateExpressionForGeneration::actualTypeName (void) const {
  return "negateExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__negateExpressionForGeneration ("negateExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_negateExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_negateExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_negateExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_negateExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_negateExpressionForGeneration GGS_negateExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_negateExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_negateExpressionForGeneration * p = dynamic_cast <const GGS_negateExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_negateExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_negateExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_negateExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_ifExpressionForGeneration'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ifExpressionForGeneration::
cPtr_ifExpressionForGeneration (const GGS_semanticExpressionForGeneration & argument_0,
                                const GGS_semanticExpressionForGeneration & argument_1,
                                const GGS_semanticExpressionForGeneration & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (THERE),
mIfExpression (argument_0),
mThenExpression (argument_1),
mElseExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ifExpressionForGeneration * GGS_ifExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_ifExpressionForGeneration) ;
    return (cPtr_ifExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ifExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ifExpressionForGeneration * ptr = dynamic_cast <const cPtr_ifExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mIfExpression.operator_isEqual (ptr->mIfExpression).boolValue ()
         && mThenExpression.operator_isEqual (ptr->mThenExpression).boolValue ()
         && mElseExpression.operator_isEqual (ptr->mElseExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ifExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@ifExpressionForGeneration:"
           << mIfExpression.reader_description (inIndentation + 1)
           << mThenExpression.reader_description (inIndentation + 1)
           << mElseExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ifExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ifExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ifExpressionForGeneration (& typeid (cPtr_ifExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_ifExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__ifExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_ifExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_ifExpressionForGeneration (mIfExpression, mThenExpression, mElseExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_ifExpressionForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_ifExpressionForGeneration ("ifExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_ifExpressionForGeneration::
GGS_ifExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ifExpressionForGeneration::
GGS_ifExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_ifExpressionForGeneration GGS_ifExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ifExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ifExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_ifExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_ifExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ifExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ifExpressionForGeneration GGS_ifExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_semanticExpressionForGeneration & argument_0,
                 const GGS_semanticExpressionForGeneration & argument_1,
                 const GGS_semanticExpressionForGeneration & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_ifExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_ifExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_ifExpressionForGeneration::
reader_mIfExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ifExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ifExpressionForGeneration *) mPointer)->mIfExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_ifExpressionForGeneration::
reader_mThenExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ifExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ifExpressionForGeneration *) mPointer)->mThenExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_ifExpressionForGeneration::
reader_mElseExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ifExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ifExpressionForGeneration *) mPointer)->mElseExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ifExpressionForGeneration::actualTypeName (void) const {
  return "ifExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__ifExpressionForGeneration ("ifExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_ifExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_ifExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_ifExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_ifExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ifExpressionForGeneration GGS_ifExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_ifExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_ifExpressionForGeneration * p = dynamic_cast <const GGS_ifExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_ifExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_ifExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_ifExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_functionCallExpressionForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_functionCallExpressionForGeneration::
cPtr_functionCallExpressionForGeneration (const GGS_lstring & argument_0,
                                const GGS_outSemanticExpressionListForGeneration & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (THERE),
mFunctionName (argument_0),
mExpressions (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_functionCallExpressionForGeneration * GGS_functionCallExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_functionCallExpressionForGeneration) ;
    return (cPtr_functionCallExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_functionCallExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_functionCallExpressionForGeneration * ptr = dynamic_cast <const cPtr_functionCallExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mFunctionName.operator_isEqual (ptr->mFunctionName).boolValue ()
         && mExpressions.operator_isEqual (ptr->mExpressions).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_functionCallExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@functionCallExpressionForGeneration:"
           << mFunctionName.reader_description (inIndentation + 1)
           << mExpressions.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_functionCallExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_functionCallExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_functionCallExpressionForGeneration (& typeid (cPtr_functionCallExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_functionCallExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__functionCallExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_functionCallExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_functionCallExpressionForGeneration (mFunctionName, mExpressions COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_functionCallExpressionForGeneration'           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_functionCallExpressionForGeneration ("functionCallExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_functionCallExpressionForGeneration::
GGS_functionCallExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_functionCallExpressionForGeneration::
GGS_functionCallExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_functionCallExpressionForGeneration GGS_functionCallExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_functionCallExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_functionCallExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_functionCallExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_functionCallExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_functionCallExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_functionCallExpressionForGeneration GGS_functionCallExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_outSemanticExpressionListForGeneration & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_functionCallExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_functionCallExpressionForGeneration (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_functionCallExpressionForGeneration::
reader_mFunctionName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_functionCallExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_functionCallExpressionForGeneration *) mPointer)->mFunctionName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_outSemanticExpressionListForGeneration  GGS_functionCallExpressionForGeneration::
reader_mExpressions (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_outSemanticExpressionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_functionCallExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_functionCallExpressionForGeneration *) mPointer)->mExpressions ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_functionCallExpressionForGeneration::actualTypeName (void) const {
  return "functionCallExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__functionCallExpressionForGeneration ("functionCallExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_functionCallExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_functionCallExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_functionCallExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_functionCallExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_functionCallExpressionForGeneration GGS_functionCallExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_functionCallExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_functionCallExpressionForGeneration * p = dynamic_cast <const GGS_functionCallExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_functionCallExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_functionCallExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_functionCallExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_varInExpressionForGeneration'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_varInExpressionForGeneration::
cPtr_varInExpressionForGeneration (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (THERE),
mVarName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_varInExpressionForGeneration * GGS_varInExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_varInExpressionForGeneration) ;
    return (cPtr_varInExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_varInExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_varInExpressionForGeneration * ptr = dynamic_cast <const cPtr_varInExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mVarName.operator_isEqual (ptr->mVarName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_varInExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@varInExpressionForGeneration:"
           << mVarName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_varInExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_varInExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_varInExpressionForGeneration (& typeid (cPtr_varInExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_varInExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__varInExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_varInExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_varInExpressionForGeneration (mVarName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_varInExpressionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_varInExpressionForGeneration ("varInExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_varInExpressionForGeneration::
GGS_varInExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_varInExpressionForGeneration::
GGS_varInExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_varInExpressionForGeneration GGS_varInExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_varInExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_varInExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_varInExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_varInExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_varInExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_varInExpressionForGeneration GGS_varInExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_varInExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_varInExpressionForGeneration (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_varInExpressionForGeneration::
reader_mVarName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_varInExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_varInExpressionForGeneration *) mPointer)->mVarName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_varInExpressionForGeneration::actualTypeName (void) const {
  return "varInExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__varInExpressionForGeneration ("varInExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_varInExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_varInExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_varInExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_varInExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_varInExpressionForGeneration GGS_varInExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_varInExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_varInExpressionForGeneration * p = dynamic_cast <const GGS_varInExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_varInExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_varInExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_varInExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            class 'cPtr_literalTypeInExpressionForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_literalTypeInExpressionForGeneration::
cPtr_literalTypeInExpressionForGeneration (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (THERE),
mVarName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_literalTypeInExpressionForGeneration * GGS_literalTypeInExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_literalTypeInExpressionForGeneration) ;
    return (cPtr_literalTypeInExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_literalTypeInExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_literalTypeInExpressionForGeneration * ptr = dynamic_cast <const cPtr_literalTypeInExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mVarName.operator_isEqual (ptr->mVarName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_literalTypeInExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@literalTypeInExpressionForGeneration:"
           << mVarName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_literalTypeInExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_literalTypeInExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_literalTypeInExpressionForGeneration (& typeid (cPtr_literalTypeInExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_literalTypeInExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__literalTypeInExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_literalTypeInExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_literalTypeInExpressionForGeneration (mVarName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         GALGAS class 'GGS_literalTypeInExpressionForGeneration'           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_literalTypeInExpressionForGeneration ("literalTypeInExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_literalTypeInExpressionForGeneration::
GGS_literalTypeInExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_literalTypeInExpressionForGeneration::
GGS_literalTypeInExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_literalTypeInExpressionForGeneration GGS_literalTypeInExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_literalTypeInExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_literalTypeInExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_literalTypeInExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_literalTypeInExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_literalTypeInExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalTypeInExpressionForGeneration GGS_literalTypeInExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_literalTypeInExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_literalTypeInExpressionForGeneration (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_literalTypeInExpressionForGeneration::
reader_mVarName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_literalTypeInExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_literalTypeInExpressionForGeneration *) mPointer)->mVarName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_literalTypeInExpressionForGeneration::actualTypeName (void) const {
  return "literalTypeInExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__literalTypeInExpressionForGeneration ("literalTypeInExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_literalTypeInExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_literalTypeInExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_literalTypeInExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_literalTypeInExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalTypeInExpressionForGeneration GGS_literalTypeInExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_literalTypeInExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_literalTypeInExpressionForGeneration * p = dynamic_cast <const GGS_literalTypeInExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_literalTypeInExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_literalTypeInExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_literalTypeInExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_castInExpressionForGeneration'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_castInExpressionForGeneration::
cPtr_castInExpressionForGeneration (const GGS_semanticExpressionForGeneration & argument_0,
                                const GGS_bool& argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (THERE),
mReceiverExpression (argument_0),
mUseKindOfClass (argument_1),
mTypeName (argument_2),
mErrorLocationExpression (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_castInExpressionForGeneration * GGS_castInExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_castInExpressionForGeneration) ;
    return (cPtr_castInExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_castInExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_castInExpressionForGeneration * ptr = dynamic_cast <const cPtr_castInExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mReceiverExpression.operator_isEqual (ptr->mReceiverExpression).boolValue ()
         && mUseKindOfClass.operator_isEqual (ptr->mUseKindOfClass).boolValue ()
         && mTypeName.operator_isEqual (ptr->mTypeName).boolValue ()
         && mErrorLocationExpression.operator_isEqual (ptr->mErrorLocationExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_castInExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@castInExpressionForGeneration:"
           << mReceiverExpression.reader_description (inIndentation + 1)
           << mUseKindOfClass.reader_description (inIndentation + 1)
           << mTypeName.reader_description (inIndentation + 1)
           << mErrorLocationExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_castInExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_castInExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_castInExpressionForGeneration (& typeid (cPtr_castInExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_castInExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__castInExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_castInExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_castInExpressionForGeneration (mReceiverExpression, mUseKindOfClass, mTypeName, mErrorLocationExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_castInExpressionForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_castInExpressionForGeneration ("castInExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_castInExpressionForGeneration::
GGS_castInExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_castInExpressionForGeneration::
GGS_castInExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_castInExpressionForGeneration GGS_castInExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_castInExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_castInExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_castInExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_castInExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_castInExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_castInExpressionForGeneration GGS_castInExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_semanticExpressionForGeneration & argument_0,
                 const GGS_bool& argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_castInExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_castInExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_castInExpressionForGeneration::
reader_mReceiverExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_castInExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_castInExpressionForGeneration *) mPointer)->mReceiverExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_castInExpressionForGeneration::
reader_mUseKindOfClass (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_castInExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_castInExpressionForGeneration *) mPointer)->mUseKindOfClass ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_castInExpressionForGeneration::
reader_mTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_castInExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_castInExpressionForGeneration *) mPointer)->mTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_castInExpressionForGeneration::
reader_mErrorLocationExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_castInExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_castInExpressionForGeneration *) mPointer)->mErrorLocationExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_castInExpressionForGeneration::actualTypeName (void) const {
  return "castInExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__castInExpressionForGeneration ("castInExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_castInExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_castInExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_castInExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_castInExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_castInExpressionForGeneration GGS_castInExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_castInExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_castInExpressionForGeneration * p = dynamic_cast <const GGS_castInExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_castInExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_castInExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_castInExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//   class 'cPtr_filewrapperObjectInstanciationInExpressionForGeneration'    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_filewrapperObjectInstanciationInExpressionForGeneration::
cPtr_filewrapperObjectInstanciationInExpressionForGeneration (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (THERE),
mFilewrapperName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_filewrapperObjectInstanciationInExpressionForGeneration * GGS_filewrapperObjectInstanciationInExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_filewrapperObjectInstanciationInExpressionForGeneration) ;
    return (cPtr_filewrapperObjectInstanciationInExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_filewrapperObjectInstanciationInExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_filewrapperObjectInstanciationInExpressionForGeneration * ptr = dynamic_cast <const cPtr_filewrapperObjectInstanciationInExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mFilewrapperName.operator_isEqual (ptr->mFilewrapperName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_filewrapperObjectInstanciationInExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@filewrapperObjectInstanciationInExpressionForGeneration:"
           << mFilewrapperName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_filewrapperObjectInstanciationInExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_filewrapperObjectInstanciationInExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_filewrapperObjectInstanciationInExpressionForGeneration (& typeid (cPtr_filewrapperObjectInstanciationInExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_filewrapperObjectInstanciationInExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__filewrapperObjectInstanciationInExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_filewrapperObjectInstanciationInExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_filewrapperObjectInstanciationInExpressionForGeneration (mFilewrapperName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//GALGAS class 'GGS_filewrapperObjectInstanciationInExpressionForGeneration' *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_filewrapperObjectInstanciationInExpressionForGeneration ("filewrapperObjectInstanciationInExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_filewrapperObjectInstanciationInExpressionForGeneration::
GGS_filewrapperObjectInstanciationInExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperObjectInstanciationInExpressionForGeneration::
GGS_filewrapperObjectInstanciationInExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_filewrapperObjectInstanciationInExpressionForGeneration GGS_filewrapperObjectInstanciationInExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_filewrapperObjectInstanciationInExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_filewrapperObjectInstanciationInExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_filewrapperObjectInstanciationInExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_filewrapperObjectInstanciationInExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_filewrapperObjectInstanciationInExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperObjectInstanciationInExpressionForGeneration GGS_filewrapperObjectInstanciationInExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_filewrapperObjectInstanciationInExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_filewrapperObjectInstanciationInExpressionForGeneration (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_filewrapperObjectInstanciationInExpressionForGeneration::
reader_mFilewrapperName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_filewrapperObjectInstanciationInExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_filewrapperObjectInstanciationInExpressionForGeneration *) mPointer)->mFilewrapperName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_filewrapperObjectInstanciationInExpressionForGeneration::actualTypeName (void) const {
  return "filewrapperObjectInstanciationInExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__filewrapperObjectInstanciationInExpressionForGeneration ("filewrapperObjectInstanciationInExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_filewrapperObjectInstanciationInExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_filewrapperObjectInstanciationInExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_filewrapperObjectInstanciationInExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_filewrapperObjectInstanciationInExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperObjectInstanciationInExpressionForGeneration GGS_filewrapperObjectInstanciationInExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_filewrapperObjectInstanciationInExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_filewrapperObjectInstanciationInExpressionForGeneration * p = dynamic_cast <const GGS_filewrapperObjectInstanciationInExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_filewrapperObjectInstanciationInExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_filewrapperObjectInstanciationInExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_filewrapperObjectInstanciationInExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            class 'cPtr_filewrapperInExpressionForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_filewrapperInExpressionForGeneration::
cPtr_filewrapperInExpressionForGeneration (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (THERE),
mFilewrapperName (argument_0),
mFilewrapperPath (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_filewrapperInExpressionForGeneration * GGS_filewrapperInExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_filewrapperInExpressionForGeneration) ;
    return (cPtr_filewrapperInExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_filewrapperInExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_filewrapperInExpressionForGeneration * ptr = dynamic_cast <const cPtr_filewrapperInExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mFilewrapperName.operator_isEqual (ptr->mFilewrapperName).boolValue ()
         && mFilewrapperPath.operator_isEqual (ptr->mFilewrapperPath).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_filewrapperInExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@filewrapperInExpressionForGeneration:"
           << mFilewrapperName.reader_description (inIndentation + 1)
           << mFilewrapperPath.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_filewrapperInExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_filewrapperInExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_filewrapperInExpressionForGeneration (& typeid (cPtr_filewrapperInExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_filewrapperInExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__filewrapperInExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_filewrapperInExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_filewrapperInExpressionForGeneration (mFilewrapperName, mFilewrapperPath COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         GALGAS class 'GGS_filewrapperInExpressionForGeneration'           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_filewrapperInExpressionForGeneration ("filewrapperInExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_filewrapperInExpressionForGeneration::
GGS_filewrapperInExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperInExpressionForGeneration::
GGS_filewrapperInExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_filewrapperInExpressionForGeneration GGS_filewrapperInExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_filewrapperInExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_filewrapperInExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_filewrapperInExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_filewrapperInExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_filewrapperInExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperInExpressionForGeneration GGS_filewrapperInExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_filewrapperInExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_filewrapperInExpressionForGeneration (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_filewrapperInExpressionForGeneration::
reader_mFilewrapperName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_filewrapperInExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_filewrapperInExpressionForGeneration *) mPointer)->mFilewrapperName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_filewrapperInExpressionForGeneration::
reader_mFilewrapperPath (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_filewrapperInExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_filewrapperInExpressionForGeneration *) mPointer)->mFilewrapperPath ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_filewrapperInExpressionForGeneration::actualTypeName (void) const {
  return "filewrapperInExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__filewrapperInExpressionForGeneration ("filewrapperInExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_filewrapperInExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_filewrapperInExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_filewrapperInExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_filewrapperInExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperInExpressionForGeneration GGS_filewrapperInExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_filewrapperInExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_filewrapperInExpressionForGeneration * p = dynamic_cast <const GGS_filewrapperInExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_filewrapperInExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_filewrapperInExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_filewrapperInExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        class 'cPtr_filewrapperTemplateInExpressionForGeneration'          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_filewrapperTemplateInExpressionForGeneration::
cPtr_filewrapperTemplateInExpressionForGeneration (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_outSemanticExpressionListForGeneration & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (THERE),
mFilewrapperName (argument_0),
mFilewrapperTemplateName (argument_1),
mActualOutputParameterList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_filewrapperTemplateInExpressionForGeneration * GGS_filewrapperTemplateInExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_filewrapperTemplateInExpressionForGeneration) ;
    return (cPtr_filewrapperTemplateInExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_filewrapperTemplateInExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_filewrapperTemplateInExpressionForGeneration * ptr = dynamic_cast <const cPtr_filewrapperTemplateInExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mFilewrapperName.operator_isEqual (ptr->mFilewrapperName).boolValue ()
         && mFilewrapperTemplateName.operator_isEqual (ptr->mFilewrapperTemplateName).boolValue ()
         && mActualOutputParameterList.operator_isEqual (ptr->mActualOutputParameterList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_filewrapperTemplateInExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@filewrapperTemplateInExpressionForGeneration:"
           << mFilewrapperName.reader_description (inIndentation + 1)
           << mFilewrapperTemplateName.reader_description (inIndentation + 1)
           << mActualOutputParameterList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_filewrapperTemplateInExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_filewrapperTemplateInExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_filewrapperTemplateInExpressionForGeneration (& typeid (cPtr_filewrapperTemplateInExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_filewrapperTemplateInExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__filewrapperTemplateInExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_filewrapperTemplateInExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_filewrapperTemplateInExpressionForGeneration (mFilewrapperName, mFilewrapperTemplateName, mActualOutputParameterList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//     GALGAS class 'GGS_filewrapperTemplateInExpressionForGeneration'       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_filewrapperTemplateInExpressionForGeneration ("filewrapperTemplateInExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateInExpressionForGeneration::
GGS_filewrapperTemplateInExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateInExpressionForGeneration::
GGS_filewrapperTemplateInExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_filewrapperTemplateInExpressionForGeneration GGS_filewrapperTemplateInExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_filewrapperTemplateInExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_filewrapperTemplateInExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_filewrapperTemplateInExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_filewrapperTemplateInExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_filewrapperTemplateInExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateInExpressionForGeneration GGS_filewrapperTemplateInExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_outSemanticExpressionListForGeneration & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_filewrapperTemplateInExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_filewrapperTemplateInExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_filewrapperTemplateInExpressionForGeneration::
reader_mFilewrapperName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_filewrapperTemplateInExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_filewrapperTemplateInExpressionForGeneration *) mPointer)->mFilewrapperName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_filewrapperTemplateInExpressionForGeneration::
reader_mFilewrapperTemplateName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_filewrapperTemplateInExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_filewrapperTemplateInExpressionForGeneration *) mPointer)->mFilewrapperTemplateName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_outSemanticExpressionListForGeneration  GGS_filewrapperTemplateInExpressionForGeneration::
reader_mActualOutputParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_outSemanticExpressionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_filewrapperTemplateInExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_filewrapperTemplateInExpressionForGeneration *) mPointer)->mActualOutputParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_filewrapperTemplateInExpressionForGeneration::actualTypeName (void) const {
  return "filewrapperTemplateInExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__filewrapperTemplateInExpressionForGeneration ("filewrapperTemplateInExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_filewrapperTemplateInExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_filewrapperTemplateInExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_filewrapperTemplateInExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_filewrapperTemplateInExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateInExpressionForGeneration GGS_filewrapperTemplateInExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_filewrapperTemplateInExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_filewrapperTemplateInExpressionForGeneration * p = dynamic_cast <const GGS_filewrapperTemplateInExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_filewrapperTemplateInExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_filewrapperTemplateInExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_filewrapperTemplateInExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Class for 'formalArgumentPassingModeForGeneration' Enumeration       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_formalArgumentPassingModeForGeneration ("formalArgumentPassingModeForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

bool GGS_formalArgumentPassingModeForGeneration::
isBuilt (void) const {
  return mValue > kNotBuilt ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_formalArgumentPassingModeForGeneration::
operator_isEqual (const GGS_formalArgumentPassingModeForGeneration inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_formalArgumentPassingModeForGeneration::
operator_isNotEqual (const GGS_formalArgumentPassingModeForGeneration inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_formalArgumentPassingModeForGeneration::
operator_infOrEqual (const GGS_formalArgumentPassingModeForGeneration inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_formalArgumentPassingModeForGeneration::
operator_supOrEqual (const GGS_formalArgumentPassingModeForGeneration inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_formalArgumentPassingModeForGeneration::
operator_strictInf (const GGS_formalArgumentPassingModeForGeneration inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_formalArgumentPassingModeForGeneration::
operator_strictSup (const GGS_formalArgumentPassingModeForGeneration inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_formalArgumentPassingModeForGeneration::
reader_formalArgumentMessage (C_Compiler & /* inLexique */
                       COMMA_UNUSED_LOCATION_ARGS) const {
  const char * kMessages [5] = {"",
    "a constant input (\?\?) formal argument",
    "an input (\?) formal argument",
    "an input/output (\?!) argument",
    "an output (!) formal argument"
  } ;
  return GGS_string (mValue > 0, kMessages [mValue]) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_formalArgumentPassingModeForGeneration::
reader_formalArgumentString (C_Compiler & /* inLexique */
                       COMMA_UNUSED_LOCATION_ARGS) const {
  const char * kMessages [5] = {"",
    "'\?\?'",
    "'\?'",
    "'\?!'",
    "'!'"
  } ;
  return GGS_string (mValue > 0, kMessages [mValue]) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_formalArgumentPassingModeForGeneration::
reader_string (C_Compiler & /* inLexique */
                       COMMA_UNUSED_LOCATION_ARGS) const {
  const char * kMessages [5] = {"",
    "\?\?",
    "\?",
    "\?!",
    "!"
  } ;
  return GGS_string (mValue > 0, kMessages [mValue]) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_formalArgumentPassingModeForGeneration::
reader_generation1ForFormalParameter (C_Compiler & /* inLexique */
                       COMMA_UNUSED_LOCATION_ARGS) const {
  const char * kMessages [5] = {"",
    "const ",
    "",
    "",
    ""
  } ;
  return GGS_string (mValue > 0, kMessages [mValue]) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_formalArgumentPassingModeForGeneration::
reader_generation2ForFormalParameter (C_Compiler & /* inLexique */
                       COMMA_UNUSED_LOCATION_ARGS) const {
  const char * kMessages [5] = {"",
    "",
    "",
    " &",
    " &"
  } ;
  return GGS_string (mValue > 0, kMessages [mValue]) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_formalArgumentPassingModeForGeneration::
reader_description (const PMSInt32 /* inIndentation */) const {
  C_String s ;
  s << "<enum @formalArgumentPassingModeForGeneration" ;
  switch (mValue) {
  case enum_argumentConstantIn:
    s << " argumentConstantIn>" ;
    break ;
  case enum_argumentIn:
    s << " argumentIn>" ;
    break ;
  case enum_argumentInOut:
    s << " argumentInOut>" ;
    break ;
  case enum_argumentOut:
    s << " argumentOut>" ;
    break ;
  case kNotBuilt:
    s << " (not built)>" ;
    break ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_formalArgumentPassingModeForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_formalArgumentPassingModeForGeneration * p = NULL ;
    macroMyNew (p, GGS_formalArgumentPassingModeForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalArgumentPassingModeForGeneration GGS_formalArgumentPassingModeForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_formalArgumentPassingModeForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_formalArgumentPassingModeForGeneration * p = dynamic_cast <const GGS_formalArgumentPassingModeForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_formalArgumentPassingModeForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_formalArgumentPassingModeForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_formalArgumentPassingModeForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Element of list '@formalParameterListForGeneration'             *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_formalParameterListForGeneration::
elementOf_GGS_formalParameterListForGeneration (const GGS_formalArgumentPassingModeForGeneration& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_bool& argument_3
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mFormalParameterPassingMode (argument_0),
mFormalParameterTypeName (argument_1),
mFormalParameterName (argument_2),
mIsUnused (argument_3) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_formalParameterListForGeneration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_formalParameterListForGeneration * ptr = dynamic_cast <const elementOf_GGS_formalParameterListForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mFormalParameterPassingMode.operator_isEqual (ptr->mFormalParameterPassingMode).boolValue ()
         && mFormalParameterTypeName.operator_isEqual (ptr->mFormalParameterTypeName).boolValue ()
         && mFormalParameterName.operator_isEqual (ptr->mFormalParameterName).boolValue ()
         && mIsUnused.operator_isEqual (ptr->mIsUnused).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_formalParameterListForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFormalParameterPassingMode.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFormalParameterTypeName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFormalParameterName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mIsUnused.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 List '@formalParameterListForGeneration'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_formalParameterListForGeneration ("formalParameterListForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_formalParameterListForGeneration::
internalAppendValues (const GGS_formalArgumentPassingModeForGeneration& argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_bool& argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_formalParameterListForGeneration::
internalPrependValues (const GGS_formalArgumentPassingModeForGeneration& argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_bool& argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_formalParameterListForGeneration::
addAssign_operation (const GGS_formalArgumentPassingModeForGeneration& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_bool& argument_3) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()&& argument_3.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_formalParameterListForGeneration GGS_formalParameterListForGeneration::
operator_concat (const GGS_formalParameterListForGeneration & inOperand) const {
  GGS_formalParameterListForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_formalParameterListForGeneration::
dotAssign_operation (const GGS_formalParameterListForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_formalParameterListForGeneration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_formalArgumentPassingModeForGeneration p_0 = p->mFormalParameterPassingMode ;
          GGS_lstring  p_1 = p->mFormalParameterTypeName ;
          GGS_lstring  p_2 = p->mFormalParameterName ;
          GGS_bool p_3 = p->mIsUnused ;
          internalAppendValues (p_0, p_1, p_2, p_3 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_formalParameterListForGeneration::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_formalArgumentPassingModeForGeneration& argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_lstring & argument_2,
                     const GGS_bool& argument_3
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_formalParameterListForGeneration::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mFormalParameterPassingMode,
                                ptr->mFormalParameterTypeName,
                                ptr->mFormalParameterName,
                                ptr->mIsUnused
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_formalParameterListForGeneration  GGS_formalParameterListForGeneration::
constructor_emptyList (void) {
  GGS_formalParameterListForGeneration result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameterListForGeneration  GGS_formalParameterListForGeneration::
constructor_listWithValue (const GGS_formalArgumentPassingModeForGeneration& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_bool& argument_3) {
  GGS_formalParameterListForGeneration result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2, argument_3) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_formalParameterListForGeneration::
internalSubListWithRange (GGS_formalParameterListForGeneration & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mFormalParameterPassingMode, ptr->mFormalParameterTypeName, ptr->mFormalParameterName, ptr->mIsUnused) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_formalParameterListForGeneration GGS_formalParameterListForGeneration::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_formalParameterListForGeneration result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameterListForGeneration GGS_formalParameterListForGeneration::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_formalParameterListForGeneration result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_formalParameterListForGeneration::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@formalParameterListForGeneration", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_formalParameterListForGeneration::
method_first (C_Compiler & inLexique,
              GGS_formalArgumentPassingModeForGeneration& _out_0,
              GGS_lstring & _out_1,
              GGS_lstring & _out_2,
              GGS_bool& _out_3
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mFormalParameterPassingMode ;
    _out_1 = ptr->mFormalParameterTypeName ;
    _out_2 = ptr->mFormalParameterName ;
    _out_3 = ptr->mIsUnused ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_formalParameterListForGeneration::
method_last (C_Compiler & inLexique,
             GGS_formalArgumentPassingModeForGeneration& _out_0,
             GGS_lstring & _out_1,
             GGS_lstring & _out_2,
             GGS_bool& _out_3
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mFormalParameterPassingMode ;
    _out_1 = ptr->mFormalParameterTypeName ;
    _out_2 = ptr->mFormalParameterName ;
    _out_3 = ptr->mIsUnused ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_formalParameterListForGeneration::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_formalArgumentPassingModeForGeneration& _out_0,
                 GGS_lstring & _out_1,
                 GGS_lstring & _out_2,
                 GGS_bool& _out_3
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mFormalParameterPassingMode ;
    _out_1 = ptr->mFormalParameterTypeName ;
    _out_2 = ptr->mFormalParameterName ;
    _out_3 = ptr->mIsUnused ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_formalParameterListForGeneration::
modifier_popLast (C_Compiler & inLexique,
                GGS_formalArgumentPassingModeForGeneration& _out_0,
                GGS_lstring & _out_1,
                GGS_lstring & _out_2,
                GGS_bool& _out_3
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mFormalParameterPassingMode ;
    _out_1 = ptr->mFormalParameterTypeName ;
    _out_2 = ptr->mFormalParameterName ;
    _out_3 = ptr->mIsUnused ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_formalArgumentPassingModeForGeneration GGS_formalParameterListForGeneration::
reader_mFormalParameterPassingModeAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_formalArgumentPassingModeForGeneration result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mFormalParameterPassingMode ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_formalParameterListForGeneration::
reader_mFormalParameterTypeNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mFormalParameterTypeName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_formalParameterListForGeneration::
reader_mFormalParameterNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mFormalParameterName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_formalParameterListForGeneration::
reader_mIsUnusedAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mIsUnused ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_formalParameterListForGeneration::
modifier_setMFormalParameterPassingModeAtIndex (C_Compiler & inLexique,
                              const GGS_formalArgumentPassingModeForGeneration & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mFormalParameterPassingMode = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_formalParameterListForGeneration::
modifier_setMFormalParameterTypeNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mFormalParameterTypeName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_formalParameterListForGeneration::
modifier_setMFormalParameterNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mFormalParameterName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_formalParameterListForGeneration::
modifier_setMIsUnusedAtIndex (C_Compiler & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mIsUnused = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_formalArgumentPassingModeForGeneration & GGS_formalParameterListForGeneration::cEnumerator::_mFormalParameterPassingMode (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mFormalParameterPassingMode ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_formalParameterListForGeneration::cEnumerator::_mFormalParameterTypeName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mFormalParameterTypeName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_formalParameterListForGeneration::cEnumerator::_mFormalParameterName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mFormalParameterName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_formalParameterListForGeneration::cEnumerator::_mIsUnused (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mIsUnused ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_formalParameterListForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_formalParameterListForGeneration * p = NULL ;
    macroMyNew (p, GGS_formalParameterListForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameterListForGeneration GGS_formalParameterListForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_formalParameterListForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_formalParameterListForGeneration * p = dynamic_cast <const GGS_formalParameterListForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_formalParameterListForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_formalParameterListForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_formalParameterListForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         Element of list '@formalInputParameterListForGeneration'          *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_formalInputParameterListForGeneration::
elementOf_GGS_formalInputParameterListForGeneration (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_bool& argument_2
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mFormalParameterTypeName (argument_0),
mFormalParameterName (argument_1),
mIsUnused (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_formalInputParameterListForGeneration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_formalInputParameterListForGeneration * ptr = dynamic_cast <const elementOf_GGS_formalInputParameterListForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mFormalParameterTypeName.operator_isEqual (ptr->mFormalParameterTypeName).boolValue ()
         && mFormalParameterName.operator_isEqual (ptr->mFormalParameterName).boolValue ()
         && mIsUnused.operator_isEqual (ptr->mIsUnused).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_formalInputParameterListForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFormalParameterTypeName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFormalParameterName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mIsUnused.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              List '@formalInputParameterListForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_formalInputParameterListForGeneration ("formalInputParameterListForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_formalInputParameterListForGeneration::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_bool& argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_formalInputParameterListForGeneration::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_bool& argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_formalInputParameterListForGeneration::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_bool& argument_2) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_formalInputParameterListForGeneration GGS_formalInputParameterListForGeneration::
operator_concat (const GGS_formalInputParameterListForGeneration & inOperand) const {
  GGS_formalInputParameterListForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_formalInputParameterListForGeneration::
dotAssign_operation (const GGS_formalInputParameterListForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_formalInputParameterListForGeneration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mFormalParameterTypeName ;
          GGS_lstring  p_1 = p->mFormalParameterName ;
          GGS_bool p_2 = p->mIsUnused ;
          internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_formalInputParameterListForGeneration::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_bool& argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_formalInputParameterListForGeneration::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mFormalParameterTypeName,
                                ptr->mFormalParameterName,
                                ptr->mIsUnused
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_formalInputParameterListForGeneration  GGS_formalInputParameterListForGeneration::
constructor_emptyList (void) {
  GGS_formalInputParameterListForGeneration result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalInputParameterListForGeneration  GGS_formalInputParameterListForGeneration::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_bool& argument_2) {
  GGS_formalInputParameterListForGeneration result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_formalInputParameterListForGeneration::
internalSubListWithRange (GGS_formalInputParameterListForGeneration & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mFormalParameterTypeName, ptr->mFormalParameterName, ptr->mIsUnused) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_formalInputParameterListForGeneration GGS_formalInputParameterListForGeneration::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_formalInputParameterListForGeneration result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalInputParameterListForGeneration GGS_formalInputParameterListForGeneration::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_formalInputParameterListForGeneration result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_formalInputParameterListForGeneration::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@formalInputParameterListForGeneration", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_formalInputParameterListForGeneration::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1,
              GGS_bool& _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mFormalParameterTypeName ;
    _out_1 = ptr->mFormalParameterName ;
    _out_2 = ptr->mIsUnused ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_formalInputParameterListForGeneration::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1,
             GGS_bool& _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mFormalParameterTypeName ;
    _out_1 = ptr->mFormalParameterName ;
    _out_2 = ptr->mIsUnused ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_formalInputParameterListForGeneration::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1,
                 GGS_bool& _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mFormalParameterTypeName ;
    _out_1 = ptr->mFormalParameterName ;
    _out_2 = ptr->mIsUnused ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_formalInputParameterListForGeneration::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1,
                GGS_bool& _out_2
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mFormalParameterTypeName ;
    _out_1 = ptr->mFormalParameterName ;
    _out_2 = ptr->mIsUnused ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_formalInputParameterListForGeneration::
reader_mFormalParameterTypeNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mFormalParameterTypeName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_formalInputParameterListForGeneration::
reader_mFormalParameterNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mFormalParameterName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_formalInputParameterListForGeneration::
reader_mIsUnusedAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mIsUnused ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_formalInputParameterListForGeneration::
modifier_setMFormalParameterTypeNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mFormalParameterTypeName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_formalInputParameterListForGeneration::
modifier_setMFormalParameterNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mFormalParameterName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_formalInputParameterListForGeneration::
modifier_setMIsUnusedAtIndex (C_Compiler & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mIsUnused = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_formalInputParameterListForGeneration::cEnumerator::_mFormalParameterTypeName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mFormalParameterTypeName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_formalInputParameterListForGeneration::cEnumerator::_mFormalParameterName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mFormalParameterName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_formalInputParameterListForGeneration::cEnumerator::_mIsUnused (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mIsUnused ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_formalInputParameterListForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_formalInputParameterListForGeneration * p = NULL ;
    macroMyNew (p, GGS_formalInputParameterListForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalInputParameterListForGeneration GGS_formalInputParameterListForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_formalInputParameterListForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_formalInputParameterListForGeneration * p = dynamic_cast <const GGS_formalInputParameterListForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_formalInputParameterListForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_formalInputParameterListForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_formalInputParameterListForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_actualParameterForGeneration'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_actualParameterForGeneration::
cPtr_actualParameterForGeneration (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_actualParameterForGeneration * GGS_actualParameterForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_actualParameterForGeneration) ;
    return (cPtr_actualParameterForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_actualParameterForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@actualParameterForGeneration:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_actualParameterForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_actualParameterForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_actualParameterForGeneration (& typeid (cPtr_actualParameterForGeneration), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_actualParameterForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__actualParameterForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_actualParameterForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_actualParameterForGeneration ("actualParameterForGeneration", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_actualParameterForGeneration::
GGS_actualParameterForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_actualParameterForGeneration::
GGS_actualParameterForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_actualParameterForGeneration GGS_actualParameterForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_actualParameterForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_actualParameterForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_actualParameterForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_actualParameterForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_actualParameterForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_actualParameterForGeneration::actualTypeName (void) const {
  return "actualParameterForGeneration" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_actualParameterForGeneration::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__actualParameterForGeneration ("actualParameterForGeneration", & kTypeDescriptor_GGS_actualParameterForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_actualParameterForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_actualParameterForGeneration * p = NULL ;
    macroMyNew (p, GGS_actualParameterForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameterForGeneration GGS_actualParameterForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_actualParameterForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_actualParameterForGeneration * p = dynamic_cast <const GGS_actualParameterForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_actualParameterForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_actualParameterForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_actualParameterForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_outputActualParameterForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_outputActualParameterForGeneration::
cPtr_outputActualParameterForGeneration (const GGS_semanticExpressionForGeneration & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_actualParameterForGeneration (THERE),
mOutputActualParameterExpression (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_outputActualParameterForGeneration * GGS_outputActualParameterForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_outputActualParameterForGeneration) ;
    return (cPtr_outputActualParameterForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_outputActualParameterForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_outputActualParameterForGeneration * ptr = dynamic_cast <const cPtr_outputActualParameterForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOutputActualParameterExpression.operator_isEqual (ptr->mOutputActualParameterExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_outputActualParameterForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@outputActualParameterForGeneration:"
           << mOutputActualParameterExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_outputActualParameterForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_outputActualParameterForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_outputActualParameterForGeneration (& typeid (cPtr_outputActualParameterForGeneration), & typeid (cPtr_actualParameterForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_outputActualParameterForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__outputActualParameterForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_outputActualParameterForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_outputActualParameterForGeneration (mOutputActualParameterExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_outputActualParameterForGeneration'            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_outputActualParameterForGeneration ("outputActualParameterForGeneration", true, & kTypeDescriptor_GGS_actualParameterForGeneration) ;

//---------------------------------------------------------------------------*

GGS_outputActualParameterForGeneration::
GGS_outputActualParameterForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_outputActualParameterForGeneration::
GGS_outputActualParameterForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_outputActualParameterForGeneration GGS_outputActualParameterForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_outputActualParameterForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_outputActualParameterForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_outputActualParameterForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_outputActualParameterForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_outputActualParameterForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_outputActualParameterForGeneration GGS_outputActualParameterForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_semanticExpressionForGeneration & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_outputActualParameterForGeneration result ;
  macroMyNew (result.mPointer, cPtr_outputActualParameterForGeneration (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_outputActualParameterForGeneration::
reader_mOutputActualParameterExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_outputActualParameterForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_outputActualParameterForGeneration *) mPointer)->mOutputActualParameterExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_outputActualParameterForGeneration::actualTypeName (void) const {
  return "outputActualParameterForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__outputActualParameterForGeneration ("outputActualParameterForGeneration", gClassInfoFor__actualParameterForGeneration, & kTypeDescriptor_GGS_outputActualParameterForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_outputActualParameterForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_outputActualParameterForGeneration * p = NULL ;
    macroMyNew (p, GGS_outputActualParameterForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_outputActualParameterForGeneration GGS_outputActualParameterForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_outputActualParameterForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_outputActualParameterForGeneration * p = dynamic_cast <const GGS_outputActualParameterForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_outputActualParameterForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_outputActualParameterForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_outputActualParameterForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           class 'cPtr_outputInputActualParameterForGeneration'            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_outputInputActualParameterForGeneration::
cPtr_outputInputActualParameterForGeneration (const GGS_lstring & argument_0,
                                const GGS_lstringlist & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_actualParameterForGeneration (THERE),
mOutputInputActualParameterName (argument_0),
mStructAttributeList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_outputInputActualParameterForGeneration * GGS_outputInputActualParameterForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_outputInputActualParameterForGeneration) ;
    return (cPtr_outputInputActualParameterForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_outputInputActualParameterForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_outputInputActualParameterForGeneration * ptr = dynamic_cast <const cPtr_outputInputActualParameterForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOutputInputActualParameterName.operator_isEqual (ptr->mOutputInputActualParameterName).boolValue ()
         && mStructAttributeList.operator_isEqual (ptr->mStructAttributeList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_outputInputActualParameterForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@outputInputActualParameterForGeneration:"
           << mOutputInputActualParameterName.reader_description (inIndentation + 1)
           << mStructAttributeList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_outputInputActualParameterForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_outputInputActualParameterForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_outputInputActualParameterForGeneration (& typeid (cPtr_outputInputActualParameterForGeneration), & typeid (cPtr_actualParameterForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_outputInputActualParameterForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__outputInputActualParameterForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_outputInputActualParameterForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_outputInputActualParameterForGeneration (mOutputInputActualParameterName, mStructAttributeList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        GALGAS class 'GGS_outputInputActualParameterForGeneration'         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_outputInputActualParameterForGeneration ("outputInputActualParameterForGeneration", true, & kTypeDescriptor_GGS_actualParameterForGeneration) ;

//---------------------------------------------------------------------------*

GGS_outputInputActualParameterForGeneration::
GGS_outputInputActualParameterForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_outputInputActualParameterForGeneration::
GGS_outputInputActualParameterForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_outputInputActualParameterForGeneration GGS_outputInputActualParameterForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_outputInputActualParameterForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_outputInputActualParameterForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_outputInputActualParameterForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_outputInputActualParameterForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_outputInputActualParameterForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_outputInputActualParameterForGeneration GGS_outputInputActualParameterForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstringlist & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_outputInputActualParameterForGeneration result ;
  macroMyNew (result.mPointer, cPtr_outputInputActualParameterForGeneration (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_outputInputActualParameterForGeneration::
reader_mOutputInputActualParameterName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_outputInputActualParameterForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_outputInputActualParameterForGeneration *) mPointer)->mOutputInputActualParameterName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_outputInputActualParameterForGeneration::
reader_mStructAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_outputInputActualParameterForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_outputInputActualParameterForGeneration *) mPointer)->mStructAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_outputInputActualParameterForGeneration::actualTypeName (void) const {
  return "outputInputActualParameterForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__outputInputActualParameterForGeneration ("outputInputActualParameterForGeneration", gClassInfoFor__actualParameterForGeneration, & kTypeDescriptor_GGS_outputInputActualParameterForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_outputInputActualParameterForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_outputInputActualParameterForGeneration * p = NULL ;
    macroMyNew (p, GGS_outputInputActualParameterForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_outputInputActualParameterForGeneration GGS_outputInputActualParameterForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_outputInputActualParameterForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_outputInputActualParameterForGeneration * p = dynamic_cast <const GGS_outputInputActualParameterForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_outputInputActualParameterForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_outputInputActualParameterForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_outputInputActualParameterForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'cPtr_inputActualParameterForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_inputActualParameterForGeneration::
cPtr_inputActualParameterForGeneration (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_actualParameterForGeneration (THERE),
mDeclarationTypeName (argument_0),
mInputActualParameterName (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_inputActualParameterForGeneration * GGS_inputActualParameterForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_inputActualParameterForGeneration) ;
    return (cPtr_inputActualParameterForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_inputActualParameterForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_inputActualParameterForGeneration * ptr = dynamic_cast <const cPtr_inputActualParameterForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mDeclarationTypeName.operator_isEqual (ptr->mDeclarationTypeName).boolValue ()
         && mInputActualParameterName.operator_isEqual (ptr->mInputActualParameterName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_inputActualParameterForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@inputActualParameterForGeneration:"
           << mDeclarationTypeName.reader_description (inIndentation + 1)
           << mInputActualParameterName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_inputActualParameterForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_inputActualParameterForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_inputActualParameterForGeneration (& typeid (cPtr_inputActualParameterForGeneration), & typeid (cPtr_actualParameterForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_inputActualParameterForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__inputActualParameterForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_inputActualParameterForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_inputActualParameterForGeneration (mDeclarationTypeName, mInputActualParameterName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_inputActualParameterForGeneration'            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_inputActualParameterForGeneration ("inputActualParameterForGeneration", true, & kTypeDescriptor_GGS_actualParameterForGeneration) ;

//---------------------------------------------------------------------------*

GGS_inputActualParameterForGeneration::
GGS_inputActualParameterForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_inputActualParameterForGeneration::
GGS_inputActualParameterForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_inputActualParameterForGeneration GGS_inputActualParameterForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_inputActualParameterForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_inputActualParameterForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_inputActualParameterForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_inputActualParameterForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_inputActualParameterForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_inputActualParameterForGeneration GGS_inputActualParameterForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_inputActualParameterForGeneration result ;
  macroMyNew (result.mPointer, cPtr_inputActualParameterForGeneration (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_inputActualParameterForGeneration::
reader_mDeclarationTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_inputActualParameterForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_inputActualParameterForGeneration *) mPointer)->mDeclarationTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_inputActualParameterForGeneration::
reader_mInputActualParameterName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_inputActualParameterForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_inputActualParameterForGeneration *) mPointer)->mInputActualParameterName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_inputActualParameterForGeneration::actualTypeName (void) const {
  return "inputActualParameterForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__inputActualParameterForGeneration ("inputActualParameterForGeneration", gClassInfoFor__actualParameterForGeneration, & kTypeDescriptor_GGS_inputActualParameterForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_inputActualParameterForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_inputActualParameterForGeneration * p = NULL ;
    macroMyNew (p, GGS_inputActualParameterForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_inputActualParameterForGeneration GGS_inputActualParameterForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_inputActualParameterForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_inputActualParameterForGeneration * p = dynamic_cast <const GGS_inputActualParameterForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_inputActualParameterForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_inputActualParameterForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_inputActualParameterForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           class 'cPtr_inputJokerActualParameterForGeneration'             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_inputJokerActualParameterForGeneration::
cPtr_inputJokerActualParameterForGeneration (LOCATION_ARGS)
:cPtr_actualParameterForGeneration (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_inputJokerActualParameterForGeneration * GGS_inputJokerActualParameterForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_inputJokerActualParameterForGeneration) ;
    return (cPtr_inputJokerActualParameterForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_inputJokerActualParameterForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_inputJokerActualParameterForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@inputJokerActualParameterForGeneration:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_inputJokerActualParameterForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_inputJokerActualParameterForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_inputJokerActualParameterForGeneration (& typeid (cPtr_inputJokerActualParameterForGeneration), & typeid (cPtr_actualParameterForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_inputJokerActualParameterForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__inputJokerActualParameterForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        GALGAS class 'GGS_inputJokerActualParameterForGeneration'          *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_inputJokerActualParameterForGeneration ("inputJokerActualParameterForGeneration", true, & kTypeDescriptor_GGS_actualParameterForGeneration) ;

//---------------------------------------------------------------------------*

GGS_inputJokerActualParameterForGeneration::
GGS_inputJokerActualParameterForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_inputJokerActualParameterForGeneration::
GGS_inputJokerActualParameterForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_inputJokerActualParameterForGeneration GGS_inputJokerActualParameterForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_inputJokerActualParameterForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_inputJokerActualParameterForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_inputJokerActualParameterForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_inputJokerActualParameterForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_inputJokerActualParameterForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_inputJokerActualParameterForGeneration * gSingleton_inputJokerActualParameterForGeneration = NULL ;

//---------------------------------------------------------------------------*

GGS_inputJokerActualParameterForGeneration GGS_inputJokerActualParameterForGeneration::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_inputJokerActualParameterForGeneration result ;
  if (NULL == gSingleton_inputJokerActualParameterForGeneration) {
    macroMyNew (gSingleton_inputJokerActualParameterForGeneration, cPtr_inputJokerActualParameterForGeneration (THERE)) ;
    macroRetainObject (gSingleton_inputJokerActualParameterForGeneration) ;
  }
  macroAssignObject (result.mPointer, gSingleton_inputJokerActualParameterForGeneration) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_inputJokerActualParameterForGeneration::actualTypeName (void) const {
  return "inputJokerActualParameterForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__inputJokerActualParameterForGeneration ("inputJokerActualParameterForGeneration", gClassInfoFor__actualParameterForGeneration, & kTypeDescriptor_GGS_inputJokerActualParameterForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_inputJokerActualParameterForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_inputJokerActualParameterForGeneration * p = NULL ;
    macroMyNew (p, GGS_inputJokerActualParameterForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_inputJokerActualParameterForGeneration GGS_inputJokerActualParameterForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_inputJokerActualParameterForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_inputJokerActualParameterForGeneration * p = dynamic_cast <const GGS_inputJokerActualParameterForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_inputJokerActualParameterForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_inputJokerActualParameterForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_inputJokerActualParameterForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Element of list '@actualParameterListForGeneration'             *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_actualParameterListForGeneration::
elementOf_GGS_actualParameterListForGeneration (const GGS_actualParameterForGeneration & argument_0
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mActualParameter (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_actualParameterListForGeneration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_actualParameterListForGeneration * ptr = dynamic_cast <const elementOf_GGS_actualParameterListForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mActualParameter.operator_isEqual (ptr->mActualParameter).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_actualParameterListForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mActualParameter.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 List '@actualParameterListForGeneration'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_actualParameterListForGeneration ("actualParameterListForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_actualParameterListForGeneration::
internalAppendValues (const GGS_actualParameterForGeneration & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_actualParameterListForGeneration::
internalPrependValues (const GGS_actualParameterForGeneration & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_actualParameterListForGeneration::
addAssign_operation (const GGS_actualParameterForGeneration & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_actualParameterListForGeneration GGS_actualParameterListForGeneration::
operator_concat (const GGS_actualParameterListForGeneration & inOperand) const {
  GGS_actualParameterListForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_actualParameterListForGeneration::
dotAssign_operation (const GGS_actualParameterListForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_actualParameterListForGeneration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_actualParameterForGeneration  p_0 = p->mActualParameter ;
          internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_actualParameterListForGeneration::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_actualParameterForGeneration & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_actualParameterListForGeneration::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mActualParameter
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_actualParameterListForGeneration  GGS_actualParameterListForGeneration::
constructor_emptyList (void) {
  GGS_actualParameterListForGeneration result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameterListForGeneration  GGS_actualParameterListForGeneration::
constructor_listWithValue (const GGS_actualParameterForGeneration & argument_0) {
  GGS_actualParameterListForGeneration result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_actualParameterListForGeneration::
internalSubListWithRange (GGS_actualParameterListForGeneration & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mActualParameter) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_actualParameterListForGeneration GGS_actualParameterListForGeneration::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_actualParameterListForGeneration result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameterListForGeneration GGS_actualParameterListForGeneration::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_actualParameterListForGeneration result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_actualParameterListForGeneration::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@actualParameterListForGeneration", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_actualParameterListForGeneration::
method_first (C_Compiler & inLexique,
              GGS_actualParameterForGeneration & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mActualParameter ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_actualParameterListForGeneration::
method_last (C_Compiler & inLexique,
             GGS_actualParameterForGeneration & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mActualParameter ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_actualParameterListForGeneration::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_actualParameterForGeneration & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mActualParameter ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_actualParameterListForGeneration::
modifier_popLast (C_Compiler & inLexique,
                GGS_actualParameterForGeneration & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mActualParameter ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_actualParameterForGeneration  GGS_actualParameterListForGeneration::
reader_mActualParameterAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_actualParameterForGeneration  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mActualParameter ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_actualParameterListForGeneration::
modifier_setMActualParameterAtIndex (C_Compiler & inLexique,
                              const GGS_actualParameterForGeneration  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mActualParameter = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_actualParameterForGeneration  & GGS_actualParameterListForGeneration::cEnumerator::_mActualParameter (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mActualParameter ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_actualParameterListForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_actualParameterListForGeneration * p = NULL ;
    macroMyNew (p, GGS_actualParameterListForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameterListForGeneration GGS_actualParameterListForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_actualParameterListForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_actualParameterListForGeneration * p = dynamic_cast <const GGS_actualParameterListForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_actualParameterListForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_actualParameterListForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_actualParameterListForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         Element of list '@actualInputParameterListForGeneration'          *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_actualInputParameterListForGeneration::
elementOf_GGS_actualInputParameterListForGeneration (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mActualParameterTypeName (argument_0),
mActualParameterName (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_actualInputParameterListForGeneration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_actualInputParameterListForGeneration * ptr = dynamic_cast <const elementOf_GGS_actualInputParameterListForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mActualParameterTypeName.operator_isEqual (ptr->mActualParameterTypeName).boolValue ()
         && mActualParameterName.operator_isEqual (ptr->mActualParameterName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_actualInputParameterListForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mActualParameterTypeName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mActualParameterName.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              List '@actualInputParameterListForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_actualInputParameterListForGeneration ("actualInputParameterListForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_actualInputParameterListForGeneration::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_actualInputParameterListForGeneration::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_actualInputParameterListForGeneration::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_actualInputParameterListForGeneration GGS_actualInputParameterListForGeneration::
operator_concat (const GGS_actualInputParameterListForGeneration & inOperand) const {
  GGS_actualInputParameterListForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_actualInputParameterListForGeneration::
dotAssign_operation (const GGS_actualInputParameterListForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_actualInputParameterListForGeneration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mActualParameterTypeName ;
          GGS_lstring  p_1 = p->mActualParameterName ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_actualInputParameterListForGeneration::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_actualInputParameterListForGeneration::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mActualParameterTypeName,
                                ptr->mActualParameterName
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_actualInputParameterListForGeneration  GGS_actualInputParameterListForGeneration::
constructor_emptyList (void) {
  GGS_actualInputParameterListForGeneration result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualInputParameterListForGeneration  GGS_actualInputParameterListForGeneration::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  GGS_actualInputParameterListForGeneration result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_actualInputParameterListForGeneration::
internalSubListWithRange (GGS_actualInputParameterListForGeneration & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mActualParameterTypeName, ptr->mActualParameterName) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_actualInputParameterListForGeneration GGS_actualInputParameterListForGeneration::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_actualInputParameterListForGeneration result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualInputParameterListForGeneration GGS_actualInputParameterListForGeneration::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_actualInputParameterListForGeneration result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_actualInputParameterListForGeneration::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@actualInputParameterListForGeneration", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_actualInputParameterListForGeneration::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mActualParameterTypeName ;
    _out_1 = ptr->mActualParameterName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_actualInputParameterListForGeneration::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mActualParameterTypeName ;
    _out_1 = ptr->mActualParameterName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_actualInputParameterListForGeneration::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mActualParameterTypeName ;
    _out_1 = ptr->mActualParameterName ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_actualInputParameterListForGeneration::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mActualParameterTypeName ;
    _out_1 = ptr->mActualParameterName ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_actualInputParameterListForGeneration::
reader_mActualParameterTypeNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mActualParameterTypeName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_actualInputParameterListForGeneration::
reader_mActualParameterNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mActualParameterName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_actualInputParameterListForGeneration::
modifier_setMActualParameterTypeNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mActualParameterTypeName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_actualInputParameterListForGeneration::
modifier_setMActualParameterNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mActualParameterName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_actualInputParameterListForGeneration::cEnumerator::_mActualParameterTypeName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mActualParameterTypeName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_actualInputParameterListForGeneration::cEnumerator::_mActualParameterName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mActualParameterName ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_actualInputParameterListForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_actualInputParameterListForGeneration * p = NULL ;
    macroMyNew (p, GGS_actualInputParameterListForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualInputParameterListForGeneration GGS_actualInputParameterListForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_actualInputParameterListForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_actualInputParameterListForGeneration * p = dynamic_cast <const GGS_actualInputParameterListForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_actualInputParameterListForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_actualInputParameterListForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_actualInputParameterListForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_syntaxInstructionForGeneration'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_syntaxInstructionForGeneration::
cPtr_syntaxInstructionForGeneration (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE),
mStartLocation (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_syntaxInstructionForGeneration * GGS_syntaxInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_syntaxInstructionForGeneration) ;
    return (cPtr_syntaxInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_syntaxInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@syntaxInstructionForGeneration:"
           << mStartLocation.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_syntaxInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_syntaxInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_syntaxInstructionForGeneration (& typeid (cPtr_syntaxInstructionForGeneration), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_syntaxInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__syntaxInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_syntaxInstructionForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_syntaxInstructionForGeneration ("syntaxInstructionForGeneration", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_syntaxInstructionForGeneration::
GGS_syntaxInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_syntaxInstructionForGeneration::
GGS_syntaxInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_syntaxInstructionForGeneration GGS_syntaxInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_syntaxInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_syntaxInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_syntaxInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_syntaxInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_syntaxInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_syntaxInstructionForGeneration::actualTypeName (void) const {
  return "syntaxInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_syntaxInstructionForGeneration::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__syntaxInstructionForGeneration ("syntaxInstructionForGeneration", & kTypeDescriptor_GGS_syntaxInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_syntaxInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_syntaxInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_syntaxInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_syntaxInstructionForGeneration GGS_syntaxInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_syntaxInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_syntaxInstructionForGeneration * p = dynamic_cast <const GGS_syntaxInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_syntaxInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_syntaxInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_syntaxInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'cPtr_semanticInstructionForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_semanticInstructionForGeneration::
cPtr_semanticInstructionForGeneration (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_syntaxInstructionForGeneration (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_semanticInstructionForGeneration * GGS_semanticInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_semanticInstructionForGeneration) ;
    return (cPtr_semanticInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_semanticInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@semanticInstructionForGeneration:"
           << mStartLocation.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_semanticInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_semanticInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_semanticInstructionForGeneration (& typeid (cPtr_semanticInstructionForGeneration), & typeid (cPtr_syntaxInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_semanticInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__semanticInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_semanticInstructionForGeneration'             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_semanticInstructionForGeneration ("semanticInstructionForGeneration", true, & kTypeDescriptor_GGS_syntaxInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_semanticInstructionForGeneration::
GGS_semanticInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionForGeneration::
GGS_semanticInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_semanticInstructionForGeneration GGS_semanticInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_semanticInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_semanticInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_semanticInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_semanticInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_semanticInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_semanticInstructionForGeneration::actualTypeName (void) const {
  return "semanticInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__semanticInstructionForGeneration ("semanticInstructionForGeneration", gClassInfoFor__syntaxInstructionForGeneration, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_semanticInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_semanticInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_semanticInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionForGeneration GGS_semanticInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_semanticInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_semanticInstructionForGeneration * p = dynamic_cast <const GGS_semanticInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_semanticInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_semanticInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_semanticInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         Element of list '@semanticInstructionListForGeneration'           *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_semanticInstructionListForGeneration::
elementOf_GGS_semanticInstructionListForGeneration (const GGS_semanticInstructionForGeneration & argument_0
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mInstruction (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_semanticInstructionListForGeneration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_semanticInstructionListForGeneration * ptr = dynamic_cast <const elementOf_GGS_semanticInstructionListForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstruction.operator_isEqual (ptr->mInstruction).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_semanticInstructionListForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstruction.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               List '@semanticInstructionListForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_semanticInstructionListForGeneration ("semanticInstructionListForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_semanticInstructionListForGeneration::
internalAppendValues (const GGS_semanticInstructionForGeneration & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionListForGeneration::
internalPrependValues (const GGS_semanticInstructionForGeneration & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionListForGeneration::
addAssign_operation (const GGS_semanticInstructionForGeneration & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration GGS_semanticInstructionListForGeneration::
operator_concat (const GGS_semanticInstructionListForGeneration & inOperand) const {
  GGS_semanticInstructionListForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionListForGeneration::
dotAssign_operation (const GGS_semanticInstructionListForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_semanticInstructionListForGeneration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_semanticInstructionForGeneration  p_0 = p->mInstruction ;
          internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionListForGeneration::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_semanticInstructionForGeneration & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionListForGeneration::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mInstruction
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration  GGS_semanticInstructionListForGeneration::
constructor_emptyList (void) {
  GGS_semanticInstructionListForGeneration result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration  GGS_semanticInstructionListForGeneration::
constructor_listWithValue (const GGS_semanticInstructionForGeneration & argument_0) {
  GGS_semanticInstructionListForGeneration result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionListForGeneration::
internalSubListWithRange (GGS_semanticInstructionListForGeneration & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mInstruction) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration GGS_semanticInstructionListForGeneration::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_semanticInstructionListForGeneration result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration GGS_semanticInstructionListForGeneration::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_semanticInstructionListForGeneration result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_semanticInstructionListForGeneration::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@semanticInstructionListForGeneration", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionListForGeneration::
method_first (C_Compiler & inLexique,
              GGS_semanticInstructionForGeneration & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInstruction ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionListForGeneration::
method_last (C_Compiler & inLexique,
             GGS_semanticInstructionForGeneration & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInstruction ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionListForGeneration::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_semanticInstructionForGeneration & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInstruction ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionListForGeneration::
modifier_popLast (C_Compiler & inLexique,
                GGS_semanticInstructionForGeneration & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInstruction ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionForGeneration  GGS_semanticInstructionListForGeneration::
reader_mInstructionAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticInstructionForGeneration  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstruction ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionListForGeneration::
modifier_setMInstructionAtIndex (C_Compiler & inLexique,
                              const GGS_semanticInstructionForGeneration  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstruction = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticInstructionForGeneration  & GGS_semanticInstructionListForGeneration::cEnumerator::_mInstruction (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mInstruction ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_semanticInstructionListForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_semanticInstructionListForGeneration * p = NULL ;
    macroMyNew (p, GGS_semanticInstructionListForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration GGS_semanticInstructionListForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_semanticInstructionListForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_semanticInstructionListForGeneration * p = dynamic_cast <const GGS_semanticInstructionListForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_semanticInstructionListForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_semanticInstructionListForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_semanticInstructionListForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'cPtr_semanticDeclarationForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_semanticDeclarationForGeneration::
cPtr_semanticDeclarationForGeneration (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_semanticDeclarationForGeneration * GGS_semanticDeclarationForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_semanticDeclarationForGeneration) ;
    return (cPtr_semanticDeclarationForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_semanticDeclarationForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@semanticDeclarationForGeneration:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_semanticDeclarationForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_semanticDeclarationForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_semanticDeclarationForGeneration (& typeid (cPtr_semanticDeclarationForGeneration), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_semanticDeclarationForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__semanticDeclarationForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_semanticDeclarationForGeneration'             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_semanticDeclarationForGeneration ("semanticDeclarationForGeneration", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_semanticDeclarationForGeneration::
GGS_semanticDeclarationForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationForGeneration::
GGS_semanticDeclarationForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_semanticDeclarationForGeneration GGS_semanticDeclarationForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_semanticDeclarationForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_semanticDeclarationForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_semanticDeclarationForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_semanticDeclarationForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_semanticDeclarationForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_semanticDeclarationForGeneration::actualTypeName (void) const {
  return "semanticDeclarationForGeneration" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_semanticDeclarationForGeneration::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__semanticDeclarationForGeneration ("semanticDeclarationForGeneration", & kTypeDescriptor_GGS_semanticDeclarationForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_semanticDeclarationForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_semanticDeclarationForGeneration * p = NULL ;
    macroMyNew (p, GGS_semanticDeclarationForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationForGeneration GGS_semanticDeclarationForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_semanticDeclarationForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_semanticDeclarationForGeneration * p = dynamic_cast <const GGS_semanticDeclarationForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_semanticDeclarationForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_semanticDeclarationForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_semanticDeclarationForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Element of list '@semanticDeclarationSortedListForGeneration'        *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_semanticDeclarationSortedListForGeneration::
elementOf_GGS_semanticDeclarationSortedListForGeneration (const GGS_string& argument_0,
                                const GGS_semanticDeclarationForGeneration & argument_1):
mOrderString (argument_0),
mSemanticDeclaration (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_semanticDeclarationSortedListForGeneration::
isEqualToObject (const cSortedListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_semanticDeclarationSortedListForGeneration * ptr = dynamic_cast <const elementOf_GGS_semanticDeclarationSortedListForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOrderString.operator_isEqual (ptr->mOrderString).boolValue ()
         && mSemanticDeclaration.operator_isEqual (ptr->mSemanticDeclaration).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

PMSInt32 elementOf_GGS_semanticDeclarationSortedListForGeneration::
compareForSorting (const cSortedListElement * inOperand) const {
  const elementOf_GGS_semanticDeclarationSortedListForGeneration * operand = (const elementOf_GGS_semanticDeclarationSortedListForGeneration *) inOperand ;
  PMSInt32 result = mOrderString.genericObjectCompare (operand->mOrderString) ;
  return result ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_semanticDeclarationSortedListForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOrderString.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSemanticDeclaration.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        Sorted list '@semanticDeclarationSortedListForGeneration'          *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_semanticDeclarationSortedListForGeneration ("semanticDeclarationSortedListForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

GGS_semanticDeclarationSortedListForGeneration::GGS_semanticDeclarationSortedListForGeneration (void): AC_galgas_sortedlist () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationSortedListForGeneration::
GGS_semanticDeclarationSortedListForGeneration (const GGS_semanticDeclarationSortedListForGeneration & inSource): AC_galgas_sortedlist (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_semanticDeclarationSortedListForGeneration::
operator_isEqual (const GGS_semanticDeclarationSortedListForGeneration & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_semanticDeclarationSortedListForGeneration::
operator_isNotEqual (const GGS_semanticDeclarationSortedListForGeneration & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationSortedListForGeneration::
internalAppendValues (const GGS_string& argument_0,
                    const GGS_semanticDeclarationForGeneration & argument_1) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationSortedListForGeneration::
addAssign_operation (const GGS_string& argument_0,
                                const GGS_semanticDeclarationForGeneration & argument_1) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationSortedListForGeneration GGS_semanticDeclarationSortedListForGeneration::
operator_concat (const GGS_semanticDeclarationSortedListForGeneration & inOperand) const {
  GGS_semanticDeclarationSortedListForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationSortedListForGeneration::
dotAssign_operation (const GGS_semanticDeclarationSortedListForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      *this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_semanticDeclarationSortedListForGeneration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_string p_0 = p->mOrderString ;
          GGS_semanticDeclarationForGeneration  p_1 = p->mSemanticDeclaration ;
          internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationSortedListForGeneration::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mOrderString,
                                ptr->mSemanticDeclaration) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationSortedListForGeneration  GGS_semanticDeclarationSortedListForGeneration::
constructor_emptySortedList (void) {
  GGS_semanticDeclarationSortedListForGeneration result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationSortedListForGeneration  GGS_semanticDeclarationSortedListForGeneration::
constructor_sortedListWithValue (const GGS_string& argument_0,
                           const GGS_semanticDeclarationForGeneration & argument_1) {
  GGS_semanticDeclarationSortedListForGeneration result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_semanticDeclarationSortedListForGeneration::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@semanticDeclarationSortedListForGeneration", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationSortedListForGeneration::
method_smallest (C_Compiler & inLexique,
                 GGS_string& _out_0,
                 GGS_semanticDeclarationForGeneration & _out_1
                 COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mOrderString ;
    _out_1 = ptr->mSemanticDeclaration ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationSortedListForGeneration::
method_greatest (C_Compiler & inLexique,
             GGS_string& _out_0,
             GGS_semanticDeclarationForGeneration & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'greatest' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mOrderString ;
    _out_1 = ptr->mSemanticDeclaration ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationSortedListForGeneration::
modifier_popSmallest (C_Compiler & inLexique,
                 GGS_string& _out_0,
                 GGS_semanticDeclarationForGeneration & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popSmallest' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mOrderString ;
    _out_1 = ptr->mSemanticDeclaration ;
    insulateList () ;
    _internalRemoveSmallest () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationSortedListForGeneration::
modifier_popGreatest (C_Compiler & inLexique,
                GGS_string& _out_0,
                GGS_semanticDeclarationForGeneration & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popGreatest' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mOrderString ;
    _out_1 = ptr->mSemanticDeclaration ;
    insulateList () ;
    _internalRemoveGreatest () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_semanticDeclarationSortedListForGeneration::cEnumerator::_mOrderString (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mOrderString ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticDeclarationForGeneration  & GGS_semanticDeclarationSortedListForGeneration::cEnumerator::_mSemanticDeclaration (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mSemanticDeclaration ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_semanticDeclarationSortedListForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_semanticDeclarationSortedListForGeneration * p = NULL ;
    macroMyNew (p, GGS_semanticDeclarationSortedListForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationSortedListForGeneration GGS_semanticDeclarationSortedListForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_semanticDeclarationSortedListForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_semanticDeclarationSortedListForGeneration * p = dynamic_cast <const GGS_semanticDeclarationSortedListForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_semanticDeclarationSortedListForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_semanticDeclarationSortedListForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_semanticDeclarationSortedListForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         Element of list '@semanticDeclarationListForGeneration'           *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_semanticDeclarationListForGeneration::
elementOf_GGS_semanticDeclarationListForGeneration (const GGS_semanticDeclarationForGeneration & argument_0
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mSemanticDeclaration (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_semanticDeclarationListForGeneration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_semanticDeclarationListForGeneration * ptr = dynamic_cast <const elementOf_GGS_semanticDeclarationListForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mSemanticDeclaration.operator_isEqual (ptr->mSemanticDeclaration).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_semanticDeclarationListForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSemanticDeclaration.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               List '@semanticDeclarationListForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_semanticDeclarationListForGeneration ("semanticDeclarationListForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationListForGeneration::
internalAppendValues (const GGS_semanticDeclarationForGeneration & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationListForGeneration::
internalPrependValues (const GGS_semanticDeclarationForGeneration & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationListForGeneration::
addAssign_operation (const GGS_semanticDeclarationForGeneration & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationListForGeneration GGS_semanticDeclarationListForGeneration::
operator_concat (const GGS_semanticDeclarationListForGeneration & inOperand) const {
  GGS_semanticDeclarationListForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationListForGeneration::
dotAssign_operation (const GGS_semanticDeclarationListForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_semanticDeclarationListForGeneration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_semanticDeclarationForGeneration  p_0 = p->mSemanticDeclaration ;
          internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationListForGeneration::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_semanticDeclarationForGeneration & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationListForGeneration::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mSemanticDeclaration
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationListForGeneration  GGS_semanticDeclarationListForGeneration::
constructor_emptyList (void) {
  GGS_semanticDeclarationListForGeneration result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationListForGeneration  GGS_semanticDeclarationListForGeneration::
constructor_listWithValue (const GGS_semanticDeclarationForGeneration & argument_0) {
  GGS_semanticDeclarationListForGeneration result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationListForGeneration::
internalSubListWithRange (GGS_semanticDeclarationListForGeneration & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mSemanticDeclaration) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationListForGeneration GGS_semanticDeclarationListForGeneration::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_semanticDeclarationListForGeneration result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationListForGeneration GGS_semanticDeclarationListForGeneration::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_semanticDeclarationListForGeneration result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_semanticDeclarationListForGeneration::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@semanticDeclarationListForGeneration", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationListForGeneration::
method_first (C_Compiler & inLexique,
              GGS_semanticDeclarationForGeneration & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSemanticDeclaration ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationListForGeneration::
method_last (C_Compiler & inLexique,
             GGS_semanticDeclarationForGeneration & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSemanticDeclaration ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationListForGeneration::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_semanticDeclarationForGeneration & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSemanticDeclaration ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationListForGeneration::
modifier_popLast (C_Compiler & inLexique,
                GGS_semanticDeclarationForGeneration & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSemanticDeclaration ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationForGeneration  GGS_semanticDeclarationListForGeneration::
reader_mSemanticDeclarationAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticDeclarationForGeneration  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSemanticDeclaration ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationListForGeneration::
modifier_setMSemanticDeclarationAtIndex (C_Compiler & inLexique,
                              const GGS_semanticDeclarationForGeneration  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSemanticDeclaration = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticDeclarationForGeneration  & GGS_semanticDeclarationListForGeneration::cEnumerator::_mSemanticDeclaration (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mSemanticDeclaration ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_semanticDeclarationListForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_semanticDeclarationListForGeneration * p = NULL ;
    macroMyNew (p, GGS_semanticDeclarationListForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationListForGeneration GGS_semanticDeclarationListForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_semanticDeclarationListForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_semanticDeclarationListForGeneration * p = dynamic_cast <const GGS_semanticDeclarationListForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_semanticDeclarationListForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_semanticDeclarationListForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_semanticDeclarationListForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            class 'cPtr_externRoutineDeclarationForGeneration'             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_externRoutineDeclarationForGeneration::
cPtr_externRoutineDeclarationForGeneration (const GGS_lstring & argument_0,
                                const GGS_formalParameterListForGeneration & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticDeclarationForGeneration (THERE),
mRoutineName (argument_0),
mFormalParameterList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_externRoutineDeclarationForGeneration * GGS_externRoutineDeclarationForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_externRoutineDeclarationForGeneration) ;
    return (cPtr_externRoutineDeclarationForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_externRoutineDeclarationForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_externRoutineDeclarationForGeneration * ptr = dynamic_cast <const cPtr_externRoutineDeclarationForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mRoutineName.operator_isEqual (ptr->mRoutineName).boolValue ()
         && mFormalParameterList.operator_isEqual (ptr->mFormalParameterList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_externRoutineDeclarationForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@externRoutineDeclarationForGeneration:"
           << mRoutineName.reader_description (inIndentation + 1)
           << mFormalParameterList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_externRoutineDeclarationForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_externRoutineDeclarationForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_externRoutineDeclarationForGeneration (& typeid (cPtr_externRoutineDeclarationForGeneration), & typeid (cPtr_semanticDeclarationForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_externRoutineDeclarationForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__externRoutineDeclarationForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_externRoutineDeclarationForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_externRoutineDeclarationForGeneration (mRoutineName, mFormalParameterList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         GALGAS class 'GGS_externRoutineDeclarationForGeneration'          *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_externRoutineDeclarationForGeneration ("externRoutineDeclarationForGeneration", true, & kTypeDescriptor_GGS_semanticDeclarationForGeneration) ;

//---------------------------------------------------------------------------*

GGS_externRoutineDeclarationForGeneration::
GGS_externRoutineDeclarationForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_externRoutineDeclarationForGeneration::
GGS_externRoutineDeclarationForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_externRoutineDeclarationForGeneration GGS_externRoutineDeclarationForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_externRoutineDeclarationForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_externRoutineDeclarationForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_externRoutineDeclarationForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_externRoutineDeclarationForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_externRoutineDeclarationForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_externRoutineDeclarationForGeneration GGS_externRoutineDeclarationForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_formalParameterListForGeneration & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_externRoutineDeclarationForGeneration result ;
  macroMyNew (result.mPointer, cPtr_externRoutineDeclarationForGeneration (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_externRoutineDeclarationForGeneration::
reader_mRoutineName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_externRoutineDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_externRoutineDeclarationForGeneration *) mPointer)->mRoutineName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameterListForGeneration  GGS_externRoutineDeclarationForGeneration::
reader_mFormalParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_formalParameterListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_externRoutineDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_externRoutineDeclarationForGeneration *) mPointer)->mFormalParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_externRoutineDeclarationForGeneration::actualTypeName (void) const {
  return "externRoutineDeclarationForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__externRoutineDeclarationForGeneration ("externRoutineDeclarationForGeneration", gClassInfoFor__semanticDeclarationForGeneration, & kTypeDescriptor_GGS_externRoutineDeclarationForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_externRoutineDeclarationForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_externRoutineDeclarationForGeneration * p = NULL ;
    macroMyNew (p, GGS_externRoutineDeclarationForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_externRoutineDeclarationForGeneration GGS_externRoutineDeclarationForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_externRoutineDeclarationForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_externRoutineDeclarationForGeneration * p = dynamic_cast <const GGS_externRoutineDeclarationForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_externRoutineDeclarationForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_externRoutineDeclarationForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_externRoutineDeclarationForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          class 'cPtr_routinePrototypeDeclarationForGeneration'            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_routinePrototypeDeclarationForGeneration::
cPtr_routinePrototypeDeclarationForGeneration (const GGS_lstring & argument_0,
                                const GGS_formalParameterListForGeneration & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_externRoutineDeclarationForGeneration (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_routinePrototypeDeclarationForGeneration * GGS_routinePrototypeDeclarationForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_routinePrototypeDeclarationForGeneration) ;
    return (cPtr_routinePrototypeDeclarationForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_routinePrototypeDeclarationForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_routinePrototypeDeclarationForGeneration * ptr = dynamic_cast <const cPtr_routinePrototypeDeclarationForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mRoutineName.operator_isEqual (ptr->mRoutineName).boolValue ()
         && mFormalParameterList.operator_isEqual (ptr->mFormalParameterList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_routinePrototypeDeclarationForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@routinePrototypeDeclarationForGeneration:"
           << mRoutineName.reader_description (inIndentation + 1)
           << mFormalParameterList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_routinePrototypeDeclarationForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_routinePrototypeDeclarationForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_routinePrototypeDeclarationForGeneration (& typeid (cPtr_routinePrototypeDeclarationForGeneration), & typeid (cPtr_externRoutineDeclarationForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_routinePrototypeDeclarationForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__routinePrototypeDeclarationForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_routinePrototypeDeclarationForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_routinePrototypeDeclarationForGeneration (mRoutineName, mFormalParameterList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//       GALGAS class 'GGS_routinePrototypeDeclarationForGeneration'         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_routinePrototypeDeclarationForGeneration ("routinePrototypeDeclarationForGeneration", true, & kTypeDescriptor_GGS_externRoutineDeclarationForGeneration) ;

//---------------------------------------------------------------------------*

GGS_routinePrototypeDeclarationForGeneration::
GGS_routinePrototypeDeclarationForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_routinePrototypeDeclarationForGeneration::
GGS_routinePrototypeDeclarationForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_routinePrototypeDeclarationForGeneration GGS_routinePrototypeDeclarationForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_routinePrototypeDeclarationForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_routinePrototypeDeclarationForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_routinePrototypeDeclarationForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_routinePrototypeDeclarationForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_routinePrototypeDeclarationForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_routinePrototypeDeclarationForGeneration GGS_routinePrototypeDeclarationForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_formalParameterListForGeneration & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_routinePrototypeDeclarationForGeneration result ;
  macroMyNew (result.mPointer, cPtr_routinePrototypeDeclarationForGeneration (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_routinePrototypeDeclarationForGeneration::actualTypeName (void) const {
  return "routinePrototypeDeclarationForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__routinePrototypeDeclarationForGeneration ("routinePrototypeDeclarationForGeneration", gClassInfoFor__externRoutineDeclarationForGeneration, & kTypeDescriptor_GGS_routinePrototypeDeclarationForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_routinePrototypeDeclarationForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_routinePrototypeDeclarationForGeneration * p = NULL ;
    macroMyNew (p, GGS_routinePrototypeDeclarationForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_routinePrototypeDeclarationForGeneration GGS_routinePrototypeDeclarationForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_routinePrototypeDeclarationForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_routinePrototypeDeclarationForGeneration * p = dynamic_cast <const GGS_routinePrototypeDeclarationForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_routinePrototypeDeclarationForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_routinePrototypeDeclarationForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_routinePrototypeDeclarationForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_routineDeclarationForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_routineDeclarationForGeneration::
cPtr_routineDeclarationForGeneration (const GGS_lstring & argument_0,
                                const GGS_formalParameterListForGeneration & argument_1,
                                const GGS_semanticInstructionListForGeneration & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_routinePrototypeDeclarationForGeneration (argument_0, argument_1 COMMA_THERE),
mRoutineInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_routineDeclarationForGeneration * GGS_routineDeclarationForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_routineDeclarationForGeneration) ;
    return (cPtr_routineDeclarationForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_routineDeclarationForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_routineDeclarationForGeneration * ptr = dynamic_cast <const cPtr_routineDeclarationForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mRoutineName.operator_isEqual (ptr->mRoutineName).boolValue ()
         && mFormalParameterList.operator_isEqual (ptr->mFormalParameterList).boolValue ()
         && mRoutineInstructionList.operator_isEqual (ptr->mRoutineInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_routineDeclarationForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@routineDeclarationForGeneration:"
           << mRoutineName.reader_description (inIndentation + 1)
           << mFormalParameterList.reader_description (inIndentation + 1)
           << mRoutineInstructionList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_routineDeclarationForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_routineDeclarationForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_routineDeclarationForGeneration (& typeid (cPtr_routineDeclarationForGeneration), & typeid (cPtr_routinePrototypeDeclarationForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_routineDeclarationForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__routineDeclarationForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_routineDeclarationForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_routineDeclarationForGeneration (mRoutineName, mFormalParameterList, mRoutineInstructionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_routineDeclarationForGeneration'             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_routineDeclarationForGeneration ("routineDeclarationForGeneration", true, & kTypeDescriptor_GGS_routinePrototypeDeclarationForGeneration) ;

//---------------------------------------------------------------------------*

GGS_routineDeclarationForGeneration::
GGS_routineDeclarationForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_routineDeclarationForGeneration::
GGS_routineDeclarationForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_routineDeclarationForGeneration GGS_routineDeclarationForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_routineDeclarationForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_routineDeclarationForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_routineDeclarationForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_routineDeclarationForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_routineDeclarationForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_routineDeclarationForGeneration GGS_routineDeclarationForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_formalParameterListForGeneration & argument_1,
                 const GGS_semanticInstructionListForGeneration & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_routineDeclarationForGeneration result ;
  macroMyNew (result.mPointer, cPtr_routineDeclarationForGeneration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration  GGS_routineDeclarationForGeneration::
reader_mRoutineInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_routineDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_routineDeclarationForGeneration *) mPointer)->mRoutineInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_routineDeclarationForGeneration::actualTypeName (void) const {
  return "routineDeclarationForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__routineDeclarationForGeneration ("routineDeclarationForGeneration", gClassInfoFor__routinePrototypeDeclarationForGeneration, & kTypeDescriptor_GGS_routineDeclarationForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_routineDeclarationForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_routineDeclarationForGeneration * p = NULL ;
    macroMyNew (p, GGS_routineDeclarationForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_routineDeclarationForGeneration GGS_routineDeclarationForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_routineDeclarationForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_routineDeclarationForGeneration * p = dynamic_cast <const GGS_routineDeclarationForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_routineDeclarationForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_routineDeclarationForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_routineDeclarationForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           class 'cPtr_externFunctionDeclarationForGeneration'             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_externFunctionDeclarationForGeneration::
cPtr_externFunctionDeclarationForGeneration (const GGS_lstring & argument_0,
                                const GGS_formalParameterListForGeneration & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticDeclarationForGeneration (THERE),
mFunctionName (argument_0),
mFormalParameterList (argument_1),
mResultTypeName (argument_2),
mResultVariableName (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_externFunctionDeclarationForGeneration * GGS_externFunctionDeclarationForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_externFunctionDeclarationForGeneration) ;
    return (cPtr_externFunctionDeclarationForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_externFunctionDeclarationForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_externFunctionDeclarationForGeneration * ptr = dynamic_cast <const cPtr_externFunctionDeclarationForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mFunctionName.operator_isEqual (ptr->mFunctionName).boolValue ()
         && mFormalParameterList.operator_isEqual (ptr->mFormalParameterList).boolValue ()
         && mResultTypeName.operator_isEqual (ptr->mResultTypeName).boolValue ()
         && mResultVariableName.operator_isEqual (ptr->mResultVariableName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_externFunctionDeclarationForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@externFunctionDeclarationForGeneration:"
           << mFunctionName.reader_description (inIndentation + 1)
           << mFormalParameterList.reader_description (inIndentation + 1)
           << mResultTypeName.reader_description (inIndentation + 1)
           << mResultVariableName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_externFunctionDeclarationForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_externFunctionDeclarationForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_externFunctionDeclarationForGeneration (& typeid (cPtr_externFunctionDeclarationForGeneration), & typeid (cPtr_semanticDeclarationForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_externFunctionDeclarationForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__externFunctionDeclarationForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_externFunctionDeclarationForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_externFunctionDeclarationForGeneration (mFunctionName, mFormalParameterList, mResultTypeName, mResultVariableName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        GALGAS class 'GGS_externFunctionDeclarationForGeneration'          *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_externFunctionDeclarationForGeneration ("externFunctionDeclarationForGeneration", true, & kTypeDescriptor_GGS_semanticDeclarationForGeneration) ;

//---------------------------------------------------------------------------*

GGS_externFunctionDeclarationForGeneration::
GGS_externFunctionDeclarationForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_externFunctionDeclarationForGeneration::
GGS_externFunctionDeclarationForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_externFunctionDeclarationForGeneration GGS_externFunctionDeclarationForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_externFunctionDeclarationForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_externFunctionDeclarationForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_externFunctionDeclarationForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_externFunctionDeclarationForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_externFunctionDeclarationForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_externFunctionDeclarationForGeneration GGS_externFunctionDeclarationForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_formalParameterListForGeneration & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_lstring & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_externFunctionDeclarationForGeneration result ;
  macroMyNew (result.mPointer, cPtr_externFunctionDeclarationForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_externFunctionDeclarationForGeneration::
reader_mFunctionName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_externFunctionDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_externFunctionDeclarationForGeneration *) mPointer)->mFunctionName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameterListForGeneration  GGS_externFunctionDeclarationForGeneration::
reader_mFormalParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_formalParameterListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_externFunctionDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_externFunctionDeclarationForGeneration *) mPointer)->mFormalParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_externFunctionDeclarationForGeneration::
reader_mResultTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_externFunctionDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_externFunctionDeclarationForGeneration *) mPointer)->mResultTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_externFunctionDeclarationForGeneration::
reader_mResultVariableName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_externFunctionDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_externFunctionDeclarationForGeneration *) mPointer)->mResultVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_externFunctionDeclarationForGeneration::actualTypeName (void) const {
  return "externFunctionDeclarationForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__externFunctionDeclarationForGeneration ("externFunctionDeclarationForGeneration", gClassInfoFor__semanticDeclarationForGeneration, & kTypeDescriptor_GGS_externFunctionDeclarationForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_externFunctionDeclarationForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_externFunctionDeclarationForGeneration * p = NULL ;
    macroMyNew (p, GGS_externFunctionDeclarationForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_externFunctionDeclarationForGeneration GGS_externFunctionDeclarationForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_externFunctionDeclarationForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_externFunctionDeclarationForGeneration * p = dynamic_cast <const GGS_externFunctionDeclarationForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_externFunctionDeclarationForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_externFunctionDeclarationForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_externFunctionDeclarationForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'cPtr_functionDeclarationForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_functionDeclarationForGeneration::
cPtr_functionDeclarationForGeneration (const GGS_lstring & argument_0,
                                const GGS_formalParameterListForGeneration & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_semanticInstructionListForGeneration & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_externFunctionDeclarationForGeneration (argument_0, argument_1, argument_2, argument_3 COMMA_THERE),
mFunctionInstructionList (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_functionDeclarationForGeneration * GGS_functionDeclarationForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_functionDeclarationForGeneration) ;
    return (cPtr_functionDeclarationForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_functionDeclarationForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_functionDeclarationForGeneration * ptr = dynamic_cast <const cPtr_functionDeclarationForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mFunctionName.operator_isEqual (ptr->mFunctionName).boolValue ()
         && mFormalParameterList.operator_isEqual (ptr->mFormalParameterList).boolValue ()
         && mResultTypeName.operator_isEqual (ptr->mResultTypeName).boolValue ()
         && mResultVariableName.operator_isEqual (ptr->mResultVariableName).boolValue ()
         && mFunctionInstructionList.operator_isEqual (ptr->mFunctionInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_functionDeclarationForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@functionDeclarationForGeneration:"
           << mFunctionName.reader_description (inIndentation + 1)
           << mFormalParameterList.reader_description (inIndentation + 1)
           << mResultTypeName.reader_description (inIndentation + 1)
           << mResultVariableName.reader_description (inIndentation + 1)
           << mFunctionInstructionList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_functionDeclarationForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_functionDeclarationForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_functionDeclarationForGeneration (& typeid (cPtr_functionDeclarationForGeneration), & typeid (cPtr_externFunctionDeclarationForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_functionDeclarationForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__functionDeclarationForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_functionDeclarationForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_functionDeclarationForGeneration (mFunctionName, mFormalParameterList, mResultTypeName, mResultVariableName, mFunctionInstructionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_functionDeclarationForGeneration'             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_functionDeclarationForGeneration ("functionDeclarationForGeneration", true, & kTypeDescriptor_GGS_externFunctionDeclarationForGeneration) ;

//---------------------------------------------------------------------------*

GGS_functionDeclarationForGeneration::
GGS_functionDeclarationForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_functionDeclarationForGeneration::
GGS_functionDeclarationForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_functionDeclarationForGeneration GGS_functionDeclarationForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_functionDeclarationForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_functionDeclarationForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_functionDeclarationForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_functionDeclarationForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_functionDeclarationForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_functionDeclarationForGeneration GGS_functionDeclarationForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_formalParameterListForGeneration & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_lstring & argument_3,
                 const GGS_semanticInstructionListForGeneration & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_functionDeclarationForGeneration result ;
  macroMyNew (result.mPointer, cPtr_functionDeclarationForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration  GGS_functionDeclarationForGeneration::
reader_mFunctionInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_functionDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_functionDeclarationForGeneration *) mPointer)->mFunctionInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_functionDeclarationForGeneration::actualTypeName (void) const {
  return "functionDeclarationForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__functionDeclarationForGeneration ("functionDeclarationForGeneration", gClassInfoFor__externFunctionDeclarationForGeneration, & kTypeDescriptor_GGS_functionDeclarationForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_functionDeclarationForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_functionDeclarationForGeneration * p = NULL ;
    macroMyNew (p, GGS_functionDeclarationForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_functionDeclarationForGeneration GGS_functionDeclarationForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_functionDeclarationForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_functionDeclarationForGeneration * p = dynamic_cast <const GGS_functionDeclarationForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_functionDeclarationForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_functionDeclarationForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_functionDeclarationForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            class 'cPtr_lazyFunctionDeclarationForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lazyFunctionDeclarationForGeneration::
cPtr_lazyFunctionDeclarationForGeneration (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_semanticInstructionListForGeneration & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticDeclarationForGeneration (THERE),
mFunctionName (argument_0),
mResultTypeName (argument_1),
mResultVariableName (argument_2),
mFunctionInstructionList (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lazyFunctionDeclarationForGeneration * GGS_lazyFunctionDeclarationForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_lazyFunctionDeclarationForGeneration) ;
    return (cPtr_lazyFunctionDeclarationForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lazyFunctionDeclarationForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lazyFunctionDeclarationForGeneration * ptr = dynamic_cast <const cPtr_lazyFunctionDeclarationForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mFunctionName.operator_isEqual (ptr->mFunctionName).boolValue ()
         && mResultTypeName.operator_isEqual (ptr->mResultTypeName).boolValue ()
         && mResultVariableName.operator_isEqual (ptr->mResultVariableName).boolValue ()
         && mFunctionInstructionList.operator_isEqual (ptr->mFunctionInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lazyFunctionDeclarationForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@lazyFunctionDeclarationForGeneration:"
           << mFunctionName.reader_description (inIndentation + 1)
           << mResultTypeName.reader_description (inIndentation + 1)
           << mResultVariableName.reader_description (inIndentation + 1)
           << mFunctionInstructionList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lazyFunctionDeclarationForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lazyFunctionDeclarationForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lazyFunctionDeclarationForGeneration (& typeid (cPtr_lazyFunctionDeclarationForGeneration), & typeid (cPtr_semanticDeclarationForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_lazyFunctionDeclarationForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__lazyFunctionDeclarationForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lazyFunctionDeclarationForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lazyFunctionDeclarationForGeneration (mFunctionName, mResultTypeName, mResultVariableName, mFunctionInstructionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         GALGAS class 'GGS_lazyFunctionDeclarationForGeneration'           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_lazyFunctionDeclarationForGeneration ("lazyFunctionDeclarationForGeneration", true, & kTypeDescriptor_GGS_semanticDeclarationForGeneration) ;

//---------------------------------------------------------------------------*

GGS_lazyFunctionDeclarationForGeneration::
GGS_lazyFunctionDeclarationForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lazyFunctionDeclarationForGeneration::
GGS_lazyFunctionDeclarationForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lazyFunctionDeclarationForGeneration GGS_lazyFunctionDeclarationForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lazyFunctionDeclarationForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lazyFunctionDeclarationForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_lazyFunctionDeclarationForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lazyFunctionDeclarationForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lazyFunctionDeclarationForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lazyFunctionDeclarationForGeneration GGS_lazyFunctionDeclarationForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_semanticInstructionListForGeneration & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_lazyFunctionDeclarationForGeneration result ;
  macroMyNew (result.mPointer, cPtr_lazyFunctionDeclarationForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lazyFunctionDeclarationForGeneration::
reader_mFunctionName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lazyFunctionDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lazyFunctionDeclarationForGeneration *) mPointer)->mFunctionName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lazyFunctionDeclarationForGeneration::
reader_mResultTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lazyFunctionDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lazyFunctionDeclarationForGeneration *) mPointer)->mResultTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lazyFunctionDeclarationForGeneration::
reader_mResultVariableName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lazyFunctionDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lazyFunctionDeclarationForGeneration *) mPointer)->mResultVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration  GGS_lazyFunctionDeclarationForGeneration::
reader_mFunctionInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lazyFunctionDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lazyFunctionDeclarationForGeneration *) mPointer)->mFunctionInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lazyFunctionDeclarationForGeneration::actualTypeName (void) const {
  return "lazyFunctionDeclarationForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__lazyFunctionDeclarationForGeneration ("lazyFunctionDeclarationForGeneration", gClassInfoFor__semanticDeclarationForGeneration, & kTypeDescriptor_GGS_lazyFunctionDeclarationForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_lazyFunctionDeclarationForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_lazyFunctionDeclarationForGeneration * p = NULL ;
    macroMyNew (p, GGS_lazyFunctionDeclarationForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lazyFunctionDeclarationForGeneration GGS_lazyFunctionDeclarationForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_lazyFunctionDeclarationForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_lazyFunctionDeclarationForGeneration * p = dynamic_cast <const GGS_lazyFunctionDeclarationForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_lazyFunctionDeclarationForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_lazyFunctionDeclarationForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_lazyFunctionDeclarationForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            class 'cPtr_localVariableDeclarationForGeneration'             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_localVariableDeclarationForGeneration::
cPtr_localVariableDeclarationForGeneration (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (argument_0 COMMA_THERE),
mTypeName (argument_1),
mVariableName (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_localVariableDeclarationForGeneration * GGS_localVariableDeclarationForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_localVariableDeclarationForGeneration) ;
    return (cPtr_localVariableDeclarationForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_localVariableDeclarationForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_localVariableDeclarationForGeneration * ptr = dynamic_cast <const cPtr_localVariableDeclarationForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mTypeName.operator_isEqual (ptr->mTypeName).boolValue ()
         && mVariableName.operator_isEqual (ptr->mVariableName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_localVariableDeclarationForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@localVariableDeclarationForGeneration:"
           << mStartLocation.reader_description (inIndentation + 1)
           << mTypeName.reader_description (inIndentation + 1)
           << mVariableName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_localVariableDeclarationForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_localVariableDeclarationForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_localVariableDeclarationForGeneration (& typeid (cPtr_localVariableDeclarationForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_localVariableDeclarationForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__localVariableDeclarationForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_localVariableDeclarationForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_localVariableDeclarationForGeneration (mStartLocation, mTypeName, mVariableName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         GALGAS class 'GGS_localVariableDeclarationForGeneration'          *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_localVariableDeclarationForGeneration ("localVariableDeclarationForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_localVariableDeclarationForGeneration::
GGS_localVariableDeclarationForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_localVariableDeclarationForGeneration::
GGS_localVariableDeclarationForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_localVariableDeclarationForGeneration GGS_localVariableDeclarationForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_localVariableDeclarationForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_localVariableDeclarationForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_localVariableDeclarationForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_localVariableDeclarationForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_localVariableDeclarationForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_localVariableDeclarationForGeneration GGS_localVariableDeclarationForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_localVariableDeclarationForGeneration result ;
  macroMyNew (result.mPointer, cPtr_localVariableDeclarationForGeneration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_localVariableDeclarationForGeneration::
reader_mTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableDeclarationForGeneration *) mPointer)->mTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_localVariableDeclarationForGeneration::
reader_mVariableName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableDeclarationForGeneration *) mPointer)->mVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_localVariableDeclarationForGeneration::actualTypeName (void) const {
  return "localVariableDeclarationForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__localVariableDeclarationForGeneration ("localVariableDeclarationForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_localVariableDeclarationForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_localVariableDeclarationForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_localVariableDeclarationForGeneration * p = NULL ;
    macroMyNew (p, GGS_localVariableDeclarationForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_localVariableDeclarationForGeneration GGS_localVariableDeclarationForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_localVariableDeclarationForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_localVariableDeclarationForGeneration * p = dynamic_cast <const GGS_localVariableDeclarationForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_localVariableDeclarationForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_localVariableDeclarationForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_localVariableDeclarationForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//   class 'cPtr_localVariableDeclarationWithInitializationForGeneration'    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_localVariableDeclarationWithInitializationForGeneration::
cPtr_localVariableDeclarationWithInitializationForGeneration (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_outSemanticExpressionListForGeneration & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (argument_0 COMMA_THERE),
mTypeName (argument_1),
mVariableName (argument_2),
mConstructorName (argument_3),
mConstructorArguments (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_localVariableDeclarationWithInitializationForGeneration * GGS_localVariableDeclarationWithInitializationForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_localVariableDeclarationWithInitializationForGeneration) ;
    return (cPtr_localVariableDeclarationWithInitializationForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_localVariableDeclarationWithInitializationForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_localVariableDeclarationWithInitializationForGeneration * ptr = dynamic_cast <const cPtr_localVariableDeclarationWithInitializationForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mTypeName.operator_isEqual (ptr->mTypeName).boolValue ()
         && mVariableName.operator_isEqual (ptr->mVariableName).boolValue ()
         && mConstructorName.operator_isEqual (ptr->mConstructorName).boolValue ()
         && mConstructorArguments.operator_isEqual (ptr->mConstructorArguments).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_localVariableDeclarationWithInitializationForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@localVariableDeclarationWithInitializationForGeneration:"
           << mStartLocation.reader_description (inIndentation + 1)
           << mTypeName.reader_description (inIndentation + 1)
           << mVariableName.reader_description (inIndentation + 1)
           << mConstructorName.reader_description (inIndentation + 1)
           << mConstructorArguments.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_localVariableDeclarationWithInitializationForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_localVariableDeclarationWithInitializationForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_localVariableDeclarationWithInitializationForGeneration (& typeid (cPtr_localVariableDeclarationWithInitializationForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_localVariableDeclarationWithInitializationForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__localVariableDeclarationWithInitializationForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_localVariableDeclarationWithInitializationForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_localVariableDeclarationWithInitializationForGeneration (mStartLocation, mTypeName, mVariableName, mConstructorName, mConstructorArguments COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//GALGAS class 'GGS_localVariableDeclarationWithInitializationForGeneration' *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_localVariableDeclarationWithInitializationForGeneration ("localVariableDeclarationWithInitializationForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_localVariableDeclarationWithInitializationForGeneration::
GGS_localVariableDeclarationWithInitializationForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_localVariableDeclarationWithInitializationForGeneration::
GGS_localVariableDeclarationWithInitializationForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_localVariableDeclarationWithInitializationForGeneration GGS_localVariableDeclarationWithInitializationForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_localVariableDeclarationWithInitializationForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_localVariableDeclarationWithInitializationForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_localVariableDeclarationWithInitializationForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_localVariableDeclarationWithInitializationForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_localVariableDeclarationWithInitializationForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_localVariableDeclarationWithInitializationForGeneration GGS_localVariableDeclarationWithInitializationForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_lstring & argument_3,
                 const GGS_outSemanticExpressionListForGeneration & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_localVariableDeclarationWithInitializationForGeneration result ;
  macroMyNew (result.mPointer, cPtr_localVariableDeclarationWithInitializationForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_localVariableDeclarationWithInitializationForGeneration::
reader_mTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableDeclarationWithInitializationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableDeclarationWithInitializationForGeneration *) mPointer)->mTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_localVariableDeclarationWithInitializationForGeneration::
reader_mVariableName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableDeclarationWithInitializationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableDeclarationWithInitializationForGeneration *) mPointer)->mVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_localVariableDeclarationWithInitializationForGeneration::
reader_mConstructorName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableDeclarationWithInitializationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableDeclarationWithInitializationForGeneration *) mPointer)->mConstructorName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_outSemanticExpressionListForGeneration  GGS_localVariableDeclarationWithInitializationForGeneration::
reader_mConstructorArguments (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_outSemanticExpressionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableDeclarationWithInitializationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableDeclarationWithInitializationForGeneration *) mPointer)->mConstructorArguments ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_localVariableDeclarationWithInitializationForGeneration::actualTypeName (void) const {
  return "localVariableDeclarationWithInitializationForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__localVariableDeclarationWithInitializationForGeneration ("localVariableDeclarationWithInitializationForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_localVariableDeclarationWithInitializationForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_localVariableDeclarationWithInitializationForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_localVariableDeclarationWithInitializationForGeneration * p = NULL ;
    macroMyNew (p, GGS_localVariableDeclarationWithInitializationForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_localVariableDeclarationWithInitializationForGeneration GGS_localVariableDeclarationWithInitializationForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_localVariableDeclarationWithInitializationForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_localVariableDeclarationWithInitializationForGeneration * p = dynamic_cast <const GGS_localVariableDeclarationWithInitializationForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_localVariableDeclarationWithInitializationForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_localVariableDeclarationWithInitializationForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_localVariableDeclarationWithInitializationForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//     class 'cPtr_localVariableDeclarationWithAssignmentForGeneration'      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_localVariableDeclarationWithAssignmentForGeneration::
cPtr_localVariableDeclarationWithAssignmentForGeneration (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (argument_0 COMMA_THERE),
mTypeName (argument_1),
mVariableName (argument_2),
mSourceExpression (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_localVariableDeclarationWithAssignmentForGeneration * GGS_localVariableDeclarationWithAssignmentForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_localVariableDeclarationWithAssignmentForGeneration) ;
    return (cPtr_localVariableDeclarationWithAssignmentForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_localVariableDeclarationWithAssignmentForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_localVariableDeclarationWithAssignmentForGeneration * ptr = dynamic_cast <const cPtr_localVariableDeclarationWithAssignmentForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mTypeName.operator_isEqual (ptr->mTypeName).boolValue ()
         && mVariableName.operator_isEqual (ptr->mVariableName).boolValue ()
         && mSourceExpression.operator_isEqual (ptr->mSourceExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_localVariableDeclarationWithAssignmentForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@localVariableDeclarationWithAssignmentForGeneration:"
           << mStartLocation.reader_description (inIndentation + 1)
           << mTypeName.reader_description (inIndentation + 1)
           << mVariableName.reader_description (inIndentation + 1)
           << mSourceExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_localVariableDeclarationWithAssignmentForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_localVariableDeclarationWithAssignmentForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_localVariableDeclarationWithAssignmentForGeneration (& typeid (cPtr_localVariableDeclarationWithAssignmentForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_localVariableDeclarationWithAssignmentForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__localVariableDeclarationWithAssignmentForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_localVariableDeclarationWithAssignmentForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_localVariableDeclarationWithAssignmentForGeneration (mStartLocation, mTypeName, mVariableName, mSourceExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//  GALGAS class 'GGS_localVariableDeclarationWithAssignmentForGeneration'   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_localVariableDeclarationWithAssignmentForGeneration ("localVariableDeclarationWithAssignmentForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_localVariableDeclarationWithAssignmentForGeneration::
GGS_localVariableDeclarationWithAssignmentForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_localVariableDeclarationWithAssignmentForGeneration::
GGS_localVariableDeclarationWithAssignmentForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_localVariableDeclarationWithAssignmentForGeneration GGS_localVariableDeclarationWithAssignmentForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_localVariableDeclarationWithAssignmentForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_localVariableDeclarationWithAssignmentForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_localVariableDeclarationWithAssignmentForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_localVariableDeclarationWithAssignmentForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_localVariableDeclarationWithAssignmentForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_localVariableDeclarationWithAssignmentForGeneration GGS_localVariableDeclarationWithAssignmentForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_localVariableDeclarationWithAssignmentForGeneration result ;
  macroMyNew (result.mPointer, cPtr_localVariableDeclarationWithAssignmentForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_localVariableDeclarationWithAssignmentForGeneration::
reader_mTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableDeclarationWithAssignmentForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableDeclarationWithAssignmentForGeneration *) mPointer)->mTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_localVariableDeclarationWithAssignmentForGeneration::
reader_mVariableName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableDeclarationWithAssignmentForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableDeclarationWithAssignmentForGeneration *) mPointer)->mVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_localVariableDeclarationWithAssignmentForGeneration::
reader_mSourceExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableDeclarationWithAssignmentForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableDeclarationWithAssignmentForGeneration *) mPointer)->mSourceExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_localVariableDeclarationWithAssignmentForGeneration::actualTypeName (void) const {
  return "localVariableDeclarationWithAssignmentForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__localVariableDeclarationWithAssignmentForGeneration ("localVariableDeclarationWithAssignmentForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_localVariableDeclarationWithAssignmentForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_localVariableDeclarationWithAssignmentForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_localVariableDeclarationWithAssignmentForGeneration * p = NULL ;
    macroMyNew (p, GGS_localVariableDeclarationWithAssignmentForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_localVariableDeclarationWithAssignmentForGeneration GGS_localVariableDeclarationWithAssignmentForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_localVariableDeclarationWithAssignmentForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_localVariableDeclarationWithAssignmentForGeneration * p = dynamic_cast <const GGS_localVariableDeclarationWithAssignmentForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_localVariableDeclarationWithAssignmentForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_localVariableDeclarationWithAssignmentForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_localVariableDeclarationWithAssignmentForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//  class 'cPtr_localConstantDeclarationWithSourceExpressionForGeneration'   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_localConstantDeclarationWithSourceExpressionForGeneration::
cPtr_localConstantDeclarationWithSourceExpressionForGeneration (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (argument_0 COMMA_THERE),
mTypeName (argument_1),
mVariableName (argument_2),
mSourceExpression (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_localConstantDeclarationWithSourceExpressionForGeneration * GGS_localConstantDeclarationWithSourceExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_localConstantDeclarationWithSourceExpressionForGeneration) ;
    return (cPtr_localConstantDeclarationWithSourceExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_localConstantDeclarationWithSourceExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_localConstantDeclarationWithSourceExpressionForGeneration * ptr = dynamic_cast <const cPtr_localConstantDeclarationWithSourceExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mTypeName.operator_isEqual (ptr->mTypeName).boolValue ()
         && mVariableName.operator_isEqual (ptr->mVariableName).boolValue ()
         && mSourceExpression.operator_isEqual (ptr->mSourceExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_localConstantDeclarationWithSourceExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@localConstantDeclarationWithSourceExpressionForGeneration:"
           << mStartLocation.reader_description (inIndentation + 1)
           << mTypeName.reader_description (inIndentation + 1)
           << mVariableName.reader_description (inIndentation + 1)
           << mSourceExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_localConstantDeclarationWithSourceExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_localConstantDeclarationWithSourceExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_localConstantDeclarationWithSourceExpressionForGeneration (& typeid (cPtr_localConstantDeclarationWithSourceExpressionForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_localConstantDeclarationWithSourceExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__localConstantDeclarationWithSourceExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_localConstantDeclarationWithSourceExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_localConstantDeclarationWithSourceExpressionForGeneration (mStartLocation, mTypeName, mVariableName, mSourceExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//GALGAS class 'GGS_localConstantDeclarationWithSourceExpressionForGeneration'*
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_localConstantDeclarationWithSourceExpressionForGeneration ("localConstantDeclarationWithSourceExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_localConstantDeclarationWithSourceExpressionForGeneration::
GGS_localConstantDeclarationWithSourceExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_localConstantDeclarationWithSourceExpressionForGeneration::
GGS_localConstantDeclarationWithSourceExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_localConstantDeclarationWithSourceExpressionForGeneration GGS_localConstantDeclarationWithSourceExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_localConstantDeclarationWithSourceExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_localConstantDeclarationWithSourceExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_localConstantDeclarationWithSourceExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_localConstantDeclarationWithSourceExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_localConstantDeclarationWithSourceExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_localConstantDeclarationWithSourceExpressionForGeneration GGS_localConstantDeclarationWithSourceExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_localConstantDeclarationWithSourceExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_localConstantDeclarationWithSourceExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_localConstantDeclarationWithSourceExpressionForGeneration::
reader_mTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localConstantDeclarationWithSourceExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localConstantDeclarationWithSourceExpressionForGeneration *) mPointer)->mTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_localConstantDeclarationWithSourceExpressionForGeneration::
reader_mVariableName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localConstantDeclarationWithSourceExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localConstantDeclarationWithSourceExpressionForGeneration *) mPointer)->mVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_localConstantDeclarationWithSourceExpressionForGeneration::
reader_mSourceExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localConstantDeclarationWithSourceExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localConstantDeclarationWithSourceExpressionForGeneration *) mPointer)->mSourceExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_localConstantDeclarationWithSourceExpressionForGeneration::actualTypeName (void) const {
  return "localConstantDeclarationWithSourceExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__localConstantDeclarationWithSourceExpressionForGeneration ("localConstantDeclarationWithSourceExpressionForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_localConstantDeclarationWithSourceExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_localConstantDeclarationWithSourceExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_localConstantDeclarationWithSourceExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_localConstantDeclarationWithSourceExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_localConstantDeclarationWithSourceExpressionForGeneration GGS_localConstantDeclarationWithSourceExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_localConstantDeclarationWithSourceExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_localConstantDeclarationWithSourceExpressionForGeneration * p = dynamic_cast <const GGS_localConstantDeclarationWithSourceExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_localConstantDeclarationWithSourceExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_localConstantDeclarationWithSourceExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_localConstantDeclarationWithSourceExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//  class 'cPtr_localConstantDeclarationWithConstructorCallForGeneration'    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_localConstantDeclarationWithConstructorCallForGeneration::
cPtr_localConstantDeclarationWithConstructorCallForGeneration (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_outSemanticExpressionListForGeneration & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (argument_0 COMMA_THERE),
mTypeName (argument_1),
mVariableName (argument_2),
mConstructorName (argument_3),
mConstructorArguments (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_localConstantDeclarationWithConstructorCallForGeneration * GGS_localConstantDeclarationWithConstructorCallForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_localConstantDeclarationWithConstructorCallForGeneration) ;
    return (cPtr_localConstantDeclarationWithConstructorCallForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_localConstantDeclarationWithConstructorCallForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_localConstantDeclarationWithConstructorCallForGeneration * ptr = dynamic_cast <const cPtr_localConstantDeclarationWithConstructorCallForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mTypeName.operator_isEqual (ptr->mTypeName).boolValue ()
         && mVariableName.operator_isEqual (ptr->mVariableName).boolValue ()
         && mConstructorName.operator_isEqual (ptr->mConstructorName).boolValue ()
         && mConstructorArguments.operator_isEqual (ptr->mConstructorArguments).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_localConstantDeclarationWithConstructorCallForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@localConstantDeclarationWithConstructorCallForGeneration:"
           << mStartLocation.reader_description (inIndentation + 1)
           << mTypeName.reader_description (inIndentation + 1)
           << mVariableName.reader_description (inIndentation + 1)
           << mConstructorName.reader_description (inIndentation + 1)
           << mConstructorArguments.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_localConstantDeclarationWithConstructorCallForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_localConstantDeclarationWithConstructorCallForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_localConstantDeclarationWithConstructorCallForGeneration (& typeid (cPtr_localConstantDeclarationWithConstructorCallForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_localConstantDeclarationWithConstructorCallForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__localConstantDeclarationWithConstructorCallForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_localConstantDeclarationWithConstructorCallForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_localConstantDeclarationWithConstructorCallForGeneration (mStartLocation, mTypeName, mVariableName, mConstructorName, mConstructorArguments COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//GALGAS class 'GGS_localConstantDeclarationWithConstructorCallForGeneration'*
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_localConstantDeclarationWithConstructorCallForGeneration ("localConstantDeclarationWithConstructorCallForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_localConstantDeclarationWithConstructorCallForGeneration::
GGS_localConstantDeclarationWithConstructorCallForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_localConstantDeclarationWithConstructorCallForGeneration::
GGS_localConstantDeclarationWithConstructorCallForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_localConstantDeclarationWithConstructorCallForGeneration GGS_localConstantDeclarationWithConstructorCallForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_localConstantDeclarationWithConstructorCallForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_localConstantDeclarationWithConstructorCallForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_localConstantDeclarationWithConstructorCallForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_localConstantDeclarationWithConstructorCallForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_localConstantDeclarationWithConstructorCallForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_localConstantDeclarationWithConstructorCallForGeneration GGS_localConstantDeclarationWithConstructorCallForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_lstring & argument_3,
                 const GGS_outSemanticExpressionListForGeneration & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_localConstantDeclarationWithConstructorCallForGeneration result ;
  macroMyNew (result.mPointer, cPtr_localConstantDeclarationWithConstructorCallForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_localConstantDeclarationWithConstructorCallForGeneration::
reader_mTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localConstantDeclarationWithConstructorCallForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localConstantDeclarationWithConstructorCallForGeneration *) mPointer)->mTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_localConstantDeclarationWithConstructorCallForGeneration::
reader_mVariableName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localConstantDeclarationWithConstructorCallForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localConstantDeclarationWithConstructorCallForGeneration *) mPointer)->mVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_localConstantDeclarationWithConstructorCallForGeneration::
reader_mConstructorName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localConstantDeclarationWithConstructorCallForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localConstantDeclarationWithConstructorCallForGeneration *) mPointer)->mConstructorName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_outSemanticExpressionListForGeneration  GGS_localConstantDeclarationWithConstructorCallForGeneration::
reader_mConstructorArguments (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_outSemanticExpressionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localConstantDeclarationWithConstructorCallForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localConstantDeclarationWithConstructorCallForGeneration *) mPointer)->mConstructorArguments ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_localConstantDeclarationWithConstructorCallForGeneration::actualTypeName (void) const {
  return "localConstantDeclarationWithConstructorCallForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__localConstantDeclarationWithConstructorCallForGeneration ("localConstantDeclarationWithConstructorCallForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_localConstantDeclarationWithConstructorCallForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_localConstantDeclarationWithConstructorCallForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_localConstantDeclarationWithConstructorCallForGeneration * p = NULL ;
    macroMyNew (p, GGS_localConstantDeclarationWithConstructorCallForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_localConstantDeclarationWithConstructorCallForGeneration GGS_localConstantDeclarationWithConstructorCallForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_localConstantDeclarationWithConstructorCallForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_localConstantDeclarationWithConstructorCallForGeneration * p = dynamic_cast <const GGS_localConstantDeclarationWithConstructorCallForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_localConstantDeclarationWithConstructorCallForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_localConstantDeclarationWithConstructorCallForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_localConstantDeclarationWithConstructorCallForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_assignmentInstructionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_assignmentInstructionForGeneration::
cPtr_assignmentInstructionForGeneration (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstringlist & argument_2,
                                const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (argument_0 COMMA_THERE),
mTargetVariableName (argument_1),
mStructAttributeList (argument_2),
mSourceExpression (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_assignmentInstructionForGeneration * GGS_assignmentInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_assignmentInstructionForGeneration) ;
    return (cPtr_assignmentInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_assignmentInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_assignmentInstructionForGeneration * ptr = dynamic_cast <const cPtr_assignmentInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mTargetVariableName.operator_isEqual (ptr->mTargetVariableName).boolValue ()
         && mStructAttributeList.operator_isEqual (ptr->mStructAttributeList).boolValue ()
         && mSourceExpression.operator_isEqual (ptr->mSourceExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_assignmentInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@assignmentInstructionForGeneration:"
           << mStartLocation.reader_description (inIndentation + 1)
           << mTargetVariableName.reader_description (inIndentation + 1)
           << mStructAttributeList.reader_description (inIndentation + 1)
           << mSourceExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_assignmentInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_assignmentInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_assignmentInstructionForGeneration (& typeid (cPtr_assignmentInstructionForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_assignmentInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__assignmentInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_assignmentInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_assignmentInstructionForGeneration (mStartLocation, mTargetVariableName, mStructAttributeList, mSourceExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_assignmentInstructionForGeneration'            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_assignmentInstructionForGeneration ("assignmentInstructionForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_assignmentInstructionForGeneration::
GGS_assignmentInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_assignmentInstructionForGeneration::
GGS_assignmentInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_assignmentInstructionForGeneration GGS_assignmentInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_assignmentInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_assignmentInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_assignmentInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_assignmentInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_assignmentInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_assignmentInstructionForGeneration GGS_assignmentInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstringlist & argument_2,
                 const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_assignmentInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_assignmentInstructionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_assignmentInstructionForGeneration::
reader_mTargetVariableName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_assignmentInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_assignmentInstructionForGeneration *) mPointer)->mTargetVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_assignmentInstructionForGeneration::
reader_mStructAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_assignmentInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_assignmentInstructionForGeneration *) mPointer)->mStructAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_assignmentInstructionForGeneration::
reader_mSourceExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_assignmentInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_assignmentInstructionForGeneration *) mPointer)->mSourceExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_assignmentInstructionForGeneration::actualTypeName (void) const {
  return "assignmentInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__assignmentInstructionForGeneration ("assignmentInstructionForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_assignmentInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_assignmentInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_assignmentInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_assignmentInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_assignmentInstructionForGeneration GGS_assignmentInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_assignmentInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_assignmentInstructionForGeneration * p = dynamic_cast <const GGS_assignmentInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_assignmentInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_assignmentInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_assignmentInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_appendInstructionForGeneration'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_appendInstructionForGeneration::
cPtr_appendInstructionForGeneration (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstringlist & argument_2,
                                const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (argument_0 COMMA_THERE),
mTargetVariableName (argument_1),
mStructAttributeList (argument_2),
mSourceExpression (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_appendInstructionForGeneration * GGS_appendInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_appendInstructionForGeneration) ;
    return (cPtr_appendInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_appendInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_appendInstructionForGeneration * ptr = dynamic_cast <const cPtr_appendInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mTargetVariableName.operator_isEqual (ptr->mTargetVariableName).boolValue ()
         && mStructAttributeList.operator_isEqual (ptr->mStructAttributeList).boolValue ()
         && mSourceExpression.operator_isEqual (ptr->mSourceExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_appendInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@appendInstructionForGeneration:"
           << mStartLocation.reader_description (inIndentation + 1)
           << mTargetVariableName.reader_description (inIndentation + 1)
           << mStructAttributeList.reader_description (inIndentation + 1)
           << mSourceExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_appendInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_appendInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_appendInstructionForGeneration (& typeid (cPtr_appendInstructionForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_appendInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__appendInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_appendInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_appendInstructionForGeneration (mStartLocation, mTargetVariableName, mStructAttributeList, mSourceExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_appendInstructionForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_appendInstructionForGeneration ("appendInstructionForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_appendInstructionForGeneration::
GGS_appendInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_appendInstructionForGeneration::
GGS_appendInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_appendInstructionForGeneration GGS_appendInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_appendInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_appendInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_appendInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_appendInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_appendInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_appendInstructionForGeneration GGS_appendInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstringlist & argument_2,
                 const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_appendInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_appendInstructionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_appendInstructionForGeneration::
reader_mTargetVariableName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_appendInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_appendInstructionForGeneration *) mPointer)->mTargetVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_appendInstructionForGeneration::
reader_mStructAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_appendInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_appendInstructionForGeneration *) mPointer)->mStructAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_appendInstructionForGeneration::
reader_mSourceExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_appendInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_appendInstructionForGeneration *) mPointer)->mSourceExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_appendInstructionForGeneration::actualTypeName (void) const {
  return "appendInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__appendInstructionForGeneration ("appendInstructionForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_appendInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_appendInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_appendInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_appendInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_appendInstructionForGeneration GGS_appendInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_appendInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_appendInstructionForGeneration * p = dynamic_cast <const GGS_appendInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_appendInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_appendInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_appendInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_sendInstructionForGeneration'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_sendInstructionForGeneration::
cPtr_sendInstructionForGeneration (const GGS_location & argument_0,
                                const GGS_semanticExpressionForGeneration & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (argument_0 COMMA_THERE),
mSourceExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_sendInstructionForGeneration * GGS_sendInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_sendInstructionForGeneration) ;
    return (cPtr_sendInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_sendInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_sendInstructionForGeneration * ptr = dynamic_cast <const cPtr_sendInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mSourceExpression.operator_isEqual (ptr->mSourceExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_sendInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@sendInstructionForGeneration:"
           << mStartLocation.reader_description (inIndentation + 1)
           << mSourceExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_sendInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_sendInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_sendInstructionForGeneration (& typeid (cPtr_sendInstructionForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_sendInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__sendInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_sendInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_sendInstructionForGeneration (mStartLocation, mSourceExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_sendInstructionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_sendInstructionForGeneration ("sendInstructionForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_sendInstructionForGeneration::
GGS_sendInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_sendInstructionForGeneration::
GGS_sendInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_sendInstructionForGeneration GGS_sendInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_sendInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_sendInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_sendInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_sendInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_sendInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sendInstructionForGeneration GGS_sendInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionForGeneration & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_sendInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_sendInstructionForGeneration (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_sendInstructionForGeneration::
reader_mSourceExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sendInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sendInstructionForGeneration *) mPointer)->mSourceExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_sendInstructionForGeneration::actualTypeName (void) const {
  return "sendInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__sendInstructionForGeneration ("sendInstructionForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_sendInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_sendInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_sendInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_sendInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sendInstructionForGeneration GGS_sendInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_sendInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_sendInstructionForGeneration * p = dynamic_cast <const GGS_sendInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_sendInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_sendInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_sendInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//   class 'cPtr_foreachInstructionEnumeratedObjectElementForGeneration'     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_foreachInstructionEnumeratedObjectElementForGeneration::
cPtr_foreachInstructionEnumeratedObjectElementForGeneration (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_foreachInstructionEnumeratedObjectElementForGeneration * GGS_foreachInstructionEnumeratedObjectElementForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_foreachInstructionEnumeratedObjectElementForGeneration) ;
    return (cPtr_foreachInstructionEnumeratedObjectElementForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_foreachInstructionEnumeratedObjectElementForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@foreachInstructionEnumeratedObjectElementForGeneration:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_foreachInstructionEnumeratedObjectElementForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_foreachInstructionEnumeratedObjectElementForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_foreachInstructionEnumeratedObjectElementForGeneration (& typeid (cPtr_foreachInstructionEnumeratedObjectElementForGeneration), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_foreachInstructionEnumeratedObjectElementForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__foreachInstructionEnumeratedObjectElementForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//GALGAS class 'GGS_foreachInstructionEnumeratedObjectElementForGeneration'  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_foreachInstructionEnumeratedObjectElementForGeneration ("foreachInstructionEnumeratedObjectElementForGeneration", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectElementForGeneration::
GGS_foreachInstructionEnumeratedObjectElementForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectElementForGeneration::
GGS_foreachInstructionEnumeratedObjectElementForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_foreachInstructionEnumeratedObjectElementForGeneration GGS_foreachInstructionEnumeratedObjectElementForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_foreachInstructionEnumeratedObjectElementForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_foreachInstructionEnumeratedObjectElementForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_foreachInstructionEnumeratedObjectElementForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_foreachInstructionEnumeratedObjectElementForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_foreachInstructionEnumeratedObjectElementForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_foreachInstructionEnumeratedObjectElementForGeneration::actualTypeName (void) const {
  return "foreachInstructionEnumeratedObjectElementForGeneration" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_foreachInstructionEnumeratedObjectElementForGeneration::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__foreachInstructionEnumeratedObjectElementForGeneration ("foreachInstructionEnumeratedObjectElementForGeneration", & kTypeDescriptor_GGS_foreachInstructionEnumeratedObjectElementForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_foreachInstructionEnumeratedObjectElementForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_foreachInstructionEnumeratedObjectElementForGeneration * p = NULL ;
    macroMyNew (p, GGS_foreachInstructionEnumeratedObjectElementForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectElementForGeneration GGS_foreachInstructionEnumeratedObjectElementForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_foreachInstructionEnumeratedObjectElementForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_foreachInstructionEnumeratedObjectElementForGeneration * p = dynamic_cast <const GGS_foreachInstructionEnumeratedObjectElementForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_foreachInstructionEnumeratedObjectElementForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_foreachInstructionEnumeratedObjectElementForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_foreachInstructionEnumeratedObjectElementForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            class 'cPtr_foreachInstructionJokerForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_foreachInstructionJokerForGeneration::
cPtr_foreachInstructionJokerForGeneration (LOCATION_ARGS)
:cPtr_foreachInstructionEnumeratedObjectElementForGeneration (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_foreachInstructionJokerForGeneration * GGS_foreachInstructionJokerForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_foreachInstructionJokerForGeneration) ;
    return (cPtr_foreachInstructionJokerForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_foreachInstructionJokerForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_foreachInstructionJokerForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@foreachInstructionJokerForGeneration:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_foreachInstructionJokerForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_foreachInstructionJokerForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_foreachInstructionJokerForGeneration (& typeid (cPtr_foreachInstructionJokerForGeneration), & typeid (cPtr_foreachInstructionEnumeratedObjectElementForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_foreachInstructionJokerForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__foreachInstructionJokerForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         GALGAS class 'GGS_foreachInstructionJokerForGeneration'           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_foreachInstructionJokerForGeneration ("foreachInstructionJokerForGeneration", true, & kTypeDescriptor_GGS_foreachInstructionEnumeratedObjectElementForGeneration) ;

//---------------------------------------------------------------------------*

GGS_foreachInstructionJokerForGeneration::
GGS_foreachInstructionJokerForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionJokerForGeneration::
GGS_foreachInstructionJokerForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_foreachInstructionJokerForGeneration GGS_foreachInstructionJokerForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_foreachInstructionJokerForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_foreachInstructionJokerForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_foreachInstructionJokerForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_foreachInstructionJokerForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_foreachInstructionJokerForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_foreachInstructionJokerForGeneration * gSingleton_foreachInstructionJokerForGeneration = NULL ;

//---------------------------------------------------------------------------*

GGS_foreachInstructionJokerForGeneration GGS_foreachInstructionJokerForGeneration::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_foreachInstructionJokerForGeneration result ;
  if (NULL == gSingleton_foreachInstructionJokerForGeneration) {
    macroMyNew (gSingleton_foreachInstructionJokerForGeneration, cPtr_foreachInstructionJokerForGeneration (THERE)) ;
    macroRetainObject (gSingleton_foreachInstructionJokerForGeneration) ;
  }
  macroAssignObject (result.mPointer, gSingleton_foreachInstructionJokerForGeneration) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_foreachInstructionJokerForGeneration::actualTypeName (void) const {
  return "foreachInstructionJokerForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__foreachInstructionJokerForGeneration ("foreachInstructionJokerForGeneration", gClassInfoFor__foreachInstructionEnumeratedObjectElementForGeneration, & kTypeDescriptor_GGS_foreachInstructionJokerForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_foreachInstructionJokerForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_foreachInstructionJokerForGeneration * p = NULL ;
    macroMyNew (p, GGS_foreachInstructionJokerForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionJokerForGeneration GGS_foreachInstructionJokerForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_foreachInstructionJokerForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_foreachInstructionJokerForGeneration * p = dynamic_cast <const GGS_foreachInstructionJokerForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_foreachInstructionJokerForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_foreachInstructionJokerForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_foreachInstructionJokerForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//      class 'cPtr_foreachInstructionEnumeratedConstantForGeneration'       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_foreachInstructionEnumeratedConstantForGeneration::
cPtr_foreachInstructionEnumeratedConstantForGeneration (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_foreachInstructionEnumeratedObjectElementForGeneration (THERE),
mTypeName (argument_0),
mConstantName (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_foreachInstructionEnumeratedConstantForGeneration * GGS_foreachInstructionEnumeratedConstantForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_foreachInstructionEnumeratedConstantForGeneration) ;
    return (cPtr_foreachInstructionEnumeratedConstantForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_foreachInstructionEnumeratedConstantForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_foreachInstructionEnumeratedConstantForGeneration * ptr = dynamic_cast <const cPtr_foreachInstructionEnumeratedConstantForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTypeName.operator_isEqual (ptr->mTypeName).boolValue ()
         && mConstantName.operator_isEqual (ptr->mConstantName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_foreachInstructionEnumeratedConstantForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@foreachInstructionEnumeratedConstantForGeneration:"
           << mTypeName.reader_description (inIndentation + 1)
           << mConstantName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_foreachInstructionEnumeratedConstantForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_foreachInstructionEnumeratedConstantForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_foreachInstructionEnumeratedConstantForGeneration (& typeid (cPtr_foreachInstructionEnumeratedConstantForGeneration), & typeid (cPtr_foreachInstructionEnumeratedObjectElementForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_foreachInstructionEnumeratedConstantForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__foreachInstructionEnumeratedConstantForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_foreachInstructionEnumeratedConstantForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_foreachInstructionEnumeratedConstantForGeneration (mTypeName, mConstantName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//   GALGAS class 'GGS_foreachInstructionEnumeratedConstantForGeneration'    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_foreachInstructionEnumeratedConstantForGeneration ("foreachInstructionEnumeratedConstantForGeneration", true, & kTypeDescriptor_GGS_foreachInstructionEnumeratedObjectElementForGeneration) ;

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedConstantForGeneration::
GGS_foreachInstructionEnumeratedConstantForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedConstantForGeneration::
GGS_foreachInstructionEnumeratedConstantForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_foreachInstructionEnumeratedConstantForGeneration GGS_foreachInstructionEnumeratedConstantForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_foreachInstructionEnumeratedConstantForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_foreachInstructionEnumeratedConstantForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_foreachInstructionEnumeratedConstantForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_foreachInstructionEnumeratedConstantForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_foreachInstructionEnumeratedConstantForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedConstantForGeneration GGS_foreachInstructionEnumeratedConstantForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_foreachInstructionEnumeratedConstantForGeneration result ;
  macroMyNew (result.mPointer, cPtr_foreachInstructionEnumeratedConstantForGeneration (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_foreachInstructionEnumeratedConstantForGeneration::
reader_mTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstructionEnumeratedConstantForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstructionEnumeratedConstantForGeneration *) mPointer)->mTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_foreachInstructionEnumeratedConstantForGeneration::
reader_mConstantName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstructionEnumeratedConstantForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstructionEnumeratedConstantForGeneration *) mPointer)->mConstantName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_foreachInstructionEnumeratedConstantForGeneration::actualTypeName (void) const {
  return "foreachInstructionEnumeratedConstantForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__foreachInstructionEnumeratedConstantForGeneration ("foreachInstructionEnumeratedConstantForGeneration", gClassInfoFor__foreachInstructionEnumeratedObjectElementForGeneration, & kTypeDescriptor_GGS_foreachInstructionEnumeratedConstantForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_foreachInstructionEnumeratedConstantForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_foreachInstructionEnumeratedConstantForGeneration * p = NULL ;
    macroMyNew (p, GGS_foreachInstructionEnumeratedConstantForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedConstantForGeneration GGS_foreachInstructionEnumeratedConstantForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_foreachInstructionEnumeratedConstantForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_foreachInstructionEnumeratedConstantForGeneration * p = dynamic_cast <const GGS_foreachInstructionEnumeratedConstantForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_foreachInstructionEnumeratedConstantForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_foreachInstructionEnumeratedConstantForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_foreachInstructionEnumeratedConstantForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//Element of list '@foreachInstructionEnumeratedObjectElementListForGeneration'*
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_foreachInstructionEnumeratedObjectElementListForGeneration::
elementOf_GGS_foreachInstructionEnumeratedObjectElementListForGeneration (const GGS_foreachInstructionEnumeratedObjectElementForGeneration & argument_0
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mElement (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_foreachInstructionEnumeratedObjectElementListForGeneration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_foreachInstructionEnumeratedObjectElementListForGeneration * ptr = dynamic_cast <const elementOf_GGS_foreachInstructionEnumeratedObjectElementListForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mElement.operator_isEqual (ptr->mElement).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_foreachInstructionEnumeratedObjectElementListForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mElement.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//    List '@foreachInstructionEnumeratedObjectElementListForGeneration'     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_foreachInstructionEnumeratedObjectElementListForGeneration ("foreachInstructionEnumeratedObjectElementListForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectElementListForGeneration::
internalAppendValues (const GGS_foreachInstructionEnumeratedObjectElementForGeneration & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectElementListForGeneration::
internalPrependValues (const GGS_foreachInstructionEnumeratedObjectElementForGeneration & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectElementListForGeneration::
addAssign_operation (const GGS_foreachInstructionEnumeratedObjectElementForGeneration & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectElementListForGeneration GGS_foreachInstructionEnumeratedObjectElementListForGeneration::
operator_concat (const GGS_foreachInstructionEnumeratedObjectElementListForGeneration & inOperand) const {
  GGS_foreachInstructionEnumeratedObjectElementListForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectElementListForGeneration::
dotAssign_operation (const GGS_foreachInstructionEnumeratedObjectElementListForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_foreachInstructionEnumeratedObjectElementListForGeneration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_foreachInstructionEnumeratedObjectElementForGeneration  p_0 = p->mElement ;
          internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectElementListForGeneration::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_foreachInstructionEnumeratedObjectElementForGeneration & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectElementListForGeneration::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mElement
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectElementListForGeneration  GGS_foreachInstructionEnumeratedObjectElementListForGeneration::
constructor_emptyList (void) {
  GGS_foreachInstructionEnumeratedObjectElementListForGeneration result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectElementListForGeneration  GGS_foreachInstructionEnumeratedObjectElementListForGeneration::
constructor_listWithValue (const GGS_foreachInstructionEnumeratedObjectElementForGeneration & argument_0) {
  GGS_foreachInstructionEnumeratedObjectElementListForGeneration result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectElementListForGeneration::
internalSubListWithRange (GGS_foreachInstructionEnumeratedObjectElementListForGeneration & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mElement) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectElementListForGeneration GGS_foreachInstructionEnumeratedObjectElementListForGeneration::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_foreachInstructionEnumeratedObjectElementListForGeneration result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectElementListForGeneration GGS_foreachInstructionEnumeratedObjectElementListForGeneration::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_foreachInstructionEnumeratedObjectElementListForGeneration result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_foreachInstructionEnumeratedObjectElementListForGeneration::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@foreachInstructionEnumeratedObjectElementListForGeneration", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectElementListForGeneration::
method_first (C_Compiler & inLexique,
              GGS_foreachInstructionEnumeratedObjectElementForGeneration & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mElement ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectElementListForGeneration::
method_last (C_Compiler & inLexique,
             GGS_foreachInstructionEnumeratedObjectElementForGeneration & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mElement ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectElementListForGeneration::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_foreachInstructionEnumeratedObjectElementForGeneration & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mElement ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectElementListForGeneration::
modifier_popLast (C_Compiler & inLexique,
                GGS_foreachInstructionEnumeratedObjectElementForGeneration & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mElement ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectElementForGeneration  GGS_foreachInstructionEnumeratedObjectElementListForGeneration::
reader_mElementAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_foreachInstructionEnumeratedObjectElementForGeneration  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mElement ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectElementListForGeneration::
modifier_setMElementAtIndex (C_Compiler & inLexique,
                              const GGS_foreachInstructionEnumeratedObjectElementForGeneration  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mElement = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_foreachInstructionEnumeratedObjectElementForGeneration  & GGS_foreachInstructionEnumeratedObjectElementListForGeneration::cEnumerator::_mElement (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mElement ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_foreachInstructionEnumeratedObjectElementListForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_foreachInstructionEnumeratedObjectElementListForGeneration * p = NULL ;
    macroMyNew (p, GGS_foreachInstructionEnumeratedObjectElementListForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectElementListForGeneration GGS_foreachInstructionEnumeratedObjectElementListForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_foreachInstructionEnumeratedObjectElementListForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_foreachInstructionEnumeratedObjectElementListForGeneration * p = dynamic_cast <const GGS_foreachInstructionEnumeratedObjectElementListForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_foreachInstructionEnumeratedObjectElementListForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_foreachInstructionEnumeratedObjectElementListForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_foreachInstructionEnumeratedObjectElementListForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//  Element of list '@foreachInstructionEnumeratedObjectListForGeneration'   *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_foreachInstructionEnumeratedObjectListForGeneration::
elementOf_GGS_foreachInstructionEnumeratedObjectListForGeneration (const GGS_bool& argument_0,
                                const GGS_semanticExpressionForGeneration & argument_1,
                                const GGS_foreachInstructionEnumeratedObjectElementListForGeneration & argument_2,
                                const GGS_bool& argument_3,
                                const GGS_lstring & argument_4
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mIsAscending (argument_0),
mEnumeratedExpression (argument_1),
mElementList (argument_2),
mEndsWithEllipsis (argument_3),
mPrefix (argument_4) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_foreachInstructionEnumeratedObjectListForGeneration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_foreachInstructionEnumeratedObjectListForGeneration * ptr = dynamic_cast <const elementOf_GGS_foreachInstructionEnumeratedObjectListForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mIsAscending.operator_isEqual (ptr->mIsAscending).boolValue ()
         && mEnumeratedExpression.operator_isEqual (ptr->mEnumeratedExpression).boolValue ()
         && mElementList.operator_isEqual (ptr->mElementList).boolValue ()
         && mEndsWithEllipsis.operator_isEqual (ptr->mEndsWithEllipsis).boolValue ()
         && mPrefix.operator_isEqual (ptr->mPrefix).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_foreachInstructionEnumeratedObjectListForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mIsAscending.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEnumeratedExpression.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mElementList.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEndsWithEllipsis.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mPrefix.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//       List '@foreachInstructionEnumeratedObjectListForGeneration'         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_foreachInstructionEnumeratedObjectListForGeneration ("foreachInstructionEnumeratedObjectListForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListForGeneration::
internalAppendValues (const GGS_bool& argument_0,
                    const GGS_semanticExpressionForGeneration & argument_1,
                    const GGS_foreachInstructionEnumeratedObjectElementListForGeneration & argument_2,
                    const GGS_bool& argument_3,
                    const GGS_lstring & argument_4
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListForGeneration::
internalPrependValues (const GGS_bool& argument_0,
                    const GGS_semanticExpressionForGeneration & argument_1,
                    const GGS_foreachInstructionEnumeratedObjectElementListForGeneration & argument_2,
                    const GGS_bool& argument_3,
                    const GGS_lstring & argument_4
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListForGeneration::
addAssign_operation (const GGS_bool& argument_0,
                                const GGS_semanticExpressionForGeneration & argument_1,
                                const GGS_foreachInstructionEnumeratedObjectElementListForGeneration & argument_2,
                                const GGS_bool& argument_3,
                                const GGS_lstring & argument_4) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()&& argument_3.isBuilt ()&& argument_4.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectListForGeneration GGS_foreachInstructionEnumeratedObjectListForGeneration::
operator_concat (const GGS_foreachInstructionEnumeratedObjectListForGeneration & inOperand) const {
  GGS_foreachInstructionEnumeratedObjectListForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListForGeneration::
dotAssign_operation (const GGS_foreachInstructionEnumeratedObjectListForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_foreachInstructionEnumeratedObjectListForGeneration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_bool p_0 = p->mIsAscending ;
          GGS_semanticExpressionForGeneration  p_1 = p->mEnumeratedExpression ;
          GGS_foreachInstructionEnumeratedObjectElementListForGeneration  p_2 = p->mElementList ;
          GGS_bool p_3 = p->mEndsWithEllipsis ;
          GGS_lstring  p_4 = p->mPrefix ;
          internalAppendValues (p_0, p_1, p_2, p_3, p_4 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListForGeneration::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_bool& argument_0,
                     const GGS_semanticExpressionForGeneration & argument_1,
                     const GGS_foreachInstructionEnumeratedObjectElementListForGeneration & argument_2,
                     const GGS_bool& argument_3,
                     const GGS_lstring & argument_4
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListForGeneration::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mIsAscending,
                                ptr->mEnumeratedExpression,
                                ptr->mElementList,
                                ptr->mEndsWithEllipsis,
                                ptr->mPrefix
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectListForGeneration  GGS_foreachInstructionEnumeratedObjectListForGeneration::
constructor_emptyList (void) {
  GGS_foreachInstructionEnumeratedObjectListForGeneration result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectListForGeneration  GGS_foreachInstructionEnumeratedObjectListForGeneration::
constructor_listWithValue (const GGS_bool& argument_0,
                                const GGS_semanticExpressionForGeneration & argument_1,
                                const GGS_foreachInstructionEnumeratedObjectElementListForGeneration & argument_2,
                                const GGS_bool& argument_3,
                                const GGS_lstring & argument_4) {
  GGS_foreachInstructionEnumeratedObjectListForGeneration result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2, argument_3, argument_4) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListForGeneration::
internalSubListWithRange (GGS_foreachInstructionEnumeratedObjectListForGeneration & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mIsAscending, ptr->mEnumeratedExpression, ptr->mElementList, ptr->mEndsWithEllipsis, ptr->mPrefix) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectListForGeneration GGS_foreachInstructionEnumeratedObjectListForGeneration::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_foreachInstructionEnumeratedObjectListForGeneration result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectListForGeneration GGS_foreachInstructionEnumeratedObjectListForGeneration::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_foreachInstructionEnumeratedObjectListForGeneration result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_foreachInstructionEnumeratedObjectListForGeneration::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@foreachInstructionEnumeratedObjectListForGeneration", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListForGeneration::
method_first (C_Compiler & inLexique,
              GGS_bool& _out_0,
              GGS_semanticExpressionForGeneration & _out_1,
              GGS_foreachInstructionEnumeratedObjectElementListForGeneration & _out_2,
              GGS_bool& _out_3,
              GGS_lstring & _out_4
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mIsAscending ;
    _out_1 = ptr->mEnumeratedExpression ;
    _out_2 = ptr->mElementList ;
    _out_3 = ptr->mEndsWithEllipsis ;
    _out_4 = ptr->mPrefix ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListForGeneration::
method_last (C_Compiler & inLexique,
             GGS_bool& _out_0,
             GGS_semanticExpressionForGeneration & _out_1,
             GGS_foreachInstructionEnumeratedObjectElementListForGeneration & _out_2,
             GGS_bool& _out_3,
             GGS_lstring & _out_4
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mIsAscending ;
    _out_1 = ptr->mEnumeratedExpression ;
    _out_2 = ptr->mElementList ;
    _out_3 = ptr->mEndsWithEllipsis ;
    _out_4 = ptr->mPrefix ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListForGeneration::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_bool& _out_0,
                 GGS_semanticExpressionForGeneration & _out_1,
                 GGS_foreachInstructionEnumeratedObjectElementListForGeneration & _out_2,
                 GGS_bool& _out_3,
                 GGS_lstring & _out_4
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mIsAscending ;
    _out_1 = ptr->mEnumeratedExpression ;
    _out_2 = ptr->mElementList ;
    _out_3 = ptr->mEndsWithEllipsis ;
    _out_4 = ptr->mPrefix ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListForGeneration::
modifier_popLast (C_Compiler & inLexique,
                GGS_bool& _out_0,
                GGS_semanticExpressionForGeneration & _out_1,
                GGS_foreachInstructionEnumeratedObjectElementListForGeneration & _out_2,
                GGS_bool& _out_3,
                GGS_lstring & _out_4
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mIsAscending ;
    _out_1 = ptr->mEnumeratedExpression ;
    _out_2 = ptr->mElementList ;
    _out_3 = ptr->mEndsWithEllipsis ;
    _out_4 = ptr->mPrefix ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_bool GGS_foreachInstructionEnumeratedObjectListForGeneration::
reader_mIsAscendingAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mIsAscending ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_foreachInstructionEnumeratedObjectListForGeneration::
reader_mEnumeratedExpressionAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mEnumeratedExpression ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectElementListForGeneration  GGS_foreachInstructionEnumeratedObjectListForGeneration::
reader_mElementListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_foreachInstructionEnumeratedObjectElementListForGeneration  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mElementList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_foreachInstructionEnumeratedObjectListForGeneration::
reader_mEndsWithEllipsisAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mEndsWithEllipsis ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_foreachInstructionEnumeratedObjectListForGeneration::
reader_mPrefixAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mPrefix ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListForGeneration::
modifier_setMIsAscendingAtIndex (C_Compiler & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mIsAscending = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListForGeneration::
modifier_setMEnumeratedExpressionAtIndex (C_Compiler & inLexique,
                              const GGS_semanticExpressionForGeneration  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mEnumeratedExpression = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListForGeneration::
modifier_setMElementListAtIndex (C_Compiler & inLexique,
                              const GGS_foreachInstructionEnumeratedObjectElementListForGeneration  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mElementList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListForGeneration::
modifier_setMEndsWithEllipsisAtIndex (C_Compiler & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mEndsWithEllipsis = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListForGeneration::
modifier_setMPrefixAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mPrefix = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_foreachInstructionEnumeratedObjectListForGeneration::cEnumerator::_mIsAscending (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mIsAscending ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticExpressionForGeneration  & GGS_foreachInstructionEnumeratedObjectListForGeneration::cEnumerator::_mEnumeratedExpression (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mEnumeratedExpression ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_foreachInstructionEnumeratedObjectElementListForGeneration  & GGS_foreachInstructionEnumeratedObjectListForGeneration::cEnumerator::_mElementList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mElementList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_foreachInstructionEnumeratedObjectListForGeneration::cEnumerator::_mEndsWithEllipsis (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mEndsWithEllipsis ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_foreachInstructionEnumeratedObjectListForGeneration::cEnumerator::_mPrefix (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mPrefix ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_foreachInstructionEnumeratedObjectListForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_foreachInstructionEnumeratedObjectListForGeneration * p = NULL ;
    macroMyNew (p, GGS_foreachInstructionEnumeratedObjectListForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectListForGeneration GGS_foreachInstructionEnumeratedObjectListForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_foreachInstructionEnumeratedObjectListForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_foreachInstructionEnumeratedObjectListForGeneration * p = dynamic_cast <const GGS_foreachInstructionEnumeratedObjectListForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_foreachInstructionEnumeratedObjectListForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_foreachInstructionEnumeratedObjectListForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_foreachInstructionEnumeratedObjectListForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_foreachInstructionForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_foreachInstructionForGeneration::
cPtr_foreachInstructionForGeneration (const GGS_location & argument_0,
                                const GGS_foreachInstructionEnumeratedObjectListForGeneration & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_semanticExpressionForGeneration & argument_3,
                                const GGS_semanticInstructionListForGeneration & argument_4,
                                const GGS_semanticInstructionListForGeneration & argument_5,
                                const GGS_semanticInstructionListForGeneration & argument_6,
                                const GGS_semanticInstructionListForGeneration & argument_7
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (argument_0 COMMA_THERE),
mEnumeratedObjectList (argument_1),
mIndexVariableName (argument_2),
mWhileExpression (argument_3),
mBeforeInstructionList (argument_4),
mBetweenInstructionList (argument_5),
mDoInstructionList (argument_6),
mAfterInstructionList (argument_7) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_foreachInstructionForGeneration * GGS_foreachInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_foreachInstructionForGeneration) ;
    return (cPtr_foreachInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_foreachInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_foreachInstructionForGeneration * ptr = dynamic_cast <const cPtr_foreachInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mEnumeratedObjectList.operator_isEqual (ptr->mEnumeratedObjectList).boolValue ()
         && mIndexVariableName.operator_isEqual (ptr->mIndexVariableName).boolValue ()
         && mWhileExpression.operator_isEqual (ptr->mWhileExpression).boolValue ()
         && mBeforeInstructionList.operator_isEqual (ptr->mBeforeInstructionList).boolValue ()
         && mBetweenInstructionList.operator_isEqual (ptr->mBetweenInstructionList).boolValue ()
         && mDoInstructionList.operator_isEqual (ptr->mDoInstructionList).boolValue ()
         && mAfterInstructionList.operator_isEqual (ptr->mAfterInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_foreachInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@foreachInstructionForGeneration:"
           << mStartLocation.reader_description (inIndentation + 1)
           << mEnumeratedObjectList.reader_description (inIndentation + 1)
           << mIndexVariableName.reader_description (inIndentation + 1)
           << mWhileExpression.reader_description (inIndentation + 1)
           << mBeforeInstructionList.reader_description (inIndentation + 1)
           << mBetweenInstructionList.reader_description (inIndentation + 1)
           << mDoInstructionList.reader_description (inIndentation + 1)
           << mAfterInstructionList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_foreachInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_foreachInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_foreachInstructionForGeneration (& typeid (cPtr_foreachInstructionForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_foreachInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__foreachInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_foreachInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_foreachInstructionForGeneration (mStartLocation, mEnumeratedObjectList, mIndexVariableName, mWhileExpression, mBeforeInstructionList, mBetweenInstructionList, mDoInstructionList, mAfterInstructionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_foreachInstructionForGeneration'             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_foreachInstructionForGeneration ("foreachInstructionForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_foreachInstructionForGeneration::
GGS_foreachInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionForGeneration::
GGS_foreachInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_foreachInstructionForGeneration GGS_foreachInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_foreachInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_foreachInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_foreachInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_foreachInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_foreachInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionForGeneration GGS_foreachInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_foreachInstructionEnumeratedObjectListForGeneration & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_semanticExpressionForGeneration & argument_3,
                 const GGS_semanticInstructionListForGeneration & argument_4,
                 const GGS_semanticInstructionListForGeneration & argument_5,
                 const GGS_semanticInstructionListForGeneration & argument_6,
                 const GGS_semanticInstructionListForGeneration & argument_7
                                COMMA_LOCATION_ARGS) {
  GGS_foreachInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_foreachInstructionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectListForGeneration  GGS_foreachInstructionForGeneration::
reader_mEnumeratedObjectList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_foreachInstructionEnumeratedObjectListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstructionForGeneration *) mPointer)->mEnumeratedObjectList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_foreachInstructionForGeneration::
reader_mIndexVariableName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstructionForGeneration *) mPointer)->mIndexVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_foreachInstructionForGeneration::
reader_mWhileExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstructionForGeneration *) mPointer)->mWhileExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration  GGS_foreachInstructionForGeneration::
reader_mBeforeInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstructionForGeneration *) mPointer)->mBeforeInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration  GGS_foreachInstructionForGeneration::
reader_mBetweenInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstructionForGeneration *) mPointer)->mBetweenInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration  GGS_foreachInstructionForGeneration::
reader_mDoInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstructionForGeneration *) mPointer)->mDoInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration  GGS_foreachInstructionForGeneration::
reader_mAfterInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstructionForGeneration *) mPointer)->mAfterInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_foreachInstructionForGeneration::actualTypeName (void) const {
  return "foreachInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__foreachInstructionForGeneration ("foreachInstructionForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_foreachInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_foreachInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_foreachInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_foreachInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionForGeneration GGS_foreachInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_foreachInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_foreachInstructionForGeneration * p = dynamic_cast <const GGS_foreachInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_foreachInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_foreachInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_foreachInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@ifBranchListForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_ifBranchListForGeneration::
elementOf_GGS_ifBranchListForGeneration (const GGS_semanticExpressionForGeneration & argument_0,
                                const GGS_semanticInstructionListForGeneration & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mIFexpression (argument_0),
mIFinstructionList (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_ifBranchListForGeneration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_ifBranchListForGeneration * ptr = dynamic_cast <const elementOf_GGS_ifBranchListForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mIFexpression.operator_isEqual (ptr->mIFexpression).boolValue ()
         && mIFinstructionList.operator_isEqual (ptr->mIFinstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_ifBranchListForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mIFexpression.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mIFinstructionList.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@ifBranchListForGeneration'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_ifBranchListForGeneration ("ifBranchListForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_ifBranchListForGeneration::
internalAppendValues (const GGS_semanticExpressionForGeneration & argument_0,
                    const GGS_semanticInstructionListForGeneration & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_ifBranchListForGeneration::
internalPrependValues (const GGS_semanticExpressionForGeneration & argument_0,
                    const GGS_semanticInstructionListForGeneration & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_ifBranchListForGeneration::
addAssign_operation (const GGS_semanticExpressionForGeneration & argument_0,
                                const GGS_semanticInstructionListForGeneration & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_ifBranchListForGeneration GGS_ifBranchListForGeneration::
operator_concat (const GGS_ifBranchListForGeneration & inOperand) const {
  GGS_ifBranchListForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_ifBranchListForGeneration::
dotAssign_operation (const GGS_ifBranchListForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_ifBranchListForGeneration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_semanticExpressionForGeneration  p_0 = p->mIFexpression ;
          GGS_semanticInstructionListForGeneration  p_1 = p->mIFinstructionList ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_ifBranchListForGeneration::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_semanticExpressionForGeneration & argument_0,
                     const GGS_semanticInstructionListForGeneration & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ifBranchListForGeneration::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mIFexpression,
                                ptr->mIFinstructionList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_ifBranchListForGeneration  GGS_ifBranchListForGeneration::
constructor_emptyList (void) {
  GGS_ifBranchListForGeneration result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ifBranchListForGeneration  GGS_ifBranchListForGeneration::
constructor_listWithValue (const GGS_semanticExpressionForGeneration & argument_0,
                                const GGS_semanticInstructionListForGeneration & argument_1) {
  GGS_ifBranchListForGeneration result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_ifBranchListForGeneration::
internalSubListWithRange (GGS_ifBranchListForGeneration & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mIFexpression, ptr->mIFinstructionList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_ifBranchListForGeneration GGS_ifBranchListForGeneration::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_ifBranchListForGeneration result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ifBranchListForGeneration GGS_ifBranchListForGeneration::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_ifBranchListForGeneration result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_ifBranchListForGeneration::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@ifBranchListForGeneration", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_ifBranchListForGeneration::
method_first (C_Compiler & inLexique,
              GGS_semanticExpressionForGeneration & _out_0,
              GGS_semanticInstructionListForGeneration & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mIFexpression ;
    _out_1 = ptr->mIFinstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ifBranchListForGeneration::
method_last (C_Compiler & inLexique,
             GGS_semanticExpressionForGeneration & _out_0,
             GGS_semanticInstructionListForGeneration & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mIFexpression ;
    _out_1 = ptr->mIFinstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ifBranchListForGeneration::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_semanticExpressionForGeneration & _out_0,
                 GGS_semanticInstructionListForGeneration & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mIFexpression ;
    _out_1 = ptr->mIFinstructionList ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ifBranchListForGeneration::
modifier_popLast (C_Compiler & inLexique,
                GGS_semanticExpressionForGeneration & _out_0,
                GGS_semanticInstructionListForGeneration & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mIFexpression ;
    _out_1 = ptr->mIFinstructionList ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_ifBranchListForGeneration::
reader_mIFexpressionAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mIFexpression ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration  GGS_ifBranchListForGeneration::
reader_mIFinstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticInstructionListForGeneration  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mIFinstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_ifBranchListForGeneration::
modifier_setMIFexpressionAtIndex (C_Compiler & inLexique,
                              const GGS_semanticExpressionForGeneration  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mIFexpression = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_ifBranchListForGeneration::
modifier_setMIFinstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_semanticInstructionListForGeneration  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mIFinstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticExpressionForGeneration  & GGS_ifBranchListForGeneration::cEnumerator::_mIFexpression (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mIFexpression ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticInstructionListForGeneration  & GGS_ifBranchListForGeneration::cEnumerator::_mIFinstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mIFinstructionList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_ifBranchListForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_ifBranchListForGeneration * p = NULL ;
    macroMyNew (p, GGS_ifBranchListForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ifBranchListForGeneration GGS_ifBranchListForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_ifBranchListForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_ifBranchListForGeneration * p = dynamic_cast <const GGS_ifBranchListForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_ifBranchListForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_ifBranchListForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_ifBranchListForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_ifInstructionForGeneration'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ifInstructionForGeneration::
cPtr_ifInstructionForGeneration (const GGS_location & argument_0,
                                const GGS_ifBranchListForGeneration & argument_1,
                                const GGS_semanticInstructionListForGeneration & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (argument_0 COMMA_THERE),
mBranchList (argument_1),
mElseInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ifInstructionForGeneration * GGS_ifInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_ifInstructionForGeneration) ;
    return (cPtr_ifInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ifInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ifInstructionForGeneration * ptr = dynamic_cast <const cPtr_ifInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mBranchList.operator_isEqual (ptr->mBranchList).boolValue ()
         && mElseInstructionList.operator_isEqual (ptr->mElseInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ifInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@ifInstructionForGeneration:"
           << mStartLocation.reader_description (inIndentation + 1)
           << mBranchList.reader_description (inIndentation + 1)
           << mElseInstructionList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ifInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ifInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ifInstructionForGeneration (& typeid (cPtr_ifInstructionForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_ifInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__ifInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_ifInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_ifInstructionForGeneration (mStartLocation, mBranchList, mElseInstructionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_ifInstructionForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_ifInstructionForGeneration ("ifInstructionForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_ifInstructionForGeneration::
GGS_ifInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ifInstructionForGeneration::
GGS_ifInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_ifInstructionForGeneration GGS_ifInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ifInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ifInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_ifInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_ifInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ifInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ifInstructionForGeneration GGS_ifInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_ifBranchListForGeneration & argument_1,
                 const GGS_semanticInstructionListForGeneration & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_ifInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_ifInstructionForGeneration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ifBranchListForGeneration  GGS_ifInstructionForGeneration::
reader_mBranchList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_ifBranchListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ifInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ifInstructionForGeneration *) mPointer)->mBranchList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration  GGS_ifInstructionForGeneration::
reader_mElseInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ifInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ifInstructionForGeneration *) mPointer)->mElseInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ifInstructionForGeneration::actualTypeName (void) const {
  return "ifInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__ifInstructionForGeneration ("ifInstructionForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_ifInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_ifInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_ifInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_ifInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ifInstructionForGeneration GGS_ifInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_ifInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_ifInstructionForGeneration * p = dynamic_cast <const GGS_ifInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_ifInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_ifInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_ifInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_methodCallInstructionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_methodCallInstructionForGeneration::
cPtr_methodCallInstructionForGeneration (const GGS_location & argument_0,
                                const GGS_semanticExpressionForGeneration & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_actualParameterListForGeneration & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (argument_0 COMMA_THERE),
mReceiverExpression (argument_1),
mMethodName (argument_2),
mActualParameterList (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_methodCallInstructionForGeneration * GGS_methodCallInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_methodCallInstructionForGeneration) ;
    return (cPtr_methodCallInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_methodCallInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_methodCallInstructionForGeneration * ptr = dynamic_cast <const cPtr_methodCallInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mReceiverExpression.operator_isEqual (ptr->mReceiverExpression).boolValue ()
         && mMethodName.operator_isEqual (ptr->mMethodName).boolValue ()
         && mActualParameterList.operator_isEqual (ptr->mActualParameterList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_methodCallInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@methodCallInstructionForGeneration:"
           << mStartLocation.reader_description (inIndentation + 1)
           << mReceiverExpression.reader_description (inIndentation + 1)
           << mMethodName.reader_description (inIndentation + 1)
           << mActualParameterList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_methodCallInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_methodCallInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_methodCallInstructionForGeneration (& typeid (cPtr_methodCallInstructionForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_methodCallInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__methodCallInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_methodCallInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_methodCallInstructionForGeneration (mStartLocation, mReceiverExpression, mMethodName, mActualParameterList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_methodCallInstructionForGeneration'            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_methodCallInstructionForGeneration ("methodCallInstructionForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_methodCallInstructionForGeneration::
GGS_methodCallInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_methodCallInstructionForGeneration::
GGS_methodCallInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_methodCallInstructionForGeneration GGS_methodCallInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_methodCallInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_methodCallInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_methodCallInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_methodCallInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_methodCallInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_methodCallInstructionForGeneration GGS_methodCallInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionForGeneration & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_actualParameterListForGeneration & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_methodCallInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_methodCallInstructionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_methodCallInstructionForGeneration::
reader_mReceiverExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_methodCallInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_methodCallInstructionForGeneration *) mPointer)->mReceiverExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_methodCallInstructionForGeneration::
reader_mMethodName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_methodCallInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_methodCallInstructionForGeneration *) mPointer)->mMethodName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameterListForGeneration  GGS_methodCallInstructionForGeneration::
reader_mActualParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_actualParameterListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_methodCallInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_methodCallInstructionForGeneration *) mPointer)->mActualParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_methodCallInstructionForGeneration::actualTypeName (void) const {
  return "methodCallInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__methodCallInstructionForGeneration ("methodCallInstructionForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_methodCallInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_methodCallInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_methodCallInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_methodCallInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_methodCallInstructionForGeneration GGS_methodCallInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_methodCallInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_methodCallInstructionForGeneration * p = dynamic_cast <const GGS_methodCallInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_methodCallInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_methodCallInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_methodCallInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            class 'cPtr_modifierCallInstructionForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_modifierCallInstructionForGeneration::
cPtr_modifierCallInstructionForGeneration (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstringlist & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_actualParameterListForGeneration & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (argument_0 COMMA_THERE),
mReceiverName (argument_1),
mReceiverStructAttributes (argument_2),
mModifierName (argument_3),
mActualParameterList (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_modifierCallInstructionForGeneration * GGS_modifierCallInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_modifierCallInstructionForGeneration) ;
    return (cPtr_modifierCallInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_modifierCallInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_modifierCallInstructionForGeneration * ptr = dynamic_cast <const cPtr_modifierCallInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mReceiverName.operator_isEqual (ptr->mReceiverName).boolValue ()
         && mReceiverStructAttributes.operator_isEqual (ptr->mReceiverStructAttributes).boolValue ()
         && mModifierName.operator_isEqual (ptr->mModifierName).boolValue ()
         && mActualParameterList.operator_isEqual (ptr->mActualParameterList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_modifierCallInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@modifierCallInstructionForGeneration:"
           << mStartLocation.reader_description (inIndentation + 1)
           << mReceiverName.reader_description (inIndentation + 1)
           << mReceiverStructAttributes.reader_description (inIndentation + 1)
           << mModifierName.reader_description (inIndentation + 1)
           << mActualParameterList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_modifierCallInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_modifierCallInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_modifierCallInstructionForGeneration (& typeid (cPtr_modifierCallInstructionForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_modifierCallInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__modifierCallInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_modifierCallInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_modifierCallInstructionForGeneration (mStartLocation, mReceiverName, mReceiverStructAttributes, mModifierName, mActualParameterList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         GALGAS class 'GGS_modifierCallInstructionForGeneration'           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_modifierCallInstructionForGeneration ("modifierCallInstructionForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_modifierCallInstructionForGeneration::
GGS_modifierCallInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_modifierCallInstructionForGeneration::
GGS_modifierCallInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_modifierCallInstructionForGeneration GGS_modifierCallInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_modifierCallInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_modifierCallInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_modifierCallInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_modifierCallInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_modifierCallInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_modifierCallInstructionForGeneration GGS_modifierCallInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstringlist & argument_2,
                 const GGS_lstring & argument_3,
                 const GGS_actualParameterListForGeneration & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_modifierCallInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_modifierCallInstructionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_modifierCallInstructionForGeneration::
reader_mReceiverName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_modifierCallInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_modifierCallInstructionForGeneration *) mPointer)->mReceiverName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_modifierCallInstructionForGeneration::
reader_mReceiverStructAttributes (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_modifierCallInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_modifierCallInstructionForGeneration *) mPointer)->mReceiverStructAttributes ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_modifierCallInstructionForGeneration::
reader_mModifierName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_modifierCallInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_modifierCallInstructionForGeneration *) mPointer)->mModifierName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameterListForGeneration  GGS_modifierCallInstructionForGeneration::
reader_mActualParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_actualParameterListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_modifierCallInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_modifierCallInstructionForGeneration *) mPointer)->mActualParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_modifierCallInstructionForGeneration::actualTypeName (void) const {
  return "modifierCallInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__modifierCallInstructionForGeneration ("modifierCallInstructionForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_modifierCallInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_modifierCallInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_modifierCallInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_modifierCallInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_modifierCallInstructionForGeneration GGS_modifierCallInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_modifierCallInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_modifierCallInstructionForGeneration * p = dynamic_cast <const GGS_modifierCallInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_modifierCallInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_modifierCallInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_modifierCallInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_errorInstructionForGeneration'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_errorInstructionForGeneration::
cPtr_errorInstructionForGeneration (const GGS_location & argument_0,
                                const GGS_semanticExpressionForGeneration & argument_1,
                                const GGS_semanticExpressionForGeneration & argument_2,
                                const GGS_lstringlist & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (argument_0 COMMA_THERE),
mReceiverExpression (argument_1),
mErrorExpression (argument_2),
mBuiltVariableList (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_errorInstructionForGeneration * GGS_errorInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_errorInstructionForGeneration) ;
    return (cPtr_errorInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_errorInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_errorInstructionForGeneration * ptr = dynamic_cast <const cPtr_errorInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mReceiverExpression.operator_isEqual (ptr->mReceiverExpression).boolValue ()
         && mErrorExpression.operator_isEqual (ptr->mErrorExpression).boolValue ()
         && mBuiltVariableList.operator_isEqual (ptr->mBuiltVariableList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_errorInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@errorInstructionForGeneration:"
           << mStartLocation.reader_description (inIndentation + 1)
           << mReceiverExpression.reader_description (inIndentation + 1)
           << mErrorExpression.reader_description (inIndentation + 1)
           << mBuiltVariableList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_errorInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_errorInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_errorInstructionForGeneration (& typeid (cPtr_errorInstructionForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_errorInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__errorInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_errorInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_errorInstructionForGeneration (mStartLocation, mReceiverExpression, mErrorExpression, mBuiltVariableList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_errorInstructionForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_errorInstructionForGeneration ("errorInstructionForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_errorInstructionForGeneration::
GGS_errorInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_errorInstructionForGeneration::
GGS_errorInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_errorInstructionForGeneration GGS_errorInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_errorInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_errorInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_errorInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_errorInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_errorInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_errorInstructionForGeneration GGS_errorInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionForGeneration & argument_1,
                 const GGS_semanticExpressionForGeneration & argument_2,
                 const GGS_lstringlist & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_errorInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_errorInstructionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_errorInstructionForGeneration::
reader_mReceiverExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_errorInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_errorInstructionForGeneration *) mPointer)->mReceiverExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_errorInstructionForGeneration::
reader_mErrorExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_errorInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_errorInstructionForGeneration *) mPointer)->mErrorExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_errorInstructionForGeneration::
reader_mBuiltVariableList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_errorInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_errorInstructionForGeneration *) mPointer)->mBuiltVariableList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_errorInstructionForGeneration::actualTypeName (void) const {
  return "errorInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__errorInstructionForGeneration ("errorInstructionForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_errorInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_errorInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_errorInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_errorInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_errorInstructionForGeneration GGS_errorInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_errorInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_errorInstructionForGeneration * p = dynamic_cast <const GGS_errorInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_errorInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_errorInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_errorInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_warningInstructionForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_warningInstructionForGeneration::
cPtr_warningInstructionForGeneration (const GGS_location & argument_0,
                                const GGS_semanticExpressionForGeneration & argument_1,
                                const GGS_semanticExpressionForGeneration & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (argument_0 COMMA_THERE),
mReceiverExpression (argument_1),
mWarningExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_warningInstructionForGeneration * GGS_warningInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_warningInstructionForGeneration) ;
    return (cPtr_warningInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_warningInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_warningInstructionForGeneration * ptr = dynamic_cast <const cPtr_warningInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mReceiverExpression.operator_isEqual (ptr->mReceiverExpression).boolValue ()
         && mWarningExpression.operator_isEqual (ptr->mWarningExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_warningInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@warningInstructionForGeneration:"
           << mStartLocation.reader_description (inIndentation + 1)
           << mReceiverExpression.reader_description (inIndentation + 1)
           << mWarningExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_warningInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_warningInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_warningInstructionForGeneration (& typeid (cPtr_warningInstructionForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_warningInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__warningInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_warningInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_warningInstructionForGeneration (mStartLocation, mReceiverExpression, mWarningExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_warningInstructionForGeneration'             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_warningInstructionForGeneration ("warningInstructionForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_warningInstructionForGeneration::
GGS_warningInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_warningInstructionForGeneration::
GGS_warningInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_warningInstructionForGeneration GGS_warningInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_warningInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_warningInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_warningInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_warningInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_warningInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_warningInstructionForGeneration GGS_warningInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionForGeneration & argument_1,
                 const GGS_semanticExpressionForGeneration & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_warningInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_warningInstructionForGeneration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_warningInstructionForGeneration::
reader_mReceiverExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_warningInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_warningInstructionForGeneration *) mPointer)->mReceiverExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_warningInstructionForGeneration::
reader_mWarningExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_warningInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_warningInstructionForGeneration *) mPointer)->mWarningExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_warningInstructionForGeneration::actualTypeName (void) const {
  return "warningInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__warningInstructionForGeneration ("warningInstructionForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_warningInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_warningInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_warningInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_warningInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_warningInstructionForGeneration GGS_warningInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_warningInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_warningInstructionForGeneration * p = dynamic_cast <const GGS_warningInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_warningInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_warningInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_warningInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_routineCallInstructionForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_routineCallInstructionForGeneration::
cPtr_routineCallInstructionForGeneration (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_actualParameterListForGeneration & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (argument_0 COMMA_THERE),
mRoutineName (argument_1),
mActualParameterList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_routineCallInstructionForGeneration * GGS_routineCallInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_routineCallInstructionForGeneration) ;
    return (cPtr_routineCallInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_routineCallInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_routineCallInstructionForGeneration * ptr = dynamic_cast <const cPtr_routineCallInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mRoutineName.operator_isEqual (ptr->mRoutineName).boolValue ()
         && mActualParameterList.operator_isEqual (ptr->mActualParameterList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_routineCallInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@routineCallInstructionForGeneration:"
           << mStartLocation.reader_description (inIndentation + 1)
           << mRoutineName.reader_description (inIndentation + 1)
           << mActualParameterList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_routineCallInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_routineCallInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_routineCallInstructionForGeneration (& typeid (cPtr_routineCallInstructionForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_routineCallInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__routineCallInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_routineCallInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_routineCallInstructionForGeneration (mStartLocation, mRoutineName, mActualParameterList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_routineCallInstructionForGeneration'           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_routineCallInstructionForGeneration ("routineCallInstructionForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_routineCallInstructionForGeneration::
GGS_routineCallInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_routineCallInstructionForGeneration::
GGS_routineCallInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_routineCallInstructionForGeneration GGS_routineCallInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_routineCallInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_routineCallInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_routineCallInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_routineCallInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_routineCallInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_routineCallInstructionForGeneration GGS_routineCallInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_actualParameterListForGeneration & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_routineCallInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_routineCallInstructionForGeneration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_routineCallInstructionForGeneration::
reader_mRoutineName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_routineCallInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_routineCallInstructionForGeneration *) mPointer)->mRoutineName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameterListForGeneration  GGS_routineCallInstructionForGeneration::
reader_mActualParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_actualParameterListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_routineCallInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_routineCallInstructionForGeneration *) mPointer)->mActualParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_routineCallInstructionForGeneration::actualTypeName (void) const {
  return "routineCallInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__routineCallInstructionForGeneration ("routineCallInstructionForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_routineCallInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_routineCallInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_routineCallInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_routineCallInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_routineCallInstructionForGeneration GGS_routineCallInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_routineCallInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_routineCallInstructionForGeneration * p = dynamic_cast <const GGS_routineCallInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_routineCallInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_routineCallInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_routineCallInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_matchEntryForGeneration'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_matchEntryForGeneration::
cPtr_matchEntryForGeneration (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_matchEntryForGeneration * GGS_matchEntryForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_matchEntryForGeneration) ;
    return (cPtr_matchEntryForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_matchEntryForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@matchEntryForGeneration:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_matchEntryForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_matchEntryForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_matchEntryForGeneration (& typeid (cPtr_matchEntryForGeneration), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_matchEntryForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__matchEntryForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_matchEntryForGeneration'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_matchEntryForGeneration ("matchEntryForGeneration", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_matchEntryForGeneration::
GGS_matchEntryForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_matchEntryForGeneration::
GGS_matchEntryForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_matchEntryForGeneration GGS_matchEntryForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_matchEntryForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_matchEntryForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_matchEntryForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_matchEntryForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_matchEntryForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_matchEntryForGeneration::actualTypeName (void) const {
  return "matchEntryForGeneration" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_matchEntryForGeneration::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__matchEntryForGeneration ("matchEntryForGeneration", & kTypeDescriptor_GGS_matchEntryForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_matchEntryForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_matchEntryForGeneration * p = NULL ;
    macroMyNew (p, GGS_matchEntryForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_matchEntryForGeneration GGS_matchEntryForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_matchEntryForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_matchEntryForGeneration * p = dynamic_cast <const GGS_matchEntryForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_matchEntryForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_matchEntryForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_matchEntryForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@matchEntryListForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_matchEntryListForGeneration::
elementOf_GGS_matchEntryListForGeneration (const GGS_matchEntryForGeneration & argument_0
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mEntry (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_matchEntryListForGeneration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_matchEntryListForGeneration * ptr = dynamic_cast <const elementOf_GGS_matchEntryListForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mEntry.operator_isEqual (ptr->mEntry).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_matchEntryListForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEntry.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@matchEntryListForGeneration'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_matchEntryListForGeneration ("matchEntryListForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_matchEntryListForGeneration::
internalAppendValues (const GGS_matchEntryForGeneration & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_matchEntryListForGeneration::
internalPrependValues (const GGS_matchEntryForGeneration & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_matchEntryListForGeneration::
addAssign_operation (const GGS_matchEntryForGeneration & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_matchEntryListForGeneration GGS_matchEntryListForGeneration::
operator_concat (const GGS_matchEntryListForGeneration & inOperand) const {
  GGS_matchEntryListForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_matchEntryListForGeneration::
dotAssign_operation (const GGS_matchEntryListForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_matchEntryListForGeneration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_matchEntryForGeneration  p_0 = p->mEntry ;
          internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_matchEntryListForGeneration::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_matchEntryForGeneration & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_matchEntryListForGeneration::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mEntry
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_matchEntryListForGeneration  GGS_matchEntryListForGeneration::
constructor_emptyList (void) {
  GGS_matchEntryListForGeneration result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_matchEntryListForGeneration  GGS_matchEntryListForGeneration::
constructor_listWithValue (const GGS_matchEntryForGeneration & argument_0) {
  GGS_matchEntryListForGeneration result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_matchEntryListForGeneration::
internalSubListWithRange (GGS_matchEntryListForGeneration & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mEntry) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_matchEntryListForGeneration GGS_matchEntryListForGeneration::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_matchEntryListForGeneration result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_matchEntryListForGeneration GGS_matchEntryListForGeneration::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_matchEntryListForGeneration result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_matchEntryListForGeneration::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@matchEntryListForGeneration", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_matchEntryListForGeneration::
method_first (C_Compiler & inLexique,
              GGS_matchEntryForGeneration & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mEntry ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_matchEntryListForGeneration::
method_last (C_Compiler & inLexique,
             GGS_matchEntryForGeneration & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mEntry ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_matchEntryListForGeneration::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_matchEntryForGeneration & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mEntry ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_matchEntryListForGeneration::
modifier_popLast (C_Compiler & inLexique,
                GGS_matchEntryForGeneration & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mEntry ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_matchEntryForGeneration  GGS_matchEntryListForGeneration::
reader_mEntryAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_matchEntryForGeneration  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mEntry ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_matchEntryListForGeneration::
modifier_setMEntryAtIndex (C_Compiler & inLexique,
                              const GGS_matchEntryForGeneration  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mEntry = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_matchEntryForGeneration  & GGS_matchEntryListForGeneration::cEnumerator::_mEntry (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mEntry ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_matchEntryListForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_matchEntryListForGeneration * p = NULL ;
    macroMyNew (p, GGS_matchEntryListForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_matchEntryListForGeneration GGS_matchEntryListForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_matchEntryListForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_matchEntryListForGeneration * p = dynamic_cast <const GGS_matchEntryListForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_matchEntryListForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_matchEntryListForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_matchEntryListForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_constantMatchEntryForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_constantMatchEntryForGeneration::
cPtr_constantMatchEntryForGeneration (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_matchEntryForGeneration (THERE),
mConstantName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_constantMatchEntryForGeneration * GGS_constantMatchEntryForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_constantMatchEntryForGeneration) ;
    return (cPtr_constantMatchEntryForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_constantMatchEntryForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_constantMatchEntryForGeneration * ptr = dynamic_cast <const cPtr_constantMatchEntryForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mConstantName.operator_isEqual (ptr->mConstantName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_constantMatchEntryForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@constantMatchEntryForGeneration:"
           << mConstantName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_constantMatchEntryForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_constantMatchEntryForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_constantMatchEntryForGeneration (& typeid (cPtr_constantMatchEntryForGeneration), & typeid (cPtr_matchEntryForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_constantMatchEntryForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__constantMatchEntryForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_constantMatchEntryForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_constantMatchEntryForGeneration (mConstantName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_constantMatchEntryForGeneration'             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_constantMatchEntryForGeneration ("constantMatchEntryForGeneration", true, & kTypeDescriptor_GGS_matchEntryForGeneration) ;

//---------------------------------------------------------------------------*

GGS_constantMatchEntryForGeneration::
GGS_constantMatchEntryForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_constantMatchEntryForGeneration::
GGS_constantMatchEntryForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_constantMatchEntryForGeneration GGS_constantMatchEntryForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_constantMatchEntryForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_constantMatchEntryForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_constantMatchEntryForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_constantMatchEntryForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_constantMatchEntryForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_constantMatchEntryForGeneration GGS_constantMatchEntryForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_constantMatchEntryForGeneration result ;
  macroMyNew (result.mPointer, cPtr_constantMatchEntryForGeneration (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_constantMatchEntryForGeneration::
reader_mConstantName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_constantMatchEntryForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_constantMatchEntryForGeneration *) mPointer)->mConstantName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_constantMatchEntryForGeneration::actualTypeName (void) const {
  return "constantMatchEntryForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__constantMatchEntryForGeneration ("constantMatchEntryForGeneration", gClassInfoFor__matchEntryForGeneration, & kTypeDescriptor_GGS_constantMatchEntryForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_constantMatchEntryForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_constantMatchEntryForGeneration * p = NULL ;
    macroMyNew (p, GGS_constantMatchEntryForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_constantMatchEntryForGeneration GGS_constantMatchEntryForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_constantMatchEntryForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_constantMatchEntryForGeneration * p = dynamic_cast <const GGS_constantMatchEntryForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_constantMatchEntryForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_constantMatchEntryForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_constantMatchEntryForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_classMatchEntryForGeneration'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_classMatchEntryForGeneration::
cPtr_classMatchEntryForGeneration (const GGS_lstring & argument_0,
                                const GGS_foreachInstructionEnumeratedObjectElementListForGeneration & argument_1,
                                const GGS_bool& argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_matchEntryForGeneration (THERE),
mClassName (argument_0),
mElements (argument_1),
mEndsWithEllipsis (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_classMatchEntryForGeneration * GGS_classMatchEntryForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_classMatchEntryForGeneration) ;
    return (cPtr_classMatchEntryForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_classMatchEntryForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_classMatchEntryForGeneration * ptr = dynamic_cast <const cPtr_classMatchEntryForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mClassName.operator_isEqual (ptr->mClassName).boolValue ()
         && mElements.operator_isEqual (ptr->mElements).boolValue ()
         && mEndsWithEllipsis.operator_isEqual (ptr->mEndsWithEllipsis).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_classMatchEntryForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@classMatchEntryForGeneration:"
           << mClassName.reader_description (inIndentation + 1)
           << mElements.reader_description (inIndentation + 1)
           << mEndsWithEllipsis.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_classMatchEntryForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_classMatchEntryForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_classMatchEntryForGeneration (& typeid (cPtr_classMatchEntryForGeneration), & typeid (cPtr_matchEntryForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_classMatchEntryForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__classMatchEntryForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_classMatchEntryForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_classMatchEntryForGeneration (mClassName, mElements, mEndsWithEllipsis COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_classMatchEntryForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_classMatchEntryForGeneration ("classMatchEntryForGeneration", true, & kTypeDescriptor_GGS_matchEntryForGeneration) ;

//---------------------------------------------------------------------------*

GGS_classMatchEntryForGeneration::
GGS_classMatchEntryForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_classMatchEntryForGeneration::
GGS_classMatchEntryForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_classMatchEntryForGeneration GGS_classMatchEntryForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_classMatchEntryForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_classMatchEntryForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_classMatchEntryForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_classMatchEntryForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_classMatchEntryForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_classMatchEntryForGeneration GGS_classMatchEntryForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_foreachInstructionEnumeratedObjectElementListForGeneration & argument_1,
                 const GGS_bool& argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_classMatchEntryForGeneration result ;
  macroMyNew (result.mPointer, cPtr_classMatchEntryForGeneration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_classMatchEntryForGeneration::
reader_mClassName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classMatchEntryForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classMatchEntryForGeneration *) mPointer)->mClassName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectElementListForGeneration  GGS_classMatchEntryForGeneration::
reader_mElements (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_foreachInstructionEnumeratedObjectElementListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classMatchEntryForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classMatchEntryForGeneration *) mPointer)->mElements ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_classMatchEntryForGeneration::
reader_mEndsWithEllipsis (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classMatchEntryForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classMatchEntryForGeneration *) mPointer)->mEndsWithEllipsis ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_classMatchEntryForGeneration::actualTypeName (void) const {
  return "classMatchEntryForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__classMatchEntryForGeneration ("classMatchEntryForGeneration", gClassInfoFor__matchEntryForGeneration, & kTypeDescriptor_GGS_classMatchEntryForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_classMatchEntryForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_classMatchEntryForGeneration * p = NULL ;
    macroMyNew (p, GGS_classMatchEntryForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_classMatchEntryForGeneration GGS_classMatchEntryForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_classMatchEntryForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_classMatchEntryForGeneration * p = dynamic_cast <const GGS_classMatchEntryForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_classMatchEntryForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_classMatchEntryForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_classMatchEntryForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        Element of list '@matchInstructionBranchListForGeneration'         *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_matchInstructionBranchListForGeneration::
elementOf_GGS_matchInstructionBranchListForGeneration (const GGS_matchEntryListForGeneration & argument_0,
                                const GGS_semanticInstructionListForGeneration & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mMatchEntryList (argument_0),
mMatchBranchInstructionList (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_matchInstructionBranchListForGeneration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_matchInstructionBranchListForGeneration * ptr = dynamic_cast <const elementOf_GGS_matchInstructionBranchListForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mMatchEntryList.operator_isEqual (ptr->mMatchEntryList).boolValue ()
         && mMatchBranchInstructionList.operator_isEqual (ptr->mMatchBranchInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_matchInstructionBranchListForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMatchEntryList.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMatchBranchInstructionList.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             List '@matchInstructionBranchListForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_matchInstructionBranchListForGeneration ("matchInstructionBranchListForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchListForGeneration::
internalAppendValues (const GGS_matchEntryListForGeneration & argument_0,
                    const GGS_semanticInstructionListForGeneration & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchListForGeneration::
internalPrependValues (const GGS_matchEntryListForGeneration & argument_0,
                    const GGS_semanticInstructionListForGeneration & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchListForGeneration::
addAssign_operation (const GGS_matchEntryListForGeneration & argument_0,
                                const GGS_semanticInstructionListForGeneration & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_matchInstructionBranchListForGeneration GGS_matchInstructionBranchListForGeneration::
operator_concat (const GGS_matchInstructionBranchListForGeneration & inOperand) const {
  GGS_matchInstructionBranchListForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchListForGeneration::
dotAssign_operation (const GGS_matchInstructionBranchListForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_matchInstructionBranchListForGeneration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_matchEntryListForGeneration  p_0 = p->mMatchEntryList ;
          GGS_semanticInstructionListForGeneration  p_1 = p->mMatchBranchInstructionList ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchListForGeneration::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_matchEntryListForGeneration & argument_0,
                     const GGS_semanticInstructionListForGeneration & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchListForGeneration::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mMatchEntryList,
                                ptr->mMatchBranchInstructionList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_matchInstructionBranchListForGeneration  GGS_matchInstructionBranchListForGeneration::
constructor_emptyList (void) {
  GGS_matchInstructionBranchListForGeneration result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_matchInstructionBranchListForGeneration  GGS_matchInstructionBranchListForGeneration::
constructor_listWithValue (const GGS_matchEntryListForGeneration & argument_0,
                                const GGS_semanticInstructionListForGeneration & argument_1) {
  GGS_matchInstructionBranchListForGeneration result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchListForGeneration::
internalSubListWithRange (GGS_matchInstructionBranchListForGeneration & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mMatchEntryList, ptr->mMatchBranchInstructionList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_matchInstructionBranchListForGeneration GGS_matchInstructionBranchListForGeneration::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_matchInstructionBranchListForGeneration result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_matchInstructionBranchListForGeneration GGS_matchInstructionBranchListForGeneration::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_matchInstructionBranchListForGeneration result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_matchInstructionBranchListForGeneration::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@matchInstructionBranchListForGeneration", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchListForGeneration::
method_first (C_Compiler & inLexique,
              GGS_matchEntryListForGeneration & _out_0,
              GGS_semanticInstructionListForGeneration & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMatchEntryList ;
    _out_1 = ptr->mMatchBranchInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchListForGeneration::
method_last (C_Compiler & inLexique,
             GGS_matchEntryListForGeneration & _out_0,
             GGS_semanticInstructionListForGeneration & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMatchEntryList ;
    _out_1 = ptr->mMatchBranchInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchListForGeneration::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_matchEntryListForGeneration & _out_0,
                 GGS_semanticInstructionListForGeneration & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMatchEntryList ;
    _out_1 = ptr->mMatchBranchInstructionList ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchListForGeneration::
modifier_popLast (C_Compiler & inLexique,
                GGS_matchEntryListForGeneration & _out_0,
                GGS_semanticInstructionListForGeneration & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMatchEntryList ;
    _out_1 = ptr->mMatchBranchInstructionList ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_matchEntryListForGeneration  GGS_matchInstructionBranchListForGeneration::
reader_mMatchEntryListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_matchEntryListForGeneration  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mMatchEntryList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration  GGS_matchInstructionBranchListForGeneration::
reader_mMatchBranchInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticInstructionListForGeneration  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mMatchBranchInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchListForGeneration::
modifier_setMMatchEntryListAtIndex (C_Compiler & inLexique,
                              const GGS_matchEntryListForGeneration  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mMatchEntryList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchListForGeneration::
modifier_setMMatchBranchInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_semanticInstructionListForGeneration  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mMatchBranchInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_matchEntryListForGeneration  & GGS_matchInstructionBranchListForGeneration::cEnumerator::_mMatchEntryList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mMatchEntryList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticInstructionListForGeneration  & GGS_matchInstructionBranchListForGeneration::cEnumerator::_mMatchBranchInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mMatchBranchInstructionList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_matchInstructionBranchListForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_matchInstructionBranchListForGeneration * p = NULL ;
    macroMyNew (p, GGS_matchInstructionBranchListForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_matchInstructionBranchListForGeneration GGS_matchInstructionBranchListForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_matchInstructionBranchListForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_matchInstructionBranchListForGeneration * p = dynamic_cast <const GGS_matchInstructionBranchListForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_matchInstructionBranchListForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_matchInstructionBranchListForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_matchInstructionBranchListForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_matchInstructionForGeneration'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_matchInstructionForGeneration::
cPtr_matchInstructionForGeneration (const GGS_location & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_matchInstructionBranchListForGeneration & argument_2,
                                const GGS_semanticInstructionListForGeneration & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (argument_0 COMMA_THERE),
mMatchedVariableNameList (argument_1),
mMatchInstructionBranchList (argument_2),
mElseInstructionList (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_matchInstructionForGeneration * GGS_matchInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_matchInstructionForGeneration) ;
    return (cPtr_matchInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_matchInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_matchInstructionForGeneration * ptr = dynamic_cast <const cPtr_matchInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mMatchedVariableNameList.operator_isEqual (ptr->mMatchedVariableNameList).boolValue ()
         && mMatchInstructionBranchList.operator_isEqual (ptr->mMatchInstructionBranchList).boolValue ()
         && mElseInstructionList.operator_isEqual (ptr->mElseInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_matchInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@matchInstructionForGeneration:"
           << mStartLocation.reader_description (inIndentation + 1)
           << mMatchedVariableNameList.reader_description (inIndentation + 1)
           << mMatchInstructionBranchList.reader_description (inIndentation + 1)
           << mElseInstructionList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_matchInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_matchInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_matchInstructionForGeneration (& typeid (cPtr_matchInstructionForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_matchInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__matchInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_matchInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_matchInstructionForGeneration (mStartLocation, mMatchedVariableNameList, mMatchInstructionBranchList, mElseInstructionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_matchInstructionForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_matchInstructionForGeneration ("matchInstructionForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_matchInstructionForGeneration::
GGS_matchInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_matchInstructionForGeneration::
GGS_matchInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_matchInstructionForGeneration GGS_matchInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_matchInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_matchInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_matchInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_matchInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_matchInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_matchInstructionForGeneration GGS_matchInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstringlist & argument_1,
                 const GGS_matchInstructionBranchListForGeneration & argument_2,
                 const GGS_semanticInstructionListForGeneration & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_matchInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_matchInstructionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_matchInstructionForGeneration::
reader_mMatchedVariableNameList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_matchInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_matchInstructionForGeneration *) mPointer)->mMatchedVariableNameList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_matchInstructionBranchListForGeneration  GGS_matchInstructionForGeneration::
reader_mMatchInstructionBranchList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_matchInstructionBranchListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_matchInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_matchInstructionForGeneration *) mPointer)->mMatchInstructionBranchList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration  GGS_matchInstructionForGeneration::
reader_mElseInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_matchInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_matchInstructionForGeneration *) mPointer)->mElseInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_matchInstructionForGeneration::actualTypeName (void) const {
  return "matchInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__matchInstructionForGeneration ("matchInstructionForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_matchInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_matchInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_matchInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_matchInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_matchInstructionForGeneration GGS_matchInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_matchInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_matchInstructionForGeneration * p = dynamic_cast <const GGS_matchInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_matchInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_matchInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_matchInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        Element of list '@castInstructionBranchListForGeneration'          *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_castInstructionBranchListForGeneration::
elementOf_GGS_castInstructionBranchListForGeneration (const GGS_bool& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_bool& argument_3,
                                const GGS_semanticInstructionListForGeneration & argument_4
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mUseKindOfClass (argument_0),
mTypeName (argument_1),
mConstantVarName (argument_2),
mConstantVarNameIsUnused (argument_3),
mCastBranchInstructionList (argument_4) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_castInstructionBranchListForGeneration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_castInstructionBranchListForGeneration * ptr = dynamic_cast <const elementOf_GGS_castInstructionBranchListForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mUseKindOfClass.operator_isEqual (ptr->mUseKindOfClass).boolValue ()
         && mTypeName.operator_isEqual (ptr->mTypeName).boolValue ()
         && mConstantVarName.operator_isEqual (ptr->mConstantVarName).boolValue ()
         && mConstantVarNameIsUnused.operator_isEqual (ptr->mConstantVarNameIsUnused).boolValue ()
         && mCastBranchInstructionList.operator_isEqual (ptr->mCastBranchInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_castInstructionBranchListForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mUseKindOfClass.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTypeName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mConstantVarName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mConstantVarNameIsUnused.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mCastBranchInstructionList.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              List '@castInstructionBranchListForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_castInstructionBranchListForGeneration ("castInstructionBranchListForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListForGeneration::
internalAppendValues (const GGS_bool& argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_bool& argument_3,
                    const GGS_semanticInstructionListForGeneration & argument_4
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListForGeneration::
internalPrependValues (const GGS_bool& argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_bool& argument_3,
                    const GGS_semanticInstructionListForGeneration & argument_4
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListForGeneration::
addAssign_operation (const GGS_bool& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_bool& argument_3,
                                const GGS_semanticInstructionListForGeneration & argument_4) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()&& argument_3.isBuilt ()&& argument_4.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_castInstructionBranchListForGeneration GGS_castInstructionBranchListForGeneration::
operator_concat (const GGS_castInstructionBranchListForGeneration & inOperand) const {
  GGS_castInstructionBranchListForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListForGeneration::
dotAssign_operation (const GGS_castInstructionBranchListForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_castInstructionBranchListForGeneration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_bool p_0 = p->mUseKindOfClass ;
          GGS_lstring  p_1 = p->mTypeName ;
          GGS_lstring  p_2 = p->mConstantVarName ;
          GGS_bool p_3 = p->mConstantVarNameIsUnused ;
          GGS_semanticInstructionListForGeneration  p_4 = p->mCastBranchInstructionList ;
          internalAppendValues (p_0, p_1, p_2, p_3, p_4 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListForGeneration::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_bool& argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_lstring & argument_2,
                     const GGS_bool& argument_3,
                     const GGS_semanticInstructionListForGeneration & argument_4
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListForGeneration::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mUseKindOfClass,
                                ptr->mTypeName,
                                ptr->mConstantVarName,
                                ptr->mConstantVarNameIsUnused,
                                ptr->mCastBranchInstructionList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_castInstructionBranchListForGeneration  GGS_castInstructionBranchListForGeneration::
constructor_emptyList (void) {
  GGS_castInstructionBranchListForGeneration result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_castInstructionBranchListForGeneration  GGS_castInstructionBranchListForGeneration::
constructor_listWithValue (const GGS_bool& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_bool& argument_3,
                                const GGS_semanticInstructionListForGeneration & argument_4) {
  GGS_castInstructionBranchListForGeneration result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2, argument_3, argument_4) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListForGeneration::
internalSubListWithRange (GGS_castInstructionBranchListForGeneration & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mUseKindOfClass, ptr->mTypeName, ptr->mConstantVarName, ptr->mConstantVarNameIsUnused, ptr->mCastBranchInstructionList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_castInstructionBranchListForGeneration GGS_castInstructionBranchListForGeneration::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_castInstructionBranchListForGeneration result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_castInstructionBranchListForGeneration GGS_castInstructionBranchListForGeneration::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_castInstructionBranchListForGeneration result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_castInstructionBranchListForGeneration::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@castInstructionBranchListForGeneration", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListForGeneration::
method_first (C_Compiler & inLexique,
              GGS_bool& _out_0,
              GGS_lstring & _out_1,
              GGS_lstring & _out_2,
              GGS_bool& _out_3,
              GGS_semanticInstructionListForGeneration & _out_4
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mUseKindOfClass ;
    _out_1 = ptr->mTypeName ;
    _out_2 = ptr->mConstantVarName ;
    _out_3 = ptr->mConstantVarNameIsUnused ;
    _out_4 = ptr->mCastBranchInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListForGeneration::
method_last (C_Compiler & inLexique,
             GGS_bool& _out_0,
             GGS_lstring & _out_1,
             GGS_lstring & _out_2,
             GGS_bool& _out_3,
             GGS_semanticInstructionListForGeneration & _out_4
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mUseKindOfClass ;
    _out_1 = ptr->mTypeName ;
    _out_2 = ptr->mConstantVarName ;
    _out_3 = ptr->mConstantVarNameIsUnused ;
    _out_4 = ptr->mCastBranchInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListForGeneration::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_bool& _out_0,
                 GGS_lstring & _out_1,
                 GGS_lstring & _out_2,
                 GGS_bool& _out_3,
                 GGS_semanticInstructionListForGeneration & _out_4
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mUseKindOfClass ;
    _out_1 = ptr->mTypeName ;
    _out_2 = ptr->mConstantVarName ;
    _out_3 = ptr->mConstantVarNameIsUnused ;
    _out_4 = ptr->mCastBranchInstructionList ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListForGeneration::
modifier_popLast (C_Compiler & inLexique,
                GGS_bool& _out_0,
                GGS_lstring & _out_1,
                GGS_lstring & _out_2,
                GGS_bool& _out_3,
                GGS_semanticInstructionListForGeneration & _out_4
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mUseKindOfClass ;
    _out_1 = ptr->mTypeName ;
    _out_2 = ptr->mConstantVarName ;
    _out_3 = ptr->mConstantVarNameIsUnused ;
    _out_4 = ptr->mCastBranchInstructionList ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_bool GGS_castInstructionBranchListForGeneration::
reader_mUseKindOfClassAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mUseKindOfClass ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_castInstructionBranchListForGeneration::
reader_mTypeNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mTypeName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_castInstructionBranchListForGeneration::
reader_mConstantVarNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mConstantVarName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_castInstructionBranchListForGeneration::
reader_mConstantVarNameIsUnusedAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mConstantVarNameIsUnused ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration  GGS_castInstructionBranchListForGeneration::
reader_mCastBranchInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticInstructionListForGeneration  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mCastBranchInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListForGeneration::
modifier_setMUseKindOfClassAtIndex (C_Compiler & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mUseKindOfClass = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListForGeneration::
modifier_setMTypeNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mTypeName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListForGeneration::
modifier_setMConstantVarNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mConstantVarName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListForGeneration::
modifier_setMConstantVarNameIsUnusedAtIndex (C_Compiler & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mConstantVarNameIsUnused = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListForGeneration::
modifier_setMCastBranchInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_semanticInstructionListForGeneration  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mCastBranchInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_castInstructionBranchListForGeneration::cEnumerator::_mUseKindOfClass (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mUseKindOfClass ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_castInstructionBranchListForGeneration::cEnumerator::_mTypeName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mTypeName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_castInstructionBranchListForGeneration::cEnumerator::_mConstantVarName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mConstantVarName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_castInstructionBranchListForGeneration::cEnumerator::_mConstantVarNameIsUnused (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mConstantVarNameIsUnused ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticInstructionListForGeneration  & GGS_castInstructionBranchListForGeneration::cEnumerator::_mCastBranchInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mCastBranchInstructionList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_castInstructionBranchListForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_castInstructionBranchListForGeneration * p = NULL ;
    macroMyNew (p, GGS_castInstructionBranchListForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_castInstructionBranchListForGeneration GGS_castInstructionBranchListForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_castInstructionBranchListForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_castInstructionBranchListForGeneration * p = dynamic_cast <const GGS_castInstructionBranchListForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_castInstructionBranchListForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_castInstructionBranchListForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_castInstructionBranchListForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        class 'cPtr_elseOrDefaultForCastInstructionForGeneration'          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_elseOrDefaultForCastInstructionForGeneration::
cPtr_elseOrDefaultForCastInstructionForGeneration (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_elseOrDefaultForCastInstructionForGeneration * GGS_elseOrDefaultForCastInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_elseOrDefaultForCastInstructionForGeneration) ;
    return (cPtr_elseOrDefaultForCastInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_elseOrDefaultForCastInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@elseOrDefaultForCastInstructionForGeneration:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_elseOrDefaultForCastInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_elseOrDefaultForCastInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_elseOrDefaultForCastInstructionForGeneration (& typeid (cPtr_elseOrDefaultForCastInstructionForGeneration), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_elseOrDefaultForCastInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__elseOrDefaultForCastInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//     GALGAS class 'GGS_elseOrDefaultForCastInstructionForGeneration'       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_elseOrDefaultForCastInstructionForGeneration ("elseOrDefaultForCastInstructionForGeneration", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_elseOrDefaultForCastInstructionForGeneration::
GGS_elseOrDefaultForCastInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_elseOrDefaultForCastInstructionForGeneration::
GGS_elseOrDefaultForCastInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_elseOrDefaultForCastInstructionForGeneration GGS_elseOrDefaultForCastInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_elseOrDefaultForCastInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_elseOrDefaultForCastInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_elseOrDefaultForCastInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_elseOrDefaultForCastInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_elseOrDefaultForCastInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_elseOrDefaultForCastInstructionForGeneration::actualTypeName (void) const {
  return "elseOrDefaultForCastInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_elseOrDefaultForCastInstructionForGeneration::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__elseOrDefaultForCastInstructionForGeneration ("elseOrDefaultForCastInstructionForGeneration", & kTypeDescriptor_GGS_elseOrDefaultForCastInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_elseOrDefaultForCastInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_elseOrDefaultForCastInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_elseOrDefaultForCastInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_elseOrDefaultForCastInstructionForGeneration GGS_elseOrDefaultForCastInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_elseOrDefaultForCastInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_elseOrDefaultForCastInstructionForGeneration * p = dynamic_cast <const GGS_elseOrDefaultForCastInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_elseOrDefaultForCastInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_elseOrDefaultForCastInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_elseOrDefaultForCastInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_elseForCastInstructionForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_elseForCastInstructionForGeneration::
cPtr_elseForCastInstructionForGeneration (const GGS_semanticInstructionListForGeneration & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_elseOrDefaultForCastInstructionForGeneration (THERE),
mElseInstructionList (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_elseForCastInstructionForGeneration * GGS_elseForCastInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_elseForCastInstructionForGeneration) ;
    return (cPtr_elseForCastInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_elseForCastInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_elseForCastInstructionForGeneration * ptr = dynamic_cast <const cPtr_elseForCastInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mElseInstructionList.operator_isEqual (ptr->mElseInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_elseForCastInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@elseForCastInstructionForGeneration:"
           << mElseInstructionList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_elseForCastInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_elseForCastInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_elseForCastInstructionForGeneration (& typeid (cPtr_elseForCastInstructionForGeneration), & typeid (cPtr_elseOrDefaultForCastInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_elseForCastInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__elseForCastInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_elseForCastInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_elseForCastInstructionForGeneration (mElseInstructionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_elseForCastInstructionForGeneration'           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_elseForCastInstructionForGeneration ("elseForCastInstructionForGeneration", true, & kTypeDescriptor_GGS_elseOrDefaultForCastInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_elseForCastInstructionForGeneration::
GGS_elseForCastInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_elseForCastInstructionForGeneration::
GGS_elseForCastInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_elseForCastInstructionForGeneration GGS_elseForCastInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_elseForCastInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_elseForCastInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_elseForCastInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_elseForCastInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_elseForCastInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_elseForCastInstructionForGeneration GGS_elseForCastInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_semanticInstructionListForGeneration & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_elseForCastInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_elseForCastInstructionForGeneration (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration  GGS_elseForCastInstructionForGeneration::
reader_mElseInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_elseForCastInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_elseForCastInstructionForGeneration *) mPointer)->mElseInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_elseForCastInstructionForGeneration::actualTypeName (void) const {
  return "elseForCastInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__elseForCastInstructionForGeneration ("elseForCastInstructionForGeneration", gClassInfoFor__elseOrDefaultForCastInstructionForGeneration, & kTypeDescriptor_GGS_elseForCastInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_elseForCastInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_elseForCastInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_elseForCastInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_elseForCastInstructionForGeneration GGS_elseForCastInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_elseForCastInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_elseForCastInstructionForGeneration * p = dynamic_cast <const GGS_elseForCastInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_elseForCastInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_elseForCastInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_elseForCastInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           class 'cPtr_defaultForCastInstructionForGeneration'             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_defaultForCastInstructionForGeneration::
cPtr_defaultForCastInstructionForGeneration (const GGS_semanticExpressionForGeneration & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_elseOrDefaultForCastInstructionForGeneration (THERE),
mErrorLocationExpression (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_defaultForCastInstructionForGeneration * GGS_defaultForCastInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_defaultForCastInstructionForGeneration) ;
    return (cPtr_defaultForCastInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_defaultForCastInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_defaultForCastInstructionForGeneration * ptr = dynamic_cast <const cPtr_defaultForCastInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mErrorLocationExpression.operator_isEqual (ptr->mErrorLocationExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_defaultForCastInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@defaultForCastInstructionForGeneration:"
           << mErrorLocationExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_defaultForCastInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_defaultForCastInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_defaultForCastInstructionForGeneration (& typeid (cPtr_defaultForCastInstructionForGeneration), & typeid (cPtr_elseOrDefaultForCastInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_defaultForCastInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__defaultForCastInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_defaultForCastInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_defaultForCastInstructionForGeneration (mErrorLocationExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        GALGAS class 'GGS_defaultForCastInstructionForGeneration'          *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_defaultForCastInstructionForGeneration ("defaultForCastInstructionForGeneration", true, & kTypeDescriptor_GGS_elseOrDefaultForCastInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_defaultForCastInstructionForGeneration::
GGS_defaultForCastInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_defaultForCastInstructionForGeneration::
GGS_defaultForCastInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_defaultForCastInstructionForGeneration GGS_defaultForCastInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_defaultForCastInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_defaultForCastInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_defaultForCastInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_defaultForCastInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_defaultForCastInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_defaultForCastInstructionForGeneration GGS_defaultForCastInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_semanticExpressionForGeneration & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_defaultForCastInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_defaultForCastInstructionForGeneration (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_defaultForCastInstructionForGeneration::
reader_mErrorLocationExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_defaultForCastInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_defaultForCastInstructionForGeneration *) mPointer)->mErrorLocationExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_defaultForCastInstructionForGeneration::actualTypeName (void) const {
  return "defaultForCastInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__defaultForCastInstructionForGeneration ("defaultForCastInstructionForGeneration", gClassInfoFor__elseOrDefaultForCastInstructionForGeneration, & kTypeDescriptor_GGS_defaultForCastInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_defaultForCastInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_defaultForCastInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_defaultForCastInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_defaultForCastInstructionForGeneration GGS_defaultForCastInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_defaultForCastInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_defaultForCastInstructionForGeneration * p = dynamic_cast <const GGS_defaultForCastInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_defaultForCastInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_defaultForCastInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_defaultForCastInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_castInstructionForGeneration'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_castInstructionForGeneration::
cPtr_castInstructionForGeneration (const GGS_location & argument_0,
                                const GGS_semanticExpressionForGeneration & argument_1,
                                const GGS_castInstructionBranchListForGeneration & argument_2,
                                const GGS_elseOrDefaultForCastInstructionForGeneration & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (argument_0 COMMA_THERE),
mExpression (argument_1),
mCastInstructionBranchList (argument_2),
mElseOrDefault (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_castInstructionForGeneration * GGS_castInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_castInstructionForGeneration) ;
    return (cPtr_castInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_castInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_castInstructionForGeneration * ptr = dynamic_cast <const cPtr_castInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mExpression.operator_isEqual (ptr->mExpression).boolValue ()
         && mCastInstructionBranchList.operator_isEqual (ptr->mCastInstructionBranchList).boolValue ()
         && mElseOrDefault.operator_isEqual (ptr->mElseOrDefault).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_castInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@castInstructionForGeneration:"
           << mStartLocation.reader_description (inIndentation + 1)
           << mExpression.reader_description (inIndentation + 1)
           << mCastInstructionBranchList.reader_description (inIndentation + 1)
           << mElseOrDefault.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_castInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_castInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_castInstructionForGeneration (& typeid (cPtr_castInstructionForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_castInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__castInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_castInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_castInstructionForGeneration (mStartLocation, mExpression, mCastInstructionBranchList, mElseOrDefault COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_castInstructionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_castInstructionForGeneration ("castInstructionForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_castInstructionForGeneration::
GGS_castInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_castInstructionForGeneration::
GGS_castInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_castInstructionForGeneration GGS_castInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_castInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_castInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_castInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_castInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_castInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_castInstructionForGeneration GGS_castInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionForGeneration & argument_1,
                 const GGS_castInstructionBranchListForGeneration & argument_2,
                 const GGS_elseOrDefaultForCastInstructionForGeneration & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_castInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_castInstructionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_castInstructionForGeneration::
reader_mExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_castInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_castInstructionForGeneration *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_castInstructionBranchListForGeneration  GGS_castInstructionForGeneration::
reader_mCastInstructionBranchList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_castInstructionBranchListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_castInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_castInstructionForGeneration *) mPointer)->mCastInstructionBranchList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_elseOrDefaultForCastInstructionForGeneration  GGS_castInstructionForGeneration::
reader_mElseOrDefault (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_elseOrDefaultForCastInstructionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_castInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_castInstructionForGeneration *) mPointer)->mElseOrDefault ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_castInstructionForGeneration::actualTypeName (void) const {
  return "castInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__castInstructionForGeneration ("castInstructionForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_castInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_castInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_castInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_castInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_castInstructionForGeneration GGS_castInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_castInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_castInstructionForGeneration * p = dynamic_cast <const GGS_castInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_castInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_castInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_castInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_addInstructionForGeneration'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_addInstructionForGeneration::
cPtr_addInstructionForGeneration (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstringlist & argument_2,
                                const GGS_outSemanticExpressionListForGeneration & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (argument_0 COMMA_THERE),
mReceiverName (argument_1),
mStructAttributeList (argument_2),
mExpressionList (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_addInstructionForGeneration * GGS_addInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_addInstructionForGeneration) ;
    return (cPtr_addInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_addInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_addInstructionForGeneration * ptr = dynamic_cast <const cPtr_addInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mReceiverName.operator_isEqual (ptr->mReceiverName).boolValue ()
         && mStructAttributeList.operator_isEqual (ptr->mStructAttributeList).boolValue ()
         && mExpressionList.operator_isEqual (ptr->mExpressionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_addInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@addInstructionForGeneration:"
           << mStartLocation.reader_description (inIndentation + 1)
           << mReceiverName.reader_description (inIndentation + 1)
           << mStructAttributeList.reader_description (inIndentation + 1)
           << mExpressionList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_addInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_addInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_addInstructionForGeneration (& typeid (cPtr_addInstructionForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_addInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__addInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_addInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_addInstructionForGeneration (mStartLocation, mReceiverName, mStructAttributeList, mExpressionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_addInstructionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_addInstructionForGeneration ("addInstructionForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_addInstructionForGeneration::
GGS_addInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_addInstructionForGeneration::
GGS_addInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_addInstructionForGeneration GGS_addInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_addInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_addInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_addInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_addInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_addInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_addInstructionForGeneration GGS_addInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstringlist & argument_2,
                 const GGS_outSemanticExpressionListForGeneration & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_addInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_addInstructionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_addInstructionForGeneration::
reader_mReceiverName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_addInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_addInstructionForGeneration *) mPointer)->mReceiverName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_addInstructionForGeneration::
reader_mStructAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_addInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_addInstructionForGeneration *) mPointer)->mStructAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_outSemanticExpressionListForGeneration  GGS_addInstructionForGeneration::
reader_mExpressionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_outSemanticExpressionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_addInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_addInstructionForGeneration *) mPointer)->mExpressionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_addInstructionForGeneration::actualTypeName (void) const {
  return "addInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__addInstructionForGeneration ("addInstructionForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_addInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_addInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_addInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_addInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_addInstructionForGeneration GGS_addInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_addInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_addInstructionForGeneration * p = dynamic_cast <const GGS_addInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_addInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_addInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_addInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_removeInstructionForGeneration'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_removeInstructionForGeneration::
cPtr_removeInstructionForGeneration (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstringlist & argument_2,
                                const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (argument_0 COMMA_THERE),
mReceiverName (argument_1),
mStructAttributeList (argument_2),
mExpression (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_removeInstructionForGeneration * GGS_removeInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_removeInstructionForGeneration) ;
    return (cPtr_removeInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_removeInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_removeInstructionForGeneration * ptr = dynamic_cast <const cPtr_removeInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mReceiverName.operator_isEqual (ptr->mReceiverName).boolValue ()
         && mStructAttributeList.operator_isEqual (ptr->mStructAttributeList).boolValue ()
         && mExpression.operator_isEqual (ptr->mExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_removeInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@removeInstructionForGeneration:"
           << mStartLocation.reader_description (inIndentation + 1)
           << mReceiverName.reader_description (inIndentation + 1)
           << mStructAttributeList.reader_description (inIndentation + 1)
           << mExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_removeInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_removeInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_removeInstructionForGeneration (& typeid (cPtr_removeInstructionForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_removeInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__removeInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_removeInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_removeInstructionForGeneration (mStartLocation, mReceiverName, mStructAttributeList, mExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_removeInstructionForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_removeInstructionForGeneration ("removeInstructionForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_removeInstructionForGeneration::
GGS_removeInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_removeInstructionForGeneration::
GGS_removeInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_removeInstructionForGeneration GGS_removeInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_removeInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_removeInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_removeInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_removeInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_removeInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_removeInstructionForGeneration GGS_removeInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstringlist & argument_2,
                 const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_removeInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_removeInstructionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_removeInstructionForGeneration::
reader_mReceiverName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_removeInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_removeInstructionForGeneration *) mPointer)->mReceiverName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_removeInstructionForGeneration::
reader_mStructAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_removeInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_removeInstructionForGeneration *) mPointer)->mStructAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_removeInstructionForGeneration::
reader_mExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_removeInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_removeInstructionForGeneration *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_removeInstructionForGeneration::actualTypeName (void) const {
  return "removeInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__removeInstructionForGeneration ("removeInstructionForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_removeInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_removeInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_removeInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_removeInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_removeInstructionForGeneration GGS_removeInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_removeInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_removeInstructionForGeneration * p = dynamic_cast <const GGS_removeInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_removeInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_removeInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_removeInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'cPtr_incrementInstructionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_incrementInstructionForGeneration::
cPtr_incrementInstructionForGeneration (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstringlist & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (argument_0 COMMA_THERE),
mReceiverName (argument_1),
mStructAttributeList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_incrementInstructionForGeneration * GGS_incrementInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_incrementInstructionForGeneration) ;
    return (cPtr_incrementInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_incrementInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_incrementInstructionForGeneration * ptr = dynamic_cast <const cPtr_incrementInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mReceiverName.operator_isEqual (ptr->mReceiverName).boolValue ()
         && mStructAttributeList.operator_isEqual (ptr->mStructAttributeList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_incrementInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@incrementInstructionForGeneration:"
           << mStartLocation.reader_description (inIndentation + 1)
           << mReceiverName.reader_description (inIndentation + 1)
           << mStructAttributeList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_incrementInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_incrementInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_incrementInstructionForGeneration (& typeid (cPtr_incrementInstructionForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_incrementInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__incrementInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_incrementInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_incrementInstructionForGeneration (mStartLocation, mReceiverName, mStructAttributeList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_incrementInstructionForGeneration'            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_incrementInstructionForGeneration ("incrementInstructionForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_incrementInstructionForGeneration::
GGS_incrementInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_incrementInstructionForGeneration::
GGS_incrementInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_incrementInstructionForGeneration GGS_incrementInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_incrementInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_incrementInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_incrementInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_incrementInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_incrementInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_incrementInstructionForGeneration GGS_incrementInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstringlist & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_incrementInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_incrementInstructionForGeneration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_incrementInstructionForGeneration::
reader_mReceiverName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_incrementInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_incrementInstructionForGeneration *) mPointer)->mReceiverName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_incrementInstructionForGeneration::
reader_mStructAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_incrementInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_incrementInstructionForGeneration *) mPointer)->mStructAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_incrementInstructionForGeneration::actualTypeName (void) const {
  return "incrementInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__incrementInstructionForGeneration ("incrementInstructionForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_incrementInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_incrementInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_incrementInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_incrementInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_incrementInstructionForGeneration GGS_incrementInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_incrementInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_incrementInstructionForGeneration * p = dynamic_cast <const GGS_incrementInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_incrementInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_incrementInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_incrementInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'cPtr_decrementInstructionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_decrementInstructionForGeneration::
cPtr_decrementInstructionForGeneration (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstringlist & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (argument_0 COMMA_THERE),
mReceiverName (argument_1),
mStructAttributeList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_decrementInstructionForGeneration * GGS_decrementInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_decrementInstructionForGeneration) ;
    return (cPtr_decrementInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_decrementInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_decrementInstructionForGeneration * ptr = dynamic_cast <const cPtr_decrementInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mReceiverName.operator_isEqual (ptr->mReceiverName).boolValue ()
         && mStructAttributeList.operator_isEqual (ptr->mStructAttributeList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_decrementInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@decrementInstructionForGeneration:"
           << mStartLocation.reader_description (inIndentation + 1)
           << mReceiverName.reader_description (inIndentation + 1)
           << mStructAttributeList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_decrementInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_decrementInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_decrementInstructionForGeneration (& typeid (cPtr_decrementInstructionForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_decrementInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__decrementInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_decrementInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_decrementInstructionForGeneration (mStartLocation, mReceiverName, mStructAttributeList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_decrementInstructionForGeneration'            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_decrementInstructionForGeneration ("decrementInstructionForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_decrementInstructionForGeneration::
GGS_decrementInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_decrementInstructionForGeneration::
GGS_decrementInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_decrementInstructionForGeneration GGS_decrementInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_decrementInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_decrementInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_decrementInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_decrementInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_decrementInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_decrementInstructionForGeneration GGS_decrementInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstringlist & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_decrementInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_decrementInstructionForGeneration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_decrementInstructionForGeneration::
reader_mReceiverName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_decrementInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_decrementInstructionForGeneration *) mPointer)->mReceiverName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_decrementInstructionForGeneration::
reader_mStructAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_decrementInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_decrementInstructionForGeneration *) mPointer)->mStructAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_decrementInstructionForGeneration::actualTypeName (void) const {
  return "decrementInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__decrementInstructionForGeneration ("decrementInstructionForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_decrementInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_decrementInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_decrementInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_decrementInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_decrementInstructionForGeneration GGS_decrementInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_decrementInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_decrementInstructionForGeneration * p = dynamic_cast <const GGS_decrementInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_decrementInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_decrementInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_decrementInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_loopInstructionForGeneration'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_loopInstructionForGeneration::
cPtr_loopInstructionForGeneration (const GGS_location & argument_0,
                                const GGS_semanticExpressionForGeneration & argument_1,
                                const GGS_semanticInstructionListForGeneration & argument_2,
                                const GGS_semanticExpressionForGeneration & argument_3,
                                const GGS_semanticInstructionListForGeneration & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (argument_0 COMMA_THERE),
mVariantExpression (argument_1),
mFirstInstructions (argument_2),
mLoopExpression (argument_3),
mSecondInstructions (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_loopInstructionForGeneration * GGS_loopInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_loopInstructionForGeneration) ;
    return (cPtr_loopInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_loopInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_loopInstructionForGeneration * ptr = dynamic_cast <const cPtr_loopInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mVariantExpression.operator_isEqual (ptr->mVariantExpression).boolValue ()
         && mFirstInstructions.operator_isEqual (ptr->mFirstInstructions).boolValue ()
         && mLoopExpression.operator_isEqual (ptr->mLoopExpression).boolValue ()
         && mSecondInstructions.operator_isEqual (ptr->mSecondInstructions).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_loopInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@loopInstructionForGeneration:"
           << mStartLocation.reader_description (inIndentation + 1)
           << mVariantExpression.reader_description (inIndentation + 1)
           << mFirstInstructions.reader_description (inIndentation + 1)
           << mLoopExpression.reader_description (inIndentation + 1)
           << mSecondInstructions.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_loopInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_loopInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_loopInstructionForGeneration (& typeid (cPtr_loopInstructionForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_loopInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__loopInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_loopInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_loopInstructionForGeneration (mStartLocation, mVariantExpression, mFirstInstructions, mLoopExpression, mSecondInstructions COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_loopInstructionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_loopInstructionForGeneration ("loopInstructionForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_loopInstructionForGeneration::
GGS_loopInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_loopInstructionForGeneration::
GGS_loopInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_loopInstructionForGeneration GGS_loopInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_loopInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_loopInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_loopInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_loopInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_loopInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_loopInstructionForGeneration GGS_loopInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionForGeneration & argument_1,
                 const GGS_semanticInstructionListForGeneration & argument_2,
                 const GGS_semanticExpressionForGeneration & argument_3,
                 const GGS_semanticInstructionListForGeneration & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_loopInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_loopInstructionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_loopInstructionForGeneration::
reader_mVariantExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_loopInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_loopInstructionForGeneration *) mPointer)->mVariantExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration  GGS_loopInstructionForGeneration::
reader_mFirstInstructions (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_loopInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_loopInstructionForGeneration *) mPointer)->mFirstInstructions ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_loopInstructionForGeneration::
reader_mLoopExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_loopInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_loopInstructionForGeneration *) mPointer)->mLoopExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration  GGS_loopInstructionForGeneration::
reader_mSecondInstructions (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_loopInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_loopInstructionForGeneration *) mPointer)->mSecondInstructions ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_loopInstructionForGeneration::actualTypeName (void) const {
  return "loopInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__loopInstructionForGeneration ("loopInstructionForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_loopInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_loopInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_loopInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_loopInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_loopInstructionForGeneration GGS_loopInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_loopInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_loopInstructionForGeneration * p = dynamic_cast <const GGS_loopInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_loopInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_loopInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_loopInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_messageInstructionForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_messageInstructionForGeneration::
cPtr_messageInstructionForGeneration (const GGS_location & argument_0,
                                const GGS_semanticExpressionForGeneration & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (argument_0 COMMA_THERE),
mExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_messageInstructionForGeneration * GGS_messageInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_messageInstructionForGeneration) ;
    return (cPtr_messageInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_messageInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_messageInstructionForGeneration * ptr = dynamic_cast <const cPtr_messageInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mExpression.operator_isEqual (ptr->mExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_messageInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@messageInstructionForGeneration:"
           << mStartLocation.reader_description (inIndentation + 1)
           << mExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_messageInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_messageInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_messageInstructionForGeneration (& typeid (cPtr_messageInstructionForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_messageInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__messageInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_messageInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_messageInstructionForGeneration (mStartLocation, mExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_messageInstructionForGeneration'             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_messageInstructionForGeneration ("messageInstructionForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_messageInstructionForGeneration::
GGS_messageInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_messageInstructionForGeneration::
GGS_messageInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_messageInstructionForGeneration GGS_messageInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_messageInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_messageInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_messageInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_messageInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_messageInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_messageInstructionForGeneration GGS_messageInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionForGeneration & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_messageInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_messageInstructionForGeneration (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_messageInstructionForGeneration::
reader_mExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_messageInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_messageInstructionForGeneration *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_messageInstructionForGeneration::actualTypeName (void) const {
  return "messageInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__messageInstructionForGeneration ("messageInstructionForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_messageInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_messageInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_messageInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_messageInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_messageInstructionForGeneration GGS_messageInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_messageInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_messageInstructionForGeneration * p = dynamic_cast <const GGS_messageInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_messageInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_messageInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_messageInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@logListForGeneration'                   *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_logListForGeneration::
elementOf_GGS_logListForGeneration (const GGS_lstring & argument_0,
                                const GGS_semanticExpressionForGeneration & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mLogMessage (argument_0),
mLogExpression (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_logListForGeneration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_logListForGeneration * ptr = dynamic_cast <const elementOf_GGS_logListForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLogMessage.operator_isEqual (ptr->mLogMessage).boolValue ()
         && mLogExpression.operator_isEqual (ptr->mLogExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_logListForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLogMessage.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLogExpression.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@logListForGeneration'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_logListForGeneration ("logListForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_logListForGeneration::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_semanticExpressionForGeneration & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_logListForGeneration::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_semanticExpressionForGeneration & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_logListForGeneration::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_semanticExpressionForGeneration & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_logListForGeneration GGS_logListForGeneration::
operator_concat (const GGS_logListForGeneration & inOperand) const {
  GGS_logListForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_logListForGeneration::
dotAssign_operation (const GGS_logListForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_logListForGeneration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mLogMessage ;
          GGS_semanticExpressionForGeneration  p_1 = p->mLogExpression ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_logListForGeneration::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_semanticExpressionForGeneration & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_logListForGeneration::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mLogMessage,
                                ptr->mLogExpression
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_logListForGeneration  GGS_logListForGeneration::
constructor_emptyList (void) {
  GGS_logListForGeneration result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_logListForGeneration  GGS_logListForGeneration::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_semanticExpressionForGeneration & argument_1) {
  GGS_logListForGeneration result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_logListForGeneration::
internalSubListWithRange (GGS_logListForGeneration & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mLogMessage, ptr->mLogExpression) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_logListForGeneration GGS_logListForGeneration::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_logListForGeneration result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_logListForGeneration GGS_logListForGeneration::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_logListForGeneration result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_logListForGeneration::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@logListForGeneration", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_logListForGeneration::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_semanticExpressionForGeneration & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mLogMessage ;
    _out_1 = ptr->mLogExpression ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_logListForGeneration::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_semanticExpressionForGeneration & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mLogMessage ;
    _out_1 = ptr->mLogExpression ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_logListForGeneration::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_semanticExpressionForGeneration & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mLogMessage ;
    _out_1 = ptr->mLogExpression ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_logListForGeneration::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_semanticExpressionForGeneration & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mLogMessage ;
    _out_1 = ptr->mLogExpression ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_logListForGeneration::
reader_mLogMessageAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mLogMessage ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_logListForGeneration::
reader_mLogExpressionAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mLogExpression ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_logListForGeneration::
modifier_setMLogMessageAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mLogMessage = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_logListForGeneration::
modifier_setMLogExpressionAtIndex (C_Compiler & inLexique,
                              const GGS_semanticExpressionForGeneration  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mLogExpression = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_logListForGeneration::cEnumerator::_mLogMessage (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mLogMessage ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticExpressionForGeneration  & GGS_logListForGeneration::cEnumerator::_mLogExpression (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mLogExpression ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_logListForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_logListForGeneration * p = NULL ;
    macroMyNew (p, GGS_logListForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_logListForGeneration GGS_logListForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_logListForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_logListForGeneration * p = dynamic_cast <const GGS_logListForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_logListForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_logListForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_logListForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_logInstructionForGeneration'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_logInstructionForGeneration::
cPtr_logInstructionForGeneration (const GGS_location & argument_0,
                                const GGS_logListForGeneration & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (argument_0 COMMA_THERE),
mLogList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_logInstructionForGeneration * GGS_logInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_logInstructionForGeneration) ;
    return (cPtr_logInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_logInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_logInstructionForGeneration * ptr = dynamic_cast <const cPtr_logInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mLogList.operator_isEqual (ptr->mLogList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_logInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@logInstructionForGeneration:"
           << mStartLocation.reader_description (inIndentation + 1)
           << mLogList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_logInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_logInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_logInstructionForGeneration (& typeid (cPtr_logInstructionForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_logInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__logInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_logInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_logInstructionForGeneration (mStartLocation, mLogList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_logInstructionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_logInstructionForGeneration ("logInstructionForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_logInstructionForGeneration::
GGS_logInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_logInstructionForGeneration::
GGS_logInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_logInstructionForGeneration GGS_logInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_logInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_logInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_logInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_logInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_logInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_logInstructionForGeneration GGS_logInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_logListForGeneration & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_logInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_logInstructionForGeneration (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_logListForGeneration  GGS_logInstructionForGeneration::
reader_mLogList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_logListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_logInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_logInstructionForGeneration *) mPointer)->mLogList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_logInstructionForGeneration::actualTypeName (void) const {
  return "logInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__logInstructionForGeneration ("logInstructionForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_logInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_logInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_logInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_logInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_logInstructionForGeneration GGS_logInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_logInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_logInstructionForGeneration * p = dynamic_cast <const GGS_logInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_logInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_logInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_logInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_grammarInstructionForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_grammarInstructionForGeneration::
cPtr_grammarInstructionForGeneration (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_semanticExpressionForGeneration & argument_3,
                                const GGS_bool& argument_4,
                                const GGS_actualParameterListForGeneration & argument_5
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (argument_0 COMMA_THERE),
mGrammarComponentName (argument_1),
mLabelName (argument_2),
mSourceExpression (argument_3),
mSourceExpressionIsFile (argument_4),
mActualParameterList (argument_5) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_grammarInstructionForGeneration * GGS_grammarInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_grammarInstructionForGeneration) ;
    return (cPtr_grammarInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_grammarInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_grammarInstructionForGeneration * ptr = dynamic_cast <const cPtr_grammarInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mGrammarComponentName.operator_isEqual (ptr->mGrammarComponentName).boolValue ()
         && mLabelName.operator_isEqual (ptr->mLabelName).boolValue ()
         && mSourceExpression.operator_isEqual (ptr->mSourceExpression).boolValue ()
         && mSourceExpressionIsFile.operator_isEqual (ptr->mSourceExpressionIsFile).boolValue ()
         && mActualParameterList.operator_isEqual (ptr->mActualParameterList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_grammarInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@grammarInstructionForGeneration:"
           << mStartLocation.reader_description (inIndentation + 1)
           << mGrammarComponentName.reader_description (inIndentation + 1)
           << mLabelName.reader_description (inIndentation + 1)
           << mSourceExpression.reader_description (inIndentation + 1)
           << mSourceExpressionIsFile.reader_description (inIndentation + 1)
           << mActualParameterList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_grammarInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_grammarInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_grammarInstructionForGeneration (& typeid (cPtr_grammarInstructionForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_grammarInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__grammarInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_grammarInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_grammarInstructionForGeneration (mStartLocation, mGrammarComponentName, mLabelName, mSourceExpression, mSourceExpressionIsFile, mActualParameterList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_grammarInstructionForGeneration'             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_grammarInstructionForGeneration ("grammarInstructionForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_grammarInstructionForGeneration::
GGS_grammarInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_grammarInstructionForGeneration::
GGS_grammarInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_grammarInstructionForGeneration GGS_grammarInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_grammarInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_grammarInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_grammarInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_grammarInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_grammarInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_grammarInstructionForGeneration GGS_grammarInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_semanticExpressionForGeneration & argument_3,
                 const GGS_bool& argument_4,
                 const GGS_actualParameterListForGeneration & argument_5
                                COMMA_LOCATION_ARGS) {
  GGS_grammarInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_grammarInstructionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_grammarInstructionForGeneration::
reader_mGrammarComponentName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_grammarInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_grammarInstructionForGeneration *) mPointer)->mGrammarComponentName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_grammarInstructionForGeneration::
reader_mLabelName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_grammarInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_grammarInstructionForGeneration *) mPointer)->mLabelName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_grammarInstructionForGeneration::
reader_mSourceExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_grammarInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_grammarInstructionForGeneration *) mPointer)->mSourceExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_grammarInstructionForGeneration::
reader_mSourceExpressionIsFile (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_grammarInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_grammarInstructionForGeneration *) mPointer)->mSourceExpressionIsFile ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameterListForGeneration  GGS_grammarInstructionForGeneration::
reader_mActualParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_actualParameterListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_grammarInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_grammarInstructionForGeneration *) mPointer)->mActualParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_grammarInstructionForGeneration::actualTypeName (void) const {
  return "grammarInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__grammarInstructionForGeneration ("grammarInstructionForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_grammarInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_grammarInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_grammarInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_grammarInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_grammarInstructionForGeneration GGS_grammarInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_grammarInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_grammarInstructionForGeneration * p = dynamic_cast <const GGS_grammarInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_grammarInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_grammarInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_grammarInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_withInstructionForGeneration'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_withInstructionForGeneration::
cPtr_withInstructionForGeneration (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstringlist & argument_3,
                                const GGS_lstring & argument_4,
                                const GGS_semanticExpressionForGeneration & argument_5,
                                const GGS_semanticInstructionListForGeneration & argument_6,
                                const GGS_semanticInstructionListForGeneration & argument_7
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (argument_0 COMMA_THERE),
mPrefix (argument_1),
mTargetObjectName (argument_2),
mStructAttributeList (argument_3),
mSearchMethodName (argument_4),
mKeyExpression (argument_5),
mDoBranchInstructions (argument_6),
mElseBranchInstructions (argument_7) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_withInstructionForGeneration * GGS_withInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_withInstructionForGeneration) ;
    return (cPtr_withInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_withInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_withInstructionForGeneration * ptr = dynamic_cast <const cPtr_withInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mPrefix.operator_isEqual (ptr->mPrefix).boolValue ()
         && mTargetObjectName.operator_isEqual (ptr->mTargetObjectName).boolValue ()
         && mStructAttributeList.operator_isEqual (ptr->mStructAttributeList).boolValue ()
         && mSearchMethodName.operator_isEqual (ptr->mSearchMethodName).boolValue ()
         && mKeyExpression.operator_isEqual (ptr->mKeyExpression).boolValue ()
         && mDoBranchInstructions.operator_isEqual (ptr->mDoBranchInstructions).boolValue ()
         && mElseBranchInstructions.operator_isEqual (ptr->mElseBranchInstructions).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_withInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@withInstructionForGeneration:"
           << mStartLocation.reader_description (inIndentation + 1)
           << mPrefix.reader_description (inIndentation + 1)
           << mTargetObjectName.reader_description (inIndentation + 1)
           << mStructAttributeList.reader_description (inIndentation + 1)
           << mSearchMethodName.reader_description (inIndentation + 1)
           << mKeyExpression.reader_description (inIndentation + 1)
           << mDoBranchInstructions.reader_description (inIndentation + 1)
           << mElseBranchInstructions.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_withInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_withInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_withInstructionForGeneration (& typeid (cPtr_withInstructionForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_withInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__withInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_withInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_withInstructionForGeneration (mStartLocation, mPrefix, mTargetObjectName, mStructAttributeList, mSearchMethodName, mKeyExpression, mDoBranchInstructions, mElseBranchInstructions COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_withInstructionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_withInstructionForGeneration ("withInstructionForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_withInstructionForGeneration::
GGS_withInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_withInstructionForGeneration::
GGS_withInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_withInstructionForGeneration GGS_withInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_withInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_withInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_withInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_withInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_withInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_withInstructionForGeneration GGS_withInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_lstringlist & argument_3,
                 const GGS_lstring & argument_4,
                 const GGS_semanticExpressionForGeneration & argument_5,
                 const GGS_semanticInstructionListForGeneration & argument_6,
                 const GGS_semanticInstructionListForGeneration & argument_7
                                COMMA_LOCATION_ARGS) {
  GGS_withInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_withInstructionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_withInstructionForGeneration::
reader_mPrefix (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_withInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_withInstructionForGeneration *) mPointer)->mPrefix ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_withInstructionForGeneration::
reader_mTargetObjectName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_withInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_withInstructionForGeneration *) mPointer)->mTargetObjectName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_withInstructionForGeneration::
reader_mStructAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_withInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_withInstructionForGeneration *) mPointer)->mStructAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_withInstructionForGeneration::
reader_mSearchMethodName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_withInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_withInstructionForGeneration *) mPointer)->mSearchMethodName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_withInstructionForGeneration::
reader_mKeyExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_withInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_withInstructionForGeneration *) mPointer)->mKeyExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration  GGS_withInstructionForGeneration::
reader_mDoBranchInstructions (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_withInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_withInstructionForGeneration *) mPointer)->mDoBranchInstructions ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration  GGS_withInstructionForGeneration::
reader_mElseBranchInstructions (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_withInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_withInstructionForGeneration *) mPointer)->mElseBranchInstructions ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_withInstructionForGeneration::actualTypeName (void) const {
  return "withInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__withInstructionForGeneration ("withInstructionForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_withInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_withInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_withInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_withInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_withInstructionForGeneration GGS_withInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_withInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_withInstructionForGeneration * p = dynamic_cast <const GGS_withInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_withInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_withInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_withInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@switchBranchesForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_switchBranchesForGeneration::
elementOf_GGS_switchBranchesForGeneration (const GGS_lstringlist & argument_0,
                                const GGS_semanticInstructionListForGeneration & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mSwitchConstantList (argument_0),
mInstructions (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_switchBranchesForGeneration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_switchBranchesForGeneration * ptr = dynamic_cast <const elementOf_GGS_switchBranchesForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mSwitchConstantList.operator_isEqual (ptr->mSwitchConstantList).boolValue ()
         && mInstructions.operator_isEqual (ptr->mInstructions).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_switchBranchesForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSwitchConstantList.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructions.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@switchBranchesForGeneration'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_switchBranchesForGeneration ("switchBranchesForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_switchBranchesForGeneration::
internalAppendValues (const GGS_lstringlist & argument_0,
                    const GGS_semanticInstructionListForGeneration & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_switchBranchesForGeneration::
internalPrependValues (const GGS_lstringlist & argument_0,
                    const GGS_semanticInstructionListForGeneration & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_switchBranchesForGeneration::
addAssign_operation (const GGS_lstringlist & argument_0,
                                const GGS_semanticInstructionListForGeneration & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_switchBranchesForGeneration GGS_switchBranchesForGeneration::
operator_concat (const GGS_switchBranchesForGeneration & inOperand) const {
  GGS_switchBranchesForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_switchBranchesForGeneration::
dotAssign_operation (const GGS_switchBranchesForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_switchBranchesForGeneration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstringlist  p_0 = p->mSwitchConstantList ;
          GGS_semanticInstructionListForGeneration  p_1 = p->mInstructions ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_switchBranchesForGeneration::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstringlist & argument_0,
                     const GGS_semanticInstructionListForGeneration & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_switchBranchesForGeneration::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mSwitchConstantList,
                                ptr->mInstructions
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_switchBranchesForGeneration  GGS_switchBranchesForGeneration::
constructor_emptyList (void) {
  GGS_switchBranchesForGeneration result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_switchBranchesForGeneration  GGS_switchBranchesForGeneration::
constructor_listWithValue (const GGS_lstringlist & argument_0,
                                const GGS_semanticInstructionListForGeneration & argument_1) {
  GGS_switchBranchesForGeneration result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_switchBranchesForGeneration::
internalSubListWithRange (GGS_switchBranchesForGeneration & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mSwitchConstantList, ptr->mInstructions) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_switchBranchesForGeneration GGS_switchBranchesForGeneration::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_switchBranchesForGeneration result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_switchBranchesForGeneration GGS_switchBranchesForGeneration::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_switchBranchesForGeneration result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_switchBranchesForGeneration::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@switchBranchesForGeneration", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_switchBranchesForGeneration::
method_first (C_Compiler & inLexique,
              GGS_lstringlist & _out_0,
              GGS_semanticInstructionListForGeneration & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSwitchConstantList ;
    _out_1 = ptr->mInstructions ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_switchBranchesForGeneration::
method_last (C_Compiler & inLexique,
             GGS_lstringlist & _out_0,
             GGS_semanticInstructionListForGeneration & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSwitchConstantList ;
    _out_1 = ptr->mInstructions ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_switchBranchesForGeneration::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstringlist & _out_0,
                 GGS_semanticInstructionListForGeneration & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSwitchConstantList ;
    _out_1 = ptr->mInstructions ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_switchBranchesForGeneration::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstringlist & _out_0,
                GGS_semanticInstructionListForGeneration & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSwitchConstantList ;
    _out_1 = ptr->mInstructions ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_switchBranchesForGeneration::
reader_mSwitchConstantListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstringlist  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSwitchConstantList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration  GGS_switchBranchesForGeneration::
reader_mInstructionsAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticInstructionListForGeneration  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstructions ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_switchBranchesForGeneration::
modifier_setMSwitchConstantListAtIndex (C_Compiler & inLexique,
                              const GGS_lstringlist  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSwitchConstantList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_switchBranchesForGeneration::
modifier_setMInstructionsAtIndex (C_Compiler & inLexique,
                              const GGS_semanticInstructionListForGeneration  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstructions = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstringlist  & GGS_switchBranchesForGeneration::cEnumerator::_mSwitchConstantList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mSwitchConstantList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticInstructionListForGeneration  & GGS_switchBranchesForGeneration::cEnumerator::_mInstructions (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mInstructions ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_switchBranchesForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_switchBranchesForGeneration * p = NULL ;
    macroMyNew (p, GGS_switchBranchesForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_switchBranchesForGeneration GGS_switchBranchesForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_switchBranchesForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_switchBranchesForGeneration * p = dynamic_cast <const GGS_switchBranchesForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_switchBranchesForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_switchBranchesForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_switchBranchesForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_switchInstructionForGeneration'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_switchInstructionForGeneration::
cPtr_switchInstructionForGeneration (const GGS_location & argument_0,
                                const GGS_semanticExpressionForGeneration & argument_1,
                                const GGS_switchBranchesForGeneration & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (argument_0 COMMA_THERE),
mSwitchExpression (argument_1),
mBranches (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_switchInstructionForGeneration * GGS_switchInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_switchInstructionForGeneration) ;
    return (cPtr_switchInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_switchInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_switchInstructionForGeneration * ptr = dynamic_cast <const cPtr_switchInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mSwitchExpression.operator_isEqual (ptr->mSwitchExpression).boolValue ()
         && mBranches.operator_isEqual (ptr->mBranches).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_switchInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@switchInstructionForGeneration:"
           << mStartLocation.reader_description (inIndentation + 1)
           << mSwitchExpression.reader_description (inIndentation + 1)
           << mBranches.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_switchInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_switchInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_switchInstructionForGeneration (& typeid (cPtr_switchInstructionForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_switchInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__switchInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_switchInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_switchInstructionForGeneration (mStartLocation, mSwitchExpression, mBranches COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_switchInstructionForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_switchInstructionForGeneration ("switchInstructionForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_switchInstructionForGeneration::
GGS_switchInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_switchInstructionForGeneration::
GGS_switchInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_switchInstructionForGeneration GGS_switchInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_switchInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_switchInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_switchInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_switchInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_switchInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_switchInstructionForGeneration GGS_switchInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionForGeneration & argument_1,
                 const GGS_switchBranchesForGeneration & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_switchInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_switchInstructionForGeneration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_switchInstructionForGeneration::
reader_mSwitchExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_switchInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_switchInstructionForGeneration *) mPointer)->mSwitchExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_switchBranchesForGeneration  GGS_switchInstructionForGeneration::
reader_mBranches (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_switchBranchesForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_switchInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_switchInstructionForGeneration *) mPointer)->mBranches ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_switchInstructionForGeneration::actualTypeName (void) const {
  return "switchInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__switchInstructionForGeneration ("switchInstructionForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_switchInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_switchInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_switchInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_switchInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_switchInstructionForGeneration GGS_switchInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_switchInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_switchInstructionForGeneration * p = dynamic_cast <const GGS_switchInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_switchInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_switchInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_switchInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_typeMethodInstructionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeMethodInstructionForGeneration::
cPtr_typeMethodInstructionForGeneration (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_actualParameterListForGeneration & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (argument_0 COMMA_THERE),
mTypeName (argument_1),
mMethodName (argument_2),
mActualParameterList (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeMethodInstructionForGeneration * GGS_typeMethodInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeMethodInstructionForGeneration) ;
    return (cPtr_typeMethodInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeMethodInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeMethodInstructionForGeneration * ptr = dynamic_cast <const cPtr_typeMethodInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mTypeName.operator_isEqual (ptr->mTypeName).boolValue ()
         && mMethodName.operator_isEqual (ptr->mMethodName).boolValue ()
         && mActualParameterList.operator_isEqual (ptr->mActualParameterList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeMethodInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeMethodInstructionForGeneration:"
           << mStartLocation.reader_description (inIndentation + 1)
           << mTypeName.reader_description (inIndentation + 1)
           << mMethodName.reader_description (inIndentation + 1)
           << mActualParameterList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeMethodInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeMethodInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeMethodInstructionForGeneration (& typeid (cPtr_typeMethodInstructionForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeMethodInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__typeMethodInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeMethodInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeMethodInstructionForGeneration (mStartLocation, mTypeName, mMethodName, mActualParameterList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_typeMethodInstructionForGeneration'            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeMethodInstructionForGeneration ("typeMethodInstructionForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_typeMethodInstructionForGeneration::
GGS_typeMethodInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeMethodInstructionForGeneration::
GGS_typeMethodInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeMethodInstructionForGeneration GGS_typeMethodInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeMethodInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeMethodInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_typeMethodInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeMethodInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeMethodInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeMethodInstructionForGeneration GGS_typeMethodInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_actualParameterListForGeneration & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_typeMethodInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_typeMethodInstructionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeMethodInstructionForGeneration::
reader_mTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMethodInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMethodInstructionForGeneration *) mPointer)->mTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeMethodInstructionForGeneration::
reader_mMethodName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMethodInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMethodInstructionForGeneration *) mPointer)->mMethodName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameterListForGeneration  GGS_typeMethodInstructionForGeneration::
reader_mActualParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_actualParameterListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMethodInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMethodInstructionForGeneration *) mPointer)->mActualParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeMethodInstructionForGeneration::actualTypeName (void) const {
  return "typeMethodInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeMethodInstructionForGeneration ("typeMethodInstructionForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_typeMethodInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeMethodInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeMethodInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_typeMethodInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeMethodInstructionForGeneration GGS_typeMethodInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeMethodInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeMethodInstructionForGeneration * p = dynamic_cast <const GGS_typeMethodInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeMethodInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeMethodInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeMethodInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Element of list '@abstracMultiMethodListForGeneration'           *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_abstracMultiMethodListForGeneration::
elementOf_GGS_abstracMultiMethodListForGeneration (const GGS_lstring & argument_0,
                                const GGS_formalParameterListForGeneration & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mAbstractCategoryMethodName (argument_0),
mAbstractCategoryFormalParameterList (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_abstracMultiMethodListForGeneration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_abstracMultiMethodListForGeneration * ptr = dynamic_cast <const elementOf_GGS_abstracMultiMethodListForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mAbstractCategoryMethodName.operator_isEqual (ptr->mAbstractCategoryMethodName).boolValue ()
         && mAbstractCategoryFormalParameterList.operator_isEqual (ptr->mAbstractCategoryFormalParameterList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_abstracMultiMethodListForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAbstractCategoryMethodName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAbstractCategoryFormalParameterList.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               List '@abstracMultiMethodListForGeneration'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_abstracMultiMethodListForGeneration ("abstracMultiMethodListForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_abstracMultiMethodListForGeneration::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_formalParameterListForGeneration & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_abstracMultiMethodListForGeneration::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_formalParameterListForGeneration & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_abstracMultiMethodListForGeneration::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_formalParameterListForGeneration & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_abstracMultiMethodListForGeneration GGS_abstracMultiMethodListForGeneration::
operator_concat (const GGS_abstracMultiMethodListForGeneration & inOperand) const {
  GGS_abstracMultiMethodListForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_abstracMultiMethodListForGeneration::
dotAssign_operation (const GGS_abstracMultiMethodListForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_abstracMultiMethodListForGeneration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mAbstractCategoryMethodName ;
          GGS_formalParameterListForGeneration  p_1 = p->mAbstractCategoryFormalParameterList ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_abstracMultiMethodListForGeneration::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_formalParameterListForGeneration & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_abstracMultiMethodListForGeneration::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mAbstractCategoryMethodName,
                                ptr->mAbstractCategoryFormalParameterList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_abstracMultiMethodListForGeneration  GGS_abstracMultiMethodListForGeneration::
constructor_emptyList (void) {
  GGS_abstracMultiMethodListForGeneration result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_abstracMultiMethodListForGeneration  GGS_abstracMultiMethodListForGeneration::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_formalParameterListForGeneration & argument_1) {
  GGS_abstracMultiMethodListForGeneration result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_abstracMultiMethodListForGeneration::
internalSubListWithRange (GGS_abstracMultiMethodListForGeneration & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mAbstractCategoryMethodName, ptr->mAbstractCategoryFormalParameterList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_abstracMultiMethodListForGeneration GGS_abstracMultiMethodListForGeneration::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_abstracMultiMethodListForGeneration result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_abstracMultiMethodListForGeneration GGS_abstracMultiMethodListForGeneration::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_abstracMultiMethodListForGeneration result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_abstracMultiMethodListForGeneration::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@abstracMultiMethodListForGeneration", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_abstracMultiMethodListForGeneration::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_formalParameterListForGeneration & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAbstractCategoryMethodName ;
    _out_1 = ptr->mAbstractCategoryFormalParameterList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_abstracMultiMethodListForGeneration::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_formalParameterListForGeneration & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAbstractCategoryMethodName ;
    _out_1 = ptr->mAbstractCategoryFormalParameterList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_abstracMultiMethodListForGeneration::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_formalParameterListForGeneration & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAbstractCategoryMethodName ;
    _out_1 = ptr->mAbstractCategoryFormalParameterList ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_abstracMultiMethodListForGeneration::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_formalParameterListForGeneration & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAbstractCategoryMethodName ;
    _out_1 = ptr->mAbstractCategoryFormalParameterList ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_abstracMultiMethodListForGeneration::
reader_mAbstractCategoryMethodNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mAbstractCategoryMethodName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameterListForGeneration  GGS_abstracMultiMethodListForGeneration::
reader_mAbstractCategoryFormalParameterListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_formalParameterListForGeneration  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mAbstractCategoryFormalParameterList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_abstracMultiMethodListForGeneration::
modifier_setMAbstractCategoryMethodNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mAbstractCategoryMethodName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_abstracMultiMethodListForGeneration::
modifier_setMAbstractCategoryFormalParameterListAtIndex (C_Compiler & inLexique,
                              const GGS_formalParameterListForGeneration  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mAbstractCategoryFormalParameterList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_abstracMultiMethodListForGeneration::cEnumerator::_mAbstractCategoryMethodName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mAbstractCategoryMethodName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_formalParameterListForGeneration  & GGS_abstracMultiMethodListForGeneration::cEnumerator::_mAbstractCategoryFormalParameterList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mAbstractCategoryFormalParameterList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_abstracMultiMethodListForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_abstracMultiMethodListForGeneration * p = NULL ;
    macroMyNew (p, GGS_abstracMultiMethodListForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_abstracMultiMethodListForGeneration GGS_abstracMultiMethodListForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_abstracMultiMethodListForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_abstracMultiMethodListForGeneration * p = dynamic_cast <const GGS_abstracMultiMethodListForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_abstracMultiMethodListForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_abstracMultiMethodListForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_abstracMultiMethodListForGeneration ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_abstractMultiMethodListMapForGeneration ("abstractMultiMethodListMapForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

GGS_abstractMultiMethodListMapForGeneration::cElement::cElement (LOCATION_ARGS) :
cPtrListMapObject (THERE),
mListObject (GGS_abstracMultiMethodListForGeneration::constructor_emptyList ()) {
}

//---------------------------------------------------------------------------*

cPtrObject * GGS_abstractMultiMethodListMapForGeneration::cElement::cloneObject (LOCATION_ARGS) {
  cElement * result = NULL ;
  macroMyNew (result, cElement (THERE)) ;
  result->mListObject = mListObject ;
  return result ;
}

//---------------------------------------------------------------------------*

bool GGS_abstractMultiMethodListMapForGeneration::cElement::isEqual (const cPtrListMapObject * inOperand) const {
  const GGS_bool equal = mListObject.operator_isEqual (((cElement *) inOperand)->mListObject) ;
  return equal.boolValue () ;
}

//---------------------------------------------------------------------------*

C_String GGS_abstractMultiMethodListMapForGeneration::cElement::
performDescription (const PMSInt32 inIndentation) const {
  const GGS_string s = mListObject.reader_description (inIndentation) ;
  return s.string () ;
}

//---------------------------------------------------------------------------*

GGS_abstractMultiMethodListMapForGeneration GGS_abstractMultiMethodListMapForGeneration::
constructor_emptyMap (void) {
  GGS_abstractMultiMethodListMapForGeneration result ;
  result.alloc (HERE) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_abstractMultiMethodListMapForGeneration::
_typeNameForDescriptionReader (void) const {
  return "@abstractMultiMethodListMapForGeneration" ;
}

//---------------------------------------------------------------------------*

GGS_abstractMultiMethodListMapForGeneration GGS_abstractMultiMethodListMapForGeneration::
operator_concat (const GGS_abstractMultiMethodListMapForGeneration & inOperand) const {
  GGS_abstractMultiMethodListMapForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_abstractMultiMethodListMapForGeneration::
dotAssign_operation (const GGS_abstractMultiMethodListMapForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count (HERE) == 0) {
      * this = inOperand ;
    }else if (inOperand.count (HERE) > 0) {
      cPtrDictionary * dictPtr = macroPtr (inOperand, cPtrDictionary)  ;
      cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
      const PMSInt32 objectCount = dictPtr->count () ;
      for (PMSInt32 i=0 ; i<objectCount ; i++) {
        const GGS_string key = nodeSortedArray [i].key () ;
        const PM_C_Object object = nodeSortedArray [i].mObject ;
        cElement * elementPtr = macroPtr (object, cElement) ;
        bool wasInserted = false ;
        cPtrDictionaryNode * nodePtr = findOrAddNodeForKey (key, wasInserted) ;
        if (wasInserted) {
           cElement * p = NULL ;
           macroMyNew (p, cElement (HERE)) ;
           nodePtr->mObject.setPointer (p) ;
        }
        GGS_abstracMultiMethodListForGeneration & listPtr = macroPtr (nodePtr->mObject, cElement)->mListObject ;
        listPtr.dotAssign_operation (elementPtr->mListObject) ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractMultiMethodListMapForGeneration::
addAssign_operation (const GGS_string & inKey,
                      const GGS_lstring & inAttribute0,
                      const GGS_formalParameterListForGeneration & inAttribute1) {
  if (isBuilt () && inKey.isBuilt () && inAttribute0.isBuilt () && inAttribute1.isBuilt ()) {
    bool wasInserted = false ;
    cPtrDictionaryNode * nodePtr = findOrAddNodeForKey (inKey, wasInserted) ;
    MF_Assert (nodePtr != NULL, "NULL pointer (was inserted %d)", wasInserted, 0) ;
    if (wasInserted) {
       cElement * p = NULL ;
       macroMyNew (p, cElement (HERE)) ;
       nodePtr->mObject.setPointer (p) ;
    }
    GGS_abstracMultiMethodListForGeneration & listPtr = macroPtr (nodePtr->mObject, cElement)->mListObject ;
    listPtr.addAssign_operation (inAttribute0, inAttribute1) ;
  }
}

//---------------------------------------------------------------------------*

GGS_abstracMultiMethodListForGeneration GGS_abstractMultiMethodListMapForGeneration::
reader_listForKey (C_Compiler & /* inLexique */,
                   const GGS_string & inKey
                   COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_abstracMultiMethodListForGeneration result ;
  if (isBuilt () && inKey.isBuilt ()) {
    cPtrDictionaryNode * nodePtr = dictionaryNodeForKey (inKey.string ()) ; 
    if (nodePtr == NULL) {
      result = GGS_abstracMultiMethodListForGeneration::constructor_emptyList () ;
    }else{
      result = macroPtr (nodePtr->mObject, cElement)->mListObject ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringset GGS_abstractMultiMethodListMapForGeneration::
reader_allKeys (C_Compiler & /* inLexique */
                COMMA_UNUSED_LOCATION_ARGS) const {

  GGS_stringset result ;
  result.setPointer (_pointer ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringlist GGS_abstractMultiMethodListMapForGeneration::
reader_keyList (C_Compiler & /* inLexique */
                COMMA_UNUSED_LOCATION_ARGS) const {

  GGS_stringlist result ;
  if (isBuilt ()) {
    result = GGS_stringlist::constructor_emptyList () ;
    cPtrDictionary * dictPtr = macroPtr (*this, cPtrDictionary)  ;
    cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
    const PMSInt32 objectCount = dictPtr->count () ;
    for (PMSInt32 i=0 ; i<objectCount ; i++) {
      const GGS_string key = nodeSortedArray [i].key () ;
      result.addAssign_operation (key) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_abstractMultiMethodListMapForGeneration::cEnumerator::
cEnumerator (const GGS_abstractMultiMethodListMapForGeneration & inListMap,
             const bool inAscending) :
cAbstractDictionaryEnumerator (inListMap, inAscending) {
}

//---------------------------------------------------------------------------*

const GGS_abstracMultiMethodListForGeneration & GGS_abstractMultiMethodListMapForGeneration::cEnumerator::
_object (LOCATION_ARGS) const {
  cPtrDictionary * dictPtr = macroPtr (mEnumeratedDictionary, cPtrDictionary)  ;
  MF_AssertThere (currentIndex () >= 0, "Access with negative index %d", currentIndex (), 0) ;
  MF_AssertThere (currentIndex () < dictPtr->count (), "Access with index %d >= count %d", currentIndex (), dictPtr->count ()) ;
  cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
  PM_C_Object listObject = nodeSortedArray [currentIndex ()].mObject ;
  cElement * objectPtr = macroPtr (listObject, cElement) ;
  return objectPtr->mListObject ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_abstractMultiMethodListMapForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_abstractMultiMethodListMapForGeneration * p = NULL ;
    macroMyNew (p, GGS_abstractMultiMethodListMapForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_abstractMultiMethodListMapForGeneration GGS_abstractMultiMethodListMapForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_abstractMultiMethodListMapForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_abstractMultiMethodListMapForGeneration * p = dynamic_cast <const GGS_abstractMultiMethodListMapForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_abstractMultiMethodListMapForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_abstractMultiMethodListMapForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_abstractMultiMethodListMapForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@multiMethodListForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_multiMethodListForGeneration::
elementOf_GGS_multiMethodListForGeneration (const GGS_lstring & argument_0,
                                const GGS_formalParameterListForGeneration & argument_1,
                                const GGS_semanticInstructionListForGeneration & argument_2
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mCategoryMethodName (argument_0),
mCategoryFormalParameterList (argument_1),
mRoutineInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_multiMethodListForGeneration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_multiMethodListForGeneration * ptr = dynamic_cast <const elementOf_GGS_multiMethodListForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mCategoryMethodName.operator_isEqual (ptr->mCategoryMethodName).boolValue ()
         && mCategoryFormalParameterList.operator_isEqual (ptr->mCategoryFormalParameterList).boolValue ()
         && mRoutineInstructionList.operator_isEqual (ptr->mRoutineInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_multiMethodListForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mCategoryMethodName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mCategoryFormalParameterList.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRoutineInstructionList.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@multiMethodListForGeneration'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_multiMethodListForGeneration ("multiMethodListForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_multiMethodListForGeneration::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_formalParameterListForGeneration & argument_1,
                    const GGS_semanticInstructionListForGeneration & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_multiMethodListForGeneration::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_formalParameterListForGeneration & argument_1,
                    const GGS_semanticInstructionListForGeneration & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_multiMethodListForGeneration::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_formalParameterListForGeneration & argument_1,
                                const GGS_semanticInstructionListForGeneration & argument_2) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_multiMethodListForGeneration GGS_multiMethodListForGeneration::
operator_concat (const GGS_multiMethodListForGeneration & inOperand) const {
  GGS_multiMethodListForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_multiMethodListForGeneration::
dotAssign_operation (const GGS_multiMethodListForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_multiMethodListForGeneration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mCategoryMethodName ;
          GGS_formalParameterListForGeneration  p_1 = p->mCategoryFormalParameterList ;
          GGS_semanticInstructionListForGeneration  p_2 = p->mRoutineInstructionList ;
          internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_multiMethodListForGeneration::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_formalParameterListForGeneration & argument_1,
                     const GGS_semanticInstructionListForGeneration & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_multiMethodListForGeneration::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mCategoryMethodName,
                                ptr->mCategoryFormalParameterList,
                                ptr->mRoutineInstructionList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_multiMethodListForGeneration  GGS_multiMethodListForGeneration::
constructor_emptyList (void) {
  GGS_multiMethodListForGeneration result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_multiMethodListForGeneration  GGS_multiMethodListForGeneration::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_formalParameterListForGeneration & argument_1,
                                const GGS_semanticInstructionListForGeneration & argument_2) {
  GGS_multiMethodListForGeneration result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_multiMethodListForGeneration::
internalSubListWithRange (GGS_multiMethodListForGeneration & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mCategoryMethodName, ptr->mCategoryFormalParameterList, ptr->mRoutineInstructionList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_multiMethodListForGeneration GGS_multiMethodListForGeneration::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_multiMethodListForGeneration result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_multiMethodListForGeneration GGS_multiMethodListForGeneration::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_multiMethodListForGeneration result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_multiMethodListForGeneration::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@multiMethodListForGeneration", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_multiMethodListForGeneration::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_formalParameterListForGeneration & _out_1,
              GGS_semanticInstructionListForGeneration & _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mCategoryMethodName ;
    _out_1 = ptr->mCategoryFormalParameterList ;
    _out_2 = ptr->mRoutineInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_multiMethodListForGeneration::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_formalParameterListForGeneration & _out_1,
             GGS_semanticInstructionListForGeneration & _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mCategoryMethodName ;
    _out_1 = ptr->mCategoryFormalParameterList ;
    _out_2 = ptr->mRoutineInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_multiMethodListForGeneration::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_formalParameterListForGeneration & _out_1,
                 GGS_semanticInstructionListForGeneration & _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mCategoryMethodName ;
    _out_1 = ptr->mCategoryFormalParameterList ;
    _out_2 = ptr->mRoutineInstructionList ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_multiMethodListForGeneration::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_formalParameterListForGeneration & _out_1,
                GGS_semanticInstructionListForGeneration & _out_2
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mCategoryMethodName ;
    _out_1 = ptr->mCategoryFormalParameterList ;
    _out_2 = ptr->mRoutineInstructionList ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_multiMethodListForGeneration::
reader_mCategoryMethodNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mCategoryMethodName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameterListForGeneration  GGS_multiMethodListForGeneration::
reader_mCategoryFormalParameterListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_formalParameterListForGeneration  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mCategoryFormalParameterList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration  GGS_multiMethodListForGeneration::
reader_mRoutineInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticInstructionListForGeneration  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mRoutineInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_multiMethodListForGeneration::
modifier_setMCategoryMethodNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mCategoryMethodName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_multiMethodListForGeneration::
modifier_setMCategoryFormalParameterListAtIndex (C_Compiler & inLexique,
                              const GGS_formalParameterListForGeneration  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mCategoryFormalParameterList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_multiMethodListForGeneration::
modifier_setMRoutineInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_semanticInstructionListForGeneration  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mRoutineInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_multiMethodListForGeneration::cEnumerator::_mCategoryMethodName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mCategoryMethodName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_formalParameterListForGeneration  & GGS_multiMethodListForGeneration::cEnumerator::_mCategoryFormalParameterList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mCategoryFormalParameterList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticInstructionListForGeneration  & GGS_multiMethodListForGeneration::cEnumerator::_mRoutineInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mRoutineInstructionList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_multiMethodListForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_multiMethodListForGeneration * p = NULL ;
    macroMyNew (p, GGS_multiMethodListForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_multiMethodListForGeneration GGS_multiMethodListForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_multiMethodListForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_multiMethodListForGeneration * p = dynamic_cast <const GGS_multiMethodListForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_multiMethodListForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_multiMethodListForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_multiMethodListForGeneration ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_multiMethodListMapForGeneration ("multiMethodListMapForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

GGS_multiMethodListMapForGeneration::cElement::cElement (LOCATION_ARGS) :
cPtrListMapObject (THERE),
mListObject (GGS_multiMethodListForGeneration::constructor_emptyList ()) {
}

//---------------------------------------------------------------------------*

cPtrObject * GGS_multiMethodListMapForGeneration::cElement::cloneObject (LOCATION_ARGS) {
  cElement * result = NULL ;
  macroMyNew (result, cElement (THERE)) ;
  result->mListObject = mListObject ;
  return result ;
}

//---------------------------------------------------------------------------*

bool GGS_multiMethodListMapForGeneration::cElement::isEqual (const cPtrListMapObject * inOperand) const {
  const GGS_bool equal = mListObject.operator_isEqual (((cElement *) inOperand)->mListObject) ;
  return equal.boolValue () ;
}

//---------------------------------------------------------------------------*

C_String GGS_multiMethodListMapForGeneration::cElement::
performDescription (const PMSInt32 inIndentation) const {
  const GGS_string s = mListObject.reader_description (inIndentation) ;
  return s.string () ;
}

//---------------------------------------------------------------------------*

GGS_multiMethodListMapForGeneration GGS_multiMethodListMapForGeneration::
constructor_emptyMap (void) {
  GGS_multiMethodListMapForGeneration result ;
  result.alloc (HERE) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_multiMethodListMapForGeneration::
_typeNameForDescriptionReader (void) const {
  return "@multiMethodListMapForGeneration" ;
}

//---------------------------------------------------------------------------*

GGS_multiMethodListMapForGeneration GGS_multiMethodListMapForGeneration::
operator_concat (const GGS_multiMethodListMapForGeneration & inOperand) const {
  GGS_multiMethodListMapForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_multiMethodListMapForGeneration::
dotAssign_operation (const GGS_multiMethodListMapForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count (HERE) == 0) {
      * this = inOperand ;
    }else if (inOperand.count (HERE) > 0) {
      cPtrDictionary * dictPtr = macroPtr (inOperand, cPtrDictionary)  ;
      cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
      const PMSInt32 objectCount = dictPtr->count () ;
      for (PMSInt32 i=0 ; i<objectCount ; i++) {
        const GGS_string key = nodeSortedArray [i].key () ;
        const PM_C_Object object = nodeSortedArray [i].mObject ;
        cElement * elementPtr = macroPtr (object, cElement) ;
        bool wasInserted = false ;
        cPtrDictionaryNode * nodePtr = findOrAddNodeForKey (key, wasInserted) ;
        if (wasInserted) {
           cElement * p = NULL ;
           macroMyNew (p, cElement (HERE)) ;
           nodePtr->mObject.setPointer (p) ;
        }
        GGS_multiMethodListForGeneration & listPtr = macroPtr (nodePtr->mObject, cElement)->mListObject ;
        listPtr.dotAssign_operation (elementPtr->mListObject) ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_multiMethodListMapForGeneration::
addAssign_operation (const GGS_string & inKey,
                      const GGS_lstring & inAttribute0,
                      const GGS_formalParameterListForGeneration & inAttribute1,
                      const GGS_semanticInstructionListForGeneration & inAttribute2) {
  if (isBuilt () && inKey.isBuilt () && inAttribute0.isBuilt () && inAttribute1.isBuilt () && inAttribute2.isBuilt ()) {
    bool wasInserted = false ;
    cPtrDictionaryNode * nodePtr = findOrAddNodeForKey (inKey, wasInserted) ;
    MF_Assert (nodePtr != NULL, "NULL pointer (was inserted %d)", wasInserted, 0) ;
    if (wasInserted) {
       cElement * p = NULL ;
       macroMyNew (p, cElement (HERE)) ;
       nodePtr->mObject.setPointer (p) ;
    }
    GGS_multiMethodListForGeneration & listPtr = macroPtr (nodePtr->mObject, cElement)->mListObject ;
    listPtr.addAssign_operation (inAttribute0, inAttribute1, inAttribute2) ;
  }
}

//---------------------------------------------------------------------------*

GGS_multiMethodListForGeneration GGS_multiMethodListMapForGeneration::
reader_listForKey (C_Compiler & /* inLexique */,
                   const GGS_string & inKey
                   COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_multiMethodListForGeneration result ;
  if (isBuilt () && inKey.isBuilt ()) {
    cPtrDictionaryNode * nodePtr = dictionaryNodeForKey (inKey.string ()) ; 
    if (nodePtr == NULL) {
      result = GGS_multiMethodListForGeneration::constructor_emptyList () ;
    }else{
      result = macroPtr (nodePtr->mObject, cElement)->mListObject ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringset GGS_multiMethodListMapForGeneration::
reader_allKeys (C_Compiler & /* inLexique */
                COMMA_UNUSED_LOCATION_ARGS) const {

  GGS_stringset result ;
  result.setPointer (_pointer ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringlist GGS_multiMethodListMapForGeneration::
reader_keyList (C_Compiler & /* inLexique */
                COMMA_UNUSED_LOCATION_ARGS) const {

  GGS_stringlist result ;
  if (isBuilt ()) {
    result = GGS_stringlist::constructor_emptyList () ;
    cPtrDictionary * dictPtr = macroPtr (*this, cPtrDictionary)  ;
    cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
    const PMSInt32 objectCount = dictPtr->count () ;
    for (PMSInt32 i=0 ; i<objectCount ; i++) {
      const GGS_string key = nodeSortedArray [i].key () ;
      result.addAssign_operation (key) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_multiMethodListMapForGeneration::cEnumerator::
cEnumerator (const GGS_multiMethodListMapForGeneration & inListMap,
             const bool inAscending) :
cAbstractDictionaryEnumerator (inListMap, inAscending) {
}

//---------------------------------------------------------------------------*

const GGS_multiMethodListForGeneration & GGS_multiMethodListMapForGeneration::cEnumerator::
_object (LOCATION_ARGS) const {
  cPtrDictionary * dictPtr = macroPtr (mEnumeratedDictionary, cPtrDictionary)  ;
  MF_AssertThere (currentIndex () >= 0, "Access with negative index %d", currentIndex (), 0) ;
  MF_AssertThere (currentIndex () < dictPtr->count (), "Access with index %d >= count %d", currentIndex (), dictPtr->count ()) ;
  cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
  PM_C_Object listObject = nodeSortedArray [currentIndex ()].mObject ;
  cElement * objectPtr = macroPtr (listObject, cElement) ;
  return objectPtr->mListObject ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_multiMethodListMapForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_multiMethodListMapForGeneration * p = NULL ;
    macroMyNew (p, GGS_multiMethodListMapForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_multiMethodListMapForGeneration GGS_multiMethodListMapForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_multiMethodListMapForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_multiMethodListMapForGeneration * p = dynamic_cast <const GGS_multiMethodListMapForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_multiMethodListMapForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_multiMethodListMapForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_multiMethodListMapForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        Element of list '@overridingMultiMethodListForGeneration'          *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_overridingMultiMethodListForGeneration::
elementOf_GGS_overridingMultiMethodListForGeneration (const GGS_lstring & argument_0,
                                const GGS_formalParameterListForGeneration & argument_1,
                                const GGS_semanticInstructionListForGeneration & argument_2
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mOverridingCategoryMethodName (argument_0),
mOverridingCategoryFormalParameterList (argument_1),
mRoutineInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_overridingMultiMethodListForGeneration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_overridingMultiMethodListForGeneration * ptr = dynamic_cast <const elementOf_GGS_overridingMultiMethodListForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOverridingCategoryMethodName.operator_isEqual (ptr->mOverridingCategoryMethodName).boolValue ()
         && mOverridingCategoryFormalParameterList.operator_isEqual (ptr->mOverridingCategoryFormalParameterList).boolValue ()
         && mRoutineInstructionList.operator_isEqual (ptr->mRoutineInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_overridingMultiMethodListForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOverridingCategoryMethodName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOverridingCategoryFormalParameterList.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRoutineInstructionList.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              List '@overridingMultiMethodListForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_overridingMultiMethodListForGeneration ("overridingMultiMethodListForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_overridingMultiMethodListForGeneration::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_formalParameterListForGeneration & argument_1,
                    const GGS_semanticInstructionListForGeneration & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiMethodListForGeneration::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_formalParameterListForGeneration & argument_1,
                    const GGS_semanticInstructionListForGeneration & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiMethodListForGeneration::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_formalParameterListForGeneration & argument_1,
                                const GGS_semanticInstructionListForGeneration & argument_2) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_overridingMultiMethodListForGeneration GGS_overridingMultiMethodListForGeneration::
operator_concat (const GGS_overridingMultiMethodListForGeneration & inOperand) const {
  GGS_overridingMultiMethodListForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiMethodListForGeneration::
dotAssign_operation (const GGS_overridingMultiMethodListForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_overridingMultiMethodListForGeneration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mOverridingCategoryMethodName ;
          GGS_formalParameterListForGeneration  p_1 = p->mOverridingCategoryFormalParameterList ;
          GGS_semanticInstructionListForGeneration  p_2 = p->mRoutineInstructionList ;
          internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiMethodListForGeneration::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_formalParameterListForGeneration & argument_1,
                     const GGS_semanticInstructionListForGeneration & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiMethodListForGeneration::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mOverridingCategoryMethodName,
                                ptr->mOverridingCategoryFormalParameterList,
                                ptr->mRoutineInstructionList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_overridingMultiMethodListForGeneration  GGS_overridingMultiMethodListForGeneration::
constructor_emptyList (void) {
  GGS_overridingMultiMethodListForGeneration result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_overridingMultiMethodListForGeneration  GGS_overridingMultiMethodListForGeneration::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_formalParameterListForGeneration & argument_1,
                                const GGS_semanticInstructionListForGeneration & argument_2) {
  GGS_overridingMultiMethodListForGeneration result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiMethodListForGeneration::
internalSubListWithRange (GGS_overridingMultiMethodListForGeneration & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mOverridingCategoryMethodName, ptr->mOverridingCategoryFormalParameterList, ptr->mRoutineInstructionList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_overridingMultiMethodListForGeneration GGS_overridingMultiMethodListForGeneration::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_overridingMultiMethodListForGeneration result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_overridingMultiMethodListForGeneration GGS_overridingMultiMethodListForGeneration::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_overridingMultiMethodListForGeneration result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_overridingMultiMethodListForGeneration::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@overridingMultiMethodListForGeneration", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiMethodListForGeneration::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_formalParameterListForGeneration & _out_1,
              GGS_semanticInstructionListForGeneration & _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mOverridingCategoryMethodName ;
    _out_1 = ptr->mOverridingCategoryFormalParameterList ;
    _out_2 = ptr->mRoutineInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiMethodListForGeneration::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_formalParameterListForGeneration & _out_1,
             GGS_semanticInstructionListForGeneration & _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mOverridingCategoryMethodName ;
    _out_1 = ptr->mOverridingCategoryFormalParameterList ;
    _out_2 = ptr->mRoutineInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiMethodListForGeneration::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_formalParameterListForGeneration & _out_1,
                 GGS_semanticInstructionListForGeneration & _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mOverridingCategoryMethodName ;
    _out_1 = ptr->mOverridingCategoryFormalParameterList ;
    _out_2 = ptr->mRoutineInstructionList ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiMethodListForGeneration::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_formalParameterListForGeneration & _out_1,
                GGS_semanticInstructionListForGeneration & _out_2
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mOverridingCategoryMethodName ;
    _out_1 = ptr->mOverridingCategoryFormalParameterList ;
    _out_2 = ptr->mRoutineInstructionList ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_overridingMultiMethodListForGeneration::
reader_mOverridingCategoryMethodNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mOverridingCategoryMethodName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameterListForGeneration  GGS_overridingMultiMethodListForGeneration::
reader_mOverridingCategoryFormalParameterListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_formalParameterListForGeneration  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mOverridingCategoryFormalParameterList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration  GGS_overridingMultiMethodListForGeneration::
reader_mRoutineInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticInstructionListForGeneration  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mRoutineInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiMethodListForGeneration::
modifier_setMOverridingCategoryMethodNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mOverridingCategoryMethodName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiMethodListForGeneration::
modifier_setMOverridingCategoryFormalParameterListAtIndex (C_Compiler & inLexique,
                              const GGS_formalParameterListForGeneration  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mOverridingCategoryFormalParameterList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiMethodListForGeneration::
modifier_setMRoutineInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_semanticInstructionListForGeneration  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mRoutineInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_overridingMultiMethodListForGeneration::cEnumerator::_mOverridingCategoryMethodName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mOverridingCategoryMethodName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_formalParameterListForGeneration  & GGS_overridingMultiMethodListForGeneration::cEnumerator::_mOverridingCategoryFormalParameterList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mOverridingCategoryFormalParameterList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticInstructionListForGeneration  & GGS_overridingMultiMethodListForGeneration::cEnumerator::_mRoutineInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mRoutineInstructionList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_overridingMultiMethodListForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_overridingMultiMethodListForGeneration * p = NULL ;
    macroMyNew (p, GGS_overridingMultiMethodListForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_overridingMultiMethodListForGeneration GGS_overridingMultiMethodListForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_overridingMultiMethodListForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_overridingMultiMethodListForGeneration * p = dynamic_cast <const GGS_overridingMultiMethodListForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_overridingMultiMethodListForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_overridingMultiMethodListForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_overridingMultiMethodListForGeneration ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_overridingMultiMethodListMapForGeneration ("overridingMultiMethodListMapForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

GGS_overridingMultiMethodListMapForGeneration::cElement::cElement (LOCATION_ARGS) :
cPtrListMapObject (THERE),
mListObject (GGS_overridingMultiMethodListForGeneration::constructor_emptyList ()) {
}

//---------------------------------------------------------------------------*

cPtrObject * GGS_overridingMultiMethodListMapForGeneration::cElement::cloneObject (LOCATION_ARGS) {
  cElement * result = NULL ;
  macroMyNew (result, cElement (THERE)) ;
  result->mListObject = mListObject ;
  return result ;
}

//---------------------------------------------------------------------------*

bool GGS_overridingMultiMethodListMapForGeneration::cElement::isEqual (const cPtrListMapObject * inOperand) const {
  const GGS_bool equal = mListObject.operator_isEqual (((cElement *) inOperand)->mListObject) ;
  return equal.boolValue () ;
}

//---------------------------------------------------------------------------*

C_String GGS_overridingMultiMethodListMapForGeneration::cElement::
performDescription (const PMSInt32 inIndentation) const {
  const GGS_string s = mListObject.reader_description (inIndentation) ;
  return s.string () ;
}

//---------------------------------------------------------------------------*

GGS_overridingMultiMethodListMapForGeneration GGS_overridingMultiMethodListMapForGeneration::
constructor_emptyMap (void) {
  GGS_overridingMultiMethodListMapForGeneration result ;
  result.alloc (HERE) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_overridingMultiMethodListMapForGeneration::
_typeNameForDescriptionReader (void) const {
  return "@overridingMultiMethodListMapForGeneration" ;
}

//---------------------------------------------------------------------------*

GGS_overridingMultiMethodListMapForGeneration GGS_overridingMultiMethodListMapForGeneration::
operator_concat (const GGS_overridingMultiMethodListMapForGeneration & inOperand) const {
  GGS_overridingMultiMethodListMapForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiMethodListMapForGeneration::
dotAssign_operation (const GGS_overridingMultiMethodListMapForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count (HERE) == 0) {
      * this = inOperand ;
    }else if (inOperand.count (HERE) > 0) {
      cPtrDictionary * dictPtr = macroPtr (inOperand, cPtrDictionary)  ;
      cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
      const PMSInt32 objectCount = dictPtr->count () ;
      for (PMSInt32 i=0 ; i<objectCount ; i++) {
        const GGS_string key = nodeSortedArray [i].key () ;
        const PM_C_Object object = nodeSortedArray [i].mObject ;
        cElement * elementPtr = macroPtr (object, cElement) ;
        bool wasInserted = false ;
        cPtrDictionaryNode * nodePtr = findOrAddNodeForKey (key, wasInserted) ;
        if (wasInserted) {
           cElement * p = NULL ;
           macroMyNew (p, cElement (HERE)) ;
           nodePtr->mObject.setPointer (p) ;
        }
        GGS_overridingMultiMethodListForGeneration & listPtr = macroPtr (nodePtr->mObject, cElement)->mListObject ;
        listPtr.dotAssign_operation (elementPtr->mListObject) ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiMethodListMapForGeneration::
addAssign_operation (const GGS_string & inKey,
                      const GGS_lstring & inAttribute0,
                      const GGS_formalParameterListForGeneration & inAttribute1,
                      const GGS_semanticInstructionListForGeneration & inAttribute2) {
  if (isBuilt () && inKey.isBuilt () && inAttribute0.isBuilt () && inAttribute1.isBuilt () && inAttribute2.isBuilt ()) {
    bool wasInserted = false ;
    cPtrDictionaryNode * nodePtr = findOrAddNodeForKey (inKey, wasInserted) ;
    MF_Assert (nodePtr != NULL, "NULL pointer (was inserted %d)", wasInserted, 0) ;
    if (wasInserted) {
       cElement * p = NULL ;
       macroMyNew (p, cElement (HERE)) ;
       nodePtr->mObject.setPointer (p) ;
    }
    GGS_overridingMultiMethodListForGeneration & listPtr = macroPtr (nodePtr->mObject, cElement)->mListObject ;
    listPtr.addAssign_operation (inAttribute0, inAttribute1, inAttribute2) ;
  }
}

//---------------------------------------------------------------------------*

GGS_overridingMultiMethodListForGeneration GGS_overridingMultiMethodListMapForGeneration::
reader_listForKey (C_Compiler & /* inLexique */,
                   const GGS_string & inKey
                   COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_overridingMultiMethodListForGeneration result ;
  if (isBuilt () && inKey.isBuilt ()) {
    cPtrDictionaryNode * nodePtr = dictionaryNodeForKey (inKey.string ()) ; 
    if (nodePtr == NULL) {
      result = GGS_overridingMultiMethodListForGeneration::constructor_emptyList () ;
    }else{
      result = macroPtr (nodePtr->mObject, cElement)->mListObject ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringset GGS_overridingMultiMethodListMapForGeneration::
reader_allKeys (C_Compiler & /* inLexique */
                COMMA_UNUSED_LOCATION_ARGS) const {

  GGS_stringset result ;
  result.setPointer (_pointer ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringlist GGS_overridingMultiMethodListMapForGeneration::
reader_keyList (C_Compiler & /* inLexique */
                COMMA_UNUSED_LOCATION_ARGS) const {

  GGS_stringlist result ;
  if (isBuilt ()) {
    result = GGS_stringlist::constructor_emptyList () ;
    cPtrDictionary * dictPtr = macroPtr (*this, cPtrDictionary)  ;
    cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
    const PMSInt32 objectCount = dictPtr->count () ;
    for (PMSInt32 i=0 ; i<objectCount ; i++) {
      const GGS_string key = nodeSortedArray [i].key () ;
      result.addAssign_operation (key) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_overridingMultiMethodListMapForGeneration::cEnumerator::
cEnumerator (const GGS_overridingMultiMethodListMapForGeneration & inListMap,
             const bool inAscending) :
cAbstractDictionaryEnumerator (inListMap, inAscending) {
}

//---------------------------------------------------------------------------*

const GGS_overridingMultiMethodListForGeneration & GGS_overridingMultiMethodListMapForGeneration::cEnumerator::
_object (LOCATION_ARGS) const {
  cPtrDictionary * dictPtr = macroPtr (mEnumeratedDictionary, cPtrDictionary)  ;
  MF_AssertThere (currentIndex () >= 0, "Access with negative index %d", currentIndex (), 0) ;
  MF_AssertThere (currentIndex () < dictPtr->count (), "Access with index %d >= count %d", currentIndex (), dictPtr->count ()) ;
  cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
  PM_C_Object listObject = nodeSortedArray [currentIndex ()].mObject ;
  cElement * objectPtr = macroPtr (listObject, cElement) ;
  return objectPtr->mListObject ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_overridingMultiMethodListMapForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_overridingMultiMethodListMapForGeneration * p = NULL ;
    macroMyNew (p, GGS_overridingMultiMethodListMapForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_overridingMultiMethodListMapForGeneration GGS_overridingMultiMethodListMapForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_overridingMultiMethodListMapForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_overridingMultiMethodListMapForGeneration * p = dynamic_cast <const GGS_overridingMultiMethodListMapForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_overridingMultiMethodListMapForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_overridingMultiMethodListMapForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_overridingMultiMethodListMapForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         Element of list '@abstractMultiReaderListForGeneration'           *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_abstractMultiReaderListForGeneration::
elementOf_GGS_abstractMultiReaderListForGeneration (const GGS_lstring & argument_0,
                                const GGS_formalInputParameterListForGeneration & argument_1,
                                const GGS_lstring & argument_2
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mAbstractCategoryReaderName (argument_0),
mAbstractCategoryFormalInputParameterList (argument_1),
mReturnedTypeName (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_abstractMultiReaderListForGeneration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_abstractMultiReaderListForGeneration * ptr = dynamic_cast <const elementOf_GGS_abstractMultiReaderListForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mAbstractCategoryReaderName.operator_isEqual (ptr->mAbstractCategoryReaderName).boolValue ()
         && mAbstractCategoryFormalInputParameterList.operator_isEqual (ptr->mAbstractCategoryFormalInputParameterList).boolValue ()
         && mReturnedTypeName.operator_isEqual (ptr->mReturnedTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_abstractMultiReaderListForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAbstractCategoryReaderName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAbstractCategoryFormalInputParameterList.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mReturnedTypeName.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               List '@abstractMultiReaderListForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_abstractMultiReaderListForGeneration ("abstractMultiReaderListForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_abstractMultiReaderListForGeneration::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_formalInputParameterListForGeneration & argument_1,
                    const GGS_lstring & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_abstractMultiReaderListForGeneration::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_formalInputParameterListForGeneration & argument_1,
                    const GGS_lstring & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_abstractMultiReaderListForGeneration::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_formalInputParameterListForGeneration & argument_1,
                                const GGS_lstring & argument_2) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_abstractMultiReaderListForGeneration GGS_abstractMultiReaderListForGeneration::
operator_concat (const GGS_abstractMultiReaderListForGeneration & inOperand) const {
  GGS_abstractMultiReaderListForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_abstractMultiReaderListForGeneration::
dotAssign_operation (const GGS_abstractMultiReaderListForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_abstractMultiReaderListForGeneration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mAbstractCategoryReaderName ;
          GGS_formalInputParameterListForGeneration  p_1 = p->mAbstractCategoryFormalInputParameterList ;
          GGS_lstring  p_2 = p->mReturnedTypeName ;
          internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractMultiReaderListForGeneration::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_formalInputParameterListForGeneration & argument_1,
                     const GGS_lstring & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractMultiReaderListForGeneration::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mAbstractCategoryReaderName,
                                ptr->mAbstractCategoryFormalInputParameterList,
                                ptr->mReturnedTypeName
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_abstractMultiReaderListForGeneration  GGS_abstractMultiReaderListForGeneration::
constructor_emptyList (void) {
  GGS_abstractMultiReaderListForGeneration result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_abstractMultiReaderListForGeneration  GGS_abstractMultiReaderListForGeneration::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_formalInputParameterListForGeneration & argument_1,
                                const GGS_lstring & argument_2) {
  GGS_abstractMultiReaderListForGeneration result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_abstractMultiReaderListForGeneration::
internalSubListWithRange (GGS_abstractMultiReaderListForGeneration & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mAbstractCategoryReaderName, ptr->mAbstractCategoryFormalInputParameterList, ptr->mReturnedTypeName) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_abstractMultiReaderListForGeneration GGS_abstractMultiReaderListForGeneration::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_abstractMultiReaderListForGeneration result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_abstractMultiReaderListForGeneration GGS_abstractMultiReaderListForGeneration::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_abstractMultiReaderListForGeneration result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_abstractMultiReaderListForGeneration::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@abstractMultiReaderListForGeneration", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_abstractMultiReaderListForGeneration::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_formalInputParameterListForGeneration & _out_1,
              GGS_lstring & _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAbstractCategoryReaderName ;
    _out_1 = ptr->mAbstractCategoryFormalInputParameterList ;
    _out_2 = ptr->mReturnedTypeName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractMultiReaderListForGeneration::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_formalInputParameterListForGeneration & _out_1,
             GGS_lstring & _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAbstractCategoryReaderName ;
    _out_1 = ptr->mAbstractCategoryFormalInputParameterList ;
    _out_2 = ptr->mReturnedTypeName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractMultiReaderListForGeneration::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_formalInputParameterListForGeneration & _out_1,
                 GGS_lstring & _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAbstractCategoryReaderName ;
    _out_1 = ptr->mAbstractCategoryFormalInputParameterList ;
    _out_2 = ptr->mReturnedTypeName ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractMultiReaderListForGeneration::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_formalInputParameterListForGeneration & _out_1,
                GGS_lstring & _out_2
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAbstractCategoryReaderName ;
    _out_1 = ptr->mAbstractCategoryFormalInputParameterList ;
    _out_2 = ptr->mReturnedTypeName ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_abstractMultiReaderListForGeneration::
reader_mAbstractCategoryReaderNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mAbstractCategoryReaderName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalInputParameterListForGeneration  GGS_abstractMultiReaderListForGeneration::
reader_mAbstractCategoryFormalInputParameterListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_formalInputParameterListForGeneration  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mAbstractCategoryFormalInputParameterList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_abstractMultiReaderListForGeneration::
reader_mReturnedTypeNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mReturnedTypeName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_abstractMultiReaderListForGeneration::
modifier_setMAbstractCategoryReaderNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mAbstractCategoryReaderName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractMultiReaderListForGeneration::
modifier_setMAbstractCategoryFormalInputParameterListAtIndex (C_Compiler & inLexique,
                              const GGS_formalInputParameterListForGeneration  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mAbstractCategoryFormalInputParameterList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractMultiReaderListForGeneration::
modifier_setMReturnedTypeNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mReturnedTypeName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_abstractMultiReaderListForGeneration::cEnumerator::_mAbstractCategoryReaderName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mAbstractCategoryReaderName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_formalInputParameterListForGeneration  & GGS_abstractMultiReaderListForGeneration::cEnumerator::_mAbstractCategoryFormalInputParameterList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mAbstractCategoryFormalInputParameterList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_abstractMultiReaderListForGeneration::cEnumerator::_mReturnedTypeName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mReturnedTypeName ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_abstractMultiReaderListForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_abstractMultiReaderListForGeneration * p = NULL ;
    macroMyNew (p, GGS_abstractMultiReaderListForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_abstractMultiReaderListForGeneration GGS_abstractMultiReaderListForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_abstractMultiReaderListForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_abstractMultiReaderListForGeneration * p = dynamic_cast <const GGS_abstractMultiReaderListForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_abstractMultiReaderListForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_abstractMultiReaderListForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_abstractMultiReaderListForGeneration ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_abstractMultiReaderListMapForGeneration ("abstractMultiReaderListMapForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

GGS_abstractMultiReaderListMapForGeneration::cElement::cElement (LOCATION_ARGS) :
cPtrListMapObject (THERE),
mListObject (GGS_abstractMultiReaderListForGeneration::constructor_emptyList ()) {
}

//---------------------------------------------------------------------------*

cPtrObject * GGS_abstractMultiReaderListMapForGeneration::cElement::cloneObject (LOCATION_ARGS) {
  cElement * result = NULL ;
  macroMyNew (result, cElement (THERE)) ;
  result->mListObject = mListObject ;
  return result ;
}

//---------------------------------------------------------------------------*

bool GGS_abstractMultiReaderListMapForGeneration::cElement::isEqual (const cPtrListMapObject * inOperand) const {
  const GGS_bool equal = mListObject.operator_isEqual (((cElement *) inOperand)->mListObject) ;
  return equal.boolValue () ;
}

//---------------------------------------------------------------------------*

C_String GGS_abstractMultiReaderListMapForGeneration::cElement::
performDescription (const PMSInt32 inIndentation) const {
  const GGS_string s = mListObject.reader_description (inIndentation) ;
  return s.string () ;
}

//---------------------------------------------------------------------------*

GGS_abstractMultiReaderListMapForGeneration GGS_abstractMultiReaderListMapForGeneration::
constructor_emptyMap (void) {
  GGS_abstractMultiReaderListMapForGeneration result ;
  result.alloc (HERE) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_abstractMultiReaderListMapForGeneration::
_typeNameForDescriptionReader (void) const {
  return "@abstractMultiReaderListMapForGeneration" ;
}

//---------------------------------------------------------------------------*

GGS_abstractMultiReaderListMapForGeneration GGS_abstractMultiReaderListMapForGeneration::
operator_concat (const GGS_abstractMultiReaderListMapForGeneration & inOperand) const {
  GGS_abstractMultiReaderListMapForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_abstractMultiReaderListMapForGeneration::
dotAssign_operation (const GGS_abstractMultiReaderListMapForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count (HERE) == 0) {
      * this = inOperand ;
    }else if (inOperand.count (HERE) > 0) {
      cPtrDictionary * dictPtr = macroPtr (inOperand, cPtrDictionary)  ;
      cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
      const PMSInt32 objectCount = dictPtr->count () ;
      for (PMSInt32 i=0 ; i<objectCount ; i++) {
        const GGS_string key = nodeSortedArray [i].key () ;
        const PM_C_Object object = nodeSortedArray [i].mObject ;
        cElement * elementPtr = macroPtr (object, cElement) ;
        bool wasInserted = false ;
        cPtrDictionaryNode * nodePtr = findOrAddNodeForKey (key, wasInserted) ;
        if (wasInserted) {
           cElement * p = NULL ;
           macroMyNew (p, cElement (HERE)) ;
           nodePtr->mObject.setPointer (p) ;
        }
        GGS_abstractMultiReaderListForGeneration & listPtr = macroPtr (nodePtr->mObject, cElement)->mListObject ;
        listPtr.dotAssign_operation (elementPtr->mListObject) ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractMultiReaderListMapForGeneration::
addAssign_operation (const GGS_string & inKey,
                      const GGS_lstring & inAttribute0,
                      const GGS_formalInputParameterListForGeneration & inAttribute1,
                      const GGS_lstring & inAttribute2) {
  if (isBuilt () && inKey.isBuilt () && inAttribute0.isBuilt () && inAttribute1.isBuilt () && inAttribute2.isBuilt ()) {
    bool wasInserted = false ;
    cPtrDictionaryNode * nodePtr = findOrAddNodeForKey (inKey, wasInserted) ;
    MF_Assert (nodePtr != NULL, "NULL pointer (was inserted %d)", wasInserted, 0) ;
    if (wasInserted) {
       cElement * p = NULL ;
       macroMyNew (p, cElement (HERE)) ;
       nodePtr->mObject.setPointer (p) ;
    }
    GGS_abstractMultiReaderListForGeneration & listPtr = macroPtr (nodePtr->mObject, cElement)->mListObject ;
    listPtr.addAssign_operation (inAttribute0, inAttribute1, inAttribute2) ;
  }
}

//---------------------------------------------------------------------------*

GGS_abstractMultiReaderListForGeneration GGS_abstractMultiReaderListMapForGeneration::
reader_listForKey (C_Compiler & /* inLexique */,
                   const GGS_string & inKey
                   COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_abstractMultiReaderListForGeneration result ;
  if (isBuilt () && inKey.isBuilt ()) {
    cPtrDictionaryNode * nodePtr = dictionaryNodeForKey (inKey.string ()) ; 
    if (nodePtr == NULL) {
      result = GGS_abstractMultiReaderListForGeneration::constructor_emptyList () ;
    }else{
      result = macroPtr (nodePtr->mObject, cElement)->mListObject ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringset GGS_abstractMultiReaderListMapForGeneration::
reader_allKeys (C_Compiler & /* inLexique */
                COMMA_UNUSED_LOCATION_ARGS) const {

  GGS_stringset result ;
  result.setPointer (_pointer ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringlist GGS_abstractMultiReaderListMapForGeneration::
reader_keyList (C_Compiler & /* inLexique */
                COMMA_UNUSED_LOCATION_ARGS) const {

  GGS_stringlist result ;
  if (isBuilt ()) {
    result = GGS_stringlist::constructor_emptyList () ;
    cPtrDictionary * dictPtr = macroPtr (*this, cPtrDictionary)  ;
    cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
    const PMSInt32 objectCount = dictPtr->count () ;
    for (PMSInt32 i=0 ; i<objectCount ; i++) {
      const GGS_string key = nodeSortedArray [i].key () ;
      result.addAssign_operation (key) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_abstractMultiReaderListMapForGeneration::cEnumerator::
cEnumerator (const GGS_abstractMultiReaderListMapForGeneration & inListMap,
             const bool inAscending) :
cAbstractDictionaryEnumerator (inListMap, inAscending) {
}

//---------------------------------------------------------------------------*

const GGS_abstractMultiReaderListForGeneration & GGS_abstractMultiReaderListMapForGeneration::cEnumerator::
_object (LOCATION_ARGS) const {
  cPtrDictionary * dictPtr = macroPtr (mEnumeratedDictionary, cPtrDictionary)  ;
  MF_AssertThere (currentIndex () >= 0, "Access with negative index %d", currentIndex (), 0) ;
  MF_AssertThere (currentIndex () < dictPtr->count (), "Access with index %d >= count %d", currentIndex (), dictPtr->count ()) ;
  cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
  PM_C_Object listObject = nodeSortedArray [currentIndex ()].mObject ;
  cElement * objectPtr = macroPtr (listObject, cElement) ;
  return objectPtr->mListObject ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_abstractMultiReaderListMapForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_abstractMultiReaderListMapForGeneration * p = NULL ;
    macroMyNew (p, GGS_abstractMultiReaderListMapForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_abstractMultiReaderListMapForGeneration GGS_abstractMultiReaderListMapForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_abstractMultiReaderListMapForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_abstractMultiReaderListMapForGeneration * p = dynamic_cast <const GGS_abstractMultiReaderListMapForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_abstractMultiReaderListMapForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_abstractMultiReaderListMapForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_abstractMultiReaderListMapForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@multiReaderListForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_multiReaderListForGeneration::
elementOf_GGS_multiReaderListForGeneration (const GGS_lstring & argument_0,
                                const GGS_formalInputParameterListForGeneration & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_semanticInstructionListForGeneration & argument_4
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mCategoryReaderName (argument_0),
mReaderCategoryFormalInputParameterList (argument_1),
mReturnedTypeName (argument_2),
mReturnedVariableName (argument_3),
mRoutineInstructionList (argument_4) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_multiReaderListForGeneration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_multiReaderListForGeneration * ptr = dynamic_cast <const elementOf_GGS_multiReaderListForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mCategoryReaderName.operator_isEqual (ptr->mCategoryReaderName).boolValue ()
         && mReaderCategoryFormalInputParameterList.operator_isEqual (ptr->mReaderCategoryFormalInputParameterList).boolValue ()
         && mReturnedTypeName.operator_isEqual (ptr->mReturnedTypeName).boolValue ()
         && mReturnedVariableName.operator_isEqual (ptr->mReturnedVariableName).boolValue ()
         && mRoutineInstructionList.operator_isEqual (ptr->mRoutineInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_multiReaderListForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mCategoryReaderName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mReaderCategoryFormalInputParameterList.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mReturnedTypeName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mReturnedVariableName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRoutineInstructionList.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@multiReaderListForGeneration'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_multiReaderListForGeneration ("multiReaderListForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_multiReaderListForGeneration::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_formalInputParameterListForGeneration & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_lstring & argument_3,
                    const GGS_semanticInstructionListForGeneration & argument_4
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_multiReaderListForGeneration::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_formalInputParameterListForGeneration & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_lstring & argument_3,
                    const GGS_semanticInstructionListForGeneration & argument_4
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_multiReaderListForGeneration::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_formalInputParameterListForGeneration & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_semanticInstructionListForGeneration & argument_4) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()&& argument_3.isBuilt ()&& argument_4.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_multiReaderListForGeneration GGS_multiReaderListForGeneration::
operator_concat (const GGS_multiReaderListForGeneration & inOperand) const {
  GGS_multiReaderListForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_multiReaderListForGeneration::
dotAssign_operation (const GGS_multiReaderListForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_multiReaderListForGeneration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mCategoryReaderName ;
          GGS_formalInputParameterListForGeneration  p_1 = p->mReaderCategoryFormalInputParameterList ;
          GGS_lstring  p_2 = p->mReturnedTypeName ;
          GGS_lstring  p_3 = p->mReturnedVariableName ;
          GGS_semanticInstructionListForGeneration  p_4 = p->mRoutineInstructionList ;
          internalAppendValues (p_0, p_1, p_2, p_3, p_4 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_multiReaderListForGeneration::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_formalInputParameterListForGeneration & argument_1,
                     const GGS_lstring & argument_2,
                     const GGS_lstring & argument_3,
                     const GGS_semanticInstructionListForGeneration & argument_4
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_multiReaderListForGeneration::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mCategoryReaderName,
                                ptr->mReaderCategoryFormalInputParameterList,
                                ptr->mReturnedTypeName,
                                ptr->mReturnedVariableName,
                                ptr->mRoutineInstructionList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_multiReaderListForGeneration  GGS_multiReaderListForGeneration::
constructor_emptyList (void) {
  GGS_multiReaderListForGeneration result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_multiReaderListForGeneration  GGS_multiReaderListForGeneration::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_formalInputParameterListForGeneration & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_semanticInstructionListForGeneration & argument_4) {
  GGS_multiReaderListForGeneration result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2, argument_3, argument_4) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_multiReaderListForGeneration::
internalSubListWithRange (GGS_multiReaderListForGeneration & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mCategoryReaderName, ptr->mReaderCategoryFormalInputParameterList, ptr->mReturnedTypeName, ptr->mReturnedVariableName, ptr->mRoutineInstructionList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_multiReaderListForGeneration GGS_multiReaderListForGeneration::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_multiReaderListForGeneration result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_multiReaderListForGeneration GGS_multiReaderListForGeneration::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_multiReaderListForGeneration result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_multiReaderListForGeneration::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@multiReaderListForGeneration", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_multiReaderListForGeneration::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_formalInputParameterListForGeneration & _out_1,
              GGS_lstring & _out_2,
              GGS_lstring & _out_3,
              GGS_semanticInstructionListForGeneration & _out_4
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mCategoryReaderName ;
    _out_1 = ptr->mReaderCategoryFormalInputParameterList ;
    _out_2 = ptr->mReturnedTypeName ;
    _out_3 = ptr->mReturnedVariableName ;
    _out_4 = ptr->mRoutineInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_multiReaderListForGeneration::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_formalInputParameterListForGeneration & _out_1,
             GGS_lstring & _out_2,
             GGS_lstring & _out_3,
             GGS_semanticInstructionListForGeneration & _out_4
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mCategoryReaderName ;
    _out_1 = ptr->mReaderCategoryFormalInputParameterList ;
    _out_2 = ptr->mReturnedTypeName ;
    _out_3 = ptr->mReturnedVariableName ;
    _out_4 = ptr->mRoutineInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_multiReaderListForGeneration::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_formalInputParameterListForGeneration & _out_1,
                 GGS_lstring & _out_2,
                 GGS_lstring & _out_3,
                 GGS_semanticInstructionListForGeneration & _out_4
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mCategoryReaderName ;
    _out_1 = ptr->mReaderCategoryFormalInputParameterList ;
    _out_2 = ptr->mReturnedTypeName ;
    _out_3 = ptr->mReturnedVariableName ;
    _out_4 = ptr->mRoutineInstructionList ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_multiReaderListForGeneration::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_formalInputParameterListForGeneration & _out_1,
                GGS_lstring & _out_2,
                GGS_lstring & _out_3,
                GGS_semanticInstructionListForGeneration & _out_4
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mCategoryReaderName ;
    _out_1 = ptr->mReaderCategoryFormalInputParameterList ;
    _out_2 = ptr->mReturnedTypeName ;
    _out_3 = ptr->mReturnedVariableName ;
    _out_4 = ptr->mRoutineInstructionList ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_multiReaderListForGeneration::
reader_mCategoryReaderNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mCategoryReaderName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalInputParameterListForGeneration  GGS_multiReaderListForGeneration::
reader_mReaderCategoryFormalInputParameterListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_formalInputParameterListForGeneration  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mReaderCategoryFormalInputParameterList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_multiReaderListForGeneration::
reader_mReturnedTypeNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mReturnedTypeName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_multiReaderListForGeneration::
reader_mReturnedVariableNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mReturnedVariableName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration  GGS_multiReaderListForGeneration::
reader_mRoutineInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticInstructionListForGeneration  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mRoutineInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_multiReaderListForGeneration::
modifier_setMCategoryReaderNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mCategoryReaderName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_multiReaderListForGeneration::
modifier_setMReaderCategoryFormalInputParameterListAtIndex (C_Compiler & inLexique,
                              const GGS_formalInputParameterListForGeneration  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mReaderCategoryFormalInputParameterList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_multiReaderListForGeneration::
modifier_setMReturnedTypeNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mReturnedTypeName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_multiReaderListForGeneration::
modifier_setMReturnedVariableNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mReturnedVariableName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_multiReaderListForGeneration::
modifier_setMRoutineInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_semanticInstructionListForGeneration  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mRoutineInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_multiReaderListForGeneration::cEnumerator::_mCategoryReaderName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mCategoryReaderName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_formalInputParameterListForGeneration  & GGS_multiReaderListForGeneration::cEnumerator::_mReaderCategoryFormalInputParameterList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mReaderCategoryFormalInputParameterList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_multiReaderListForGeneration::cEnumerator::_mReturnedTypeName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mReturnedTypeName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_multiReaderListForGeneration::cEnumerator::_mReturnedVariableName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mReturnedVariableName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticInstructionListForGeneration  & GGS_multiReaderListForGeneration::cEnumerator::_mRoutineInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mRoutineInstructionList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_multiReaderListForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_multiReaderListForGeneration * p = NULL ;
    macroMyNew (p, GGS_multiReaderListForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_multiReaderListForGeneration GGS_multiReaderListForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_multiReaderListForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_multiReaderListForGeneration * p = dynamic_cast <const GGS_multiReaderListForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_multiReaderListForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_multiReaderListForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_multiReaderListForGeneration ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_multiReaderListMapForGeneration ("multiReaderListMapForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

GGS_multiReaderListMapForGeneration::cElement::cElement (LOCATION_ARGS) :
cPtrListMapObject (THERE),
mListObject (GGS_multiReaderListForGeneration::constructor_emptyList ()) {
}

//---------------------------------------------------------------------------*

cPtrObject * GGS_multiReaderListMapForGeneration::cElement::cloneObject (LOCATION_ARGS) {
  cElement * result = NULL ;
  macroMyNew (result, cElement (THERE)) ;
  result->mListObject = mListObject ;
  return result ;
}

//---------------------------------------------------------------------------*

bool GGS_multiReaderListMapForGeneration::cElement::isEqual (const cPtrListMapObject * inOperand) const {
  const GGS_bool equal = mListObject.operator_isEqual (((cElement *) inOperand)->mListObject) ;
  return equal.boolValue () ;
}

//---------------------------------------------------------------------------*

C_String GGS_multiReaderListMapForGeneration::cElement::
performDescription (const PMSInt32 inIndentation) const {
  const GGS_string s = mListObject.reader_description (inIndentation) ;
  return s.string () ;
}

//---------------------------------------------------------------------------*

GGS_multiReaderListMapForGeneration GGS_multiReaderListMapForGeneration::
constructor_emptyMap (void) {
  GGS_multiReaderListMapForGeneration result ;
  result.alloc (HERE) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_multiReaderListMapForGeneration::
_typeNameForDescriptionReader (void) const {
  return "@multiReaderListMapForGeneration" ;
}

//---------------------------------------------------------------------------*

GGS_multiReaderListMapForGeneration GGS_multiReaderListMapForGeneration::
operator_concat (const GGS_multiReaderListMapForGeneration & inOperand) const {
  GGS_multiReaderListMapForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_multiReaderListMapForGeneration::
dotAssign_operation (const GGS_multiReaderListMapForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count (HERE) == 0) {
      * this = inOperand ;
    }else if (inOperand.count (HERE) > 0) {
      cPtrDictionary * dictPtr = macroPtr (inOperand, cPtrDictionary)  ;
      cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
      const PMSInt32 objectCount = dictPtr->count () ;
      for (PMSInt32 i=0 ; i<objectCount ; i++) {
        const GGS_string key = nodeSortedArray [i].key () ;
        const PM_C_Object object = nodeSortedArray [i].mObject ;
        cElement * elementPtr = macroPtr (object, cElement) ;
        bool wasInserted = false ;
        cPtrDictionaryNode * nodePtr = findOrAddNodeForKey (key, wasInserted) ;
        if (wasInserted) {
           cElement * p = NULL ;
           macroMyNew (p, cElement (HERE)) ;
           nodePtr->mObject.setPointer (p) ;
        }
        GGS_multiReaderListForGeneration & listPtr = macroPtr (nodePtr->mObject, cElement)->mListObject ;
        listPtr.dotAssign_operation (elementPtr->mListObject) ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_multiReaderListMapForGeneration::
addAssign_operation (const GGS_string & inKey,
                      const GGS_lstring & inAttribute0,
                      const GGS_formalInputParameterListForGeneration & inAttribute1,
                      const GGS_lstring & inAttribute2,
                      const GGS_lstring & inAttribute3,
                      const GGS_semanticInstructionListForGeneration & inAttribute4) {
  if (isBuilt () && inKey.isBuilt () && inAttribute0.isBuilt () && inAttribute1.isBuilt () && inAttribute2.isBuilt () && inAttribute3.isBuilt () && inAttribute4.isBuilt ()) {
    bool wasInserted = false ;
    cPtrDictionaryNode * nodePtr = findOrAddNodeForKey (inKey, wasInserted) ;
    MF_Assert (nodePtr != NULL, "NULL pointer (was inserted %d)", wasInserted, 0) ;
    if (wasInserted) {
       cElement * p = NULL ;
       macroMyNew (p, cElement (HERE)) ;
       nodePtr->mObject.setPointer (p) ;
    }
    GGS_multiReaderListForGeneration & listPtr = macroPtr (nodePtr->mObject, cElement)->mListObject ;
    listPtr.addAssign_operation (inAttribute0, inAttribute1, inAttribute2, inAttribute3, inAttribute4) ;
  }
}

//---------------------------------------------------------------------------*

GGS_multiReaderListForGeneration GGS_multiReaderListMapForGeneration::
reader_listForKey (C_Compiler & /* inLexique */,
                   const GGS_string & inKey
                   COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_multiReaderListForGeneration result ;
  if (isBuilt () && inKey.isBuilt ()) {
    cPtrDictionaryNode * nodePtr = dictionaryNodeForKey (inKey.string ()) ; 
    if (nodePtr == NULL) {
      result = GGS_multiReaderListForGeneration::constructor_emptyList () ;
    }else{
      result = macroPtr (nodePtr->mObject, cElement)->mListObject ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringset GGS_multiReaderListMapForGeneration::
reader_allKeys (C_Compiler & /* inLexique */
                COMMA_UNUSED_LOCATION_ARGS) const {

  GGS_stringset result ;
  result.setPointer (_pointer ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringlist GGS_multiReaderListMapForGeneration::
reader_keyList (C_Compiler & /* inLexique */
                COMMA_UNUSED_LOCATION_ARGS) const {

  GGS_stringlist result ;
  if (isBuilt ()) {
    result = GGS_stringlist::constructor_emptyList () ;
    cPtrDictionary * dictPtr = macroPtr (*this, cPtrDictionary)  ;
    cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
    const PMSInt32 objectCount = dictPtr->count () ;
    for (PMSInt32 i=0 ; i<objectCount ; i++) {
      const GGS_string key = nodeSortedArray [i].key () ;
      result.addAssign_operation (key) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_multiReaderListMapForGeneration::cEnumerator::
cEnumerator (const GGS_multiReaderListMapForGeneration & inListMap,
             const bool inAscending) :
cAbstractDictionaryEnumerator (inListMap, inAscending) {
}

//---------------------------------------------------------------------------*

const GGS_multiReaderListForGeneration & GGS_multiReaderListMapForGeneration::cEnumerator::
_object (LOCATION_ARGS) const {
  cPtrDictionary * dictPtr = macroPtr (mEnumeratedDictionary, cPtrDictionary)  ;
  MF_AssertThere (currentIndex () >= 0, "Access with negative index %d", currentIndex (), 0) ;
  MF_AssertThere (currentIndex () < dictPtr->count (), "Access with index %d >= count %d", currentIndex (), dictPtr->count ()) ;
  cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
  PM_C_Object listObject = nodeSortedArray [currentIndex ()].mObject ;
  cElement * objectPtr = macroPtr (listObject, cElement) ;
  return objectPtr->mListObject ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_multiReaderListMapForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_multiReaderListMapForGeneration * p = NULL ;
    macroMyNew (p, GGS_multiReaderListMapForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_multiReaderListMapForGeneration GGS_multiReaderListMapForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_multiReaderListMapForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_multiReaderListMapForGeneration * p = dynamic_cast <const GGS_multiReaderListMapForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_multiReaderListMapForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_multiReaderListMapForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_multiReaderListMapForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        Element of list '@overridingMultiReaderListForGeneration'          *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_overridingMultiReaderListForGeneration::
elementOf_GGS_overridingMultiReaderListForGeneration (const GGS_lstring & argument_0,
                                const GGS_formalInputParameterListForGeneration & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_semanticInstructionListForGeneration & argument_4
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mOverridingCategoryReaderName (argument_0),
mOverridingReaderFormalInputParameterList (argument_1),
mReturnedTypeName (argument_2),
mReturnedVariableName (argument_3),
mRoutineInstructionList (argument_4) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_overridingMultiReaderListForGeneration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_overridingMultiReaderListForGeneration * ptr = dynamic_cast <const elementOf_GGS_overridingMultiReaderListForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOverridingCategoryReaderName.operator_isEqual (ptr->mOverridingCategoryReaderName).boolValue ()
         && mOverridingReaderFormalInputParameterList.operator_isEqual (ptr->mOverridingReaderFormalInputParameterList).boolValue ()
         && mReturnedTypeName.operator_isEqual (ptr->mReturnedTypeName).boolValue ()
         && mReturnedVariableName.operator_isEqual (ptr->mReturnedVariableName).boolValue ()
         && mRoutineInstructionList.operator_isEqual (ptr->mRoutineInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_overridingMultiReaderListForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOverridingCategoryReaderName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOverridingReaderFormalInputParameterList.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mReturnedTypeName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mReturnedVariableName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRoutineInstructionList.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              List '@overridingMultiReaderListForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_overridingMultiReaderListForGeneration ("overridingMultiReaderListForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_overridingMultiReaderListForGeneration::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_formalInputParameterListForGeneration & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_lstring & argument_3,
                    const GGS_semanticInstructionListForGeneration & argument_4
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiReaderListForGeneration::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_formalInputParameterListForGeneration & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_lstring & argument_3,
                    const GGS_semanticInstructionListForGeneration & argument_4
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiReaderListForGeneration::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_formalInputParameterListForGeneration & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_semanticInstructionListForGeneration & argument_4) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()&& argument_3.isBuilt ()&& argument_4.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_overridingMultiReaderListForGeneration GGS_overridingMultiReaderListForGeneration::
operator_concat (const GGS_overridingMultiReaderListForGeneration & inOperand) const {
  GGS_overridingMultiReaderListForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiReaderListForGeneration::
dotAssign_operation (const GGS_overridingMultiReaderListForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_overridingMultiReaderListForGeneration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mOverridingCategoryReaderName ;
          GGS_formalInputParameterListForGeneration  p_1 = p->mOverridingReaderFormalInputParameterList ;
          GGS_lstring  p_2 = p->mReturnedTypeName ;
          GGS_lstring  p_3 = p->mReturnedVariableName ;
          GGS_semanticInstructionListForGeneration  p_4 = p->mRoutineInstructionList ;
          internalAppendValues (p_0, p_1, p_2, p_3, p_4 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiReaderListForGeneration::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_formalInputParameterListForGeneration & argument_1,
                     const GGS_lstring & argument_2,
                     const GGS_lstring & argument_3,
                     const GGS_semanticInstructionListForGeneration & argument_4
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiReaderListForGeneration::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mOverridingCategoryReaderName,
                                ptr->mOverridingReaderFormalInputParameterList,
                                ptr->mReturnedTypeName,
                                ptr->mReturnedVariableName,
                                ptr->mRoutineInstructionList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_overridingMultiReaderListForGeneration  GGS_overridingMultiReaderListForGeneration::
constructor_emptyList (void) {
  GGS_overridingMultiReaderListForGeneration result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_overridingMultiReaderListForGeneration  GGS_overridingMultiReaderListForGeneration::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_formalInputParameterListForGeneration & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_semanticInstructionListForGeneration & argument_4) {
  GGS_overridingMultiReaderListForGeneration result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2, argument_3, argument_4) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiReaderListForGeneration::
internalSubListWithRange (GGS_overridingMultiReaderListForGeneration & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mOverridingCategoryReaderName, ptr->mOverridingReaderFormalInputParameterList, ptr->mReturnedTypeName, ptr->mReturnedVariableName, ptr->mRoutineInstructionList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_overridingMultiReaderListForGeneration GGS_overridingMultiReaderListForGeneration::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_overridingMultiReaderListForGeneration result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_overridingMultiReaderListForGeneration GGS_overridingMultiReaderListForGeneration::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_overridingMultiReaderListForGeneration result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_overridingMultiReaderListForGeneration::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@overridingMultiReaderListForGeneration", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiReaderListForGeneration::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_formalInputParameterListForGeneration & _out_1,
              GGS_lstring & _out_2,
              GGS_lstring & _out_3,
              GGS_semanticInstructionListForGeneration & _out_4
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mOverridingCategoryReaderName ;
    _out_1 = ptr->mOverridingReaderFormalInputParameterList ;
    _out_2 = ptr->mReturnedTypeName ;
    _out_3 = ptr->mReturnedVariableName ;
    _out_4 = ptr->mRoutineInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiReaderListForGeneration::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_formalInputParameterListForGeneration & _out_1,
             GGS_lstring & _out_2,
             GGS_lstring & _out_3,
             GGS_semanticInstructionListForGeneration & _out_4
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mOverridingCategoryReaderName ;
    _out_1 = ptr->mOverridingReaderFormalInputParameterList ;
    _out_2 = ptr->mReturnedTypeName ;
    _out_3 = ptr->mReturnedVariableName ;
    _out_4 = ptr->mRoutineInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiReaderListForGeneration::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_formalInputParameterListForGeneration & _out_1,
                 GGS_lstring & _out_2,
                 GGS_lstring & _out_3,
                 GGS_semanticInstructionListForGeneration & _out_4
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mOverridingCategoryReaderName ;
    _out_1 = ptr->mOverridingReaderFormalInputParameterList ;
    _out_2 = ptr->mReturnedTypeName ;
    _out_3 = ptr->mReturnedVariableName ;
    _out_4 = ptr->mRoutineInstructionList ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiReaderListForGeneration::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_formalInputParameterListForGeneration & _out_1,
                GGS_lstring & _out_2,
                GGS_lstring & _out_3,
                GGS_semanticInstructionListForGeneration & _out_4
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mOverridingCategoryReaderName ;
    _out_1 = ptr->mOverridingReaderFormalInputParameterList ;
    _out_2 = ptr->mReturnedTypeName ;
    _out_3 = ptr->mReturnedVariableName ;
    _out_4 = ptr->mRoutineInstructionList ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_overridingMultiReaderListForGeneration::
reader_mOverridingCategoryReaderNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mOverridingCategoryReaderName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalInputParameterListForGeneration  GGS_overridingMultiReaderListForGeneration::
reader_mOverridingReaderFormalInputParameterListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_formalInputParameterListForGeneration  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mOverridingReaderFormalInputParameterList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_overridingMultiReaderListForGeneration::
reader_mReturnedTypeNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mReturnedTypeName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_overridingMultiReaderListForGeneration::
reader_mReturnedVariableNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mReturnedVariableName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration  GGS_overridingMultiReaderListForGeneration::
reader_mRoutineInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticInstructionListForGeneration  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mRoutineInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiReaderListForGeneration::
modifier_setMOverridingCategoryReaderNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mOverridingCategoryReaderName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiReaderListForGeneration::
modifier_setMOverridingReaderFormalInputParameterListAtIndex (C_Compiler & inLexique,
                              const GGS_formalInputParameterListForGeneration  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mOverridingReaderFormalInputParameterList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiReaderListForGeneration::
modifier_setMReturnedTypeNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mReturnedTypeName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiReaderListForGeneration::
modifier_setMReturnedVariableNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mReturnedVariableName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiReaderListForGeneration::
modifier_setMRoutineInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_semanticInstructionListForGeneration  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mRoutineInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_overridingMultiReaderListForGeneration::cEnumerator::_mOverridingCategoryReaderName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mOverridingCategoryReaderName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_formalInputParameterListForGeneration  & GGS_overridingMultiReaderListForGeneration::cEnumerator::_mOverridingReaderFormalInputParameterList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mOverridingReaderFormalInputParameterList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_overridingMultiReaderListForGeneration::cEnumerator::_mReturnedTypeName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mReturnedTypeName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_overridingMultiReaderListForGeneration::cEnumerator::_mReturnedVariableName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mReturnedVariableName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticInstructionListForGeneration  & GGS_overridingMultiReaderListForGeneration::cEnumerator::_mRoutineInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mRoutineInstructionList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_overridingMultiReaderListForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_overridingMultiReaderListForGeneration * p = NULL ;
    macroMyNew (p, GGS_overridingMultiReaderListForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_overridingMultiReaderListForGeneration GGS_overridingMultiReaderListForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_overridingMultiReaderListForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_overridingMultiReaderListForGeneration * p = dynamic_cast <const GGS_overridingMultiReaderListForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_overridingMultiReaderListForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_overridingMultiReaderListForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_overridingMultiReaderListForGeneration ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_overridingMultiReaderListMapForGeneration ("overridingMultiReaderListMapForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

GGS_overridingMultiReaderListMapForGeneration::cElement::cElement (LOCATION_ARGS) :
cPtrListMapObject (THERE),
mListObject (GGS_overridingMultiReaderListForGeneration::constructor_emptyList ()) {
}

//---------------------------------------------------------------------------*

cPtrObject * GGS_overridingMultiReaderListMapForGeneration::cElement::cloneObject (LOCATION_ARGS) {
  cElement * result = NULL ;
  macroMyNew (result, cElement (THERE)) ;
  result->mListObject = mListObject ;
  return result ;
}

//---------------------------------------------------------------------------*

bool GGS_overridingMultiReaderListMapForGeneration::cElement::isEqual (const cPtrListMapObject * inOperand) const {
  const GGS_bool equal = mListObject.operator_isEqual (((cElement *) inOperand)->mListObject) ;
  return equal.boolValue () ;
}

//---------------------------------------------------------------------------*

C_String GGS_overridingMultiReaderListMapForGeneration::cElement::
performDescription (const PMSInt32 inIndentation) const {
  const GGS_string s = mListObject.reader_description (inIndentation) ;
  return s.string () ;
}

//---------------------------------------------------------------------------*

GGS_overridingMultiReaderListMapForGeneration GGS_overridingMultiReaderListMapForGeneration::
constructor_emptyMap (void) {
  GGS_overridingMultiReaderListMapForGeneration result ;
  result.alloc (HERE) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_overridingMultiReaderListMapForGeneration::
_typeNameForDescriptionReader (void) const {
  return "@overridingMultiReaderListMapForGeneration" ;
}

//---------------------------------------------------------------------------*

GGS_overridingMultiReaderListMapForGeneration GGS_overridingMultiReaderListMapForGeneration::
operator_concat (const GGS_overridingMultiReaderListMapForGeneration & inOperand) const {
  GGS_overridingMultiReaderListMapForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiReaderListMapForGeneration::
dotAssign_operation (const GGS_overridingMultiReaderListMapForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count (HERE) == 0) {
      * this = inOperand ;
    }else if (inOperand.count (HERE) > 0) {
      cPtrDictionary * dictPtr = macroPtr (inOperand, cPtrDictionary)  ;
      cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
      const PMSInt32 objectCount = dictPtr->count () ;
      for (PMSInt32 i=0 ; i<objectCount ; i++) {
        const GGS_string key = nodeSortedArray [i].key () ;
        const PM_C_Object object = nodeSortedArray [i].mObject ;
        cElement * elementPtr = macroPtr (object, cElement) ;
        bool wasInserted = false ;
        cPtrDictionaryNode * nodePtr = findOrAddNodeForKey (key, wasInserted) ;
        if (wasInserted) {
           cElement * p = NULL ;
           macroMyNew (p, cElement (HERE)) ;
           nodePtr->mObject.setPointer (p) ;
        }
        GGS_overridingMultiReaderListForGeneration & listPtr = macroPtr (nodePtr->mObject, cElement)->mListObject ;
        listPtr.dotAssign_operation (elementPtr->mListObject) ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiReaderListMapForGeneration::
addAssign_operation (const GGS_string & inKey,
                      const GGS_lstring & inAttribute0,
                      const GGS_formalInputParameterListForGeneration & inAttribute1,
                      const GGS_lstring & inAttribute2,
                      const GGS_lstring & inAttribute3,
                      const GGS_semanticInstructionListForGeneration & inAttribute4) {
  if (isBuilt () && inKey.isBuilt () && inAttribute0.isBuilt () && inAttribute1.isBuilt () && inAttribute2.isBuilt () && inAttribute3.isBuilt () && inAttribute4.isBuilt ()) {
    bool wasInserted = false ;
    cPtrDictionaryNode * nodePtr = findOrAddNodeForKey (inKey, wasInserted) ;
    MF_Assert (nodePtr != NULL, "NULL pointer (was inserted %d)", wasInserted, 0) ;
    if (wasInserted) {
       cElement * p = NULL ;
       macroMyNew (p, cElement (HERE)) ;
       nodePtr->mObject.setPointer (p) ;
    }
    GGS_overridingMultiReaderListForGeneration & listPtr = macroPtr (nodePtr->mObject, cElement)->mListObject ;
    listPtr.addAssign_operation (inAttribute0, inAttribute1, inAttribute2, inAttribute3, inAttribute4) ;
  }
}

//---------------------------------------------------------------------------*

GGS_overridingMultiReaderListForGeneration GGS_overridingMultiReaderListMapForGeneration::
reader_listForKey (C_Compiler & /* inLexique */,
                   const GGS_string & inKey
                   COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_overridingMultiReaderListForGeneration result ;
  if (isBuilt () && inKey.isBuilt ()) {
    cPtrDictionaryNode * nodePtr = dictionaryNodeForKey (inKey.string ()) ; 
    if (nodePtr == NULL) {
      result = GGS_overridingMultiReaderListForGeneration::constructor_emptyList () ;
    }else{
      result = macroPtr (nodePtr->mObject, cElement)->mListObject ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringset GGS_overridingMultiReaderListMapForGeneration::
reader_allKeys (C_Compiler & /* inLexique */
                COMMA_UNUSED_LOCATION_ARGS) const {

  GGS_stringset result ;
  result.setPointer (_pointer ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringlist GGS_overridingMultiReaderListMapForGeneration::
reader_keyList (C_Compiler & /* inLexique */
                COMMA_UNUSED_LOCATION_ARGS) const {

  GGS_stringlist result ;
  if (isBuilt ()) {
    result = GGS_stringlist::constructor_emptyList () ;
    cPtrDictionary * dictPtr = macroPtr (*this, cPtrDictionary)  ;
    cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
    const PMSInt32 objectCount = dictPtr->count () ;
    for (PMSInt32 i=0 ; i<objectCount ; i++) {
      const GGS_string key = nodeSortedArray [i].key () ;
      result.addAssign_operation (key) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_overridingMultiReaderListMapForGeneration::cEnumerator::
cEnumerator (const GGS_overridingMultiReaderListMapForGeneration & inListMap,
             const bool inAscending) :
cAbstractDictionaryEnumerator (inListMap, inAscending) {
}

//---------------------------------------------------------------------------*

const GGS_overridingMultiReaderListForGeneration & GGS_overridingMultiReaderListMapForGeneration::cEnumerator::
_object (LOCATION_ARGS) const {
  cPtrDictionary * dictPtr = macroPtr (mEnumeratedDictionary, cPtrDictionary)  ;
  MF_AssertThere (currentIndex () >= 0, "Access with negative index %d", currentIndex (), 0) ;
  MF_AssertThere (currentIndex () < dictPtr->count (), "Access with index %d >= count %d", currentIndex (), dictPtr->count ()) ;
  cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
  PM_C_Object listObject = nodeSortedArray [currentIndex ()].mObject ;
  cElement * objectPtr = macroPtr (listObject, cElement) ;
  return objectPtr->mListObject ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_overridingMultiReaderListMapForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_overridingMultiReaderListMapForGeneration * p = NULL ;
    macroMyNew (p, GGS_overridingMultiReaderListMapForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_overridingMultiReaderListMapForGeneration GGS_overridingMultiReaderListMapForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_overridingMultiReaderListMapForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_overridingMultiReaderListMapForGeneration * p = dynamic_cast <const GGS_overridingMultiReaderListMapForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_overridingMultiReaderListMapForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_overridingMultiReaderListMapForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_overridingMultiReaderListMapForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//    Implementation of 'semanticDeclarationStructForGeneration' struct      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_semanticDeclarationStructForGeneration ("semanticDeclarationStructForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

GGS_semanticDeclarationStructForGeneration::GGS_semanticDeclarationStructForGeneration (void) :
mSemanticDeclarationList (),
mAbstractCategoryMethodListMap (),
mCategoryMethodListMap (),
mOverridingCategoryMethodListMap (),
mAbstractCategoryReaderListMap (),
mCategoryReaderListMap (),
mOverridingCategoryReaderListMap () {
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationStructForGeneration::~GGS_semanticDeclarationStructForGeneration (void) {
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationStructForGeneration::drop (void) {
  mSemanticDeclarationList.drop () ;
  mAbstractCategoryMethodListMap.drop () ;
  mCategoryMethodListMap.drop () ;
  mOverridingCategoryMethodListMap.drop () ;
  mAbstractCategoryReaderListMap.drop () ;
  mCategoryReaderListMap.drop () ;
  mOverridingCategoryReaderListMap.drop () ;
}

//---------------------------------------------------------------------------*

bool GGS_semanticDeclarationStructForGeneration::isBuilt (void) const {
  return mSemanticDeclarationList.isBuilt ()
    && mAbstractCategoryMethodListMap.isBuilt ()
    && mCategoryMethodListMap.isBuilt ()
    && mOverridingCategoryMethodListMap.isBuilt ()
    && mAbstractCategoryReaderListMap.isBuilt ()
    && mCategoryReaderListMap.isBuilt ()
    && mOverridingCategoryReaderListMap.isBuilt () ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_semanticDeclarationStructForGeneration::
operator_isEqual (const GGS_semanticDeclarationStructForGeneration & inOperand) const {
  return mSemanticDeclarationList.operator_isEqual (inOperand.mSemanticDeclarationList)
    .operator_and (mAbstractCategoryMethodListMap.operator_isEqual (inOperand.mAbstractCategoryMethodListMap))
    .operator_and (mCategoryMethodListMap.operator_isEqual (inOperand.mCategoryMethodListMap))
    .operator_and (mOverridingCategoryMethodListMap.operator_isEqual (inOperand.mOverridingCategoryMethodListMap))
    .operator_and (mAbstractCategoryReaderListMap.operator_isEqual (inOperand.mAbstractCategoryReaderListMap))
    .operator_and (mCategoryReaderListMap.operator_isEqual (inOperand.mCategoryReaderListMap))
    .operator_and (mOverridingCategoryReaderListMap.operator_isEqual (inOperand.mOverridingCategoryReaderListMap)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_semanticDeclarationStructForGeneration::
operator_isNotEqual (const GGS_semanticDeclarationStructForGeneration & inOperand) const {
  return mSemanticDeclarationList.operator_isNotEqual (inOperand.mSemanticDeclarationList)
    .operator_or (mAbstractCategoryMethodListMap.operator_isNotEqual (inOperand.mAbstractCategoryMethodListMap))
    .operator_or (mCategoryMethodListMap.operator_isNotEqual (inOperand.mCategoryMethodListMap))
    .operator_or (mOverridingCategoryMethodListMap.operator_isNotEqual (inOperand.mOverridingCategoryMethodListMap))
    .operator_or (mAbstractCategoryReaderListMap.operator_isNotEqual (inOperand.mAbstractCategoryReaderListMap))
    .operator_or (mCategoryReaderListMap.operator_isNotEqual (inOperand.mCategoryReaderListMap))
    .operator_or (mOverridingCategoryReaderListMap.operator_isNotEqual (inOperand.mOverridingCategoryReaderListMap)) ;
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationStructForGeneration GGS_semanticDeclarationStructForGeneration::
constructor_new (const GGS_semanticDeclarationListForGeneration & argument_0,
                 const GGS_abstractMultiMethodListMapForGeneration& argument_1,
                 const GGS_multiMethodListMapForGeneration& argument_2,
                 const GGS_overridingMultiMethodListMapForGeneration& argument_3,
                 const GGS_abstractMultiReaderListMapForGeneration& argument_4,
                 const GGS_multiReaderListMapForGeneration& argument_5,
                 const GGS_overridingMultiReaderListMapForGeneration& argument_6) {
  GGS_semanticDeclarationStructForGeneration result ;
  result.mSemanticDeclarationList = argument_0 ;
  result.mAbstractCategoryMethodListMap = argument_1 ;
  result.mCategoryMethodListMap = argument_2 ;
  result.mOverridingCategoryMethodListMap = argument_3 ;
  result.mAbstractCategoryReaderListMap = argument_4 ;
  result.mCategoryReaderListMap = argument_5 ;
  result.mOverridingCategoryReaderListMap = argument_6 ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_semanticDeclarationStructForGeneration::
reader_description (const PMSInt32 inIndentation) const {
  C_String _s ;
  _s << "<struct @semanticDeclarationStructForGeneration" ;
  if (isBuilt ()) {
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mSemanticDeclarationList " ;
    _s << mSemanticDeclarationList.reader_description (inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mAbstractCategoryMethodListMap " ;
    _s << mAbstractCategoryMethodListMap.reader_description (inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mCategoryMethodListMap " ;
    _s << mCategoryMethodListMap.reader_description (inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mOverridingCategoryMethodListMap " ;
    _s << mOverridingCategoryMethodListMap.reader_description (inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mAbstractCategoryReaderListMap " ;
    _s << mAbstractCategoryReaderListMap.reader_description (inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mCategoryReaderListMap " ;
    _s << mCategoryReaderListMap.reader_description (inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mOverridingCategoryReaderListMap " ;
    _s << mOverridingCategoryReaderListMap.reader_description (inIndentation + 1) ;
  }else{
    _s << "not built" ;
  }
  _s << "\n" ;
  _s.writeStringMultiple ("| ", inIndentation) ;
  _s << ">" ;
  return GGS_string (true, _s) ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_semanticDeclarationStructForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_semanticDeclarationStructForGeneration * p = NULL ;
    macroMyNew (p, GGS_semanticDeclarationStructForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationStructForGeneration GGS_semanticDeclarationStructForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_semanticDeclarationStructForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_semanticDeclarationStructForGeneration * p = dynamic_cast <const GGS_semanticDeclarationStructForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_semanticDeclarationStructForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_semanticDeclarationStructForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_semanticDeclarationStructForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        Element of list '@attributeInCollectionListForGeneration'          *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_attributeInCollectionListForGeneration::
elementOf_GGS_attributeInCollectionListForGeneration (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstringlist & argument_2
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mAttributeTypeName (argument_0),
mAttributeName (argument_1),
mFeatureList (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_attributeInCollectionListForGeneration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_attributeInCollectionListForGeneration * ptr = dynamic_cast <const elementOf_GGS_attributeInCollectionListForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mAttributeTypeName.operator_isEqual (ptr->mAttributeTypeName).boolValue ()
         && mAttributeName.operator_isEqual (ptr->mAttributeName).boolValue ()
         && mFeatureList.operator_isEqual (ptr->mFeatureList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_attributeInCollectionListForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAttributeTypeName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAttributeName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFeatureList.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              List '@attributeInCollectionListForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_attributeInCollectionListForGeneration ("attributeInCollectionListForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_attributeInCollectionListForGeneration::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstringlist & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_attributeInCollectionListForGeneration::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstringlist & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_attributeInCollectionListForGeneration::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstringlist & argument_2) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_attributeInCollectionListForGeneration GGS_attributeInCollectionListForGeneration::
operator_concat (const GGS_attributeInCollectionListForGeneration & inOperand) const {
  GGS_attributeInCollectionListForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_attributeInCollectionListForGeneration::
dotAssign_operation (const GGS_attributeInCollectionListForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_attributeInCollectionListForGeneration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mAttributeTypeName ;
          GGS_lstring  p_1 = p->mAttributeName ;
          GGS_lstringlist  p_2 = p->mFeatureList ;
          internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_attributeInCollectionListForGeneration::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_lstringlist & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_attributeInCollectionListForGeneration::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mAttributeTypeName,
                                ptr->mAttributeName,
                                ptr->mFeatureList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_attributeInCollectionListForGeneration  GGS_attributeInCollectionListForGeneration::
constructor_emptyList (void) {
  GGS_attributeInCollectionListForGeneration result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_attributeInCollectionListForGeneration  GGS_attributeInCollectionListForGeneration::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstringlist & argument_2) {
  GGS_attributeInCollectionListForGeneration result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_attributeInCollectionListForGeneration::
internalSubListWithRange (GGS_attributeInCollectionListForGeneration & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mAttributeTypeName, ptr->mAttributeName, ptr->mFeatureList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_attributeInCollectionListForGeneration GGS_attributeInCollectionListForGeneration::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_attributeInCollectionListForGeneration result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_attributeInCollectionListForGeneration GGS_attributeInCollectionListForGeneration::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_attributeInCollectionListForGeneration result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_attributeInCollectionListForGeneration::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@attributeInCollectionListForGeneration", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_attributeInCollectionListForGeneration::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1,
              GGS_lstringlist & _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAttributeTypeName ;
    _out_1 = ptr->mAttributeName ;
    _out_2 = ptr->mFeatureList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_attributeInCollectionListForGeneration::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1,
             GGS_lstringlist & _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAttributeTypeName ;
    _out_1 = ptr->mAttributeName ;
    _out_2 = ptr->mFeatureList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_attributeInCollectionListForGeneration::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1,
                 GGS_lstringlist & _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAttributeTypeName ;
    _out_1 = ptr->mAttributeName ;
    _out_2 = ptr->mFeatureList ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_attributeInCollectionListForGeneration::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1,
                GGS_lstringlist & _out_2
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAttributeTypeName ;
    _out_1 = ptr->mAttributeName ;
    _out_2 = ptr->mFeatureList ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_attributeInCollectionListForGeneration::
reader_mAttributeTypeNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mAttributeTypeName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_attributeInCollectionListForGeneration::
reader_mAttributeNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mAttributeName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_attributeInCollectionListForGeneration::
reader_mFeatureListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstringlist  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mFeatureList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_attributeInCollectionListForGeneration::
modifier_setMAttributeTypeNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mAttributeTypeName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_attributeInCollectionListForGeneration::
modifier_setMAttributeNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mAttributeName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_attributeInCollectionListForGeneration::
modifier_setMFeatureListAtIndex (C_Compiler & inLexique,
                              const GGS_lstringlist  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mFeatureList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_attributeInCollectionListForGeneration::cEnumerator::_mAttributeTypeName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mAttributeTypeName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_attributeInCollectionListForGeneration::cEnumerator::_mAttributeName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mAttributeName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstringlist  & GGS_attributeInCollectionListForGeneration::cEnumerator::_mFeatureList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mFeatureList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_attributeInCollectionListForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_attributeInCollectionListForGeneration * p = NULL ;
    macroMyNew (p, GGS_attributeInCollectionListForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_attributeInCollectionListForGeneration GGS_attributeInCollectionListForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_attributeInCollectionListForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_attributeInCollectionListForGeneration * p = dynamic_cast <const GGS_attributeInCollectionListForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_attributeInCollectionListForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_attributeInCollectionListForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_attributeInCollectionListForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_listmapDeclarationForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_listmapDeclarationForGeneration::
cPtr_listmapDeclarationForGeneration (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticDeclarationForGeneration (THERE),
mListmapTypeName (argument_0),
mAssociatedListTypeName (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_listmapDeclarationForGeneration * GGS_listmapDeclarationForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_listmapDeclarationForGeneration) ;
    return (cPtr_listmapDeclarationForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_listmapDeclarationForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_listmapDeclarationForGeneration * ptr = dynamic_cast <const cPtr_listmapDeclarationForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mListmapTypeName.operator_isEqual (ptr->mListmapTypeName).boolValue ()
         && mAssociatedListTypeName.operator_isEqual (ptr->mAssociatedListTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_listmapDeclarationForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@listmapDeclarationForGeneration:"
           << mListmapTypeName.reader_description (inIndentation + 1)
           << mAssociatedListTypeName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_listmapDeclarationForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_listmapDeclarationForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_listmapDeclarationForGeneration (& typeid (cPtr_listmapDeclarationForGeneration), & typeid (cPtr_semanticDeclarationForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_listmapDeclarationForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__listmapDeclarationForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_listmapDeclarationForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_listmapDeclarationForGeneration (mListmapTypeName, mAssociatedListTypeName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_listmapDeclarationForGeneration'             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_listmapDeclarationForGeneration ("listmapDeclarationForGeneration", true, & kTypeDescriptor_GGS_semanticDeclarationForGeneration) ;

//---------------------------------------------------------------------------*

GGS_listmapDeclarationForGeneration::
GGS_listmapDeclarationForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_listmapDeclarationForGeneration::
GGS_listmapDeclarationForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_listmapDeclarationForGeneration GGS_listmapDeclarationForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_listmapDeclarationForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_listmapDeclarationForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_listmapDeclarationForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_listmapDeclarationForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_listmapDeclarationForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_listmapDeclarationForGeneration GGS_listmapDeclarationForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_listmapDeclarationForGeneration result ;
  macroMyNew (result.mPointer, cPtr_listmapDeclarationForGeneration (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_listmapDeclarationForGeneration::
reader_mListmapTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_listmapDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_listmapDeclarationForGeneration *) mPointer)->mListmapTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_listmapDeclarationForGeneration::
reader_mAssociatedListTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_listmapDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_listmapDeclarationForGeneration *) mPointer)->mAssociatedListTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_listmapDeclarationForGeneration::actualTypeName (void) const {
  return "listmapDeclarationForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__listmapDeclarationForGeneration ("listmapDeclarationForGeneration", gClassInfoFor__semanticDeclarationForGeneration, & kTypeDescriptor_GGS_listmapDeclarationForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_listmapDeclarationForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_listmapDeclarationForGeneration * p = NULL ;
    macroMyNew (p, GGS_listmapDeclarationForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_listmapDeclarationForGeneration GGS_listmapDeclarationForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_listmapDeclarationForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_listmapDeclarationForGeneration * p = dynamic_cast <const GGS_listmapDeclarationForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_listmapDeclarationForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_listmapDeclarationForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_listmapDeclarationForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@mapMethodListForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_mapMethodListForGeneration::
elementOf_GGS_mapMethodListForGeneration (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mMethodName (argument_0),
mAlternateMethodName (argument_1),
mErrorMessage (argument_2),
mShadowErrorMessage (argument_3) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_mapMethodListForGeneration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_mapMethodListForGeneration * ptr = dynamic_cast <const elementOf_GGS_mapMethodListForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mMethodName.operator_isEqual (ptr->mMethodName).boolValue ()
         && mAlternateMethodName.operator_isEqual (ptr->mAlternateMethodName).boolValue ()
         && mErrorMessage.operator_isEqual (ptr->mErrorMessage).boolValue ()
         && mShadowErrorMessage.operator_isEqual (ptr->mShadowErrorMessage).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_mapMethodListForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMethodName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAlternateMethodName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mErrorMessage.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mShadowErrorMessage.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@mapMethodListForGeneration'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_mapMethodListForGeneration ("mapMethodListForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_mapMethodListForGeneration::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_lstring & argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_mapMethodListForGeneration::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_lstring & argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_mapMethodListForGeneration::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()&& argument_3.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_mapMethodListForGeneration GGS_mapMethodListForGeneration::
operator_concat (const GGS_mapMethodListForGeneration & inOperand) const {
  GGS_mapMethodListForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_mapMethodListForGeneration::
dotAssign_operation (const GGS_mapMethodListForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_mapMethodListForGeneration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mMethodName ;
          GGS_lstring  p_1 = p->mAlternateMethodName ;
          GGS_lstring  p_2 = p->mErrorMessage ;
          GGS_lstring  p_3 = p->mShadowErrorMessage ;
          internalAppendValues (p_0, p_1, p_2, p_3 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_mapMethodListForGeneration::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_lstring & argument_2,
                     const GGS_lstring & argument_3
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapMethodListForGeneration::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mMethodName,
                                ptr->mAlternateMethodName,
                                ptr->mErrorMessage,
                                ptr->mShadowErrorMessage
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_mapMethodListForGeneration  GGS_mapMethodListForGeneration::
constructor_emptyList (void) {
  GGS_mapMethodListForGeneration result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapMethodListForGeneration  GGS_mapMethodListForGeneration::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3) {
  GGS_mapMethodListForGeneration result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2, argument_3) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_mapMethodListForGeneration::
internalSubListWithRange (GGS_mapMethodListForGeneration & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mMethodName, ptr->mAlternateMethodName, ptr->mErrorMessage, ptr->mShadowErrorMessage) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_mapMethodListForGeneration GGS_mapMethodListForGeneration::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_mapMethodListForGeneration result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapMethodListForGeneration GGS_mapMethodListForGeneration::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_mapMethodListForGeneration result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_mapMethodListForGeneration::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@mapMethodListForGeneration", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_mapMethodListForGeneration::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1,
              GGS_lstring & _out_2,
              GGS_lstring & _out_3
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMethodName ;
    _out_1 = ptr->mAlternateMethodName ;
    _out_2 = ptr->mErrorMessage ;
    _out_3 = ptr->mShadowErrorMessage ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapMethodListForGeneration::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1,
             GGS_lstring & _out_2,
             GGS_lstring & _out_3
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMethodName ;
    _out_1 = ptr->mAlternateMethodName ;
    _out_2 = ptr->mErrorMessage ;
    _out_3 = ptr->mShadowErrorMessage ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapMethodListForGeneration::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1,
                 GGS_lstring & _out_2,
                 GGS_lstring & _out_3
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMethodName ;
    _out_1 = ptr->mAlternateMethodName ;
    _out_2 = ptr->mErrorMessage ;
    _out_3 = ptr->mShadowErrorMessage ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapMethodListForGeneration::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1,
                GGS_lstring & _out_2,
                GGS_lstring & _out_3
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMethodName ;
    _out_1 = ptr->mAlternateMethodName ;
    _out_2 = ptr->mErrorMessage ;
    _out_3 = ptr->mShadowErrorMessage ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapMethodListForGeneration::
reader_mMethodNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mMethodName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapMethodListForGeneration::
reader_mAlternateMethodNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mAlternateMethodName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapMethodListForGeneration::
reader_mErrorMessageAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mErrorMessage ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapMethodListForGeneration::
reader_mShadowErrorMessageAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mShadowErrorMessage ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_mapMethodListForGeneration::
modifier_setMMethodNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mMethodName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_mapMethodListForGeneration::
modifier_setMAlternateMethodNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mAlternateMethodName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_mapMethodListForGeneration::
modifier_setMErrorMessageAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mErrorMessage = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_mapMethodListForGeneration::
modifier_setMShadowErrorMessageAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mShadowErrorMessage = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_mapMethodListForGeneration::cEnumerator::_mMethodName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mMethodName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_mapMethodListForGeneration::cEnumerator::_mAlternateMethodName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mAlternateMethodName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_mapMethodListForGeneration::cEnumerator::_mErrorMessage (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mErrorMessage ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_mapMethodListForGeneration::cEnumerator::_mShadowErrorMessage (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mShadowErrorMessage ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_mapMethodListForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_mapMethodListForGeneration * p = NULL ;
    macroMyNew (p, GGS_mapMethodListForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapMethodListForGeneration GGS_mapMethodListForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_mapMethodListForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_mapMethodListForGeneration * p = dynamic_cast <const GGS_mapMethodListForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_mapMethodListForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_mapMethodListForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_mapMethodListForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_mapDeclarationForGeneration'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_mapDeclarationForGeneration::
cPtr_mapDeclarationForGeneration (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_attributeInCollectionListForGeneration & argument_3,
                                const GGS_mapMethodListForGeneration & argument_4,
                                const GGS_mapMethodListForGeneration & argument_5,
                                const GGS_mapMethodListForGeneration & argument_6
                                COMMA_LOCATION_ARGS)
:cPtr_semanticDeclarationForGeneration (THERE),
mMapTypeName (argument_0),
mAssociatedEnumTypeName (argument_1),
mAssociatedTerminaisonMethodName (argument_2),
mAttributeList (argument_3),
mInsertMethodList (argument_4),
mSearchMethodList (argument_5),
mRemoveMethodList (argument_6) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_mapDeclarationForGeneration * GGS_mapDeclarationForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_mapDeclarationForGeneration) ;
    return (cPtr_mapDeclarationForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_mapDeclarationForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_mapDeclarationForGeneration * ptr = dynamic_cast <const cPtr_mapDeclarationForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mMapTypeName.operator_isEqual (ptr->mMapTypeName).boolValue ()
         && mAssociatedEnumTypeName.operator_isEqual (ptr->mAssociatedEnumTypeName).boolValue ()
         && mAssociatedTerminaisonMethodName.operator_isEqual (ptr->mAssociatedTerminaisonMethodName).boolValue ()
         && mAttributeList.operator_isEqual (ptr->mAttributeList).boolValue ()
         && mInsertMethodList.operator_isEqual (ptr->mInsertMethodList).boolValue ()
         && mSearchMethodList.operator_isEqual (ptr->mSearchMethodList).boolValue ()
         && mRemoveMethodList.operator_isEqual (ptr->mRemoveMethodList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_mapDeclarationForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@mapDeclarationForGeneration:"
           << mMapTypeName.reader_description (inIndentation + 1)
           << mAssociatedEnumTypeName.reader_description (inIndentation + 1)
           << mAssociatedTerminaisonMethodName.reader_description (inIndentation + 1)
           << mAttributeList.reader_description (inIndentation + 1)
           << mInsertMethodList.reader_description (inIndentation + 1)
           << mSearchMethodList.reader_description (inIndentation + 1)
           << mRemoveMethodList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_mapDeclarationForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_mapDeclarationForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_mapDeclarationForGeneration (& typeid (cPtr_mapDeclarationForGeneration), & typeid (cPtr_semanticDeclarationForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_mapDeclarationForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__mapDeclarationForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_mapDeclarationForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_mapDeclarationForGeneration (mMapTypeName, mAssociatedEnumTypeName, mAssociatedTerminaisonMethodName, mAttributeList, mInsertMethodList, mSearchMethodList, mRemoveMethodList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_mapDeclarationForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_mapDeclarationForGeneration ("mapDeclarationForGeneration", true, & kTypeDescriptor_GGS_semanticDeclarationForGeneration) ;

//---------------------------------------------------------------------------*

GGS_mapDeclarationForGeneration::
GGS_mapDeclarationForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_mapDeclarationForGeneration::
GGS_mapDeclarationForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_mapDeclarationForGeneration GGS_mapDeclarationForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_mapDeclarationForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_mapDeclarationForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_mapDeclarationForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_mapDeclarationForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_mapDeclarationForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapDeclarationForGeneration GGS_mapDeclarationForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_attributeInCollectionListForGeneration & argument_3,
                 const GGS_mapMethodListForGeneration & argument_4,
                 const GGS_mapMethodListForGeneration & argument_5,
                 const GGS_mapMethodListForGeneration & argument_6
                                COMMA_LOCATION_ARGS) {
  GGS_mapDeclarationForGeneration result ;
  macroMyNew (result.mPointer, cPtr_mapDeclarationForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapDeclarationForGeneration::
reader_mMapTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapDeclarationForGeneration *) mPointer)->mMapTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapDeclarationForGeneration::
reader_mAssociatedEnumTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapDeclarationForGeneration *) mPointer)->mAssociatedEnumTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapDeclarationForGeneration::
reader_mAssociatedTerminaisonMethodName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapDeclarationForGeneration *) mPointer)->mAssociatedTerminaisonMethodName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_attributeInCollectionListForGeneration  GGS_mapDeclarationForGeneration::
reader_mAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_attributeInCollectionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapDeclarationForGeneration *) mPointer)->mAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapMethodListForGeneration  GGS_mapDeclarationForGeneration::
reader_mInsertMethodList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_mapMethodListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapDeclarationForGeneration *) mPointer)->mInsertMethodList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapMethodListForGeneration  GGS_mapDeclarationForGeneration::
reader_mSearchMethodList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_mapMethodListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapDeclarationForGeneration *) mPointer)->mSearchMethodList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapMethodListForGeneration  GGS_mapDeclarationForGeneration::
reader_mRemoveMethodList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_mapMethodListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapDeclarationForGeneration *) mPointer)->mRemoveMethodList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_mapDeclarationForGeneration::actualTypeName (void) const {
  return "mapDeclarationForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__mapDeclarationForGeneration ("mapDeclarationForGeneration", gClassInfoFor__semanticDeclarationForGeneration, & kTypeDescriptor_GGS_mapDeclarationForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_mapDeclarationForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_mapDeclarationForGeneration * p = NULL ;
    macroMyNew (p, GGS_mapDeclarationForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapDeclarationForGeneration GGS_mapDeclarationForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_mapDeclarationForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_mapDeclarationForGeneration * p = dynamic_cast <const GGS_mapDeclarationForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_mapDeclarationForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_mapDeclarationForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_mapDeclarationForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'cPtr_mapindexDeclarationForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_mapindexDeclarationForGeneration::
cPtr_mapindexDeclarationForGeneration (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticDeclarationForGeneration (THERE),
mMapIndexTypeName (argument_0),
mMapTypeName (argument_1),
mSearchMethodName (argument_2),
mSearchMethodErrorMessage (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_mapindexDeclarationForGeneration * GGS_mapindexDeclarationForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_mapindexDeclarationForGeneration) ;
    return (cPtr_mapindexDeclarationForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_mapindexDeclarationForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_mapindexDeclarationForGeneration * ptr = dynamic_cast <const cPtr_mapindexDeclarationForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mMapIndexTypeName.operator_isEqual (ptr->mMapIndexTypeName).boolValue ()
         && mMapTypeName.operator_isEqual (ptr->mMapTypeName).boolValue ()
         && mSearchMethodName.operator_isEqual (ptr->mSearchMethodName).boolValue ()
         && mSearchMethodErrorMessage.operator_isEqual (ptr->mSearchMethodErrorMessage).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_mapindexDeclarationForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@mapindexDeclarationForGeneration:"
           << mMapIndexTypeName.reader_description (inIndentation + 1)
           << mMapTypeName.reader_description (inIndentation + 1)
           << mSearchMethodName.reader_description (inIndentation + 1)
           << mSearchMethodErrorMessage.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_mapindexDeclarationForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_mapindexDeclarationForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_mapindexDeclarationForGeneration (& typeid (cPtr_mapindexDeclarationForGeneration), & typeid (cPtr_semanticDeclarationForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_mapindexDeclarationForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__mapindexDeclarationForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_mapindexDeclarationForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_mapindexDeclarationForGeneration (mMapIndexTypeName, mMapTypeName, mSearchMethodName, mSearchMethodErrorMessage COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_mapindexDeclarationForGeneration'             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_mapindexDeclarationForGeneration ("mapindexDeclarationForGeneration", true, & kTypeDescriptor_GGS_semanticDeclarationForGeneration) ;

//---------------------------------------------------------------------------*

GGS_mapindexDeclarationForGeneration::
GGS_mapindexDeclarationForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_mapindexDeclarationForGeneration::
GGS_mapindexDeclarationForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_mapindexDeclarationForGeneration GGS_mapindexDeclarationForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_mapindexDeclarationForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_mapindexDeclarationForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_mapindexDeclarationForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_mapindexDeclarationForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_mapindexDeclarationForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapindexDeclarationForGeneration GGS_mapindexDeclarationForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_lstring & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_mapindexDeclarationForGeneration result ;
  macroMyNew (result.mPointer, cPtr_mapindexDeclarationForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapindexDeclarationForGeneration::
reader_mMapIndexTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapindexDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapindexDeclarationForGeneration *) mPointer)->mMapIndexTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapindexDeclarationForGeneration::
reader_mMapTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapindexDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapindexDeclarationForGeneration *) mPointer)->mMapTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapindexDeclarationForGeneration::
reader_mSearchMethodName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapindexDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapindexDeclarationForGeneration *) mPointer)->mSearchMethodName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapindexDeclarationForGeneration::
reader_mSearchMethodErrorMessage (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapindexDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapindexDeclarationForGeneration *) mPointer)->mSearchMethodErrorMessage ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_mapindexDeclarationForGeneration::actualTypeName (void) const {
  return "mapindexDeclarationForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__mapindexDeclarationForGeneration ("mapindexDeclarationForGeneration", gClassInfoFor__semanticDeclarationForGeneration, & kTypeDescriptor_GGS_mapindexDeclarationForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_mapindexDeclarationForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_mapindexDeclarationForGeneration * p = NULL ;
    macroMyNew (p, GGS_mapindexDeclarationForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapindexDeclarationForGeneration GGS_mapindexDeclarationForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_mapindexDeclarationForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_mapindexDeclarationForGeneration * p = dynamic_cast <const GGS_mapindexDeclarationForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_mapindexDeclarationForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_mapindexDeclarationForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_mapindexDeclarationForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//       Element of list '@abstractMethodDefinitionListForGeneration'        *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_abstractMethodDefinitionListForGeneration::
elementOf_GGS_abstractMethodDefinitionListForGeneration (const GGS_lstring & argument_0,
                                const GGS_formalParameterListForGeneration & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mMethodName (argument_0),
mSignature (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_abstractMethodDefinitionListForGeneration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_abstractMethodDefinitionListForGeneration * ptr = dynamic_cast <const elementOf_GGS_abstractMethodDefinitionListForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mMethodName.operator_isEqual (ptr->mMethodName).boolValue ()
         && mSignature.operator_isEqual (ptr->mSignature).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_abstractMethodDefinitionListForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMethodName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSignature.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            List '@abstractMethodDefinitionListForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_abstractMethodDefinitionListForGeneration ("abstractMethodDefinitionListForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionListForGeneration::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_formalParameterListForGeneration & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionListForGeneration::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_formalParameterListForGeneration & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionListForGeneration::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_formalParameterListForGeneration & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_abstractMethodDefinitionListForGeneration GGS_abstractMethodDefinitionListForGeneration::
operator_concat (const GGS_abstractMethodDefinitionListForGeneration & inOperand) const {
  GGS_abstractMethodDefinitionListForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionListForGeneration::
dotAssign_operation (const GGS_abstractMethodDefinitionListForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_abstractMethodDefinitionListForGeneration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mMethodName ;
          GGS_formalParameterListForGeneration  p_1 = p->mSignature ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionListForGeneration::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_formalParameterListForGeneration & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionListForGeneration::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mMethodName,
                                ptr->mSignature
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_abstractMethodDefinitionListForGeneration  GGS_abstractMethodDefinitionListForGeneration::
constructor_emptyList (void) {
  GGS_abstractMethodDefinitionListForGeneration result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_abstractMethodDefinitionListForGeneration  GGS_abstractMethodDefinitionListForGeneration::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_formalParameterListForGeneration & argument_1) {
  GGS_abstractMethodDefinitionListForGeneration result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionListForGeneration::
internalSubListWithRange (GGS_abstractMethodDefinitionListForGeneration & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mMethodName, ptr->mSignature) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_abstractMethodDefinitionListForGeneration GGS_abstractMethodDefinitionListForGeneration::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_abstractMethodDefinitionListForGeneration result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_abstractMethodDefinitionListForGeneration GGS_abstractMethodDefinitionListForGeneration::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_abstractMethodDefinitionListForGeneration result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_abstractMethodDefinitionListForGeneration::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@abstractMethodDefinitionListForGeneration", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionListForGeneration::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_formalParameterListForGeneration & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMethodName ;
    _out_1 = ptr->mSignature ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionListForGeneration::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_formalParameterListForGeneration & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMethodName ;
    _out_1 = ptr->mSignature ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionListForGeneration::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_formalParameterListForGeneration & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMethodName ;
    _out_1 = ptr->mSignature ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionListForGeneration::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_formalParameterListForGeneration & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMethodName ;
    _out_1 = ptr->mSignature ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_abstractMethodDefinitionListForGeneration::
reader_mMethodNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mMethodName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameterListForGeneration  GGS_abstractMethodDefinitionListForGeneration::
reader_mSignatureAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_formalParameterListForGeneration  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSignature ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionListForGeneration::
modifier_setMMethodNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mMethodName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionListForGeneration::
modifier_setMSignatureAtIndex (C_Compiler & inLexique,
                              const GGS_formalParameterListForGeneration  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSignature = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_abstractMethodDefinitionListForGeneration::cEnumerator::_mMethodName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mMethodName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_formalParameterListForGeneration  & GGS_abstractMethodDefinitionListForGeneration::cEnumerator::_mSignature (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mSignature ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_abstractMethodDefinitionListForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_abstractMethodDefinitionListForGeneration * p = NULL ;
    macroMyNew (p, GGS_abstractMethodDefinitionListForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_abstractMethodDefinitionListForGeneration GGS_abstractMethodDefinitionListForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_abstractMethodDefinitionListForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_abstractMethodDefinitionListForGeneration * p = dynamic_cast <const GGS_abstractMethodDefinitionListForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_abstractMethodDefinitionListForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_abstractMethodDefinitionListForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_abstractMethodDefinitionListForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Element of list '@overridenMethodDefinitionListForGeneration'        *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_overridenMethodDefinitionListForGeneration::
elementOf_GGS_overridenMethodDefinitionListForGeneration (const GGS_lstring & argument_0,
                                const GGS_formalParameterListForGeneration & argument_1,
                                const GGS_semanticInstructionListForGeneration & argument_2
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mMethodName (argument_0),
mSignature (argument_1),
mInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_overridenMethodDefinitionListForGeneration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_overridenMethodDefinitionListForGeneration * ptr = dynamic_cast <const elementOf_GGS_overridenMethodDefinitionListForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mMethodName.operator_isEqual (ptr->mMethodName).boolValue ()
         && mSignature.operator_isEqual (ptr->mSignature).boolValue ()
         && mInstructionList.operator_isEqual (ptr->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_overridenMethodDefinitionListForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMethodName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSignature.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            List '@overridenMethodDefinitionListForGeneration'             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_overridenMethodDefinitionListForGeneration ("overridenMethodDefinitionListForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_overridenMethodDefinitionListForGeneration::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_formalParameterListForGeneration & argument_1,
                    const GGS_semanticInstructionListForGeneration & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_overridenMethodDefinitionListForGeneration::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_formalParameterListForGeneration & argument_1,
                    const GGS_semanticInstructionListForGeneration & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_overridenMethodDefinitionListForGeneration::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_formalParameterListForGeneration & argument_1,
                                const GGS_semanticInstructionListForGeneration & argument_2) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_overridenMethodDefinitionListForGeneration GGS_overridenMethodDefinitionListForGeneration::
operator_concat (const GGS_overridenMethodDefinitionListForGeneration & inOperand) const {
  GGS_overridenMethodDefinitionListForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_overridenMethodDefinitionListForGeneration::
dotAssign_operation (const GGS_overridenMethodDefinitionListForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_overridenMethodDefinitionListForGeneration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mMethodName ;
          GGS_formalParameterListForGeneration  p_1 = p->mSignature ;
          GGS_semanticInstructionListForGeneration  p_2 = p->mInstructionList ;
          internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_overridenMethodDefinitionListForGeneration::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_formalParameterListForGeneration & argument_1,
                     const GGS_semanticInstructionListForGeneration & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_overridenMethodDefinitionListForGeneration::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mMethodName,
                                ptr->mSignature,
                                ptr->mInstructionList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_overridenMethodDefinitionListForGeneration  GGS_overridenMethodDefinitionListForGeneration::
constructor_emptyList (void) {
  GGS_overridenMethodDefinitionListForGeneration result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_overridenMethodDefinitionListForGeneration  GGS_overridenMethodDefinitionListForGeneration::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_formalParameterListForGeneration & argument_1,
                                const GGS_semanticInstructionListForGeneration & argument_2) {
  GGS_overridenMethodDefinitionListForGeneration result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_overridenMethodDefinitionListForGeneration::
internalSubListWithRange (GGS_overridenMethodDefinitionListForGeneration & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mMethodName, ptr->mSignature, ptr->mInstructionList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_overridenMethodDefinitionListForGeneration GGS_overridenMethodDefinitionListForGeneration::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_overridenMethodDefinitionListForGeneration result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_overridenMethodDefinitionListForGeneration GGS_overridenMethodDefinitionListForGeneration::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_overridenMethodDefinitionListForGeneration result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_overridenMethodDefinitionListForGeneration::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@overridenMethodDefinitionListForGeneration", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_overridenMethodDefinitionListForGeneration::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_formalParameterListForGeneration & _out_1,
              GGS_semanticInstructionListForGeneration & _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMethodName ;
    _out_1 = ptr->mSignature ;
    _out_2 = ptr->mInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_overridenMethodDefinitionListForGeneration::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_formalParameterListForGeneration & _out_1,
             GGS_semanticInstructionListForGeneration & _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMethodName ;
    _out_1 = ptr->mSignature ;
    _out_2 = ptr->mInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_overridenMethodDefinitionListForGeneration::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_formalParameterListForGeneration & _out_1,
                 GGS_semanticInstructionListForGeneration & _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMethodName ;
    _out_1 = ptr->mSignature ;
    _out_2 = ptr->mInstructionList ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_overridenMethodDefinitionListForGeneration::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_formalParameterListForGeneration & _out_1,
                GGS_semanticInstructionListForGeneration & _out_2
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMethodName ;
    _out_1 = ptr->mSignature ;
    _out_2 = ptr->mInstructionList ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_overridenMethodDefinitionListForGeneration::
reader_mMethodNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mMethodName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameterListForGeneration  GGS_overridenMethodDefinitionListForGeneration::
reader_mSignatureAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_formalParameterListForGeneration  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSignature ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration  GGS_overridenMethodDefinitionListForGeneration::
reader_mInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticInstructionListForGeneration  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_overridenMethodDefinitionListForGeneration::
modifier_setMMethodNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mMethodName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_overridenMethodDefinitionListForGeneration::
modifier_setMSignatureAtIndex (C_Compiler & inLexique,
                              const GGS_formalParameterListForGeneration  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSignature = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_overridenMethodDefinitionListForGeneration::
modifier_setMInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_semanticInstructionListForGeneration  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_overridenMethodDefinitionListForGeneration::cEnumerator::_mMethodName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mMethodName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_formalParameterListForGeneration  & GGS_overridenMethodDefinitionListForGeneration::cEnumerator::_mSignature (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mSignature ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticInstructionListForGeneration  & GGS_overridenMethodDefinitionListForGeneration::cEnumerator::_mInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mInstructionList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_overridenMethodDefinitionListForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_overridenMethodDefinitionListForGeneration * p = NULL ;
    macroMyNew (p, GGS_overridenMethodDefinitionListForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_overridenMethodDefinitionListForGeneration GGS_overridenMethodDefinitionListForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_overridenMethodDefinitionListForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_overridenMethodDefinitionListForGeneration * p = dynamic_cast <const GGS_overridenMethodDefinitionListForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_overridenMethodDefinitionListForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_overridenMethodDefinitionListForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_overridenMethodDefinitionListForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Element of list '@methodDefinitionListForGeneration'            *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_methodDefinitionListForGeneration::
elementOf_GGS_methodDefinitionListForGeneration (const GGS_lstring & argument_0,
                                const GGS_formalParameterListForGeneration & argument_1,
                                const GGS_semanticInstructionListForGeneration & argument_2
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mMethodName (argument_0),
mSignature (argument_1),
mInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_methodDefinitionListForGeneration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_methodDefinitionListForGeneration * ptr = dynamic_cast <const elementOf_GGS_methodDefinitionListForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mMethodName.operator_isEqual (ptr->mMethodName).boolValue ()
         && mSignature.operator_isEqual (ptr->mSignature).boolValue ()
         && mInstructionList.operator_isEqual (ptr->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_methodDefinitionListForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMethodName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSignature.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                List '@methodDefinitionListForGeneration'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_methodDefinitionListForGeneration ("methodDefinitionListForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_methodDefinitionListForGeneration::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_formalParameterListForGeneration & argument_1,
                    const GGS_semanticInstructionListForGeneration & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionListForGeneration::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_formalParameterListForGeneration & argument_1,
                    const GGS_semanticInstructionListForGeneration & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionListForGeneration::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_formalParameterListForGeneration & argument_1,
                                const GGS_semanticInstructionListForGeneration & argument_2) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_methodDefinitionListForGeneration GGS_methodDefinitionListForGeneration::
operator_concat (const GGS_methodDefinitionListForGeneration & inOperand) const {
  GGS_methodDefinitionListForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionListForGeneration::
dotAssign_operation (const GGS_methodDefinitionListForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_methodDefinitionListForGeneration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mMethodName ;
          GGS_formalParameterListForGeneration  p_1 = p->mSignature ;
          GGS_semanticInstructionListForGeneration  p_2 = p->mInstructionList ;
          internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionListForGeneration::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_formalParameterListForGeneration & argument_1,
                     const GGS_semanticInstructionListForGeneration & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionListForGeneration::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mMethodName,
                                ptr->mSignature,
                                ptr->mInstructionList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_methodDefinitionListForGeneration  GGS_methodDefinitionListForGeneration::
constructor_emptyList (void) {
  GGS_methodDefinitionListForGeneration result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_methodDefinitionListForGeneration  GGS_methodDefinitionListForGeneration::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_formalParameterListForGeneration & argument_1,
                                const GGS_semanticInstructionListForGeneration & argument_2) {
  GGS_methodDefinitionListForGeneration result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionListForGeneration::
internalSubListWithRange (GGS_methodDefinitionListForGeneration & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mMethodName, ptr->mSignature, ptr->mInstructionList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_methodDefinitionListForGeneration GGS_methodDefinitionListForGeneration::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_methodDefinitionListForGeneration result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_methodDefinitionListForGeneration GGS_methodDefinitionListForGeneration::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_methodDefinitionListForGeneration result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_methodDefinitionListForGeneration::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@methodDefinitionListForGeneration", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionListForGeneration::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_formalParameterListForGeneration & _out_1,
              GGS_semanticInstructionListForGeneration & _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMethodName ;
    _out_1 = ptr->mSignature ;
    _out_2 = ptr->mInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionListForGeneration::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_formalParameterListForGeneration & _out_1,
             GGS_semanticInstructionListForGeneration & _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMethodName ;
    _out_1 = ptr->mSignature ;
    _out_2 = ptr->mInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionListForGeneration::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_formalParameterListForGeneration & _out_1,
                 GGS_semanticInstructionListForGeneration & _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMethodName ;
    _out_1 = ptr->mSignature ;
    _out_2 = ptr->mInstructionList ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionListForGeneration::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_formalParameterListForGeneration & _out_1,
                GGS_semanticInstructionListForGeneration & _out_2
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMethodName ;
    _out_1 = ptr->mSignature ;
    _out_2 = ptr->mInstructionList ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_methodDefinitionListForGeneration::
reader_mMethodNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mMethodName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameterListForGeneration  GGS_methodDefinitionListForGeneration::
reader_mSignatureAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_formalParameterListForGeneration  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSignature ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration  GGS_methodDefinitionListForGeneration::
reader_mInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticInstructionListForGeneration  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionListForGeneration::
modifier_setMMethodNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mMethodName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionListForGeneration::
modifier_setMSignatureAtIndex (C_Compiler & inLexique,
                              const GGS_formalParameterListForGeneration  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSignature = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionListForGeneration::
modifier_setMInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_semanticInstructionListForGeneration  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_methodDefinitionListForGeneration::cEnumerator::_mMethodName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mMethodName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_formalParameterListForGeneration  & GGS_methodDefinitionListForGeneration::cEnumerator::_mSignature (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mSignature ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticInstructionListForGeneration  & GGS_methodDefinitionListForGeneration::cEnumerator::_mInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mInstructionList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_methodDefinitionListForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_methodDefinitionListForGeneration * p = NULL ;
    macroMyNew (p, GGS_methodDefinitionListForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_methodDefinitionListForGeneration GGS_methodDefinitionListForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_methodDefinitionListForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_methodDefinitionListForGeneration * p = dynamic_cast <const GGS_methodDefinitionListForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_methodDefinitionListForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_methodDefinitionListForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_methodDefinitionListForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        Element of list '@classMessageDefinitionListForGeneration'         *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_classMessageDefinitionListForGeneration::
elementOf_GGS_classMessageDefinitionListForGeneration (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mMessageName (argument_0),
mMessageValue (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_classMessageDefinitionListForGeneration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_classMessageDefinitionListForGeneration * ptr = dynamic_cast <const elementOf_GGS_classMessageDefinitionListForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mMessageName.operator_isEqual (ptr->mMessageName).boolValue ()
         && mMessageValue.operator_isEqual (ptr->mMessageValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_classMessageDefinitionListForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMessageName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMessageValue.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             List '@classMessageDefinitionListForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_classMessageDefinitionListForGeneration ("classMessageDefinitionListForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_classMessageDefinitionListForGeneration::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_classMessageDefinitionListForGeneration::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_classMessageDefinitionListForGeneration::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_classMessageDefinitionListForGeneration GGS_classMessageDefinitionListForGeneration::
operator_concat (const GGS_classMessageDefinitionListForGeneration & inOperand) const {
  GGS_classMessageDefinitionListForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_classMessageDefinitionListForGeneration::
dotAssign_operation (const GGS_classMessageDefinitionListForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_classMessageDefinitionListForGeneration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mMessageName ;
          GGS_lstring  p_1 = p->mMessageValue ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_classMessageDefinitionListForGeneration::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_classMessageDefinitionListForGeneration::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mMessageName,
                                ptr->mMessageValue
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_classMessageDefinitionListForGeneration  GGS_classMessageDefinitionListForGeneration::
constructor_emptyList (void) {
  GGS_classMessageDefinitionListForGeneration result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_classMessageDefinitionListForGeneration  GGS_classMessageDefinitionListForGeneration::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  GGS_classMessageDefinitionListForGeneration result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_classMessageDefinitionListForGeneration::
internalSubListWithRange (GGS_classMessageDefinitionListForGeneration & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mMessageName, ptr->mMessageValue) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_classMessageDefinitionListForGeneration GGS_classMessageDefinitionListForGeneration::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_classMessageDefinitionListForGeneration result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_classMessageDefinitionListForGeneration GGS_classMessageDefinitionListForGeneration::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_classMessageDefinitionListForGeneration result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_classMessageDefinitionListForGeneration::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@classMessageDefinitionListForGeneration", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_classMessageDefinitionListForGeneration::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMessageName ;
    _out_1 = ptr->mMessageValue ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_classMessageDefinitionListForGeneration::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMessageName ;
    _out_1 = ptr->mMessageValue ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_classMessageDefinitionListForGeneration::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMessageName ;
    _out_1 = ptr->mMessageValue ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_classMessageDefinitionListForGeneration::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMessageName ;
    _out_1 = ptr->mMessageValue ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_classMessageDefinitionListForGeneration::
reader_mMessageNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mMessageName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_classMessageDefinitionListForGeneration::
reader_mMessageValueAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mMessageValue ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_classMessageDefinitionListForGeneration::
modifier_setMMessageNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mMessageName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_classMessageDefinitionListForGeneration::
modifier_setMMessageValueAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mMessageValue = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_classMessageDefinitionListForGeneration::cEnumerator::_mMessageName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mMessageName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_classMessageDefinitionListForGeneration::cEnumerator::_mMessageValue (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mMessageValue ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_classMessageDefinitionListForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_classMessageDefinitionListForGeneration * p = NULL ;
    macroMyNew (p, GGS_classMessageDefinitionListForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_classMessageDefinitionListForGeneration GGS_classMessageDefinitionListForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_classMessageDefinitionListForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_classMessageDefinitionListForGeneration * p = dynamic_cast <const GGS_classMessageDefinitionListForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_classMessageDefinitionListForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_classMessageDefinitionListForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_classMessageDefinitionListForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Element of list '@lazyAttributeListForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_lazyAttributeListForGeneration::
elementOf_GGS_lazyAttributeListForGeneration (const GGS_location & argument_0,
                                const GGS_attributeInCollectionListForGeneration & argument_1,
                                const GGS_semanticInstructionListForGeneration & argument_2
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mLocationMagicNumber (argument_0),
mAttributeList (argument_1),
mInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_lazyAttributeListForGeneration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_lazyAttributeListForGeneration * ptr = dynamic_cast <const elementOf_GGS_lazyAttributeListForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLocationMagicNumber.operator_isEqual (ptr->mLocationMagicNumber).boolValue ()
         && mAttributeList.operator_isEqual (ptr->mAttributeList).boolValue ()
         && mInstructionList.operator_isEqual (ptr->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_lazyAttributeListForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLocationMagicNumber.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAttributeList.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@lazyAttributeListForGeneration'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_lazyAttributeListForGeneration ("lazyAttributeListForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_lazyAttributeListForGeneration::
internalAppendValues (const GGS_location & argument_0,
                    const GGS_attributeInCollectionListForGeneration & argument_1,
                    const GGS_semanticInstructionListForGeneration & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lazyAttributeListForGeneration::
internalPrependValues (const GGS_location & argument_0,
                    const GGS_attributeInCollectionListForGeneration & argument_1,
                    const GGS_semanticInstructionListForGeneration & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lazyAttributeListForGeneration::
addAssign_operation (const GGS_location & argument_0,
                                const GGS_attributeInCollectionListForGeneration & argument_1,
                                const GGS_semanticInstructionListForGeneration & argument_2) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_lazyAttributeListForGeneration GGS_lazyAttributeListForGeneration::
operator_concat (const GGS_lazyAttributeListForGeneration & inOperand) const {
  GGS_lazyAttributeListForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lazyAttributeListForGeneration::
dotAssign_operation (const GGS_lazyAttributeListForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_lazyAttributeListForGeneration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_location  p_0 = p->mLocationMagicNumber ;
          GGS_attributeInCollectionListForGeneration  p_1 = p->mAttributeList ;
          GGS_semanticInstructionListForGeneration  p_2 = p->mInstructionList ;
          internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lazyAttributeListForGeneration::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_location & argument_0,
                     const GGS_attributeInCollectionListForGeneration & argument_1,
                     const GGS_semanticInstructionListForGeneration & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lazyAttributeListForGeneration::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mLocationMagicNumber,
                                ptr->mAttributeList,
                                ptr->mInstructionList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lazyAttributeListForGeneration  GGS_lazyAttributeListForGeneration::
constructor_emptyList (void) {
  GGS_lazyAttributeListForGeneration result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lazyAttributeListForGeneration  GGS_lazyAttributeListForGeneration::
constructor_listWithValue (const GGS_location & argument_0,
                                const GGS_attributeInCollectionListForGeneration & argument_1,
                                const GGS_semanticInstructionListForGeneration & argument_2) {
  GGS_lazyAttributeListForGeneration result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lazyAttributeListForGeneration::
internalSubListWithRange (GGS_lazyAttributeListForGeneration & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mLocationMagicNumber, ptr->mAttributeList, ptr->mInstructionList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lazyAttributeListForGeneration GGS_lazyAttributeListForGeneration::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_lazyAttributeListForGeneration result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lazyAttributeListForGeneration GGS_lazyAttributeListForGeneration::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_lazyAttributeListForGeneration result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lazyAttributeListForGeneration::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@lazyAttributeListForGeneration", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_lazyAttributeListForGeneration::
method_first (C_Compiler & inLexique,
              GGS_location & _out_0,
              GGS_attributeInCollectionListForGeneration & _out_1,
              GGS_semanticInstructionListForGeneration & _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mLocationMagicNumber ;
    _out_1 = ptr->mAttributeList ;
    _out_2 = ptr->mInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lazyAttributeListForGeneration::
method_last (C_Compiler & inLexique,
             GGS_location & _out_0,
             GGS_attributeInCollectionListForGeneration & _out_1,
             GGS_semanticInstructionListForGeneration & _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mLocationMagicNumber ;
    _out_1 = ptr->mAttributeList ;
    _out_2 = ptr->mInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lazyAttributeListForGeneration::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_location & _out_0,
                 GGS_attributeInCollectionListForGeneration & _out_1,
                 GGS_semanticInstructionListForGeneration & _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mLocationMagicNumber ;
    _out_1 = ptr->mAttributeList ;
    _out_2 = ptr->mInstructionList ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lazyAttributeListForGeneration::
modifier_popLast (C_Compiler & inLexique,
                GGS_location & _out_0,
                GGS_attributeInCollectionListForGeneration & _out_1,
                GGS_semanticInstructionListForGeneration & _out_2
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mLocationMagicNumber ;
    _out_1 = ptr->mAttributeList ;
    _out_2 = ptr->mInstructionList ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_location  GGS_lazyAttributeListForGeneration::
reader_mLocationMagicNumberAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_location  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mLocationMagicNumber ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_attributeInCollectionListForGeneration  GGS_lazyAttributeListForGeneration::
reader_mAttributeListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_attributeInCollectionListForGeneration  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mAttributeList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration  GGS_lazyAttributeListForGeneration::
reader_mInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticInstructionListForGeneration  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lazyAttributeListForGeneration::
modifier_setMLocationMagicNumberAtIndex (C_Compiler & inLexique,
                              const GGS_location  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mLocationMagicNumber = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lazyAttributeListForGeneration::
modifier_setMAttributeListAtIndex (C_Compiler & inLexique,
                              const GGS_attributeInCollectionListForGeneration  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mAttributeList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lazyAttributeListForGeneration::
modifier_setMInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_semanticInstructionListForGeneration  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_location  & GGS_lazyAttributeListForGeneration::cEnumerator::_mLocationMagicNumber (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mLocationMagicNumber ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_attributeInCollectionListForGeneration  & GGS_lazyAttributeListForGeneration::cEnumerator::_mAttributeList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mAttributeList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticInstructionListForGeneration  & GGS_lazyAttributeListForGeneration::cEnumerator::_mInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mInstructionList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_lazyAttributeListForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_lazyAttributeListForGeneration * p = NULL ;
    macroMyNew (p, GGS_lazyAttributeListForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lazyAttributeListForGeneration GGS_lazyAttributeListForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_lazyAttributeListForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_lazyAttributeListForGeneration * p = dynamic_cast <const GGS_lazyAttributeListForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_lazyAttributeListForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_lazyAttributeListForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_lazyAttributeListForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_classDeclarationForGeneration'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_classDeclarationForGeneration::
cPtr_classDeclarationForGeneration (const GGS_bool& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstringlist & argument_3,
                                const GGS_attributeInCollectionListForGeneration & argument_4,
                                const GGS_abstractMethodDefinitionListForGeneration & argument_5,
                                const GGS_overridenMethodDefinitionListForGeneration & argument_6,
                                const GGS_methodDefinitionListForGeneration & argument_7,
                                const GGS_classMessageDefinitionListForGeneration & argument_8,
                                const GGS_lazyAttributeListForGeneration & argument_9,
                                const GGS_string& argument_10
                                COMMA_LOCATION_ARGS)
:cPtr_semanticDeclarationForGeneration (THERE),
mIsAbstract (argument_0),
mClassTypeName (argument_1),
mSuperClassName (argument_2),
mClassFeatureList (argument_3),
mAttributeList (argument_4),
mAbstractMethodList (argument_5),
mOverridenMethodList (argument_6),
mMethodList (argument_7),
mMessageList (argument_8),
mLazyAttributeList (argument_9),
mClassMessage (argument_10) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_classDeclarationForGeneration * GGS_classDeclarationForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_classDeclarationForGeneration) ;
    return (cPtr_classDeclarationForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_classDeclarationForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_classDeclarationForGeneration * ptr = dynamic_cast <const cPtr_classDeclarationForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mIsAbstract.operator_isEqual (ptr->mIsAbstract).boolValue ()
         && mClassTypeName.operator_isEqual (ptr->mClassTypeName).boolValue ()
         && mSuperClassName.operator_isEqual (ptr->mSuperClassName).boolValue ()
         && mClassFeatureList.operator_isEqual (ptr->mClassFeatureList).boolValue ()
         && mAttributeList.operator_isEqual (ptr->mAttributeList).boolValue ()
         && mAbstractMethodList.operator_isEqual (ptr->mAbstractMethodList).boolValue ()
         && mOverridenMethodList.operator_isEqual (ptr->mOverridenMethodList).boolValue ()
         && mMethodList.operator_isEqual (ptr->mMethodList).boolValue ()
         && mMessageList.operator_isEqual (ptr->mMessageList).boolValue ()
         && mLazyAttributeList.operator_isEqual (ptr->mLazyAttributeList).boolValue ()
         && mClassMessage.operator_isEqual (ptr->mClassMessage).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_classDeclarationForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@classDeclarationForGeneration:"
           << mIsAbstract.reader_description (inIndentation + 1)
           << mClassTypeName.reader_description (inIndentation + 1)
           << mSuperClassName.reader_description (inIndentation + 1)
           << mClassFeatureList.reader_description (inIndentation + 1)
           << mAttributeList.reader_description (inIndentation + 1)
           << mAbstractMethodList.reader_description (inIndentation + 1)
           << mOverridenMethodList.reader_description (inIndentation + 1)
           << mMethodList.reader_description (inIndentation + 1)
           << mMessageList.reader_description (inIndentation + 1)
           << mLazyAttributeList.reader_description (inIndentation + 1)
           << mClassMessage.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_classDeclarationForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_classDeclarationForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_classDeclarationForGeneration (& typeid (cPtr_classDeclarationForGeneration), & typeid (cPtr_semanticDeclarationForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_classDeclarationForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__classDeclarationForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_classDeclarationForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_classDeclarationForGeneration (mIsAbstract, mClassTypeName, mSuperClassName, mClassFeatureList, mAttributeList, mAbstractMethodList, mOverridenMethodList, mMethodList, mMessageList, mLazyAttributeList, mClassMessage COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_classDeclarationForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_classDeclarationForGeneration ("classDeclarationForGeneration", true, & kTypeDescriptor_GGS_semanticDeclarationForGeneration) ;

//---------------------------------------------------------------------------*

GGS_classDeclarationForGeneration::
GGS_classDeclarationForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_classDeclarationForGeneration::
GGS_classDeclarationForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_classDeclarationForGeneration GGS_classDeclarationForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_classDeclarationForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_classDeclarationForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_classDeclarationForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_classDeclarationForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_classDeclarationForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_classDeclarationForGeneration GGS_classDeclarationForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_bool& argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_lstringlist & argument_3,
                 const GGS_attributeInCollectionListForGeneration & argument_4,
                 const GGS_abstractMethodDefinitionListForGeneration & argument_5,
                 const GGS_overridenMethodDefinitionListForGeneration & argument_6,
                 const GGS_methodDefinitionListForGeneration & argument_7,
                 const GGS_classMessageDefinitionListForGeneration & argument_8,
                 const GGS_lazyAttributeListForGeneration & argument_9,
                 const GGS_string& argument_10
                                COMMA_LOCATION_ARGS) {
  GGS_classDeclarationForGeneration result ;
  macroMyNew (result.mPointer, cPtr_classDeclarationForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7,
                                argument_8,
                                argument_9,
                                argument_10 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_classDeclarationForGeneration::
reader_mIsAbstract (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classDeclarationForGeneration *) mPointer)->mIsAbstract ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_classDeclarationForGeneration::
reader_mClassTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classDeclarationForGeneration *) mPointer)->mClassTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_classDeclarationForGeneration::
reader_mSuperClassName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classDeclarationForGeneration *) mPointer)->mSuperClassName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_classDeclarationForGeneration::
reader_mClassFeatureList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classDeclarationForGeneration *) mPointer)->mClassFeatureList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_attributeInCollectionListForGeneration  GGS_classDeclarationForGeneration::
reader_mAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_attributeInCollectionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classDeclarationForGeneration *) mPointer)->mAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_abstractMethodDefinitionListForGeneration  GGS_classDeclarationForGeneration::
reader_mAbstractMethodList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_abstractMethodDefinitionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classDeclarationForGeneration *) mPointer)->mAbstractMethodList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_overridenMethodDefinitionListForGeneration  GGS_classDeclarationForGeneration::
reader_mOverridenMethodList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_overridenMethodDefinitionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classDeclarationForGeneration *) mPointer)->mOverridenMethodList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_methodDefinitionListForGeneration  GGS_classDeclarationForGeneration::
reader_mMethodList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_methodDefinitionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classDeclarationForGeneration *) mPointer)->mMethodList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_classMessageDefinitionListForGeneration  GGS_classDeclarationForGeneration::
reader_mMessageList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_classMessageDefinitionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classDeclarationForGeneration *) mPointer)->mMessageList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lazyAttributeListForGeneration  GGS_classDeclarationForGeneration::
reader_mLazyAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lazyAttributeListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classDeclarationForGeneration *) mPointer)->mLazyAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_classDeclarationForGeneration::
reader_mClassMessage (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classDeclarationForGeneration *) mPointer)->mClassMessage ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_classDeclarationForGeneration::actualTypeName (void) const {
  return "classDeclarationForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__classDeclarationForGeneration ("classDeclarationForGeneration", gClassInfoFor__semanticDeclarationForGeneration, & kTypeDescriptor_GGS_classDeclarationForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_classDeclarationForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_classDeclarationForGeneration * p = NULL ;
    macroMyNew (p, GGS_classDeclarationForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_classDeclarationForGeneration GGS_classDeclarationForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_classDeclarationForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_classDeclarationForGeneration * p = dynamic_cast <const GGS_classDeclarationForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_classDeclarationForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_classDeclarationForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_classDeclarationForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_listDeclarationForGeneration'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_listDeclarationForGeneration::
cPtr_listDeclarationForGeneration (const GGS_lstring & argument_0,
                                const GGS_attributeInCollectionListForGeneration & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticDeclarationForGeneration (THERE),
mListTypeName (argument_0),
mAttributeList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_listDeclarationForGeneration * GGS_listDeclarationForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_listDeclarationForGeneration) ;
    return (cPtr_listDeclarationForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_listDeclarationForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_listDeclarationForGeneration * ptr = dynamic_cast <const cPtr_listDeclarationForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mListTypeName.operator_isEqual (ptr->mListTypeName).boolValue ()
         && mAttributeList.operator_isEqual (ptr->mAttributeList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_listDeclarationForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@listDeclarationForGeneration:"
           << mListTypeName.reader_description (inIndentation + 1)
           << mAttributeList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_listDeclarationForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_listDeclarationForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_listDeclarationForGeneration (& typeid (cPtr_listDeclarationForGeneration), & typeid (cPtr_semanticDeclarationForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_listDeclarationForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__listDeclarationForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_listDeclarationForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_listDeclarationForGeneration (mListTypeName, mAttributeList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_listDeclarationForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_listDeclarationForGeneration ("listDeclarationForGeneration", true, & kTypeDescriptor_GGS_semanticDeclarationForGeneration) ;

//---------------------------------------------------------------------------*

GGS_listDeclarationForGeneration::
GGS_listDeclarationForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_listDeclarationForGeneration::
GGS_listDeclarationForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_listDeclarationForGeneration GGS_listDeclarationForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_listDeclarationForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_listDeclarationForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_listDeclarationForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_listDeclarationForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_listDeclarationForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_listDeclarationForGeneration GGS_listDeclarationForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_attributeInCollectionListForGeneration & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_listDeclarationForGeneration result ;
  macroMyNew (result.mPointer, cPtr_listDeclarationForGeneration (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_listDeclarationForGeneration::
reader_mListTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_listDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_listDeclarationForGeneration *) mPointer)->mListTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_attributeInCollectionListForGeneration  GGS_listDeclarationForGeneration::
reader_mAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_attributeInCollectionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_listDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_listDeclarationForGeneration *) mPointer)->mAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_listDeclarationForGeneration::actualTypeName (void) const {
  return "listDeclarationForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__listDeclarationForGeneration ("listDeclarationForGeneration", gClassInfoFor__semanticDeclarationForGeneration, & kTypeDescriptor_GGS_listDeclarationForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_listDeclarationForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_listDeclarationForGeneration * p = NULL ;
    macroMyNew (p, GGS_listDeclarationForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_listDeclarationForGeneration GGS_listDeclarationForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_listDeclarationForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_listDeclarationForGeneration * p = dynamic_cast <const GGS_listDeclarationForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_listDeclarationForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_listDeclarationForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_listDeclarationForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_structDeclarationForGeneration'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_structDeclarationForGeneration::
cPtr_structDeclarationForGeneration (const GGS_lstring & argument_0,
                                const GGS_attributeInCollectionListForGeneration & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticDeclarationForGeneration (THERE),
mStructTypeName (argument_0),
mAttributeList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_structDeclarationForGeneration * GGS_structDeclarationForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_structDeclarationForGeneration) ;
    return (cPtr_structDeclarationForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_structDeclarationForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_structDeclarationForGeneration * ptr = dynamic_cast <const cPtr_structDeclarationForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStructTypeName.operator_isEqual (ptr->mStructTypeName).boolValue ()
         && mAttributeList.operator_isEqual (ptr->mAttributeList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_structDeclarationForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@structDeclarationForGeneration:"
           << mStructTypeName.reader_description (inIndentation + 1)
           << mAttributeList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_structDeclarationForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_structDeclarationForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_structDeclarationForGeneration (& typeid (cPtr_structDeclarationForGeneration), & typeid (cPtr_semanticDeclarationForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_structDeclarationForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__structDeclarationForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_structDeclarationForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_structDeclarationForGeneration (mStructTypeName, mAttributeList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_structDeclarationForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_structDeclarationForGeneration ("structDeclarationForGeneration", true, & kTypeDescriptor_GGS_semanticDeclarationForGeneration) ;

//---------------------------------------------------------------------------*

GGS_structDeclarationForGeneration::
GGS_structDeclarationForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_structDeclarationForGeneration::
GGS_structDeclarationForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_structDeclarationForGeneration GGS_structDeclarationForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_structDeclarationForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_structDeclarationForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_structDeclarationForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_structDeclarationForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_structDeclarationForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_structDeclarationForGeneration GGS_structDeclarationForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_attributeInCollectionListForGeneration & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_structDeclarationForGeneration result ;
  macroMyNew (result.mPointer, cPtr_structDeclarationForGeneration (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_structDeclarationForGeneration::
reader_mStructTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_structDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_structDeclarationForGeneration *) mPointer)->mStructTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_attributeInCollectionListForGeneration  GGS_structDeclarationForGeneration::
reader_mAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_attributeInCollectionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_structDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_structDeclarationForGeneration *) mPointer)->mAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_structDeclarationForGeneration::actualTypeName (void) const {
  return "structDeclarationForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__structDeclarationForGeneration ("structDeclarationForGeneration", gClassInfoFor__semanticDeclarationForGeneration, & kTypeDescriptor_GGS_structDeclarationForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_structDeclarationForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_structDeclarationForGeneration * p = NULL ;
    macroMyNew (p, GGS_structDeclarationForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_structDeclarationForGeneration GGS_structDeclarationForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_structDeclarationForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_structDeclarationForGeneration * p = dynamic_cast <const GGS_structDeclarationForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_structDeclarationForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_structDeclarationForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_structDeclarationForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//       Element of list '@sortedListSortDescriptorListForGeneration'        *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_sortedListSortDescriptorListForGeneration::
elementOf_GGS_sortedListSortDescriptorListForGeneration (const GGS_lstring & argument_0,
                                const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mSortedAttributeName (argument_0),
mAscending (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_sortedListSortDescriptorListForGeneration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_sortedListSortDescriptorListForGeneration * ptr = dynamic_cast <const elementOf_GGS_sortedListSortDescriptorListForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mSortedAttributeName.operator_isEqual (ptr->mSortedAttributeName).boolValue ()
         && mAscending.operator_isEqual (ptr->mAscending).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_sortedListSortDescriptorListForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSortedAttributeName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAscending.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            List '@sortedListSortDescriptorListForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_sortedListSortDescriptorListForGeneration ("sortedListSortDescriptorListForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_sortedListSortDescriptorListForGeneration::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_bool& argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_sortedListSortDescriptorListForGeneration::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_bool& argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_sortedListSortDescriptorListForGeneration::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_bool& argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_sortedListSortDescriptorListForGeneration GGS_sortedListSortDescriptorListForGeneration::
operator_concat (const GGS_sortedListSortDescriptorListForGeneration & inOperand) const {
  GGS_sortedListSortDescriptorListForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_sortedListSortDescriptorListForGeneration::
dotAssign_operation (const GGS_sortedListSortDescriptorListForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_sortedListSortDescriptorListForGeneration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mSortedAttributeName ;
          GGS_bool p_1 = p->mAscending ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_sortedListSortDescriptorListForGeneration::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_bool& argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_sortedListSortDescriptorListForGeneration::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mSortedAttributeName,
                                ptr->mAscending
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_sortedListSortDescriptorListForGeneration  GGS_sortedListSortDescriptorListForGeneration::
constructor_emptyList (void) {
  GGS_sortedListSortDescriptorListForGeneration result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sortedListSortDescriptorListForGeneration  GGS_sortedListSortDescriptorListForGeneration::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_bool& argument_1) {
  GGS_sortedListSortDescriptorListForGeneration result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_sortedListSortDescriptorListForGeneration::
internalSubListWithRange (GGS_sortedListSortDescriptorListForGeneration & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mSortedAttributeName, ptr->mAscending) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_sortedListSortDescriptorListForGeneration GGS_sortedListSortDescriptorListForGeneration::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_sortedListSortDescriptorListForGeneration result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sortedListSortDescriptorListForGeneration GGS_sortedListSortDescriptorListForGeneration::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_sortedListSortDescriptorListForGeneration result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_sortedListSortDescriptorListForGeneration::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@sortedListSortDescriptorListForGeneration", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_sortedListSortDescriptorListForGeneration::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_bool& _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSortedAttributeName ;
    _out_1 = ptr->mAscending ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_sortedListSortDescriptorListForGeneration::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_bool& _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSortedAttributeName ;
    _out_1 = ptr->mAscending ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_sortedListSortDescriptorListForGeneration::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_bool& _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSortedAttributeName ;
    _out_1 = ptr->mAscending ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_sortedListSortDescriptorListForGeneration::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_bool& _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSortedAttributeName ;
    _out_1 = ptr->mAscending ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_sortedListSortDescriptorListForGeneration::
reader_mSortedAttributeNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSortedAttributeName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_sortedListSortDescriptorListForGeneration::
reader_mAscendingAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mAscending ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_sortedListSortDescriptorListForGeneration::
modifier_setMSortedAttributeNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSortedAttributeName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_sortedListSortDescriptorListForGeneration::
modifier_setMAscendingAtIndex (C_Compiler & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mAscending = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_sortedListSortDescriptorListForGeneration::cEnumerator::_mSortedAttributeName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mSortedAttributeName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_sortedListSortDescriptorListForGeneration::cEnumerator::_mAscending (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mAscending ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_sortedListSortDescriptorListForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_sortedListSortDescriptorListForGeneration * p = NULL ;
    macroMyNew (p, GGS_sortedListSortDescriptorListForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sortedListSortDescriptorListForGeneration GGS_sortedListSortDescriptorListForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_sortedListSortDescriptorListForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_sortedListSortDescriptorListForGeneration * p = dynamic_cast <const GGS_sortedListSortDescriptorListForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_sortedListSortDescriptorListForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_sortedListSortDescriptorListForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_sortedListSortDescriptorListForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_sortedListDeclarationForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_sortedListDeclarationForGeneration::
cPtr_sortedListDeclarationForGeneration (const GGS_lstring & argument_0,
                                const GGS_attributeInCollectionListForGeneration & argument_1,
                                const GGS_sortedListSortDescriptorListForGeneration & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticDeclarationForGeneration (THERE),
mSortedListTypeName (argument_0),
mAttributeList (argument_1),
mSortDescriptorList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_sortedListDeclarationForGeneration * GGS_sortedListDeclarationForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_sortedListDeclarationForGeneration) ;
    return (cPtr_sortedListDeclarationForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_sortedListDeclarationForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_sortedListDeclarationForGeneration * ptr = dynamic_cast <const cPtr_sortedListDeclarationForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mSortedListTypeName.operator_isEqual (ptr->mSortedListTypeName).boolValue ()
         && mAttributeList.operator_isEqual (ptr->mAttributeList).boolValue ()
         && mSortDescriptorList.operator_isEqual (ptr->mSortDescriptorList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_sortedListDeclarationForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@sortedListDeclarationForGeneration:"
           << mSortedListTypeName.reader_description (inIndentation + 1)
           << mAttributeList.reader_description (inIndentation + 1)
           << mSortDescriptorList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_sortedListDeclarationForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_sortedListDeclarationForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_sortedListDeclarationForGeneration (& typeid (cPtr_sortedListDeclarationForGeneration), & typeid (cPtr_semanticDeclarationForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_sortedListDeclarationForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__sortedListDeclarationForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_sortedListDeclarationForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_sortedListDeclarationForGeneration (mSortedListTypeName, mAttributeList, mSortDescriptorList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_sortedListDeclarationForGeneration'            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_sortedListDeclarationForGeneration ("sortedListDeclarationForGeneration", true, & kTypeDescriptor_GGS_semanticDeclarationForGeneration) ;

//---------------------------------------------------------------------------*

GGS_sortedListDeclarationForGeneration::
GGS_sortedListDeclarationForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_sortedListDeclarationForGeneration::
GGS_sortedListDeclarationForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_sortedListDeclarationForGeneration GGS_sortedListDeclarationForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_sortedListDeclarationForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_sortedListDeclarationForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_sortedListDeclarationForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_sortedListDeclarationForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_sortedListDeclarationForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sortedListDeclarationForGeneration GGS_sortedListDeclarationForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_attributeInCollectionListForGeneration & argument_1,
                 const GGS_sortedListSortDescriptorListForGeneration & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_sortedListDeclarationForGeneration result ;
  macroMyNew (result.mPointer, cPtr_sortedListDeclarationForGeneration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_sortedListDeclarationForGeneration::
reader_mSortedListTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sortedListDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sortedListDeclarationForGeneration *) mPointer)->mSortedListTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_attributeInCollectionListForGeneration  GGS_sortedListDeclarationForGeneration::
reader_mAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_attributeInCollectionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sortedListDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sortedListDeclarationForGeneration *) mPointer)->mAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sortedListSortDescriptorListForGeneration  GGS_sortedListDeclarationForGeneration::
reader_mSortDescriptorList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_sortedListSortDescriptorListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sortedListDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sortedListDeclarationForGeneration *) mPointer)->mSortDescriptorList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_sortedListDeclarationForGeneration::actualTypeName (void) const {
  return "sortedListDeclarationForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__sortedListDeclarationForGeneration ("sortedListDeclarationForGeneration", gClassInfoFor__semanticDeclarationForGeneration, & kTypeDescriptor_GGS_sortedListDeclarationForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_sortedListDeclarationForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_sortedListDeclarationForGeneration * p = NULL ;
    macroMyNew (p, GGS_sortedListDeclarationForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sortedListDeclarationForGeneration GGS_sortedListDeclarationForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_sortedListDeclarationForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_sortedListDeclarationForGeneration * p = dynamic_cast <const GGS_sortedListDeclarationForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_sortedListDeclarationForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_sortedListDeclarationForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_sortedListDeclarationForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        Element of list '@enumMessageAssociationListForGeneration'         *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_enumMessageAssociationListForGeneration::
elementOf_GGS_enumMessageAssociationListForGeneration (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mConstantName (argument_0),
mMessage (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_enumMessageAssociationListForGeneration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_enumMessageAssociationListForGeneration * ptr = dynamic_cast <const elementOf_GGS_enumMessageAssociationListForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mConstantName.operator_isEqual (ptr->mConstantName).boolValue ()
         && mMessage.operator_isEqual (ptr->mMessage).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_enumMessageAssociationListForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mConstantName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMessage.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             List '@enumMessageAssociationListForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_enumMessageAssociationListForGeneration ("enumMessageAssociationListForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationListForGeneration::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationListForGeneration::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationListForGeneration::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_enumMessageAssociationListForGeneration GGS_enumMessageAssociationListForGeneration::
operator_concat (const GGS_enumMessageAssociationListForGeneration & inOperand) const {
  GGS_enumMessageAssociationListForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationListForGeneration::
dotAssign_operation (const GGS_enumMessageAssociationListForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_enumMessageAssociationListForGeneration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mConstantName ;
          GGS_lstring  p_1 = p->mMessage ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationListForGeneration::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationListForGeneration::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mConstantName,
                                ptr->mMessage
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_enumMessageAssociationListForGeneration  GGS_enumMessageAssociationListForGeneration::
constructor_emptyList (void) {
  GGS_enumMessageAssociationListForGeneration result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMessageAssociationListForGeneration  GGS_enumMessageAssociationListForGeneration::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  GGS_enumMessageAssociationListForGeneration result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationListForGeneration::
internalSubListWithRange (GGS_enumMessageAssociationListForGeneration & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mConstantName, ptr->mMessage) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_enumMessageAssociationListForGeneration GGS_enumMessageAssociationListForGeneration::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_enumMessageAssociationListForGeneration result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMessageAssociationListForGeneration GGS_enumMessageAssociationListForGeneration::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_enumMessageAssociationListForGeneration result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_enumMessageAssociationListForGeneration::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@enumMessageAssociationListForGeneration", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationListForGeneration::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mConstantName ;
    _out_1 = ptr->mMessage ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationListForGeneration::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mConstantName ;
    _out_1 = ptr->mMessage ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationListForGeneration::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mConstantName ;
    _out_1 = ptr->mMessage ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationListForGeneration::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mConstantName ;
    _out_1 = ptr->mMessage ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_enumMessageAssociationListForGeneration::
reader_mConstantNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mConstantName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_enumMessageAssociationListForGeneration::
reader_mMessageAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mMessage ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationListForGeneration::
modifier_setMConstantNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mConstantName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationListForGeneration::
modifier_setMMessageAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mMessage = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_enumMessageAssociationListForGeneration::cEnumerator::_mConstantName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mConstantName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_enumMessageAssociationListForGeneration::cEnumerator::_mMessage (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mMessage ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_enumMessageAssociationListForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_enumMessageAssociationListForGeneration * p = NULL ;
    macroMyNew (p, GGS_enumMessageAssociationListForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMessageAssociationListForGeneration GGS_enumMessageAssociationListForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_enumMessageAssociationListForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_enumMessageAssociationListForGeneration * p = dynamic_cast <const GGS_enumMessageAssociationListForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_enumMessageAssociationListForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_enumMessageAssociationListForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_enumMessageAssociationListForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@enumMessageListForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_enumMessageListForGeneration::
elementOf_GGS_enumMessageListForGeneration (const GGS_lstring & argument_0,
                                const GGS_enumMessageAssociationListForGeneration & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mEnumMessageName (argument_0),
mMessageAssociationList (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_enumMessageListForGeneration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_enumMessageListForGeneration * ptr = dynamic_cast <const elementOf_GGS_enumMessageListForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mEnumMessageName.operator_isEqual (ptr->mEnumMessageName).boolValue ()
         && mMessageAssociationList.operator_isEqual (ptr->mMessageAssociationList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_enumMessageListForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEnumMessageName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMessageAssociationList.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@enumMessageListForGeneration'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_enumMessageListForGeneration ("enumMessageListForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_enumMessageListForGeneration::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_enumMessageAssociationListForGeneration & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageListForGeneration::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_enumMessageAssociationListForGeneration & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageListForGeneration::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_enumMessageAssociationListForGeneration & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_enumMessageListForGeneration GGS_enumMessageListForGeneration::
operator_concat (const GGS_enumMessageListForGeneration & inOperand) const {
  GGS_enumMessageListForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageListForGeneration::
dotAssign_operation (const GGS_enumMessageListForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_enumMessageListForGeneration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mEnumMessageName ;
          GGS_enumMessageAssociationListForGeneration  p_1 = p->mMessageAssociationList ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageListForGeneration::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_enumMessageAssociationListForGeneration & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageListForGeneration::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mEnumMessageName,
                                ptr->mMessageAssociationList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_enumMessageListForGeneration  GGS_enumMessageListForGeneration::
constructor_emptyList (void) {
  GGS_enumMessageListForGeneration result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMessageListForGeneration  GGS_enumMessageListForGeneration::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_enumMessageAssociationListForGeneration & argument_1) {
  GGS_enumMessageListForGeneration result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageListForGeneration::
internalSubListWithRange (GGS_enumMessageListForGeneration & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mEnumMessageName, ptr->mMessageAssociationList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_enumMessageListForGeneration GGS_enumMessageListForGeneration::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_enumMessageListForGeneration result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMessageListForGeneration GGS_enumMessageListForGeneration::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_enumMessageListForGeneration result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_enumMessageListForGeneration::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@enumMessageListForGeneration", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageListForGeneration::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_enumMessageAssociationListForGeneration & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mEnumMessageName ;
    _out_1 = ptr->mMessageAssociationList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageListForGeneration::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_enumMessageAssociationListForGeneration & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mEnumMessageName ;
    _out_1 = ptr->mMessageAssociationList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageListForGeneration::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_enumMessageAssociationListForGeneration & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mEnumMessageName ;
    _out_1 = ptr->mMessageAssociationList ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageListForGeneration::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_enumMessageAssociationListForGeneration & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mEnumMessageName ;
    _out_1 = ptr->mMessageAssociationList ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_enumMessageListForGeneration::
reader_mEnumMessageNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mEnumMessageName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMessageAssociationListForGeneration  GGS_enumMessageListForGeneration::
reader_mMessageAssociationListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_enumMessageAssociationListForGeneration  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mMessageAssociationList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageListForGeneration::
modifier_setMEnumMessageNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mEnumMessageName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageListForGeneration::
modifier_setMMessageAssociationListAtIndex (C_Compiler & inLexique,
                              const GGS_enumMessageAssociationListForGeneration  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mMessageAssociationList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_enumMessageListForGeneration::cEnumerator::_mEnumMessageName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mEnumMessageName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_enumMessageAssociationListForGeneration  & GGS_enumMessageListForGeneration::cEnumerator::_mMessageAssociationList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mMessageAssociationList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_enumMessageListForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_enumMessageListForGeneration * p = NULL ;
    macroMyNew (p, GGS_enumMessageListForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMessageListForGeneration GGS_enumMessageListForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_enumMessageListForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_enumMessageListForGeneration * p = dynamic_cast <const GGS_enumMessageListForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_enumMessageListForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_enumMessageListForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_enumMessageListForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_enumDeclarationForGeneration'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_enumDeclarationForGeneration::
cPtr_enumDeclarationForGeneration (const GGS_lstring & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_enumMessageListForGeneration & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticDeclarationForGeneration (THERE),
mEnumTypeName (argument_0),
mConstantList (argument_1),
mEnumMessageList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_enumDeclarationForGeneration * GGS_enumDeclarationForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_enumDeclarationForGeneration) ;
    return (cPtr_enumDeclarationForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_enumDeclarationForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_enumDeclarationForGeneration * ptr = dynamic_cast <const cPtr_enumDeclarationForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mEnumTypeName.operator_isEqual (ptr->mEnumTypeName).boolValue ()
         && mConstantList.operator_isEqual (ptr->mConstantList).boolValue ()
         && mEnumMessageList.operator_isEqual (ptr->mEnumMessageList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_enumDeclarationForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@enumDeclarationForGeneration:"
           << mEnumTypeName.reader_description (inIndentation + 1)
           << mConstantList.reader_description (inIndentation + 1)
           << mEnumMessageList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_enumDeclarationForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_enumDeclarationForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_enumDeclarationForGeneration (& typeid (cPtr_enumDeclarationForGeneration), & typeid (cPtr_semanticDeclarationForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_enumDeclarationForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__enumDeclarationForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_enumDeclarationForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_enumDeclarationForGeneration (mEnumTypeName, mConstantList, mEnumMessageList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_enumDeclarationForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_enumDeclarationForGeneration ("enumDeclarationForGeneration", true, & kTypeDescriptor_GGS_semanticDeclarationForGeneration) ;

//---------------------------------------------------------------------------*

GGS_enumDeclarationForGeneration::
GGS_enumDeclarationForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_enumDeclarationForGeneration::
GGS_enumDeclarationForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_enumDeclarationForGeneration GGS_enumDeclarationForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_enumDeclarationForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_enumDeclarationForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_enumDeclarationForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_enumDeclarationForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_enumDeclarationForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumDeclarationForGeneration GGS_enumDeclarationForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstringlist & argument_1,
                 const GGS_enumMessageListForGeneration & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_enumDeclarationForGeneration result ;
  macroMyNew (result.mPointer, cPtr_enumDeclarationForGeneration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_enumDeclarationForGeneration::
reader_mEnumTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumDeclarationForGeneration *) mPointer)->mEnumTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_enumDeclarationForGeneration::
reader_mConstantList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumDeclarationForGeneration *) mPointer)->mConstantList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMessageListForGeneration  GGS_enumDeclarationForGeneration::
reader_mEnumMessageList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_enumMessageListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumDeclarationForGeneration *) mPointer)->mEnumMessageList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_enumDeclarationForGeneration::actualTypeName (void) const {
  return "enumDeclarationForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__enumDeclarationForGeneration ("enumDeclarationForGeneration", gClassInfoFor__semanticDeclarationForGeneration, & kTypeDescriptor_GGS_enumDeclarationForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_enumDeclarationForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_enumDeclarationForGeneration * p = NULL ;
    macroMyNew (p, GGS_enumDeclarationForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumDeclarationForGeneration GGS_enumDeclarationForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_enumDeclarationForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_enumDeclarationForGeneration * p = dynamic_cast <const GGS_enumDeclarationForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_enumDeclarationForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_enumDeclarationForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_enumDeclarationForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         Element of list '@filewrapperTemplateListForGeneration'           *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_filewrapperTemplateListForGeneration::
elementOf_GGS_filewrapperTemplateListForGeneration (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_formalInputParameterListForGeneration & argument_2
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mFilewrapperTemplateName (argument_0),
mFilewrapperTemplatePath (argument_1),
mFilewrapperTemplateFormalInputParameters (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_filewrapperTemplateListForGeneration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_filewrapperTemplateListForGeneration * ptr = dynamic_cast <const elementOf_GGS_filewrapperTemplateListForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mFilewrapperTemplateName.operator_isEqual (ptr->mFilewrapperTemplateName).boolValue ()
         && mFilewrapperTemplatePath.operator_isEqual (ptr->mFilewrapperTemplatePath).boolValue ()
         && mFilewrapperTemplateFormalInputParameters.operator_isEqual (ptr->mFilewrapperTemplateFormalInputParameters).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_filewrapperTemplateListForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFilewrapperTemplateName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFilewrapperTemplatePath.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFilewrapperTemplateFormalInputParameters.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               List '@filewrapperTemplateListForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_filewrapperTemplateListForGeneration ("filewrapperTemplateListForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateListForGeneration::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_formalInputParameterListForGeneration & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateListForGeneration::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_formalInputParameterListForGeneration & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateListForGeneration::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_formalInputParameterListForGeneration & argument_2) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateListForGeneration GGS_filewrapperTemplateListForGeneration::
operator_concat (const GGS_filewrapperTemplateListForGeneration & inOperand) const {
  GGS_filewrapperTemplateListForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateListForGeneration::
dotAssign_operation (const GGS_filewrapperTemplateListForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_filewrapperTemplateListForGeneration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mFilewrapperTemplateName ;
          GGS_lstring  p_1 = p->mFilewrapperTemplatePath ;
          GGS_formalInputParameterListForGeneration  p_2 = p->mFilewrapperTemplateFormalInputParameters ;
          internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateListForGeneration::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_formalInputParameterListForGeneration & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateListForGeneration::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mFilewrapperTemplateName,
                                ptr->mFilewrapperTemplatePath,
                                ptr->mFilewrapperTemplateFormalInputParameters
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateListForGeneration  GGS_filewrapperTemplateListForGeneration::
constructor_emptyList (void) {
  GGS_filewrapperTemplateListForGeneration result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateListForGeneration  GGS_filewrapperTemplateListForGeneration::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_formalInputParameterListForGeneration & argument_2) {
  GGS_filewrapperTemplateListForGeneration result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateListForGeneration::
internalSubListWithRange (GGS_filewrapperTemplateListForGeneration & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mFilewrapperTemplateName, ptr->mFilewrapperTemplatePath, ptr->mFilewrapperTemplateFormalInputParameters) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateListForGeneration GGS_filewrapperTemplateListForGeneration::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_filewrapperTemplateListForGeneration result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateListForGeneration GGS_filewrapperTemplateListForGeneration::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_filewrapperTemplateListForGeneration result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_filewrapperTemplateListForGeneration::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@filewrapperTemplateListForGeneration", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateListForGeneration::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1,
              GGS_formalInputParameterListForGeneration & _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mFilewrapperTemplateName ;
    _out_1 = ptr->mFilewrapperTemplatePath ;
    _out_2 = ptr->mFilewrapperTemplateFormalInputParameters ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateListForGeneration::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1,
             GGS_formalInputParameterListForGeneration & _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mFilewrapperTemplateName ;
    _out_1 = ptr->mFilewrapperTemplatePath ;
    _out_2 = ptr->mFilewrapperTemplateFormalInputParameters ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateListForGeneration::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1,
                 GGS_formalInputParameterListForGeneration & _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mFilewrapperTemplateName ;
    _out_1 = ptr->mFilewrapperTemplatePath ;
    _out_2 = ptr->mFilewrapperTemplateFormalInputParameters ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateListForGeneration::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1,
                GGS_formalInputParameterListForGeneration & _out_2
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mFilewrapperTemplateName ;
    _out_1 = ptr->mFilewrapperTemplatePath ;
    _out_2 = ptr->mFilewrapperTemplateFormalInputParameters ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_filewrapperTemplateListForGeneration::
reader_mFilewrapperTemplateNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mFilewrapperTemplateName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_filewrapperTemplateListForGeneration::
reader_mFilewrapperTemplatePathAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mFilewrapperTemplatePath ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalInputParameterListForGeneration  GGS_filewrapperTemplateListForGeneration::
reader_mFilewrapperTemplateFormalInputParametersAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_formalInputParameterListForGeneration  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mFilewrapperTemplateFormalInputParameters ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateListForGeneration::
modifier_setMFilewrapperTemplateNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mFilewrapperTemplateName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateListForGeneration::
modifier_setMFilewrapperTemplatePathAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mFilewrapperTemplatePath = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateListForGeneration::
modifier_setMFilewrapperTemplateFormalInputParametersAtIndex (C_Compiler & inLexique,
                              const GGS_formalInputParameterListForGeneration  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mFilewrapperTemplateFormalInputParameters = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_filewrapperTemplateListForGeneration::cEnumerator::_mFilewrapperTemplateName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mFilewrapperTemplateName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_filewrapperTemplateListForGeneration::cEnumerator::_mFilewrapperTemplatePath (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mFilewrapperTemplatePath ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_formalInputParameterListForGeneration  & GGS_filewrapperTemplateListForGeneration::cEnumerator::_mFilewrapperTemplateFormalInputParameters (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mFilewrapperTemplateFormalInputParameters ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_filewrapperTemplateListForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_filewrapperTemplateListForGeneration * p = NULL ;
    macroMyNew (p, GGS_filewrapperTemplateListForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateListForGeneration GGS_filewrapperTemplateListForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_filewrapperTemplateListForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_filewrapperTemplateListForGeneration * p = dynamic_cast <const GGS_filewrapperTemplateListForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_filewrapperTemplateListForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_filewrapperTemplateListForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_filewrapperTemplateListForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_filewrapperDeclarationForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_filewrapperDeclarationForGeneration::
cPtr_filewrapperDeclarationForGeneration (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstringlist & argument_2,
                                const GGS_filewrapperTemplateListForGeneration & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticDeclarationForGeneration (THERE),
mFilewrapperName (argument_0),
mFilewrapperPath (argument_1),
mFilewrapperExtensionList (argument_2),
mFilewrapperTemplateList (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_filewrapperDeclarationForGeneration * GGS_filewrapperDeclarationForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_filewrapperDeclarationForGeneration) ;
    return (cPtr_filewrapperDeclarationForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_filewrapperDeclarationForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_filewrapperDeclarationForGeneration * ptr = dynamic_cast <const cPtr_filewrapperDeclarationForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mFilewrapperName.operator_isEqual (ptr->mFilewrapperName).boolValue ()
         && mFilewrapperPath.operator_isEqual (ptr->mFilewrapperPath).boolValue ()
         && mFilewrapperExtensionList.operator_isEqual (ptr->mFilewrapperExtensionList).boolValue ()
         && mFilewrapperTemplateList.operator_isEqual (ptr->mFilewrapperTemplateList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_filewrapperDeclarationForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@filewrapperDeclarationForGeneration:"
           << mFilewrapperName.reader_description (inIndentation + 1)
           << mFilewrapperPath.reader_description (inIndentation + 1)
           << mFilewrapperExtensionList.reader_description (inIndentation + 1)
           << mFilewrapperTemplateList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_filewrapperDeclarationForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_filewrapperDeclarationForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_filewrapperDeclarationForGeneration (& typeid (cPtr_filewrapperDeclarationForGeneration), & typeid (cPtr_semanticDeclarationForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_filewrapperDeclarationForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__filewrapperDeclarationForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_filewrapperDeclarationForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_filewrapperDeclarationForGeneration (mFilewrapperName, mFilewrapperPath, mFilewrapperExtensionList, mFilewrapperTemplateList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_filewrapperDeclarationForGeneration'           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_filewrapperDeclarationForGeneration ("filewrapperDeclarationForGeneration", true, & kTypeDescriptor_GGS_semanticDeclarationForGeneration) ;

//---------------------------------------------------------------------------*

GGS_filewrapperDeclarationForGeneration::
GGS_filewrapperDeclarationForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperDeclarationForGeneration::
GGS_filewrapperDeclarationForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_filewrapperDeclarationForGeneration GGS_filewrapperDeclarationForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_filewrapperDeclarationForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_filewrapperDeclarationForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_filewrapperDeclarationForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_filewrapperDeclarationForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_filewrapperDeclarationForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperDeclarationForGeneration GGS_filewrapperDeclarationForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstringlist & argument_2,
                 const GGS_filewrapperTemplateListForGeneration & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_filewrapperDeclarationForGeneration result ;
  macroMyNew (result.mPointer, cPtr_filewrapperDeclarationForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_filewrapperDeclarationForGeneration::
reader_mFilewrapperName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_filewrapperDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_filewrapperDeclarationForGeneration *) mPointer)->mFilewrapperName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_filewrapperDeclarationForGeneration::
reader_mFilewrapperPath (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_filewrapperDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_filewrapperDeclarationForGeneration *) mPointer)->mFilewrapperPath ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_filewrapperDeclarationForGeneration::
reader_mFilewrapperExtensionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_filewrapperDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_filewrapperDeclarationForGeneration *) mPointer)->mFilewrapperExtensionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateListForGeneration  GGS_filewrapperDeclarationForGeneration::
reader_mFilewrapperTemplateList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_filewrapperTemplateListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_filewrapperDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_filewrapperDeclarationForGeneration *) mPointer)->mFilewrapperTemplateList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_filewrapperDeclarationForGeneration::actualTypeName (void) const {
  return "filewrapperDeclarationForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__filewrapperDeclarationForGeneration ("filewrapperDeclarationForGeneration", gClassInfoFor__semanticDeclarationForGeneration, & kTypeDescriptor_GGS_filewrapperDeclarationForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_filewrapperDeclarationForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_filewrapperDeclarationForGeneration * p = NULL ;
    macroMyNew (p, GGS_filewrapperDeclarationForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperDeclarationForGeneration GGS_filewrapperDeclarationForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_filewrapperDeclarationForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_filewrapperDeclarationForGeneration * p = dynamic_cast <const GGS_filewrapperDeclarationForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_filewrapperDeclarationForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_filewrapperDeclarationForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_filewrapperDeclarationForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_semanticsComponentForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_semanticsComponentForGeneration::
cPtr_semanticsComponentForGeneration (const GGS_lstring & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_semanticDeclarationStructForGeneration& argument_2,
                                const GGS_location & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE),
mSemanticsComponentName (argument_0),
mImportedComponentFileNameList (argument_1),
mSemanticDeclarations (argument_2),
mEndOfSourceFile (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_semanticsComponentForGeneration * GGS_semanticsComponentForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_semanticsComponentForGeneration) ;
    return (cPtr_semanticsComponentForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_semanticsComponentForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_semanticsComponentForGeneration * ptr = dynamic_cast <const cPtr_semanticsComponentForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mSemanticsComponentName.operator_isEqual (ptr->mSemanticsComponentName).boolValue ()
         && mImportedComponentFileNameList.operator_isEqual (ptr->mImportedComponentFileNameList).boolValue ()
         && mSemanticDeclarations.operator_isEqual (ptr->mSemanticDeclarations).boolValue ()
         && mEndOfSourceFile.operator_isEqual (ptr->mEndOfSourceFile).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_semanticsComponentForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@semanticsComponentForGeneration:"
           << mSemanticsComponentName.reader_description (inIndentation + 1)
           << mImportedComponentFileNameList.reader_description (inIndentation + 1)
           << mSemanticDeclarations.reader_description (inIndentation + 1)
           << mEndOfSourceFile.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_semanticsComponentForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_semanticsComponentForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_semanticsComponentForGeneration (& typeid (cPtr_semanticsComponentForGeneration), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_semanticsComponentForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__semanticsComponentForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_semanticsComponentForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_semanticsComponentForGeneration (mSemanticsComponentName, mImportedComponentFileNameList, mSemanticDeclarations, mEndOfSourceFile COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_semanticsComponentForGeneration'             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_semanticsComponentForGeneration ("semanticsComponentForGeneration", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_semanticsComponentForGeneration::
GGS_semanticsComponentForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_semanticsComponentForGeneration::
GGS_semanticsComponentForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_semanticsComponentForGeneration GGS_semanticsComponentForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_semanticsComponentForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_semanticsComponentForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_semanticsComponentForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_semanticsComponentForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_semanticsComponentForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticsComponentForGeneration GGS_semanticsComponentForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstringlist & argument_1,
                 const GGS_semanticDeclarationStructForGeneration& argument_2,
                 const GGS_location & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_semanticsComponentForGeneration result ;
  macroMyNew (result.mPointer, cPtr_semanticsComponentForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_semanticsComponentForGeneration::
reader_mSemanticsComponentName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_semanticsComponentForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_semanticsComponentForGeneration *) mPointer)->mSemanticsComponentName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_semanticsComponentForGeneration::
reader_mImportedComponentFileNameList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_semanticsComponentForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_semanticsComponentForGeneration *) mPointer)->mImportedComponentFileNameList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationStructForGeneration GGS_semanticsComponentForGeneration::
reader_mSemanticDeclarations (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticDeclarationStructForGeneration  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_semanticsComponentForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_semanticsComponentForGeneration *) mPointer)->mSemanticDeclarations ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_semanticsComponentForGeneration::
reader_mEndOfSourceFile (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_semanticsComponentForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_semanticsComponentForGeneration *) mPointer)->mEndOfSourceFile ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_semanticsComponentForGeneration::actualTypeName (void) const {
  return "semanticsComponentForGeneration" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_semanticsComponentForGeneration::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__semanticsComponentForGeneration ("semanticsComponentForGeneration", & kTypeDescriptor_GGS_semanticsComponentForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_semanticsComponentForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_semanticsComponentForGeneration * p = NULL ;
    macroMyNew (p, GGS_semanticsComponentForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticsComponentForGeneration GGS_semanticsComponentForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_semanticsComponentForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_semanticsComponentForGeneration * p = dynamic_cast <const GGS_semanticsComponentForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_semanticsComponentForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_semanticsComponentForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_semanticsComponentForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      Prologue and epilogue actions                        *
//                                                                           *
//---------------------------------------------------------------------------*

static void epilogueRoutineFor_semanticsDecoratedTypes (void) {
  macroReleaseObject (gSingleton_selfInExpressionForGeneration) ;
  macroReleaseObject (gSingleton_hereExpressionForGeneration) ;
  macroReleaseObject (gSingleton_trueExpressionForGeneration) ;
  macroReleaseObject (gSingleton_falseExpressionForGeneration) ;
  macroReleaseObject (gSingleton_inputJokerActualParameterForGeneration) ;
  macroReleaseObject (gSingleton_foreachInstructionJokerForGeneration) ;
}

//---------------------------------------------------------------------------*

C_PrologueEpilogue prologueEpilogueObjectFor_semanticsDecoratedTypes (NULL, epilogueRoutineFor_semanticsDecoratedTypes) ;

//---------------------------------------------------------------------------*

