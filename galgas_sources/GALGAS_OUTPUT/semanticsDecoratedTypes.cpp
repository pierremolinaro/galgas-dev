//---------------------------------------------------------------------------*
//                                                                           *
//                    File 'semanticsDecoratedTypes.cpp'                     *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                     october 27th, 2010, at 10h51'13"                      *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if CURRENT_LIBPM_VERSION != VERSION_OF_LIBPM_USED_BY_GALGAS_COMPILER
  #error "This file has been compiled with a version of GALGAS that uses libpm version VERSION_OF_LIBPM_USED_BY_GALGAS_COMPILER, different than the current version (CURRENT_LIBPM_VERSION) of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "galgas/C_galgas_CLI_Options.h"
#include "semanticsDecoratedTypes.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "semanticsDecoratedTypes.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'cPtr_templateInstructionForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_templateInstructionForGeneration::
cPtr_templateInstructionForGeneration (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_templateInstructionForGeneration * GGS_templateInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_templateInstructionForGeneration) ;
    return (cPtr_templateInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_templateInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@templateInstructionForGeneration:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_templateInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_templateInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_templateInstructionForGeneration (& typeid (cPtr_templateInstructionForGeneration), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_templateInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__templateInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_templateInstructionForGeneration'             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateInstructionForGeneration ("templateInstructionForGeneration", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_templateInstructionForGeneration::
GGS_templateInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionForGeneration::
GGS_templateInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_templateInstructionForGeneration GGS_templateInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_templateInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_templateInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_templateInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_templateInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_templateInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_templateInstructionForGeneration::actualTypeName (void) const {
  return "templateInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_templateInstructionForGeneration::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__templateInstructionForGeneration ("templateInstructionForGeneration", & kTypeDescriptor_GGS_templateInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_templateInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_templateInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionForGeneration GGS_templateInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateInstructionForGeneration * p = dynamic_cast <const GGS_templateInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         Element of list '@templateInstructionListForGeneration'           *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_templateInstructionListForGeneration::
elementOf_GGS_templateInstructionListForGeneration (const GGS_templateInstructionForGeneration & argument_0
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mInstruction (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_templateInstructionListForGeneration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_templateInstructionListForGeneration * ptr = dynamic_cast <const elementOf_GGS_templateInstructionListForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstruction.operator_isEqual (ptr->mInstruction).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_templateInstructionListForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstruction.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               List '@templateInstructionListForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateInstructionListForGeneration ("templateInstructionListForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_templateInstructionListForGeneration::
internalAppendValues (const GGS_templateInstructionForGeneration & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionListForGeneration::
internalPrependValues (const GGS_templateInstructionForGeneration & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionListForGeneration::
addAssign_operation (const GGS_templateInstructionForGeneration & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_templateInstructionListForGeneration GGS_templateInstructionListForGeneration::
operator_concat (const GGS_templateInstructionListForGeneration & inOperand) const {
  GGS_templateInstructionListForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionListForGeneration::
dotAssign_operation (const GGS_templateInstructionListForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_templateInstructionListForGeneration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_templateInstructionForGeneration  p_0 = p->mInstruction ;
          internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionListForGeneration::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_templateInstructionForGeneration & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionListForGeneration::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mInstruction
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_templateInstructionListForGeneration  GGS_templateInstructionListForGeneration::
constructor_emptyList (void) {
  GGS_templateInstructionListForGeneration result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionListForGeneration  GGS_templateInstructionListForGeneration::
constructor_listWithValue (const GGS_templateInstructionForGeneration & argument_0) {
  GGS_templateInstructionListForGeneration result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionListForGeneration::
internalSubListWithRange (GGS_templateInstructionListForGeneration & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mInstruction) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_templateInstructionListForGeneration GGS_templateInstructionListForGeneration::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_templateInstructionListForGeneration result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionListForGeneration GGS_templateInstructionListForGeneration::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_templateInstructionListForGeneration result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_templateInstructionListForGeneration::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@templateInstructionListForGeneration", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionListForGeneration::
method_first (C_Compiler & inLexique,
              GGS_templateInstructionForGeneration & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInstruction ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionListForGeneration::
method_last (C_Compiler & inLexique,
             GGS_templateInstructionForGeneration & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInstruction ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionListForGeneration::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_templateInstructionForGeneration & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInstruction ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionListForGeneration::
modifier_popLast (C_Compiler & inLexique,
                GGS_templateInstructionForGeneration & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInstruction ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_templateInstructionForGeneration  GGS_templateInstructionListForGeneration::
reader_mInstructionAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_templateInstructionForGeneration  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstruction ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionListForGeneration::
modifier_setMInstructionAtIndex (C_Compiler & inLexique,
                              const GGS_templateInstructionForGeneration  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstruction = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_templateInstructionForGeneration  & GGS_templateInstructionListForGeneration::cEnumerator::_mInstruction (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mInstruction ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_templateInstructionListForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateInstructionListForGeneration * p = NULL ;
    macroMyNew (p, GGS_templateInstructionListForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionListForGeneration GGS_templateInstructionListForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateInstructionListForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateInstructionListForGeneration * p = dynamic_cast <const GGS_templateInstructionListForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateInstructionListForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateInstructionListForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateInstructionListForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_semanticExpressionForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_semanticExpressionForGeneration::
cPtr_semanticExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE),
mType (argument_0),
mLocation (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_semanticExpressionForGeneration * GGS_semanticExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_semanticExpressionForGeneration) ;
    return (cPtr_semanticExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_semanticExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@semanticExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_semanticExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_semanticExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_semanticExpressionForGeneration (& typeid (cPtr_semanticExpressionForGeneration), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_semanticExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__semanticExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_semanticExpressionForGeneration'             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_semanticExpressionForGeneration ("semanticExpressionForGeneration", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration::
GGS_semanticExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration::
GGS_semanticExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_semanticExpressionForGeneration GGS_semanticExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_semanticExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_semanticExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_semanticExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_semanticExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_semanticExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapProxy  GGS_semanticExpressionForGeneration::
reader_mType (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_unifiedTypeMapProxy   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_semanticExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_semanticExpressionForGeneration *) mPointer)->mType ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_semanticExpressionForGeneration::
reader_mLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_semanticExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_semanticExpressionForGeneration *) mPointer)->mLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_semanticExpressionForGeneration::actualTypeName (void) const {
  return "semanticExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_semanticExpressionForGeneration::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__semanticExpressionForGeneration ("semanticExpressionForGeneration", & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_semanticExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_semanticExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_semanticExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration GGS_semanticExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_semanticExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_semanticExpressionForGeneration * p = dynamic_cast <const GGS_semanticExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_semanticExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_semanticExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_semanticExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Element of list '@semanticExpressionListForGeneration'           *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_semanticExpressionListForGeneration::
elementOf_GGS_semanticExpressionListForGeneration (const GGS_semanticExpressionForGeneration & argument_0
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mExpression (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_semanticExpressionListForGeneration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_semanticExpressionListForGeneration * ptr = dynamic_cast <const elementOf_GGS_semanticExpressionListForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mExpression.operator_isEqual (ptr->mExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_semanticExpressionListForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mExpression.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               List '@semanticExpressionListForGeneration'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_semanticExpressionListForGeneration ("semanticExpressionListForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_semanticExpressionListForGeneration::
internalAppendValues (const GGS_semanticExpressionForGeneration & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticExpressionListForGeneration::
internalPrependValues (const GGS_semanticExpressionForGeneration & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticExpressionListForGeneration::
addAssign_operation (const GGS_semanticExpressionForGeneration & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionListForGeneration GGS_semanticExpressionListForGeneration::
operator_concat (const GGS_semanticExpressionListForGeneration & inOperand) const {
  GGS_semanticExpressionListForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_semanticExpressionListForGeneration::
dotAssign_operation (const GGS_semanticExpressionListForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_semanticExpressionListForGeneration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_semanticExpressionForGeneration  p_0 = p->mExpression ;
          internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticExpressionListForGeneration::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_semanticExpressionForGeneration & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticExpressionListForGeneration::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mExpression
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionListForGeneration  GGS_semanticExpressionListForGeneration::
constructor_emptyList (void) {
  GGS_semanticExpressionListForGeneration result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionListForGeneration  GGS_semanticExpressionListForGeneration::
constructor_listWithValue (const GGS_semanticExpressionForGeneration & argument_0) {
  GGS_semanticExpressionListForGeneration result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_semanticExpressionListForGeneration::
internalSubListWithRange (GGS_semanticExpressionListForGeneration & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mExpression) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionListForGeneration GGS_semanticExpressionListForGeneration::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_semanticExpressionListForGeneration result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionListForGeneration GGS_semanticExpressionListForGeneration::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_semanticExpressionListForGeneration result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_semanticExpressionListForGeneration::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@semanticExpressionListForGeneration", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticExpressionListForGeneration::
method_first (C_Compiler & inLexique,
              GGS_semanticExpressionForGeneration & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mExpression ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticExpressionListForGeneration::
method_last (C_Compiler & inLexique,
             GGS_semanticExpressionForGeneration & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mExpression ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticExpressionListForGeneration::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_semanticExpressionForGeneration & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mExpression ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticExpressionListForGeneration::
modifier_popLast (C_Compiler & inLexique,
                GGS_semanticExpressionForGeneration & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mExpression ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_semanticExpressionListForGeneration::
reader_mExpressionAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mExpression ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_semanticExpressionListForGeneration::
modifier_setMExpressionAtIndex (C_Compiler & inLexique,
                              const GGS_semanticExpressionForGeneration  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mExpression = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticExpressionForGeneration  & GGS_semanticExpressionListForGeneration::cEnumerator::_mExpression (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mExpression ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_semanticExpressionListForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_semanticExpressionListForGeneration * p = NULL ;
    macroMyNew (p, GGS_semanticExpressionListForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionListForGeneration GGS_semanticExpressionListForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_semanticExpressionListForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_semanticExpressionListForGeneration * p = dynamic_cast <const GGS_semanticExpressionListForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_semanticExpressionListForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_semanticExpressionListForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_semanticExpressionListForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'cPtr_selfCopyInExpressionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_selfCopyInExpressionForGeneration::
cPtr_selfCopyInExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_string& argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mSelfCppName (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_selfCopyInExpressionForGeneration * GGS_selfCopyInExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_selfCopyInExpressionForGeneration) ;
    return (cPtr_selfCopyInExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_selfCopyInExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_selfCopyInExpressionForGeneration * ptr = dynamic_cast <const cPtr_selfCopyInExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mSelfCppName.operator_isEqual (ptr->mSelfCppName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_selfCopyInExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@selfCopyInExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mSelfCppName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_selfCopyInExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_selfCopyInExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_selfCopyInExpressionForGeneration (& typeid (cPtr_selfCopyInExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_selfCopyInExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__selfCopyInExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_selfCopyInExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_selfCopyInExpressionForGeneration (mType, mLocation, mSelfCppName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_selfCopyInExpressionForGeneration'            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_selfCopyInExpressionForGeneration ("selfCopyInExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_selfCopyInExpressionForGeneration::
GGS_selfCopyInExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_selfCopyInExpressionForGeneration::
GGS_selfCopyInExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_selfCopyInExpressionForGeneration GGS_selfCopyInExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_selfCopyInExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_selfCopyInExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_selfCopyInExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_selfCopyInExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_selfCopyInExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_selfCopyInExpressionForGeneration GGS_selfCopyInExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_string& argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_selfCopyInExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_selfCopyInExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_selfCopyInExpressionForGeneration::
reader_mSelfCppName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_selfCopyInExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_selfCopyInExpressionForGeneration *) mPointer)->mSelfCppName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_selfCopyInExpressionForGeneration::actualTypeName (void) const {
  return "selfCopyInExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__selfCopyInExpressionForGeneration ("selfCopyInExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_selfCopyInExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_selfCopyInExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_selfCopyInExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_selfCopyInExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_selfCopyInExpressionForGeneration GGS_selfCopyInExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_selfCopyInExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_selfCopyInExpressionForGeneration * p = dynamic_cast <const GGS_selfCopyInExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_selfCopyInExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_selfCopyInExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_selfCopyInExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_hereExpressionForGeneration'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_hereExpressionForGeneration::
cPtr_hereExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_hereExpressionForGeneration * GGS_hereExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_hereExpressionForGeneration) ;
    return (cPtr_hereExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_hereExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_hereExpressionForGeneration * ptr = dynamic_cast <const cPtr_hereExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_hereExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@hereExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_hereExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_hereExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_hereExpressionForGeneration (& typeid (cPtr_hereExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_hereExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__hereExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_hereExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_hereExpressionForGeneration (mType, mLocation COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_hereExpressionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_hereExpressionForGeneration ("hereExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_hereExpressionForGeneration::
GGS_hereExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_hereExpressionForGeneration::
GGS_hereExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_hereExpressionForGeneration GGS_hereExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_hereExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_hereExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_hereExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_hereExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_hereExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_hereExpressionForGeneration GGS_hereExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_hereExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_hereExpressionForGeneration (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_hereExpressionForGeneration::actualTypeName (void) const {
  return "hereExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__hereExpressionForGeneration ("hereExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_hereExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_hereExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_hereExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_hereExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_hereExpressionForGeneration GGS_hereExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_hereExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_hereExpressionForGeneration * p = dynamic_cast <const GGS_hereExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_hereExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_hereExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_hereExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_trueExpressionForGeneration'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_trueExpressionForGeneration::
cPtr_trueExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_trueExpressionForGeneration * GGS_trueExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_trueExpressionForGeneration) ;
    return (cPtr_trueExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_trueExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_trueExpressionForGeneration * ptr = dynamic_cast <const cPtr_trueExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_trueExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@trueExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_trueExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_trueExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_trueExpressionForGeneration (& typeid (cPtr_trueExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_trueExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__trueExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_trueExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_trueExpressionForGeneration (mType, mLocation COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_trueExpressionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_trueExpressionForGeneration ("trueExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_trueExpressionForGeneration::
GGS_trueExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_trueExpressionForGeneration::
GGS_trueExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_trueExpressionForGeneration GGS_trueExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_trueExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_trueExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_trueExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_trueExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_trueExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_trueExpressionForGeneration GGS_trueExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_trueExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_trueExpressionForGeneration (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_trueExpressionForGeneration::actualTypeName (void) const {
  return "trueExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__trueExpressionForGeneration ("trueExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_trueExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_trueExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_trueExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_trueExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_trueExpressionForGeneration GGS_trueExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_trueExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_trueExpressionForGeneration * p = dynamic_cast <const GGS_trueExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_trueExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_trueExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_trueExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_falseExpressionForGeneration'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_falseExpressionForGeneration::
cPtr_falseExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_falseExpressionForGeneration * GGS_falseExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_falseExpressionForGeneration) ;
    return (cPtr_falseExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_falseExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_falseExpressionForGeneration * ptr = dynamic_cast <const cPtr_falseExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_falseExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@falseExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_falseExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_falseExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_falseExpressionForGeneration (& typeid (cPtr_falseExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_falseExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__falseExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_falseExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_falseExpressionForGeneration (mType, mLocation COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_falseExpressionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_falseExpressionForGeneration ("falseExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_falseExpressionForGeneration::
GGS_falseExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_falseExpressionForGeneration::
GGS_falseExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_falseExpressionForGeneration GGS_falseExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_falseExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_falseExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_falseExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_falseExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_falseExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_falseExpressionForGeneration GGS_falseExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_falseExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_falseExpressionForGeneration (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_falseExpressionForGeneration::actualTypeName (void) const {
  return "falseExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__falseExpressionForGeneration ("falseExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_falseExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_falseExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_falseExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_falseExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_falseExpressionForGeneration GGS_falseExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_falseExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_falseExpressionForGeneration * p = dynamic_cast <const GGS_falseExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_falseExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_falseExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_falseExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_literalCharExpressionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_literalCharExpressionForGeneration::
cPtr_literalCharExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_char& argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mCharacter (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_literalCharExpressionForGeneration * GGS_literalCharExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_literalCharExpressionForGeneration) ;
    return (cPtr_literalCharExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_literalCharExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_literalCharExpressionForGeneration * ptr = dynamic_cast <const cPtr_literalCharExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mCharacter.operator_isEqual (ptr->mCharacter).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_literalCharExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@literalCharExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mCharacter.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_literalCharExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_literalCharExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_literalCharExpressionForGeneration (& typeid (cPtr_literalCharExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_literalCharExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__literalCharExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_literalCharExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_literalCharExpressionForGeneration (mType, mLocation, mCharacter COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_literalCharExpressionForGeneration'            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_literalCharExpressionForGeneration ("literalCharExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_literalCharExpressionForGeneration::
GGS_literalCharExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_literalCharExpressionForGeneration::
GGS_literalCharExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_literalCharExpressionForGeneration GGS_literalCharExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_literalCharExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_literalCharExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_literalCharExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_literalCharExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_literalCharExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalCharExpressionForGeneration GGS_literalCharExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_char& argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_literalCharExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_literalCharExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_char GGS_literalCharExpressionForGeneration::
reader_mCharacter (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_char  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_literalCharExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_literalCharExpressionForGeneration *) mPointer)->mCharacter ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_literalCharExpressionForGeneration::actualTypeName (void) const {
  return "literalCharExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__literalCharExpressionForGeneration ("literalCharExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_literalCharExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_literalCharExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_literalCharExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_literalCharExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalCharExpressionForGeneration GGS_literalCharExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_literalCharExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_literalCharExpressionForGeneration * p = dynamic_cast <const GGS_literalCharExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_literalCharExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_literalCharExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_literalCharExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            class 'cPtr_literalStringExpressionForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_literalStringExpressionForGeneration::
cPtr_literalStringExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_string& argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mString (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_literalStringExpressionForGeneration * GGS_literalStringExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_literalStringExpressionForGeneration) ;
    return (cPtr_literalStringExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_literalStringExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_literalStringExpressionForGeneration * ptr = dynamic_cast <const cPtr_literalStringExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mString.operator_isEqual (ptr->mString).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_literalStringExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@literalStringExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mString.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_literalStringExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_literalStringExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_literalStringExpressionForGeneration (& typeid (cPtr_literalStringExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_literalStringExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__literalStringExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_literalStringExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_literalStringExpressionForGeneration (mType, mLocation, mString COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         GALGAS class 'GGS_literalStringExpressionForGeneration'           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_literalStringExpressionForGeneration ("literalStringExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_literalStringExpressionForGeneration::
GGS_literalStringExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_literalStringExpressionForGeneration::
GGS_literalStringExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_literalStringExpressionForGeneration GGS_literalStringExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_literalStringExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_literalStringExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_literalStringExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_literalStringExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_literalStringExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalStringExpressionForGeneration GGS_literalStringExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_string& argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_literalStringExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_literalStringExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_literalStringExpressionForGeneration::
reader_mString (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_literalStringExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_literalStringExpressionForGeneration *) mPointer)->mString ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_literalStringExpressionForGeneration::actualTypeName (void) const {
  return "literalStringExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__literalStringExpressionForGeneration ("literalStringExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_literalStringExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_literalStringExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_literalStringExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_literalStringExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalStringExpressionForGeneration GGS_literalStringExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_literalStringExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_literalStringExpressionForGeneration * p = dynamic_cast <const GGS_literalStringExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_literalStringExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_literalStringExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_literalStringExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            class 'cPtr_literalDoubleExpressionForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_literalDoubleExpressionForGeneration::
cPtr_literalDoubleExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_double& argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mValue (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_literalDoubleExpressionForGeneration * GGS_literalDoubleExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_literalDoubleExpressionForGeneration) ;
    return (cPtr_literalDoubleExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_literalDoubleExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_literalDoubleExpressionForGeneration * ptr = dynamic_cast <const cPtr_literalDoubleExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mValue.operator_isEqual (ptr->mValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_literalDoubleExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@literalDoubleExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mValue.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_literalDoubleExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_literalDoubleExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_literalDoubleExpressionForGeneration (& typeid (cPtr_literalDoubleExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_literalDoubleExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__literalDoubleExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_literalDoubleExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_literalDoubleExpressionForGeneration (mType, mLocation, mValue COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         GALGAS class 'GGS_literalDoubleExpressionForGeneration'           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_literalDoubleExpressionForGeneration ("literalDoubleExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_literalDoubleExpressionForGeneration::
GGS_literalDoubleExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_literalDoubleExpressionForGeneration::
GGS_literalDoubleExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_literalDoubleExpressionForGeneration GGS_literalDoubleExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_literalDoubleExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_literalDoubleExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_literalDoubleExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_literalDoubleExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_literalDoubleExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalDoubleExpressionForGeneration GGS_literalDoubleExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_double& argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_literalDoubleExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_literalDoubleExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_double GGS_literalDoubleExpressionForGeneration::
reader_mValue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_double  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_literalDoubleExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_literalDoubleExpressionForGeneration *) mPointer)->mValue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_literalDoubleExpressionForGeneration::actualTypeName (void) const {
  return "literalDoubleExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__literalDoubleExpressionForGeneration ("literalDoubleExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_literalDoubleExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_literalDoubleExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_literalDoubleExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_literalDoubleExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalDoubleExpressionForGeneration GGS_literalDoubleExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_literalDoubleExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_literalDoubleExpressionForGeneration * p = dynamic_cast <const GGS_literalDoubleExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_literalDoubleExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_literalDoubleExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_literalDoubleExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_literalUIntExpressionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_literalUIntExpressionForGeneration::
cPtr_literalUIntExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_uint & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mValue (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_literalUIntExpressionForGeneration * GGS_literalUIntExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_literalUIntExpressionForGeneration) ;
    return (cPtr_literalUIntExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_literalUIntExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_literalUIntExpressionForGeneration * ptr = dynamic_cast <const cPtr_literalUIntExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mValue.operator_isEqual (ptr->mValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_literalUIntExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@literalUIntExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mValue.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_literalUIntExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_literalUIntExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_literalUIntExpressionForGeneration (& typeid (cPtr_literalUIntExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_literalUIntExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__literalUIntExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_literalUIntExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_literalUIntExpressionForGeneration (mType, mLocation, mValue COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_literalUIntExpressionForGeneration'            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_literalUIntExpressionForGeneration ("literalUIntExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_literalUIntExpressionForGeneration::
GGS_literalUIntExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_literalUIntExpressionForGeneration::
GGS_literalUIntExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_literalUIntExpressionForGeneration GGS_literalUIntExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_literalUIntExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_literalUIntExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_literalUIntExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_literalUIntExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_literalUIntExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalUIntExpressionForGeneration GGS_literalUIntExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_uint & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_literalUIntExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_literalUIntExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_literalUIntExpressionForGeneration::
reader_mValue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_literalUIntExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_literalUIntExpressionForGeneration *) mPointer)->mValue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_literalUIntExpressionForGeneration::actualTypeName (void) const {
  return "literalUIntExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__literalUIntExpressionForGeneration ("literalUIntExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_literalUIntExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_literalUIntExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_literalUIntExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_literalUIntExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalUIntExpressionForGeneration GGS_literalUIntExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_literalUIntExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_literalUIntExpressionForGeneration * p = dynamic_cast <const GGS_literalUIntExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_literalUIntExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_literalUIntExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_literalUIntExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            class 'cPtr_literalUInt64ExpressionForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_literalUInt64ExpressionForGeneration::
cPtr_literalUInt64ExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_uint64 & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mValue (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_literalUInt64ExpressionForGeneration * GGS_literalUInt64ExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_literalUInt64ExpressionForGeneration) ;
    return (cPtr_literalUInt64ExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_literalUInt64ExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_literalUInt64ExpressionForGeneration * ptr = dynamic_cast <const cPtr_literalUInt64ExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mValue.operator_isEqual (ptr->mValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_literalUInt64ExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@literalUInt64ExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mValue.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_literalUInt64ExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_literalUInt64ExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_literalUInt64ExpressionForGeneration (& typeid (cPtr_literalUInt64ExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_literalUInt64ExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__literalUInt64ExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_literalUInt64ExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_literalUInt64ExpressionForGeneration (mType, mLocation, mValue COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         GALGAS class 'GGS_literalUInt64ExpressionForGeneration'           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_literalUInt64ExpressionForGeneration ("literalUInt64ExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_literalUInt64ExpressionForGeneration::
GGS_literalUInt64ExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_literalUInt64ExpressionForGeneration::
GGS_literalUInt64ExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_literalUInt64ExpressionForGeneration GGS_literalUInt64ExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_literalUInt64ExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_literalUInt64ExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_literalUInt64ExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_literalUInt64ExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_literalUInt64ExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalUInt64ExpressionForGeneration GGS_literalUInt64ExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_uint64 & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_literalUInt64ExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_literalUInt64ExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint64  GGS_literalUInt64ExpressionForGeneration::
reader_mValue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_literalUInt64ExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_literalUInt64ExpressionForGeneration *) mPointer)->mValue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_literalUInt64ExpressionForGeneration::actualTypeName (void) const {
  return "literalUInt64ExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__literalUInt64ExpressionForGeneration ("literalUInt64ExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_literalUInt64ExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_literalUInt64ExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_literalUInt64ExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_literalUInt64ExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalUInt64ExpressionForGeneration GGS_literalUInt64ExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_literalUInt64ExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_literalUInt64ExpressionForGeneration * p = dynamic_cast <const GGS_literalUInt64ExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_literalUInt64ExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_literalUInt64ExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_literalUInt64ExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_literalSIntExpressionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_literalSIntExpressionForGeneration::
cPtr_literalSIntExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_sint & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mValue (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_literalSIntExpressionForGeneration * GGS_literalSIntExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_literalSIntExpressionForGeneration) ;
    return (cPtr_literalSIntExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_literalSIntExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_literalSIntExpressionForGeneration * ptr = dynamic_cast <const cPtr_literalSIntExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mValue.operator_isEqual (ptr->mValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_literalSIntExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@literalSIntExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mValue.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_literalSIntExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_literalSIntExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_literalSIntExpressionForGeneration (& typeid (cPtr_literalSIntExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_literalSIntExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__literalSIntExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_literalSIntExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_literalSIntExpressionForGeneration (mType, mLocation, mValue COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_literalSIntExpressionForGeneration'            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_literalSIntExpressionForGeneration ("literalSIntExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_literalSIntExpressionForGeneration::
GGS_literalSIntExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_literalSIntExpressionForGeneration::
GGS_literalSIntExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_literalSIntExpressionForGeneration GGS_literalSIntExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_literalSIntExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_literalSIntExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_literalSIntExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_literalSIntExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_literalSIntExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalSIntExpressionForGeneration GGS_literalSIntExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_sint & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_literalSIntExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_literalSIntExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sint  GGS_literalSIntExpressionForGeneration::
reader_mValue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_sint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_literalSIntExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_literalSIntExpressionForGeneration *) mPointer)->mValue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_literalSIntExpressionForGeneration::actualTypeName (void) const {
  return "literalSIntExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__literalSIntExpressionForGeneration ("literalSIntExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_literalSIntExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_literalSIntExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_literalSIntExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_literalSIntExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalSIntExpressionForGeneration GGS_literalSIntExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_literalSIntExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_literalSIntExpressionForGeneration * p = dynamic_cast <const GGS_literalSIntExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_literalSIntExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_literalSIntExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_literalSIntExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            class 'cPtr_literalSInt64ExpressionForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_literalSInt64ExpressionForGeneration::
cPtr_literalSInt64ExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_sint64 & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mValue (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_literalSInt64ExpressionForGeneration * GGS_literalSInt64ExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_literalSInt64ExpressionForGeneration) ;
    return (cPtr_literalSInt64ExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_literalSInt64ExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_literalSInt64ExpressionForGeneration * ptr = dynamic_cast <const cPtr_literalSInt64ExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mValue.operator_isEqual (ptr->mValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_literalSInt64ExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@literalSInt64ExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mValue.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_literalSInt64ExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_literalSInt64ExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_literalSInt64ExpressionForGeneration (& typeid (cPtr_literalSInt64ExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_literalSInt64ExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__literalSInt64ExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_literalSInt64ExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_literalSInt64ExpressionForGeneration (mType, mLocation, mValue COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         GALGAS class 'GGS_literalSInt64ExpressionForGeneration'           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_literalSInt64ExpressionForGeneration ("literalSInt64ExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_literalSInt64ExpressionForGeneration::
GGS_literalSInt64ExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_literalSInt64ExpressionForGeneration::
GGS_literalSInt64ExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_literalSInt64ExpressionForGeneration GGS_literalSInt64ExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_literalSInt64ExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_literalSInt64ExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_literalSInt64ExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_literalSInt64ExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_literalSInt64ExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalSInt64ExpressionForGeneration GGS_literalSInt64ExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_sint64 & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_literalSInt64ExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_literalSInt64ExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sint64  GGS_literalSInt64ExpressionForGeneration::
reader_mValue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_sint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_literalSInt64ExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_literalSInt64ExpressionForGeneration *) mPointer)->mValue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_literalSInt64ExpressionForGeneration::actualTypeName (void) const {
  return "literalSInt64ExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__literalSInt64ExpressionForGeneration ("literalSInt64ExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_literalSInt64ExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_literalSInt64ExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_literalSInt64ExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_literalSInt64ExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalSInt64ExpressionForGeneration GGS_literalSInt64ExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_literalSInt64ExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_literalSInt64ExpressionForGeneration * p = dynamic_cast <const GGS_literalSInt64ExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_literalSInt64ExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_literalSInt64ExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_literalSInt64ExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_constructorExpressionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_constructorExpressionForGeneration::
cPtr_constructorExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_unifiedTypeMapProxy & argument_2,
                                const GGS_string& argument_3,
                                const GGS_semanticExpressionListForGeneration & argument_4,
                                const GGS_bool& argument_5
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mConstructorType (argument_2),
mConstructorName (argument_3),
mEffectiveParameterList (argument_4),
mHasCompilerArgument (argument_5) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_constructorExpressionForGeneration * GGS_constructorExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_constructorExpressionForGeneration) ;
    return (cPtr_constructorExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_constructorExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_constructorExpressionForGeneration * ptr = dynamic_cast <const cPtr_constructorExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mConstructorType.operator_isEqual (ptr->mConstructorType).boolValue ()
         && mConstructorName.operator_isEqual (ptr->mConstructorName).boolValue ()
         && mEffectiveParameterList.operator_isEqual (ptr->mEffectiveParameterList).boolValue ()
         && mHasCompilerArgument.operator_isEqual (ptr->mHasCompilerArgument).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_constructorExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@constructorExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mConstructorType.reader_description (inIndentation + 1)
           << mConstructorName.reader_description (inIndentation + 1)
           << mEffectiveParameterList.reader_description (inIndentation + 1)
           << mHasCompilerArgument.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_constructorExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_constructorExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_constructorExpressionForGeneration (& typeid (cPtr_constructorExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_constructorExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__constructorExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_constructorExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_constructorExpressionForGeneration (mType, mLocation, mConstructorType, mConstructorName, mEffectiveParameterList, mHasCompilerArgument COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_constructorExpressionForGeneration'            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_constructorExpressionForGeneration ("constructorExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_constructorExpressionForGeneration::
GGS_constructorExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_constructorExpressionForGeneration::
GGS_constructorExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_constructorExpressionForGeneration GGS_constructorExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_constructorExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_constructorExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_constructorExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_constructorExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_constructorExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_constructorExpressionForGeneration GGS_constructorExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_unifiedTypeMapProxy & argument_2,
                 const GGS_string& argument_3,
                 const GGS_semanticExpressionListForGeneration & argument_4,
                 const GGS_bool& argument_5
                                COMMA_LOCATION_ARGS) {
  GGS_constructorExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_constructorExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapProxy  GGS_constructorExpressionForGeneration::
reader_mConstructorType (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_unifiedTypeMapProxy   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_constructorExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_constructorExpressionForGeneration *) mPointer)->mConstructorType ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_constructorExpressionForGeneration::
reader_mConstructorName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_constructorExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_constructorExpressionForGeneration *) mPointer)->mConstructorName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionListForGeneration  GGS_constructorExpressionForGeneration::
reader_mEffectiveParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_constructorExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_constructorExpressionForGeneration *) mPointer)->mEffectiveParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_constructorExpressionForGeneration::
reader_mHasCompilerArgument (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_constructorExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_constructorExpressionForGeneration *) mPointer)->mHasCompilerArgument ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_constructorExpressionForGeneration::actualTypeName (void) const {
  return "constructorExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__constructorExpressionForGeneration ("constructorExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_constructorExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_constructorExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_constructorExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_constructorExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_constructorExpressionForGeneration GGS_constructorExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_constructorExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_constructorExpressionForGeneration * p = dynamic_cast <const GGS_constructorExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_constructorExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_constructorExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_constructorExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'cPtr_readerCallExpressionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_readerCallExpressionForGeneration::
cPtr_readerCallExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_bool& argument_2,
                                const GGS_semanticExpressionForGeneration & argument_3,
                                const GGS_stringlist & argument_4,
                                const GGS_string& argument_5,
                                const GGS_semanticExpressionListForGeneration & argument_6,
                                const GGS_bool& argument_7
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mIsCategory (argument_2),
mReceiverExpression (argument_3),
mFieldList (argument_4),
mReaderName (argument_5),
mExpressions (argument_6),
mHasCompilerArgument (argument_7) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_readerCallExpressionForGeneration * GGS_readerCallExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_readerCallExpressionForGeneration) ;
    return (cPtr_readerCallExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_readerCallExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_readerCallExpressionForGeneration * ptr = dynamic_cast <const cPtr_readerCallExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mIsCategory.operator_isEqual (ptr->mIsCategory).boolValue ()
         && mReceiverExpression.operator_isEqual (ptr->mReceiverExpression).boolValue ()
         && mFieldList.operator_isEqual (ptr->mFieldList).boolValue ()
         && mReaderName.operator_isEqual (ptr->mReaderName).boolValue ()
         && mExpressions.operator_isEqual (ptr->mExpressions).boolValue ()
         && mHasCompilerArgument.operator_isEqual (ptr->mHasCompilerArgument).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_readerCallExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@readerCallExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mIsCategory.reader_description (inIndentation + 1)
           << mReceiverExpression.reader_description (inIndentation + 1)
           << mFieldList.reader_description (inIndentation + 1)
           << mReaderName.reader_description (inIndentation + 1)
           << mExpressions.reader_description (inIndentation + 1)
           << mHasCompilerArgument.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_readerCallExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_readerCallExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_readerCallExpressionForGeneration (& typeid (cPtr_readerCallExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_readerCallExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__readerCallExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_readerCallExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_readerCallExpressionForGeneration (mType, mLocation, mIsCategory, mReceiverExpression, mFieldList, mReaderName, mExpressions, mHasCompilerArgument COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_readerCallExpressionForGeneration'            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_readerCallExpressionForGeneration ("readerCallExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_readerCallExpressionForGeneration::
GGS_readerCallExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_readerCallExpressionForGeneration::
GGS_readerCallExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_readerCallExpressionForGeneration GGS_readerCallExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_readerCallExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_readerCallExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_readerCallExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_readerCallExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_readerCallExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_readerCallExpressionForGeneration GGS_readerCallExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_bool& argument_2,
                 const GGS_semanticExpressionForGeneration & argument_3,
                 const GGS_stringlist & argument_4,
                 const GGS_string& argument_5,
                 const GGS_semanticExpressionListForGeneration & argument_6,
                 const GGS_bool& argument_7
                                COMMA_LOCATION_ARGS) {
  GGS_readerCallExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_readerCallExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_readerCallExpressionForGeneration::
reader_mIsCategory (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_readerCallExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_readerCallExpressionForGeneration *) mPointer)->mIsCategory ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_readerCallExpressionForGeneration::
reader_mReceiverExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_readerCallExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_readerCallExpressionForGeneration *) mPointer)->mReceiverExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringlist  GGS_readerCallExpressionForGeneration::
reader_mFieldList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_stringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_readerCallExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_readerCallExpressionForGeneration *) mPointer)->mFieldList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_readerCallExpressionForGeneration::
reader_mReaderName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_readerCallExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_readerCallExpressionForGeneration *) mPointer)->mReaderName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionListForGeneration  GGS_readerCallExpressionForGeneration::
reader_mExpressions (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_readerCallExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_readerCallExpressionForGeneration *) mPointer)->mExpressions ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_readerCallExpressionForGeneration::
reader_mHasCompilerArgument (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_readerCallExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_readerCallExpressionForGeneration *) mPointer)->mHasCompilerArgument ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_readerCallExpressionForGeneration::actualTypeName (void) const {
  return "readerCallExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__readerCallExpressionForGeneration ("readerCallExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_readerCallExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_readerCallExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_readerCallExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_readerCallExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_readerCallExpressionForGeneration GGS_readerCallExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_readerCallExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_readerCallExpressionForGeneration * p = dynamic_cast <const GGS_readerCallExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_readerCallExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_readerCallExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_readerCallExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            class 'cPtr_thisReaderCallExpressionForGeneration'             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_thisReaderCallExpressionForGeneration::
cPtr_thisReaderCallExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_bool& argument_2,
                                const GGS_string& argument_3,
                                const GGS_semanticExpressionListForGeneration & argument_4,
                                const GGS_bool& argument_5
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mIsCategory (argument_2),
mReaderName (argument_3),
mExpressions (argument_4),
mHasCompilerArgument (argument_5) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_thisReaderCallExpressionForGeneration * GGS_thisReaderCallExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_thisReaderCallExpressionForGeneration) ;
    return (cPtr_thisReaderCallExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_thisReaderCallExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_thisReaderCallExpressionForGeneration * ptr = dynamic_cast <const cPtr_thisReaderCallExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mIsCategory.operator_isEqual (ptr->mIsCategory).boolValue ()
         && mReaderName.operator_isEqual (ptr->mReaderName).boolValue ()
         && mExpressions.operator_isEqual (ptr->mExpressions).boolValue ()
         && mHasCompilerArgument.operator_isEqual (ptr->mHasCompilerArgument).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_thisReaderCallExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@thisReaderCallExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mIsCategory.reader_description (inIndentation + 1)
           << mReaderName.reader_description (inIndentation + 1)
           << mExpressions.reader_description (inIndentation + 1)
           << mHasCompilerArgument.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_thisReaderCallExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_thisReaderCallExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_thisReaderCallExpressionForGeneration (& typeid (cPtr_thisReaderCallExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_thisReaderCallExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__thisReaderCallExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_thisReaderCallExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_thisReaderCallExpressionForGeneration (mType, mLocation, mIsCategory, mReaderName, mExpressions, mHasCompilerArgument COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         GALGAS class 'GGS_thisReaderCallExpressionForGeneration'          *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_thisReaderCallExpressionForGeneration ("thisReaderCallExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_thisReaderCallExpressionForGeneration::
GGS_thisReaderCallExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_thisReaderCallExpressionForGeneration::
GGS_thisReaderCallExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_thisReaderCallExpressionForGeneration GGS_thisReaderCallExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_thisReaderCallExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_thisReaderCallExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_thisReaderCallExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_thisReaderCallExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_thisReaderCallExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_thisReaderCallExpressionForGeneration GGS_thisReaderCallExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_bool& argument_2,
                 const GGS_string& argument_3,
                 const GGS_semanticExpressionListForGeneration & argument_4,
                 const GGS_bool& argument_5
                                COMMA_LOCATION_ARGS) {
  GGS_thisReaderCallExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_thisReaderCallExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_thisReaderCallExpressionForGeneration::
reader_mIsCategory (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_thisReaderCallExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_thisReaderCallExpressionForGeneration *) mPointer)->mIsCategory ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_thisReaderCallExpressionForGeneration::
reader_mReaderName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_thisReaderCallExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_thisReaderCallExpressionForGeneration *) mPointer)->mReaderName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionListForGeneration  GGS_thisReaderCallExpressionForGeneration::
reader_mExpressions (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_thisReaderCallExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_thisReaderCallExpressionForGeneration *) mPointer)->mExpressions ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_thisReaderCallExpressionForGeneration::
reader_mHasCompilerArgument (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_thisReaderCallExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_thisReaderCallExpressionForGeneration *) mPointer)->mHasCompilerArgument ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_thisReaderCallExpressionForGeneration::actualTypeName (void) const {
  return "thisReaderCallExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__thisReaderCallExpressionForGeneration ("thisReaderCallExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_thisReaderCallExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_thisReaderCallExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_thisReaderCallExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_thisReaderCallExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_thisReaderCallExpressionForGeneration GGS_thisReaderCallExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_thisReaderCallExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_thisReaderCallExpressionForGeneration * p = dynamic_cast <const GGS_thisReaderCallExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_thisReaderCallExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_thisReaderCallExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_thisReaderCallExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           class 'cPtr_superReaderCallExpressionForGeneration'             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_superReaderCallExpressionForGeneration::
cPtr_superReaderCallExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_bool& argument_2,
                                const GGS_string& argument_3,
                                const GGS_string& argument_4,
                                const GGS_semanticExpressionListForGeneration & argument_5,
                                const GGS_bool& argument_6
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mIsCategory (argument_2),
mSuperClassThatImplementsReader (argument_3),
mReaderName (argument_4),
mExpressions (argument_5),
mHasCompilerArgument (argument_6) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_superReaderCallExpressionForGeneration * GGS_superReaderCallExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_superReaderCallExpressionForGeneration) ;
    return (cPtr_superReaderCallExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_superReaderCallExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_superReaderCallExpressionForGeneration * ptr = dynamic_cast <const cPtr_superReaderCallExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mIsCategory.operator_isEqual (ptr->mIsCategory).boolValue ()
         && mSuperClassThatImplementsReader.operator_isEqual (ptr->mSuperClassThatImplementsReader).boolValue ()
         && mReaderName.operator_isEqual (ptr->mReaderName).boolValue ()
         && mExpressions.operator_isEqual (ptr->mExpressions).boolValue ()
         && mHasCompilerArgument.operator_isEqual (ptr->mHasCompilerArgument).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_superReaderCallExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@superReaderCallExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mIsCategory.reader_description (inIndentation + 1)
           << mSuperClassThatImplementsReader.reader_description (inIndentation + 1)
           << mReaderName.reader_description (inIndentation + 1)
           << mExpressions.reader_description (inIndentation + 1)
           << mHasCompilerArgument.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_superReaderCallExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_superReaderCallExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_superReaderCallExpressionForGeneration (& typeid (cPtr_superReaderCallExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_superReaderCallExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__superReaderCallExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_superReaderCallExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_superReaderCallExpressionForGeneration (mType, mLocation, mIsCategory, mSuperClassThatImplementsReader, mReaderName, mExpressions, mHasCompilerArgument COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        GALGAS class 'GGS_superReaderCallExpressionForGeneration'          *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_superReaderCallExpressionForGeneration ("superReaderCallExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_superReaderCallExpressionForGeneration::
GGS_superReaderCallExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_superReaderCallExpressionForGeneration::
GGS_superReaderCallExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_superReaderCallExpressionForGeneration GGS_superReaderCallExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_superReaderCallExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_superReaderCallExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_superReaderCallExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_superReaderCallExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_superReaderCallExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_superReaderCallExpressionForGeneration GGS_superReaderCallExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_bool& argument_2,
                 const GGS_string& argument_3,
                 const GGS_string& argument_4,
                 const GGS_semanticExpressionListForGeneration & argument_5,
                 const GGS_bool& argument_6
                                COMMA_LOCATION_ARGS) {
  GGS_superReaderCallExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_superReaderCallExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_superReaderCallExpressionForGeneration::
reader_mIsCategory (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_superReaderCallExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_superReaderCallExpressionForGeneration *) mPointer)->mIsCategory ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_superReaderCallExpressionForGeneration::
reader_mSuperClassThatImplementsReader (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_superReaderCallExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_superReaderCallExpressionForGeneration *) mPointer)->mSuperClassThatImplementsReader ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_superReaderCallExpressionForGeneration::
reader_mReaderName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_superReaderCallExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_superReaderCallExpressionForGeneration *) mPointer)->mReaderName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionListForGeneration  GGS_superReaderCallExpressionForGeneration::
reader_mExpressions (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_superReaderCallExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_superReaderCallExpressionForGeneration *) mPointer)->mExpressions ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_superReaderCallExpressionForGeneration::
reader_mHasCompilerArgument (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_superReaderCallExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_superReaderCallExpressionForGeneration *) mPointer)->mHasCompilerArgument ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_superReaderCallExpressionForGeneration::actualTypeName (void) const {
  return "superReaderCallExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__superReaderCallExpressionForGeneration ("superReaderCallExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_superReaderCallExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_superReaderCallExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_superReaderCallExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_superReaderCallExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_superReaderCallExpressionForGeneration GGS_superReaderCallExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_superReaderCallExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_superReaderCallExpressionForGeneration * p = dynamic_cast <const GGS_superReaderCallExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_superReaderCallExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_superReaderCallExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_superReaderCallExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_optionValueExpressionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_optionValueExpressionForGeneration::
cPtr_optionValueExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_string& argument_2,
                                const GGS_string& argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mOptionComponentName (argument_2),
mOptionEntryName (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_optionValueExpressionForGeneration * GGS_optionValueExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_optionValueExpressionForGeneration) ;
    return (cPtr_optionValueExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_optionValueExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_optionValueExpressionForGeneration * ptr = dynamic_cast <const cPtr_optionValueExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mOptionComponentName.operator_isEqual (ptr->mOptionComponentName).boolValue ()
         && mOptionEntryName.operator_isEqual (ptr->mOptionEntryName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_optionValueExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@optionValueExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mOptionComponentName.reader_description (inIndentation + 1)
           << mOptionEntryName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_optionValueExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_optionValueExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_optionValueExpressionForGeneration (& typeid (cPtr_optionValueExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_optionValueExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__optionValueExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_optionValueExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_optionValueExpressionForGeneration (mType, mLocation, mOptionComponentName, mOptionEntryName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_optionValueExpressionForGeneration'            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_optionValueExpressionForGeneration ("optionValueExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_optionValueExpressionForGeneration::
GGS_optionValueExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_optionValueExpressionForGeneration::
GGS_optionValueExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_optionValueExpressionForGeneration GGS_optionValueExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_optionValueExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_optionValueExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_optionValueExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_optionValueExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_optionValueExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_optionValueExpressionForGeneration GGS_optionValueExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_string& argument_2,
                 const GGS_string& argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_optionValueExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_optionValueExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_optionValueExpressionForGeneration::
reader_mOptionComponentName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_optionValueExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_optionValueExpressionForGeneration *) mPointer)->mOptionComponentName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_optionValueExpressionForGeneration::
reader_mOptionEntryName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_optionValueExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_optionValueExpressionForGeneration *) mPointer)->mOptionEntryName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_optionValueExpressionForGeneration::actualTypeName (void) const {
  return "optionValueExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__optionValueExpressionForGeneration ("optionValueExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_optionValueExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_optionValueExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_optionValueExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_optionValueExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_optionValueExpressionForGeneration GGS_optionValueExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_optionValueExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_optionValueExpressionForGeneration * p = dynamic_cast <const GGS_optionValueExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_optionValueExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_optionValueExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_optionValueExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'cPtr_optionCharExpressionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_optionCharExpressionForGeneration::
cPtr_optionCharExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_string& argument_2,
                                const GGS_string& argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mOptionComponentName (argument_2),
mOptionEntryName (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_optionCharExpressionForGeneration * GGS_optionCharExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_optionCharExpressionForGeneration) ;
    return (cPtr_optionCharExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_optionCharExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_optionCharExpressionForGeneration * ptr = dynamic_cast <const cPtr_optionCharExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mOptionComponentName.operator_isEqual (ptr->mOptionComponentName).boolValue ()
         && mOptionEntryName.operator_isEqual (ptr->mOptionEntryName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_optionCharExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@optionCharExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mOptionComponentName.reader_description (inIndentation + 1)
           << mOptionEntryName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_optionCharExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_optionCharExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_optionCharExpressionForGeneration (& typeid (cPtr_optionCharExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_optionCharExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__optionCharExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_optionCharExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_optionCharExpressionForGeneration (mType, mLocation, mOptionComponentName, mOptionEntryName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_optionCharExpressionForGeneration'            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_optionCharExpressionForGeneration ("optionCharExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_optionCharExpressionForGeneration::
GGS_optionCharExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_optionCharExpressionForGeneration::
GGS_optionCharExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_optionCharExpressionForGeneration GGS_optionCharExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_optionCharExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_optionCharExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_optionCharExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_optionCharExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_optionCharExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_optionCharExpressionForGeneration GGS_optionCharExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_string& argument_2,
                 const GGS_string& argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_optionCharExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_optionCharExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_optionCharExpressionForGeneration::
reader_mOptionComponentName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_optionCharExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_optionCharExpressionForGeneration *) mPointer)->mOptionComponentName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_optionCharExpressionForGeneration::
reader_mOptionEntryName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_optionCharExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_optionCharExpressionForGeneration *) mPointer)->mOptionEntryName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_optionCharExpressionForGeneration::actualTypeName (void) const {
  return "optionCharExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__optionCharExpressionForGeneration ("optionCharExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_optionCharExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_optionCharExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_optionCharExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_optionCharExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_optionCharExpressionForGeneration GGS_optionCharExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_optionCharExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_optionCharExpressionForGeneration * p = dynamic_cast <const GGS_optionCharExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_optionCharExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_optionCharExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_optionCharExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_optionStringExpressionForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_optionStringExpressionForGeneration::
cPtr_optionStringExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_string& argument_2,
                                const GGS_string& argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mOptionComponentName (argument_2),
mOptionEntryName (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_optionStringExpressionForGeneration * GGS_optionStringExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_optionStringExpressionForGeneration) ;
    return (cPtr_optionStringExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_optionStringExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_optionStringExpressionForGeneration * ptr = dynamic_cast <const cPtr_optionStringExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mOptionComponentName.operator_isEqual (ptr->mOptionComponentName).boolValue ()
         && mOptionEntryName.operator_isEqual (ptr->mOptionEntryName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_optionStringExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@optionStringExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mOptionComponentName.reader_description (inIndentation + 1)
           << mOptionEntryName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_optionStringExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_optionStringExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_optionStringExpressionForGeneration (& typeid (cPtr_optionStringExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_optionStringExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__optionStringExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_optionStringExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_optionStringExpressionForGeneration (mType, mLocation, mOptionComponentName, mOptionEntryName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_optionStringExpressionForGeneration'           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_optionStringExpressionForGeneration ("optionStringExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_optionStringExpressionForGeneration::
GGS_optionStringExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_optionStringExpressionForGeneration::
GGS_optionStringExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_optionStringExpressionForGeneration GGS_optionStringExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_optionStringExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_optionStringExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_optionStringExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_optionStringExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_optionStringExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_optionStringExpressionForGeneration GGS_optionStringExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_string& argument_2,
                 const GGS_string& argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_optionStringExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_optionStringExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_optionStringExpressionForGeneration::
reader_mOptionComponentName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_optionStringExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_optionStringExpressionForGeneration *) mPointer)->mOptionComponentName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_optionStringExpressionForGeneration::
reader_mOptionEntryName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_optionStringExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_optionStringExpressionForGeneration *) mPointer)->mOptionEntryName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_optionStringExpressionForGeneration::actualTypeName (void) const {
  return "optionStringExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__optionStringExpressionForGeneration ("optionStringExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_optionStringExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_optionStringExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_optionStringExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_optionStringExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_optionStringExpressionForGeneration GGS_optionStringExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_optionStringExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_optionStringExpressionForGeneration * p = dynamic_cast <const GGS_optionStringExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_optionStringExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_optionStringExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_optionStringExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            class 'cPtr_optionCommentExpressionForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_optionCommentExpressionForGeneration::
cPtr_optionCommentExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_string& argument_2,
                                const GGS_string& argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mOptionComponentName (argument_2),
mOptionEntryName (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_optionCommentExpressionForGeneration * GGS_optionCommentExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_optionCommentExpressionForGeneration) ;
    return (cPtr_optionCommentExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_optionCommentExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_optionCommentExpressionForGeneration * ptr = dynamic_cast <const cPtr_optionCommentExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mOptionComponentName.operator_isEqual (ptr->mOptionComponentName).boolValue ()
         && mOptionEntryName.operator_isEqual (ptr->mOptionEntryName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_optionCommentExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@optionCommentExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mOptionComponentName.reader_description (inIndentation + 1)
           << mOptionEntryName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_optionCommentExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_optionCommentExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_optionCommentExpressionForGeneration (& typeid (cPtr_optionCommentExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_optionCommentExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__optionCommentExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_optionCommentExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_optionCommentExpressionForGeneration (mType, mLocation, mOptionComponentName, mOptionEntryName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         GALGAS class 'GGS_optionCommentExpressionForGeneration'           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_optionCommentExpressionForGeneration ("optionCommentExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_optionCommentExpressionForGeneration::
GGS_optionCommentExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_optionCommentExpressionForGeneration::
GGS_optionCommentExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_optionCommentExpressionForGeneration GGS_optionCommentExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_optionCommentExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_optionCommentExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_optionCommentExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_optionCommentExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_optionCommentExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_optionCommentExpressionForGeneration GGS_optionCommentExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_string& argument_2,
                 const GGS_string& argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_optionCommentExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_optionCommentExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_optionCommentExpressionForGeneration::
reader_mOptionComponentName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_optionCommentExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_optionCommentExpressionForGeneration *) mPointer)->mOptionComponentName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_optionCommentExpressionForGeneration::
reader_mOptionEntryName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_optionCommentExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_optionCommentExpressionForGeneration *) mPointer)->mOptionEntryName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_optionCommentExpressionForGeneration::actualTypeName (void) const {
  return "optionCommentExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__optionCommentExpressionForGeneration ("optionCommentExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_optionCommentExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_optionCommentExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_optionCommentExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_optionCommentExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_optionCommentExpressionForGeneration GGS_optionCommentExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_optionCommentExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_optionCommentExpressionForGeneration * p = dynamic_cast <const GGS_optionCommentExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_optionCommentExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_optionCommentExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_optionCommentExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_concatExpressionForGeneration'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_concatExpressionForGeneration::
cPtr_concatExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_semanticExpressionForGeneration & argument_2,
                                const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mLeftExpression (argument_2),
mRightExpression (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_concatExpressionForGeneration * GGS_concatExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_concatExpressionForGeneration) ;
    return (cPtr_concatExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_concatExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_concatExpressionForGeneration * ptr = dynamic_cast <const cPtr_concatExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_concatExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@concatExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_concatExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_concatExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_concatExpressionForGeneration (& typeid (cPtr_concatExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_concatExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__concatExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_concatExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_concatExpressionForGeneration (mType, mLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_concatExpressionForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_concatExpressionForGeneration ("concatExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_concatExpressionForGeneration::
GGS_concatExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_concatExpressionForGeneration::
GGS_concatExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_concatExpressionForGeneration GGS_concatExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_concatExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_concatExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_concatExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_concatExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_concatExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_concatExpressionForGeneration GGS_concatExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_semanticExpressionForGeneration & argument_2,
                 const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_concatExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_concatExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_concatExpressionForGeneration::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_concatExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_concatExpressionForGeneration *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_concatExpressionForGeneration::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_concatExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_concatExpressionForGeneration *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_concatExpressionForGeneration::actualTypeName (void) const {
  return "concatExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__concatExpressionForGeneration ("concatExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_concatExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_concatExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_concatExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_concatExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_concatExpressionForGeneration GGS_concatExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_concatExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_concatExpressionForGeneration * p = dynamic_cast <const GGS_concatExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_concatExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_concatExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_concatExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_orExpressionForGeneration'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_orExpressionForGeneration::
cPtr_orExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_semanticExpressionForGeneration & argument_2,
                                const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mLeftExpression (argument_2),
mRightExpression (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_orExpressionForGeneration * GGS_orExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_orExpressionForGeneration) ;
    return (cPtr_orExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_orExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_orExpressionForGeneration * ptr = dynamic_cast <const cPtr_orExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_orExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@orExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_orExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_orExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_orExpressionForGeneration (& typeid (cPtr_orExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_orExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__orExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_orExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_orExpressionForGeneration (mType, mLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_orExpressionForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_orExpressionForGeneration ("orExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_orExpressionForGeneration::
GGS_orExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_orExpressionForGeneration::
GGS_orExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_orExpressionForGeneration GGS_orExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_orExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_orExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_orExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_orExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_orExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_orExpressionForGeneration GGS_orExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_semanticExpressionForGeneration & argument_2,
                 const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_orExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_orExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_orExpressionForGeneration::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_orExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_orExpressionForGeneration *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_orExpressionForGeneration::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_orExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_orExpressionForGeneration *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_orExpressionForGeneration::actualTypeName (void) const {
  return "orExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__orExpressionForGeneration ("orExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_orExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_orExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_orExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_orExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_orExpressionForGeneration GGS_orExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_orExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_orExpressionForGeneration * p = dynamic_cast <const GGS_orExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_orExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_orExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_orExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_xorExpressionForGeneration'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_xorExpressionForGeneration::
cPtr_xorExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_semanticExpressionForGeneration & argument_2,
                                const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mLeftExpression (argument_2),
mRightExpression (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_xorExpressionForGeneration * GGS_xorExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_xorExpressionForGeneration) ;
    return (cPtr_xorExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_xorExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_xorExpressionForGeneration * ptr = dynamic_cast <const cPtr_xorExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_xorExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@xorExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_xorExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_xorExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_xorExpressionForGeneration (& typeid (cPtr_xorExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_xorExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__xorExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_xorExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_xorExpressionForGeneration (mType, mLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_xorExpressionForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_xorExpressionForGeneration ("xorExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_xorExpressionForGeneration::
GGS_xorExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_xorExpressionForGeneration::
GGS_xorExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_xorExpressionForGeneration GGS_xorExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_xorExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_xorExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_xorExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_xorExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_xorExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_xorExpressionForGeneration GGS_xorExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_semanticExpressionForGeneration & argument_2,
                 const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_xorExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_xorExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_xorExpressionForGeneration::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_xorExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_xorExpressionForGeneration *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_xorExpressionForGeneration::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_xorExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_xorExpressionForGeneration *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_xorExpressionForGeneration::actualTypeName (void) const {
  return "xorExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__xorExpressionForGeneration ("xorExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_xorExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_xorExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_xorExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_xorExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_xorExpressionForGeneration GGS_xorExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_xorExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_xorExpressionForGeneration * p = dynamic_cast <const GGS_xorExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_xorExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_xorExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_xorExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_andExpressionForGeneration'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_andExpressionForGeneration::
cPtr_andExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_semanticExpressionForGeneration & argument_2,
                                const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mLeftExpression (argument_2),
mRightExpression (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_andExpressionForGeneration * GGS_andExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_andExpressionForGeneration) ;
    return (cPtr_andExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_andExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_andExpressionForGeneration * ptr = dynamic_cast <const cPtr_andExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_andExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@andExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_andExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_andExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_andExpressionForGeneration (& typeid (cPtr_andExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_andExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__andExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_andExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_andExpressionForGeneration (mType, mLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_andExpressionForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_andExpressionForGeneration ("andExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_andExpressionForGeneration::
GGS_andExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_andExpressionForGeneration::
GGS_andExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_andExpressionForGeneration GGS_andExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_andExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_andExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_andExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_andExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_andExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_andExpressionForGeneration GGS_andExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_semanticExpressionForGeneration & argument_2,
                 const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_andExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_andExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_andExpressionForGeneration::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_andExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_andExpressionForGeneration *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_andExpressionForGeneration::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_andExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_andExpressionForGeneration *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_andExpressionForGeneration::actualTypeName (void) const {
  return "andExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__andExpressionForGeneration ("andExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_andExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_andExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_andExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_andExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_andExpressionForGeneration GGS_andExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_andExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_andExpressionForGeneration * p = dynamic_cast <const GGS_andExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_andExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_andExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_andExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_equalExpressionForGeneration'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_equalExpressionForGeneration::
cPtr_equalExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_semanticExpressionForGeneration & argument_2,
                                const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mLeftExpression (argument_2),
mRightExpression (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_equalExpressionForGeneration * GGS_equalExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_equalExpressionForGeneration) ;
    return (cPtr_equalExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_equalExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_equalExpressionForGeneration * ptr = dynamic_cast <const cPtr_equalExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_equalExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@equalExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_equalExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_equalExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_equalExpressionForGeneration (& typeid (cPtr_equalExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_equalExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__equalExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_equalExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_equalExpressionForGeneration (mType, mLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_equalExpressionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_equalExpressionForGeneration ("equalExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_equalExpressionForGeneration::
GGS_equalExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_equalExpressionForGeneration::
GGS_equalExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_equalExpressionForGeneration GGS_equalExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_equalExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_equalExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_equalExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_equalExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_equalExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_equalExpressionForGeneration GGS_equalExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_semanticExpressionForGeneration & argument_2,
                 const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_equalExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_equalExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_equalExpressionForGeneration::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_equalExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_equalExpressionForGeneration *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_equalExpressionForGeneration::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_equalExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_equalExpressionForGeneration *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_equalExpressionForGeneration::actualTypeName (void) const {
  return "equalExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__equalExpressionForGeneration ("equalExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_equalExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_equalExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_equalExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_equalExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_equalExpressionForGeneration GGS_equalExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_equalExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_equalExpressionForGeneration * p = dynamic_cast <const GGS_equalExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_equalExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_equalExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_equalExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_notEqualExpressionForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_notEqualExpressionForGeneration::
cPtr_notEqualExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_semanticExpressionForGeneration & argument_2,
                                const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mLeftExpression (argument_2),
mRightExpression (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_notEqualExpressionForGeneration * GGS_notEqualExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_notEqualExpressionForGeneration) ;
    return (cPtr_notEqualExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_notEqualExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_notEqualExpressionForGeneration * ptr = dynamic_cast <const cPtr_notEqualExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_notEqualExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@notEqualExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_notEqualExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_notEqualExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_notEqualExpressionForGeneration (& typeid (cPtr_notEqualExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_notEqualExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__notEqualExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_notEqualExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_notEqualExpressionForGeneration (mType, mLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_notEqualExpressionForGeneration'             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_notEqualExpressionForGeneration ("notEqualExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_notEqualExpressionForGeneration::
GGS_notEqualExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_notEqualExpressionForGeneration::
GGS_notEqualExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_notEqualExpressionForGeneration GGS_notEqualExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_notEqualExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_notEqualExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_notEqualExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_notEqualExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_notEqualExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_notEqualExpressionForGeneration GGS_notEqualExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_semanticExpressionForGeneration & argument_2,
                 const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_notEqualExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_notEqualExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_notEqualExpressionForGeneration::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_notEqualExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_notEqualExpressionForGeneration *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_notEqualExpressionForGeneration::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_notEqualExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_notEqualExpressionForGeneration *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_notEqualExpressionForGeneration::actualTypeName (void) const {
  return "notEqualExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__notEqualExpressionForGeneration ("notEqualExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_notEqualExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_notEqualExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_notEqualExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_notEqualExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_notEqualExpressionForGeneration GGS_notEqualExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_notEqualExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_notEqualExpressionForGeneration * p = dynamic_cast <const GGS_notEqualExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_notEqualExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_notEqualExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_notEqualExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_lowerOrEqualExpressionForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lowerOrEqualExpressionForGeneration::
cPtr_lowerOrEqualExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_semanticExpressionForGeneration & argument_2,
                                const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mLeftExpression (argument_2),
mRightExpression (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lowerOrEqualExpressionForGeneration * GGS_lowerOrEqualExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_lowerOrEqualExpressionForGeneration) ;
    return (cPtr_lowerOrEqualExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lowerOrEqualExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lowerOrEqualExpressionForGeneration * ptr = dynamic_cast <const cPtr_lowerOrEqualExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lowerOrEqualExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@lowerOrEqualExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lowerOrEqualExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lowerOrEqualExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lowerOrEqualExpressionForGeneration (& typeid (cPtr_lowerOrEqualExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_lowerOrEqualExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__lowerOrEqualExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lowerOrEqualExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lowerOrEqualExpressionForGeneration (mType, mLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_lowerOrEqualExpressionForGeneration'           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_lowerOrEqualExpressionForGeneration ("lowerOrEqualExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_lowerOrEqualExpressionForGeneration::
GGS_lowerOrEqualExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lowerOrEqualExpressionForGeneration::
GGS_lowerOrEqualExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lowerOrEqualExpressionForGeneration GGS_lowerOrEqualExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lowerOrEqualExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lowerOrEqualExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_lowerOrEqualExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lowerOrEqualExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lowerOrEqualExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lowerOrEqualExpressionForGeneration GGS_lowerOrEqualExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_semanticExpressionForGeneration & argument_2,
                 const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_lowerOrEqualExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_lowerOrEqualExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_lowerOrEqualExpressionForGeneration::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lowerOrEqualExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lowerOrEqualExpressionForGeneration *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_lowerOrEqualExpressionForGeneration::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lowerOrEqualExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lowerOrEqualExpressionForGeneration *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lowerOrEqualExpressionForGeneration::actualTypeName (void) const {
  return "lowerOrEqualExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__lowerOrEqualExpressionForGeneration ("lowerOrEqualExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_lowerOrEqualExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_lowerOrEqualExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_lowerOrEqualExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_lowerOrEqualExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lowerOrEqualExpressionForGeneration GGS_lowerOrEqualExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_lowerOrEqualExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_lowerOrEqualExpressionForGeneration * p = dynamic_cast <const GGS_lowerOrEqualExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_lowerOrEqualExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_lowerOrEqualExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_lowerOrEqualExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            class 'cPtr_greaterOrEqualExpressionForGeneration'             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_greaterOrEqualExpressionForGeneration::
cPtr_greaterOrEqualExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_semanticExpressionForGeneration & argument_2,
                                const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mLeftExpression (argument_2),
mRightExpression (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_greaterOrEqualExpressionForGeneration * GGS_greaterOrEqualExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_greaterOrEqualExpressionForGeneration) ;
    return (cPtr_greaterOrEqualExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_greaterOrEqualExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_greaterOrEqualExpressionForGeneration * ptr = dynamic_cast <const cPtr_greaterOrEqualExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_greaterOrEqualExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@greaterOrEqualExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_greaterOrEqualExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_greaterOrEqualExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_greaterOrEqualExpressionForGeneration (& typeid (cPtr_greaterOrEqualExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_greaterOrEqualExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__greaterOrEqualExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_greaterOrEqualExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_greaterOrEqualExpressionForGeneration (mType, mLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         GALGAS class 'GGS_greaterOrEqualExpressionForGeneration'          *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_greaterOrEqualExpressionForGeneration ("greaterOrEqualExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_greaterOrEqualExpressionForGeneration::
GGS_greaterOrEqualExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_greaterOrEqualExpressionForGeneration::
GGS_greaterOrEqualExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_greaterOrEqualExpressionForGeneration GGS_greaterOrEqualExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_greaterOrEqualExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_greaterOrEqualExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_greaterOrEqualExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_greaterOrEqualExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_greaterOrEqualExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_greaterOrEqualExpressionForGeneration GGS_greaterOrEqualExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_semanticExpressionForGeneration & argument_2,
                 const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_greaterOrEqualExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_greaterOrEqualExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_greaterOrEqualExpressionForGeneration::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_greaterOrEqualExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_greaterOrEqualExpressionForGeneration *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_greaterOrEqualExpressionForGeneration::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_greaterOrEqualExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_greaterOrEqualExpressionForGeneration *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_greaterOrEqualExpressionForGeneration::actualTypeName (void) const {
  return "greaterOrEqualExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__greaterOrEqualExpressionForGeneration ("greaterOrEqualExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_greaterOrEqualExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_greaterOrEqualExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_greaterOrEqualExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_greaterOrEqualExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_greaterOrEqualExpressionForGeneration GGS_greaterOrEqualExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_greaterOrEqualExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_greaterOrEqualExpressionForGeneration * p = dynamic_cast <const GGS_greaterOrEqualExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_greaterOrEqualExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_greaterOrEqualExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_greaterOrEqualExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            class 'cPtr_strictGreaterExpressionForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_strictGreaterExpressionForGeneration::
cPtr_strictGreaterExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_semanticExpressionForGeneration & argument_2,
                                const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mLeftExpression (argument_2),
mRightExpression (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_strictGreaterExpressionForGeneration * GGS_strictGreaterExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_strictGreaterExpressionForGeneration) ;
    return (cPtr_strictGreaterExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_strictGreaterExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_strictGreaterExpressionForGeneration * ptr = dynamic_cast <const cPtr_strictGreaterExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_strictGreaterExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@strictGreaterExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_strictGreaterExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_strictGreaterExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_strictGreaterExpressionForGeneration (& typeid (cPtr_strictGreaterExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_strictGreaterExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__strictGreaterExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_strictGreaterExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_strictGreaterExpressionForGeneration (mType, mLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         GALGAS class 'GGS_strictGreaterExpressionForGeneration'           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_strictGreaterExpressionForGeneration ("strictGreaterExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_strictGreaterExpressionForGeneration::
GGS_strictGreaterExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_strictGreaterExpressionForGeneration::
GGS_strictGreaterExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_strictGreaterExpressionForGeneration GGS_strictGreaterExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_strictGreaterExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_strictGreaterExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_strictGreaterExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_strictGreaterExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_strictGreaterExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_strictGreaterExpressionForGeneration GGS_strictGreaterExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_semanticExpressionForGeneration & argument_2,
                 const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_strictGreaterExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_strictGreaterExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_strictGreaterExpressionForGeneration::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_strictGreaterExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_strictGreaterExpressionForGeneration *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_strictGreaterExpressionForGeneration::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_strictGreaterExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_strictGreaterExpressionForGeneration *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_strictGreaterExpressionForGeneration::actualTypeName (void) const {
  return "strictGreaterExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__strictGreaterExpressionForGeneration ("strictGreaterExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_strictGreaterExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_strictGreaterExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_strictGreaterExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_strictGreaterExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_strictGreaterExpressionForGeneration GGS_strictGreaterExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_strictGreaterExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_strictGreaterExpressionForGeneration * p = dynamic_cast <const GGS_strictGreaterExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_strictGreaterExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_strictGreaterExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_strictGreaterExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_strictLowerExpressionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_strictLowerExpressionForGeneration::
cPtr_strictLowerExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_semanticExpressionForGeneration & argument_2,
                                const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mLeftExpression (argument_2),
mRightExpression (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_strictLowerExpressionForGeneration * GGS_strictLowerExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_strictLowerExpressionForGeneration) ;
    return (cPtr_strictLowerExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_strictLowerExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_strictLowerExpressionForGeneration * ptr = dynamic_cast <const cPtr_strictLowerExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_strictLowerExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@strictLowerExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_strictLowerExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_strictLowerExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_strictLowerExpressionForGeneration (& typeid (cPtr_strictLowerExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_strictLowerExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__strictLowerExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_strictLowerExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_strictLowerExpressionForGeneration (mType, mLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_strictLowerExpressionForGeneration'            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_strictLowerExpressionForGeneration ("strictLowerExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_strictLowerExpressionForGeneration::
GGS_strictLowerExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_strictLowerExpressionForGeneration::
GGS_strictLowerExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_strictLowerExpressionForGeneration GGS_strictLowerExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_strictLowerExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_strictLowerExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_strictLowerExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_strictLowerExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_strictLowerExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_strictLowerExpressionForGeneration GGS_strictLowerExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_semanticExpressionForGeneration & argument_2,
                 const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_strictLowerExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_strictLowerExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_strictLowerExpressionForGeneration::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_strictLowerExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_strictLowerExpressionForGeneration *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_strictLowerExpressionForGeneration::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_strictLowerExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_strictLowerExpressionForGeneration *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_strictLowerExpressionForGeneration::actualTypeName (void) const {
  return "strictLowerExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__strictLowerExpressionForGeneration ("strictLowerExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_strictLowerExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_strictLowerExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_strictLowerExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_strictLowerExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_strictLowerExpressionForGeneration GGS_strictLowerExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_strictLowerExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_strictLowerExpressionForGeneration * p = dynamic_cast <const GGS_strictLowerExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_strictLowerExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_strictLowerExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_strictLowerExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'cPtr_rightShiftExpressionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_rightShiftExpressionForGeneration::
cPtr_rightShiftExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_semanticExpressionForGeneration & argument_2,
                                const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mLeftExpression (argument_2),
mRightExpression (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_rightShiftExpressionForGeneration * GGS_rightShiftExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_rightShiftExpressionForGeneration) ;
    return (cPtr_rightShiftExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_rightShiftExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_rightShiftExpressionForGeneration * ptr = dynamic_cast <const cPtr_rightShiftExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_rightShiftExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@rightShiftExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_rightShiftExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_rightShiftExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_rightShiftExpressionForGeneration (& typeid (cPtr_rightShiftExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_rightShiftExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__rightShiftExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_rightShiftExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_rightShiftExpressionForGeneration (mType, mLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_rightShiftExpressionForGeneration'            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_rightShiftExpressionForGeneration ("rightShiftExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_rightShiftExpressionForGeneration::
GGS_rightShiftExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_rightShiftExpressionForGeneration::
GGS_rightShiftExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_rightShiftExpressionForGeneration GGS_rightShiftExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_rightShiftExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_rightShiftExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_rightShiftExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_rightShiftExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_rightShiftExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_rightShiftExpressionForGeneration GGS_rightShiftExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_semanticExpressionForGeneration & argument_2,
                 const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_rightShiftExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_rightShiftExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_rightShiftExpressionForGeneration::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rightShiftExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rightShiftExpressionForGeneration *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_rightShiftExpressionForGeneration::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rightShiftExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rightShiftExpressionForGeneration *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_rightShiftExpressionForGeneration::actualTypeName (void) const {
  return "rightShiftExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__rightShiftExpressionForGeneration ("rightShiftExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_rightShiftExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_rightShiftExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_rightShiftExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_rightShiftExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_rightShiftExpressionForGeneration GGS_rightShiftExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_rightShiftExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_rightShiftExpressionForGeneration * p = dynamic_cast <const GGS_rightShiftExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_rightShiftExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_rightShiftExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_rightShiftExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'cPtr_leftShiftExpressionForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_leftShiftExpressionForGeneration::
cPtr_leftShiftExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_semanticExpressionForGeneration & argument_2,
                                const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mLeftExpression (argument_2),
mRightExpression (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_leftShiftExpressionForGeneration * GGS_leftShiftExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_leftShiftExpressionForGeneration) ;
    return (cPtr_leftShiftExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_leftShiftExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_leftShiftExpressionForGeneration * ptr = dynamic_cast <const cPtr_leftShiftExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_leftShiftExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@leftShiftExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_leftShiftExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_leftShiftExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_leftShiftExpressionForGeneration (& typeid (cPtr_leftShiftExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_leftShiftExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__leftShiftExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_leftShiftExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_leftShiftExpressionForGeneration (mType, mLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_leftShiftExpressionForGeneration'             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_leftShiftExpressionForGeneration ("leftShiftExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_leftShiftExpressionForGeneration::
GGS_leftShiftExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_leftShiftExpressionForGeneration::
GGS_leftShiftExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_leftShiftExpressionForGeneration GGS_leftShiftExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_leftShiftExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_leftShiftExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_leftShiftExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_leftShiftExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_leftShiftExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_leftShiftExpressionForGeneration GGS_leftShiftExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_semanticExpressionForGeneration & argument_2,
                 const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_leftShiftExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_leftShiftExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_leftShiftExpressionForGeneration::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_leftShiftExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_leftShiftExpressionForGeneration *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_leftShiftExpressionForGeneration::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_leftShiftExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_leftShiftExpressionForGeneration *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_leftShiftExpressionForGeneration::actualTypeName (void) const {
  return "leftShiftExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__leftShiftExpressionForGeneration ("leftShiftExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_leftShiftExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_leftShiftExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_leftShiftExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_leftShiftExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_leftShiftExpressionForGeneration GGS_leftShiftExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_leftShiftExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_leftShiftExpressionForGeneration * p = dynamic_cast <const GGS_leftShiftExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_leftShiftExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_leftShiftExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_leftShiftExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_addExpressionForGeneration'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_addExpressionForGeneration::
cPtr_addExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_semanticExpressionForGeneration & argument_2,
                                const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mLeftExpression (argument_2),
mRightExpression (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_addExpressionForGeneration * GGS_addExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_addExpressionForGeneration) ;
    return (cPtr_addExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_addExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_addExpressionForGeneration * ptr = dynamic_cast <const cPtr_addExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_addExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@addExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_addExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_addExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_addExpressionForGeneration (& typeid (cPtr_addExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_addExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__addExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_addExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_addExpressionForGeneration (mType, mLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_addExpressionForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_addExpressionForGeneration ("addExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_addExpressionForGeneration::
GGS_addExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_addExpressionForGeneration::
GGS_addExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_addExpressionForGeneration GGS_addExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_addExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_addExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_addExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_addExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_addExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_addExpressionForGeneration GGS_addExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_semanticExpressionForGeneration & argument_2,
                 const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_addExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_addExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_addExpressionForGeneration::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_addExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_addExpressionForGeneration *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_addExpressionForGeneration::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_addExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_addExpressionForGeneration *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_addExpressionForGeneration::actualTypeName (void) const {
  return "addExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__addExpressionForGeneration ("addExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_addExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_addExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_addExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_addExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_addExpressionForGeneration GGS_addExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_addExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_addExpressionForGeneration * p = dynamic_cast <const GGS_addExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_addExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_addExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_addExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_subExpressionForGeneration'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_subExpressionForGeneration::
cPtr_subExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_semanticExpressionForGeneration & argument_2,
                                const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mLeftExpression (argument_2),
mRightExpression (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_subExpressionForGeneration * GGS_subExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_subExpressionForGeneration) ;
    return (cPtr_subExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_subExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_subExpressionForGeneration * ptr = dynamic_cast <const cPtr_subExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_subExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@subExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_subExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_subExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_subExpressionForGeneration (& typeid (cPtr_subExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_subExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__subExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_subExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_subExpressionForGeneration (mType, mLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_subExpressionForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_subExpressionForGeneration ("subExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_subExpressionForGeneration::
GGS_subExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_subExpressionForGeneration::
GGS_subExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_subExpressionForGeneration GGS_subExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_subExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_subExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_subExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_subExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_subExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_subExpressionForGeneration GGS_subExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_semanticExpressionForGeneration & argument_2,
                 const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_subExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_subExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_subExpressionForGeneration::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_subExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_subExpressionForGeneration *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_subExpressionForGeneration::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_subExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_subExpressionForGeneration *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_subExpressionForGeneration::actualTypeName (void) const {
  return "subExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__subExpressionForGeneration ("subExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_subExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_subExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_subExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_subExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_subExpressionForGeneration GGS_subExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_subExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_subExpressionForGeneration * p = dynamic_cast <const GGS_subExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_subExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_subExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_subExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            class 'cPtr_multiplicationExpressionForGeneration'             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_multiplicationExpressionForGeneration::
cPtr_multiplicationExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_semanticExpressionForGeneration & argument_2,
                                const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mLeftExpression (argument_2),
mRightExpression (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_multiplicationExpressionForGeneration * GGS_multiplicationExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_multiplicationExpressionForGeneration) ;
    return (cPtr_multiplicationExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_multiplicationExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_multiplicationExpressionForGeneration * ptr = dynamic_cast <const cPtr_multiplicationExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_multiplicationExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@multiplicationExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_multiplicationExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_multiplicationExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_multiplicationExpressionForGeneration (& typeid (cPtr_multiplicationExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_multiplicationExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__multiplicationExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_multiplicationExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_multiplicationExpressionForGeneration (mType, mLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         GALGAS class 'GGS_multiplicationExpressionForGeneration'          *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_multiplicationExpressionForGeneration ("multiplicationExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_multiplicationExpressionForGeneration::
GGS_multiplicationExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_multiplicationExpressionForGeneration::
GGS_multiplicationExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_multiplicationExpressionForGeneration GGS_multiplicationExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_multiplicationExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_multiplicationExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_multiplicationExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_multiplicationExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_multiplicationExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_multiplicationExpressionForGeneration GGS_multiplicationExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_semanticExpressionForGeneration & argument_2,
                 const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_multiplicationExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_multiplicationExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_multiplicationExpressionForGeneration::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_multiplicationExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_multiplicationExpressionForGeneration *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_multiplicationExpressionForGeneration::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_multiplicationExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_multiplicationExpressionForGeneration *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_multiplicationExpressionForGeneration::actualTypeName (void) const {
  return "multiplicationExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__multiplicationExpressionForGeneration ("multiplicationExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_multiplicationExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_multiplicationExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_multiplicationExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_multiplicationExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_multiplicationExpressionForGeneration GGS_multiplicationExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_multiplicationExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_multiplicationExpressionForGeneration * p = dynamic_cast <const GGS_multiplicationExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_multiplicationExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_multiplicationExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_multiplicationExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_divisionExpressionForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_divisionExpressionForGeneration::
cPtr_divisionExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_semanticExpressionForGeneration & argument_2,
                                const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mLeftExpression (argument_2),
mRightExpression (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_divisionExpressionForGeneration * GGS_divisionExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_divisionExpressionForGeneration) ;
    return (cPtr_divisionExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_divisionExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_divisionExpressionForGeneration * ptr = dynamic_cast <const cPtr_divisionExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_divisionExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@divisionExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_divisionExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_divisionExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_divisionExpressionForGeneration (& typeid (cPtr_divisionExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_divisionExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__divisionExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_divisionExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_divisionExpressionForGeneration (mType, mLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_divisionExpressionForGeneration'             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_divisionExpressionForGeneration ("divisionExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_divisionExpressionForGeneration::
GGS_divisionExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_divisionExpressionForGeneration::
GGS_divisionExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_divisionExpressionForGeneration GGS_divisionExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_divisionExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_divisionExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_divisionExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_divisionExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_divisionExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_divisionExpressionForGeneration GGS_divisionExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_semanticExpressionForGeneration & argument_2,
                 const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_divisionExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_divisionExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_divisionExpressionForGeneration::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_divisionExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_divisionExpressionForGeneration *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_divisionExpressionForGeneration::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_divisionExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_divisionExpressionForGeneration *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_divisionExpressionForGeneration::actualTypeName (void) const {
  return "divisionExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__divisionExpressionForGeneration ("divisionExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_divisionExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_divisionExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_divisionExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_divisionExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_divisionExpressionForGeneration GGS_divisionExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_divisionExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_divisionExpressionForGeneration * p = dynamic_cast <const GGS_divisionExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_divisionExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_divisionExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_divisionExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_moduloExpressionForGeneration'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_moduloExpressionForGeneration::
cPtr_moduloExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_semanticExpressionForGeneration & argument_2,
                                const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mLeftExpression (argument_2),
mRightExpression (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_moduloExpressionForGeneration * GGS_moduloExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_moduloExpressionForGeneration) ;
    return (cPtr_moduloExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_moduloExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_moduloExpressionForGeneration * ptr = dynamic_cast <const cPtr_moduloExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_moduloExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@moduloExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_moduloExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_moduloExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_moduloExpressionForGeneration (& typeid (cPtr_moduloExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_moduloExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__moduloExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_moduloExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_moduloExpressionForGeneration (mType, mLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_moduloExpressionForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_moduloExpressionForGeneration ("moduloExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_moduloExpressionForGeneration::
GGS_moduloExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_moduloExpressionForGeneration::
GGS_moduloExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_moduloExpressionForGeneration GGS_moduloExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_moduloExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_moduloExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_moduloExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_moduloExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_moduloExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_moduloExpressionForGeneration GGS_moduloExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_semanticExpressionForGeneration & argument_2,
                 const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_moduloExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_moduloExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_moduloExpressionForGeneration::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_moduloExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_moduloExpressionForGeneration *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_moduloExpressionForGeneration::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_moduloExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_moduloExpressionForGeneration *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_moduloExpressionForGeneration::actualTypeName (void) const {
  return "moduloExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__moduloExpressionForGeneration ("moduloExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_moduloExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_moduloExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_moduloExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_moduloExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_moduloExpressionForGeneration GGS_moduloExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_moduloExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_moduloExpressionForGeneration * p = dynamic_cast <const GGS_moduloExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_moduloExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_moduloExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_moduloExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'cPtr_unaryMinusExpressionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_unaryMinusExpressionForGeneration::
cPtr_unaryMinusExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_semanticExpressionForGeneration & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_unaryMinusExpressionForGeneration * GGS_unaryMinusExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_unaryMinusExpressionForGeneration) ;
    return (cPtr_unaryMinusExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_unaryMinusExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_unaryMinusExpressionForGeneration * ptr = dynamic_cast <const cPtr_unaryMinusExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mExpression.operator_isEqual (ptr->mExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_unaryMinusExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@unaryMinusExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_unaryMinusExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_unaryMinusExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_unaryMinusExpressionForGeneration (& typeid (cPtr_unaryMinusExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_unaryMinusExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__unaryMinusExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_unaryMinusExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_unaryMinusExpressionForGeneration (mType, mLocation, mExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_unaryMinusExpressionForGeneration'            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_unaryMinusExpressionForGeneration ("unaryMinusExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_unaryMinusExpressionForGeneration::
GGS_unaryMinusExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_unaryMinusExpressionForGeneration::
GGS_unaryMinusExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_unaryMinusExpressionForGeneration GGS_unaryMinusExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_unaryMinusExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_unaryMinusExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_unaryMinusExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_unaryMinusExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_unaryMinusExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_unaryMinusExpressionForGeneration GGS_unaryMinusExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_semanticExpressionForGeneration & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_unaryMinusExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_unaryMinusExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_unaryMinusExpressionForGeneration::
reader_mExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_unaryMinusExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_unaryMinusExpressionForGeneration *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_unaryMinusExpressionForGeneration::actualTypeName (void) const {
  return "unaryMinusExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__unaryMinusExpressionForGeneration ("unaryMinusExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_unaryMinusExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_unaryMinusExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_unaryMinusExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_unaryMinusExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_unaryMinusExpressionForGeneration GGS_unaryMinusExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_unaryMinusExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_unaryMinusExpressionForGeneration * p = dynamic_cast <const GGS_unaryMinusExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_unaryMinusExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_unaryMinusExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_unaryMinusExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_notExpressionForGeneration'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_notExpressionForGeneration::
cPtr_notExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_semanticExpressionForGeneration & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_notExpressionForGeneration * GGS_notExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_notExpressionForGeneration) ;
    return (cPtr_notExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_notExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_notExpressionForGeneration * ptr = dynamic_cast <const cPtr_notExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mExpression.operator_isEqual (ptr->mExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_notExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@notExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_notExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_notExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_notExpressionForGeneration (& typeid (cPtr_notExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_notExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__notExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_notExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_notExpressionForGeneration (mType, mLocation, mExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_notExpressionForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_notExpressionForGeneration ("notExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_notExpressionForGeneration::
GGS_notExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_notExpressionForGeneration::
GGS_notExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_notExpressionForGeneration GGS_notExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_notExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_notExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_notExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_notExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_notExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_notExpressionForGeneration GGS_notExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_semanticExpressionForGeneration & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_notExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_notExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_notExpressionForGeneration::
reader_mExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_notExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_notExpressionForGeneration *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_notExpressionForGeneration::actualTypeName (void) const {
  return "notExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__notExpressionForGeneration ("notExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_notExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_notExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_notExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_notExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_notExpressionForGeneration GGS_notExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_notExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_notExpressionForGeneration * p = dynamic_cast <const GGS_notExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_notExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_notExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_notExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_tildeExpressionForGeneration'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_tildeExpressionForGeneration::
cPtr_tildeExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_semanticExpressionForGeneration & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_tildeExpressionForGeneration * GGS_tildeExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_tildeExpressionForGeneration) ;
    return (cPtr_tildeExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_tildeExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_tildeExpressionForGeneration * ptr = dynamic_cast <const cPtr_tildeExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mExpression.operator_isEqual (ptr->mExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_tildeExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@tildeExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_tildeExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_tildeExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_tildeExpressionForGeneration (& typeid (cPtr_tildeExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_tildeExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__tildeExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_tildeExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_tildeExpressionForGeneration (mType, mLocation, mExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_tildeExpressionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_tildeExpressionForGeneration ("tildeExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_tildeExpressionForGeneration::
GGS_tildeExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_tildeExpressionForGeneration::
GGS_tildeExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_tildeExpressionForGeneration GGS_tildeExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_tildeExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_tildeExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_tildeExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_tildeExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_tildeExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_tildeExpressionForGeneration GGS_tildeExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_semanticExpressionForGeneration & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_tildeExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_tildeExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_tildeExpressionForGeneration::
reader_mExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_tildeExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_tildeExpressionForGeneration *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_tildeExpressionForGeneration::actualTypeName (void) const {
  return "tildeExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__tildeExpressionForGeneration ("tildeExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_tildeExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_tildeExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_tildeExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_tildeExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_tildeExpressionForGeneration GGS_tildeExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_tildeExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_tildeExpressionForGeneration * p = dynamic_cast <const GGS_tildeExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_tildeExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_tildeExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_tildeExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_ifExpressionForGeneration'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ifExpressionForGeneration::
cPtr_ifExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_semanticExpressionForGeneration & argument_2,
                                const GGS_semanticExpressionForGeneration & argument_3,
                                const GGS_semanticExpressionForGeneration & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mIfExpression (argument_2),
mThenExpression (argument_3),
mElseExpression (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ifExpressionForGeneration * GGS_ifExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_ifExpressionForGeneration) ;
    return (cPtr_ifExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ifExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ifExpressionForGeneration * ptr = dynamic_cast <const cPtr_ifExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mIfExpression.operator_isEqual (ptr->mIfExpression).boolValue ()
         && mThenExpression.operator_isEqual (ptr->mThenExpression).boolValue ()
         && mElseExpression.operator_isEqual (ptr->mElseExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ifExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@ifExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mIfExpression.reader_description (inIndentation + 1)
           << mThenExpression.reader_description (inIndentation + 1)
           << mElseExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ifExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ifExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ifExpressionForGeneration (& typeid (cPtr_ifExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_ifExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__ifExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_ifExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_ifExpressionForGeneration (mType, mLocation, mIfExpression, mThenExpression, mElseExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_ifExpressionForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_ifExpressionForGeneration ("ifExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_ifExpressionForGeneration::
GGS_ifExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ifExpressionForGeneration::
GGS_ifExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_ifExpressionForGeneration GGS_ifExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ifExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ifExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_ifExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_ifExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ifExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ifExpressionForGeneration GGS_ifExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_semanticExpressionForGeneration & argument_2,
                 const GGS_semanticExpressionForGeneration & argument_3,
                 const GGS_semanticExpressionForGeneration & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_ifExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_ifExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_ifExpressionForGeneration::
reader_mIfExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ifExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ifExpressionForGeneration *) mPointer)->mIfExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_ifExpressionForGeneration::
reader_mThenExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ifExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ifExpressionForGeneration *) mPointer)->mThenExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_ifExpressionForGeneration::
reader_mElseExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ifExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ifExpressionForGeneration *) mPointer)->mElseExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ifExpressionForGeneration::actualTypeName (void) const {
  return "ifExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__ifExpressionForGeneration ("ifExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_ifExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_ifExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_ifExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_ifExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ifExpressionForGeneration GGS_ifExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_ifExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_ifExpressionForGeneration * p = dynamic_cast <const GGS_ifExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_ifExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_ifExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_ifExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_functionCallExpressionForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_functionCallExpressionForGeneration::
cPtr_functionCallExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_string& argument_2,
                                const GGS_semanticExpressionListForGeneration & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mFunctionName (argument_2),
mExpressions (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_functionCallExpressionForGeneration * GGS_functionCallExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_functionCallExpressionForGeneration) ;
    return (cPtr_functionCallExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_functionCallExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_functionCallExpressionForGeneration * ptr = dynamic_cast <const cPtr_functionCallExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mFunctionName.operator_isEqual (ptr->mFunctionName).boolValue ()
         && mExpressions.operator_isEqual (ptr->mExpressions).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_functionCallExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@functionCallExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mFunctionName.reader_description (inIndentation + 1)
           << mExpressions.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_functionCallExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_functionCallExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_functionCallExpressionForGeneration (& typeid (cPtr_functionCallExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_functionCallExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__functionCallExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_functionCallExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_functionCallExpressionForGeneration (mType, mLocation, mFunctionName, mExpressions COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_functionCallExpressionForGeneration'           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_functionCallExpressionForGeneration ("functionCallExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_functionCallExpressionForGeneration::
GGS_functionCallExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_functionCallExpressionForGeneration::
GGS_functionCallExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_functionCallExpressionForGeneration GGS_functionCallExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_functionCallExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_functionCallExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_functionCallExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_functionCallExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_functionCallExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_functionCallExpressionForGeneration GGS_functionCallExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_string& argument_2,
                 const GGS_semanticExpressionListForGeneration & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_functionCallExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_functionCallExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_functionCallExpressionForGeneration::
reader_mFunctionName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_functionCallExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_functionCallExpressionForGeneration *) mPointer)->mFunctionName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionListForGeneration  GGS_functionCallExpressionForGeneration::
reader_mExpressions (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_functionCallExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_functionCallExpressionForGeneration *) mPointer)->mExpressions ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_functionCallExpressionForGeneration::actualTypeName (void) const {
  return "functionCallExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__functionCallExpressionForGeneration ("functionCallExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_functionCallExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_functionCallExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_functionCallExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_functionCallExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_functionCallExpressionForGeneration GGS_functionCallExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_functionCallExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_functionCallExpressionForGeneration * p = dynamic_cast <const GGS_functionCallExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_functionCallExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_functionCallExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_functionCallExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_varInExpressionForGeneration'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_varInExpressionForGeneration::
cPtr_varInExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_string& argument_2,
                                const GGS_string& argument_3,
                                const GGS_lstringlist & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mCppVarName (argument_2),
mNameForCheckingFormalParameterUsing (argument_3),
mStructFieldList (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_varInExpressionForGeneration * GGS_varInExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_varInExpressionForGeneration) ;
    return (cPtr_varInExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_varInExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_varInExpressionForGeneration * ptr = dynamic_cast <const cPtr_varInExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mCppVarName.operator_isEqual (ptr->mCppVarName).boolValue ()
         && mNameForCheckingFormalParameterUsing.operator_isEqual (ptr->mNameForCheckingFormalParameterUsing).boolValue ()
         && mStructFieldList.operator_isEqual (ptr->mStructFieldList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_varInExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@varInExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mCppVarName.reader_description (inIndentation + 1)
           << mNameForCheckingFormalParameterUsing.reader_description (inIndentation + 1)
           << mStructFieldList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_varInExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_varInExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_varInExpressionForGeneration (& typeid (cPtr_varInExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_varInExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__varInExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_varInExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_varInExpressionForGeneration (mType, mLocation, mCppVarName, mNameForCheckingFormalParameterUsing, mStructFieldList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_varInExpressionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_varInExpressionForGeneration ("varInExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_varInExpressionForGeneration::
GGS_varInExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_varInExpressionForGeneration::
GGS_varInExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_varInExpressionForGeneration GGS_varInExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_varInExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_varInExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_varInExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_varInExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_varInExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_varInExpressionForGeneration GGS_varInExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_string& argument_2,
                 const GGS_string& argument_3,
                 const GGS_lstringlist & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_varInExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_varInExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_varInExpressionForGeneration::
reader_mCppVarName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_varInExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_varInExpressionForGeneration *) mPointer)->mCppVarName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_varInExpressionForGeneration::
reader_mNameForCheckingFormalParameterUsing (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_varInExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_varInExpressionForGeneration *) mPointer)->mNameForCheckingFormalParameterUsing ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_varInExpressionForGeneration::
reader_mStructFieldList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_varInExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_varInExpressionForGeneration *) mPointer)->mStructFieldList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_varInExpressionForGeneration::actualTypeName (void) const {
  return "varInExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__varInExpressionForGeneration ("varInExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_varInExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_varInExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_varInExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_varInExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_varInExpressionForGeneration GGS_varInExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_varInExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_varInExpressionForGeneration * p = dynamic_cast <const GGS_varInExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_varInExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_varInExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_varInExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            class 'cPtr_literalTypeInExpressionForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_literalTypeInExpressionForGeneration::
cPtr_literalTypeInExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_string& argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mTypeName (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_literalTypeInExpressionForGeneration * GGS_literalTypeInExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_literalTypeInExpressionForGeneration) ;
    return (cPtr_literalTypeInExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_literalTypeInExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_literalTypeInExpressionForGeneration * ptr = dynamic_cast <const cPtr_literalTypeInExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mTypeName.operator_isEqual (ptr->mTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_literalTypeInExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@literalTypeInExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mTypeName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_literalTypeInExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_literalTypeInExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_literalTypeInExpressionForGeneration (& typeid (cPtr_literalTypeInExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_literalTypeInExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__literalTypeInExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_literalTypeInExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_literalTypeInExpressionForGeneration (mType, mLocation, mTypeName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         GALGAS class 'GGS_literalTypeInExpressionForGeneration'           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_literalTypeInExpressionForGeneration ("literalTypeInExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_literalTypeInExpressionForGeneration::
GGS_literalTypeInExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_literalTypeInExpressionForGeneration::
GGS_literalTypeInExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_literalTypeInExpressionForGeneration GGS_literalTypeInExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_literalTypeInExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_literalTypeInExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_literalTypeInExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_literalTypeInExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_literalTypeInExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalTypeInExpressionForGeneration GGS_literalTypeInExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_string& argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_literalTypeInExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_literalTypeInExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_literalTypeInExpressionForGeneration::
reader_mTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_literalTypeInExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_literalTypeInExpressionForGeneration *) mPointer)->mTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_literalTypeInExpressionForGeneration::actualTypeName (void) const {
  return "literalTypeInExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__literalTypeInExpressionForGeneration ("literalTypeInExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_literalTypeInExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_literalTypeInExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_literalTypeInExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_literalTypeInExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalTypeInExpressionForGeneration GGS_literalTypeInExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_literalTypeInExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_literalTypeInExpressionForGeneration * p = dynamic_cast <const GGS_literalTypeInExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_literalTypeInExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_literalTypeInExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_literalTypeInExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_castInExpressionForGeneration'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_castInExpressionForGeneration::
cPtr_castInExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_semanticExpressionForGeneration & argument_2,
                                const GGS_bool& argument_3,
                                const GGS_string& argument_4,
                                const GGS_semanticExpressionForGeneration & argument_5
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mReceiverExpression (argument_2),
mUseKindOfClass (argument_3),
mTypeName (argument_4),
mErrorLocationExpression (argument_5) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_castInExpressionForGeneration * GGS_castInExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_castInExpressionForGeneration) ;
    return (cPtr_castInExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_castInExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_castInExpressionForGeneration * ptr = dynamic_cast <const cPtr_castInExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mReceiverExpression.operator_isEqual (ptr->mReceiverExpression).boolValue ()
         && mUseKindOfClass.operator_isEqual (ptr->mUseKindOfClass).boolValue ()
         && mTypeName.operator_isEqual (ptr->mTypeName).boolValue ()
         && mErrorLocationExpression.operator_isEqual (ptr->mErrorLocationExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_castInExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@castInExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mReceiverExpression.reader_description (inIndentation + 1)
           << mUseKindOfClass.reader_description (inIndentation + 1)
           << mTypeName.reader_description (inIndentation + 1)
           << mErrorLocationExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_castInExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_castInExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_castInExpressionForGeneration (& typeid (cPtr_castInExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_castInExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__castInExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_castInExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_castInExpressionForGeneration (mType, mLocation, mReceiverExpression, mUseKindOfClass, mTypeName, mErrorLocationExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_castInExpressionForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_castInExpressionForGeneration ("castInExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_castInExpressionForGeneration::
GGS_castInExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_castInExpressionForGeneration::
GGS_castInExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_castInExpressionForGeneration GGS_castInExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_castInExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_castInExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_castInExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_castInExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_castInExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_castInExpressionForGeneration GGS_castInExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_semanticExpressionForGeneration & argument_2,
                 const GGS_bool& argument_3,
                 const GGS_string& argument_4,
                 const GGS_semanticExpressionForGeneration & argument_5
                                COMMA_LOCATION_ARGS) {
  GGS_castInExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_castInExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_castInExpressionForGeneration::
reader_mReceiverExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_castInExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_castInExpressionForGeneration *) mPointer)->mReceiverExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_castInExpressionForGeneration::
reader_mUseKindOfClass (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_castInExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_castInExpressionForGeneration *) mPointer)->mUseKindOfClass ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_castInExpressionForGeneration::
reader_mTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_castInExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_castInExpressionForGeneration *) mPointer)->mTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_castInExpressionForGeneration::
reader_mErrorLocationExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_castInExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_castInExpressionForGeneration *) mPointer)->mErrorLocationExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_castInExpressionForGeneration::actualTypeName (void) const {
  return "castInExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__castInExpressionForGeneration ("castInExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_castInExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_castInExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_castInExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_castInExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_castInExpressionForGeneration GGS_castInExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_castInExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_castInExpressionForGeneration * p = dynamic_cast <const GGS_castInExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_castInExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_castInExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_castInExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           class 'cPtr_extractObjectInExpressionForGeneration'             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_extractObjectInExpressionForGeneration::
cPtr_extractObjectInExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_semanticExpressionForGeneration & argument_2,
                                const GGS_string& argument_3,
                                const GGS_semanticExpressionForGeneration & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mReceiverExpression (argument_2),
mTypeName (argument_3),
mErrorLocationExpression (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_extractObjectInExpressionForGeneration * GGS_extractObjectInExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_extractObjectInExpressionForGeneration) ;
    return (cPtr_extractObjectInExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_extractObjectInExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_extractObjectInExpressionForGeneration * ptr = dynamic_cast <const cPtr_extractObjectInExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mReceiverExpression.operator_isEqual (ptr->mReceiverExpression).boolValue ()
         && mTypeName.operator_isEqual (ptr->mTypeName).boolValue ()
         && mErrorLocationExpression.operator_isEqual (ptr->mErrorLocationExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_extractObjectInExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@extractObjectInExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mReceiverExpression.reader_description (inIndentation + 1)
           << mTypeName.reader_description (inIndentation + 1)
           << mErrorLocationExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_extractObjectInExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_extractObjectInExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_extractObjectInExpressionForGeneration (& typeid (cPtr_extractObjectInExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_extractObjectInExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__extractObjectInExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_extractObjectInExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_extractObjectInExpressionForGeneration (mType, mLocation, mReceiverExpression, mTypeName, mErrorLocationExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        GALGAS class 'GGS_extractObjectInExpressionForGeneration'          *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_extractObjectInExpressionForGeneration ("extractObjectInExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_extractObjectInExpressionForGeneration::
GGS_extractObjectInExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_extractObjectInExpressionForGeneration::
GGS_extractObjectInExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_extractObjectInExpressionForGeneration GGS_extractObjectInExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_extractObjectInExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_extractObjectInExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_extractObjectInExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_extractObjectInExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_extractObjectInExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_extractObjectInExpressionForGeneration GGS_extractObjectInExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_semanticExpressionForGeneration & argument_2,
                 const GGS_string& argument_3,
                 const GGS_semanticExpressionForGeneration & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_extractObjectInExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_extractObjectInExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_extractObjectInExpressionForGeneration::
reader_mReceiverExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_extractObjectInExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_extractObjectInExpressionForGeneration *) mPointer)->mReceiverExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_extractObjectInExpressionForGeneration::
reader_mTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_extractObjectInExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_extractObjectInExpressionForGeneration *) mPointer)->mTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_extractObjectInExpressionForGeneration::
reader_mErrorLocationExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_extractObjectInExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_extractObjectInExpressionForGeneration *) mPointer)->mErrorLocationExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_extractObjectInExpressionForGeneration::actualTypeName (void) const {
  return "extractObjectInExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__extractObjectInExpressionForGeneration ("extractObjectInExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_extractObjectInExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_extractObjectInExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_extractObjectInExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_extractObjectInExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_extractObjectInExpressionForGeneration GGS_extractObjectInExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_extractObjectInExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_extractObjectInExpressionForGeneration * p = dynamic_cast <const GGS_extractObjectInExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_extractObjectInExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_extractObjectInExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_extractObjectInExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            class 'cPtr_filewrapperInExpressionForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_filewrapperInExpressionForGeneration::
cPtr_filewrapperInExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_string& argument_2,
                                const GGS_string& argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mFilewrapperName (argument_2),
mFilewrapperPath (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_filewrapperInExpressionForGeneration * GGS_filewrapperInExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_filewrapperInExpressionForGeneration) ;
    return (cPtr_filewrapperInExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_filewrapperInExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_filewrapperInExpressionForGeneration * ptr = dynamic_cast <const cPtr_filewrapperInExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mFilewrapperName.operator_isEqual (ptr->mFilewrapperName).boolValue ()
         && mFilewrapperPath.operator_isEqual (ptr->mFilewrapperPath).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_filewrapperInExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@filewrapperInExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mFilewrapperName.reader_description (inIndentation + 1)
           << mFilewrapperPath.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_filewrapperInExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_filewrapperInExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_filewrapperInExpressionForGeneration (& typeid (cPtr_filewrapperInExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_filewrapperInExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__filewrapperInExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_filewrapperInExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_filewrapperInExpressionForGeneration (mType, mLocation, mFilewrapperName, mFilewrapperPath COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         GALGAS class 'GGS_filewrapperInExpressionForGeneration'           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_filewrapperInExpressionForGeneration ("filewrapperInExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_filewrapperInExpressionForGeneration::
GGS_filewrapperInExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperInExpressionForGeneration::
GGS_filewrapperInExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_filewrapperInExpressionForGeneration GGS_filewrapperInExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_filewrapperInExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_filewrapperInExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_filewrapperInExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_filewrapperInExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_filewrapperInExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperInExpressionForGeneration GGS_filewrapperInExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_string& argument_2,
                 const GGS_string& argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_filewrapperInExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_filewrapperInExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_filewrapperInExpressionForGeneration::
reader_mFilewrapperName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_filewrapperInExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_filewrapperInExpressionForGeneration *) mPointer)->mFilewrapperName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_filewrapperInExpressionForGeneration::
reader_mFilewrapperPath (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_filewrapperInExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_filewrapperInExpressionForGeneration *) mPointer)->mFilewrapperPath ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_filewrapperInExpressionForGeneration::actualTypeName (void) const {
  return "filewrapperInExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__filewrapperInExpressionForGeneration ("filewrapperInExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_filewrapperInExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_filewrapperInExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_filewrapperInExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_filewrapperInExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperInExpressionForGeneration GGS_filewrapperInExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_filewrapperInExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_filewrapperInExpressionForGeneration * p = dynamic_cast <const GGS_filewrapperInExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_filewrapperInExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_filewrapperInExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_filewrapperInExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//       class 'cPtr_filewrapperStaticPathInExpressionForGeneration'         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_filewrapperStaticPathInExpressionForGeneration::
cPtr_filewrapperStaticPathInExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_string& argument_2,
                                const GGS_uint & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mFilewrapperName (argument_2),
mFilewrapperFileIndex (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_filewrapperStaticPathInExpressionForGeneration * GGS_filewrapperStaticPathInExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_filewrapperStaticPathInExpressionForGeneration) ;
    return (cPtr_filewrapperStaticPathInExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_filewrapperStaticPathInExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_filewrapperStaticPathInExpressionForGeneration * ptr = dynamic_cast <const cPtr_filewrapperStaticPathInExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mFilewrapperName.operator_isEqual (ptr->mFilewrapperName).boolValue ()
         && mFilewrapperFileIndex.operator_isEqual (ptr->mFilewrapperFileIndex).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_filewrapperStaticPathInExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@filewrapperStaticPathInExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mFilewrapperName.reader_description (inIndentation + 1)
           << mFilewrapperFileIndex.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_filewrapperStaticPathInExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_filewrapperStaticPathInExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_filewrapperStaticPathInExpressionForGeneration (& typeid (cPtr_filewrapperStaticPathInExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_filewrapperStaticPathInExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__filewrapperStaticPathInExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_filewrapperStaticPathInExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_filewrapperStaticPathInExpressionForGeneration (mType, mLocation, mFilewrapperName, mFilewrapperFileIndex COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//    GALGAS class 'GGS_filewrapperStaticPathInExpressionForGeneration'      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_filewrapperStaticPathInExpressionForGeneration ("filewrapperStaticPathInExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_filewrapperStaticPathInExpressionForGeneration::
GGS_filewrapperStaticPathInExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperStaticPathInExpressionForGeneration::
GGS_filewrapperStaticPathInExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_filewrapperStaticPathInExpressionForGeneration GGS_filewrapperStaticPathInExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_filewrapperStaticPathInExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_filewrapperStaticPathInExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_filewrapperStaticPathInExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_filewrapperStaticPathInExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_filewrapperStaticPathInExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperStaticPathInExpressionForGeneration GGS_filewrapperStaticPathInExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_string& argument_2,
                 const GGS_uint & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_filewrapperStaticPathInExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_filewrapperStaticPathInExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_filewrapperStaticPathInExpressionForGeneration::
reader_mFilewrapperName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_filewrapperStaticPathInExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_filewrapperStaticPathInExpressionForGeneration *) mPointer)->mFilewrapperName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_filewrapperStaticPathInExpressionForGeneration::
reader_mFilewrapperFileIndex (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_filewrapperStaticPathInExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_filewrapperStaticPathInExpressionForGeneration *) mPointer)->mFilewrapperFileIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_filewrapperStaticPathInExpressionForGeneration::actualTypeName (void) const {
  return "filewrapperStaticPathInExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__filewrapperStaticPathInExpressionForGeneration ("filewrapperStaticPathInExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_filewrapperStaticPathInExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_filewrapperStaticPathInExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_filewrapperStaticPathInExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_filewrapperStaticPathInExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperStaticPathInExpressionForGeneration GGS_filewrapperStaticPathInExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_filewrapperStaticPathInExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_filewrapperStaticPathInExpressionForGeneration * p = dynamic_cast <const GGS_filewrapperStaticPathInExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_filewrapperStaticPathInExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_filewrapperStaticPathInExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_filewrapperStaticPathInExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        class 'cPtr_filewrapperTemplateInExpressionForGeneration'          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_filewrapperTemplateInExpressionForGeneration::
cPtr_filewrapperTemplateInExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_location & argument_1,
                                const GGS_string& argument_2,
                                const GGS_string& argument_3,
                                const GGS_semanticExpressionListForGeneration & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionForGeneration (argument_0, argument_1 COMMA_THERE),
mFilewrapperName (argument_2),
mFilewrapperTemplateName (argument_3),
mActualOutputParameterList (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_filewrapperTemplateInExpressionForGeneration * GGS_filewrapperTemplateInExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_filewrapperTemplateInExpressionForGeneration) ;
    return (cPtr_filewrapperTemplateInExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_filewrapperTemplateInExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_filewrapperTemplateInExpressionForGeneration * ptr = dynamic_cast <const cPtr_filewrapperTemplateInExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mFilewrapperName.operator_isEqual (ptr->mFilewrapperName).boolValue ()
         && mFilewrapperTemplateName.operator_isEqual (ptr->mFilewrapperTemplateName).boolValue ()
         && mActualOutputParameterList.operator_isEqual (ptr->mActualOutputParameterList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_filewrapperTemplateInExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@filewrapperTemplateInExpressionForGeneration:"
           << mType.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mFilewrapperName.reader_description (inIndentation + 1)
           << mFilewrapperTemplateName.reader_description (inIndentation + 1)
           << mActualOutputParameterList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_filewrapperTemplateInExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_filewrapperTemplateInExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_filewrapperTemplateInExpressionForGeneration (& typeid (cPtr_filewrapperTemplateInExpressionForGeneration), & typeid (cPtr_semanticExpressionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_filewrapperTemplateInExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__filewrapperTemplateInExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_filewrapperTemplateInExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_filewrapperTemplateInExpressionForGeneration (mType, mLocation, mFilewrapperName, mFilewrapperTemplateName, mActualOutputParameterList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//     GALGAS class 'GGS_filewrapperTemplateInExpressionForGeneration'       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_filewrapperTemplateInExpressionForGeneration ("filewrapperTemplateInExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateInExpressionForGeneration::
GGS_filewrapperTemplateInExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateInExpressionForGeneration::
GGS_filewrapperTemplateInExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_filewrapperTemplateInExpressionForGeneration GGS_filewrapperTemplateInExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_filewrapperTemplateInExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_filewrapperTemplateInExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_filewrapperTemplateInExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_filewrapperTemplateInExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_filewrapperTemplateInExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateInExpressionForGeneration GGS_filewrapperTemplateInExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_location & argument_1,
                 const GGS_string& argument_2,
                 const GGS_string& argument_3,
                 const GGS_semanticExpressionListForGeneration & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_filewrapperTemplateInExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_filewrapperTemplateInExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_filewrapperTemplateInExpressionForGeneration::
reader_mFilewrapperName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_filewrapperTemplateInExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_filewrapperTemplateInExpressionForGeneration *) mPointer)->mFilewrapperName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_filewrapperTemplateInExpressionForGeneration::
reader_mFilewrapperTemplateName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_filewrapperTemplateInExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_filewrapperTemplateInExpressionForGeneration *) mPointer)->mFilewrapperTemplateName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionListForGeneration  GGS_filewrapperTemplateInExpressionForGeneration::
reader_mActualOutputParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_filewrapperTemplateInExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_filewrapperTemplateInExpressionForGeneration *) mPointer)->mActualOutputParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_filewrapperTemplateInExpressionForGeneration::actualTypeName (void) const {
  return "filewrapperTemplateInExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__filewrapperTemplateInExpressionForGeneration ("filewrapperTemplateInExpressionForGeneration", gClassInfoFor__semanticExpressionForGeneration, & kTypeDescriptor_GGS_filewrapperTemplateInExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_filewrapperTemplateInExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_filewrapperTemplateInExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_filewrapperTemplateInExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateInExpressionForGeneration GGS_filewrapperTemplateInExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_filewrapperTemplateInExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_filewrapperTemplateInExpressionForGeneration * p = dynamic_cast <const GGS_filewrapperTemplateInExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_filewrapperTemplateInExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_filewrapperTemplateInExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_filewrapperTemplateInExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Element of list '@formalParameterListForGeneration'             *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_formalParameterListForGeneration::
elementOf_GGS_formalParameterListForGeneration (const GGS_formalArgumentPassingModeAST& argument_0,
                                const GGS_unifiedTypeMapProxy & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_string& argument_3
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mFormalArgumentPassingMode (argument_0),
mFormalArgumentType (argument_1),
mFormalArgumentName (argument_2),
mFormalArgumentCppName (argument_3) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_formalParameterListForGeneration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_formalParameterListForGeneration * ptr = dynamic_cast <const elementOf_GGS_formalParameterListForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mFormalArgumentPassingMode.operator_isEqual (ptr->mFormalArgumentPassingMode).boolValue ()
         && mFormalArgumentType.operator_isEqual (ptr->mFormalArgumentType).boolValue ()
         && mFormalArgumentName.operator_isEqual (ptr->mFormalArgumentName).boolValue ()
         && mFormalArgumentCppName.operator_isEqual (ptr->mFormalArgumentCppName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_formalParameterListForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFormalArgumentPassingMode.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFormalArgumentType.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFormalArgumentName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFormalArgumentCppName.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 List '@formalParameterListForGeneration'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_formalParameterListForGeneration ("formalParameterListForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_formalParameterListForGeneration::
internalAppendValues (const GGS_formalArgumentPassingModeAST& argument_0,
                    const GGS_unifiedTypeMapProxy & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_string& argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_formalParameterListForGeneration::
internalPrependValues (const GGS_formalArgumentPassingModeAST& argument_0,
                    const GGS_unifiedTypeMapProxy & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_string& argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_formalParameterListForGeneration::
addAssign_operation (const GGS_formalArgumentPassingModeAST& argument_0,
                                const GGS_unifiedTypeMapProxy & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_string& argument_3) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()&& argument_3.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_formalParameterListForGeneration GGS_formalParameterListForGeneration::
operator_concat (const GGS_formalParameterListForGeneration & inOperand) const {
  GGS_formalParameterListForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_formalParameterListForGeneration::
dotAssign_operation (const GGS_formalParameterListForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_formalParameterListForGeneration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_formalArgumentPassingModeAST p_0 = p->mFormalArgumentPassingMode ;
          GGS_unifiedTypeMapProxy  p_1 = p->mFormalArgumentType ;
          GGS_lstring  p_2 = p->mFormalArgumentName ;
          GGS_string p_3 = p->mFormalArgumentCppName ;
          internalAppendValues (p_0, p_1, p_2, p_3 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_formalParameterListForGeneration::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_formalArgumentPassingModeAST& argument_0,
                     const GGS_unifiedTypeMapProxy & argument_1,
                     const GGS_lstring & argument_2,
                     const GGS_string& argument_3
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_formalParameterListForGeneration::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mFormalArgumentPassingMode,
                                ptr->mFormalArgumentType,
                                ptr->mFormalArgumentName,
                                ptr->mFormalArgumentCppName
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_formalParameterListForGeneration  GGS_formalParameterListForGeneration::
constructor_emptyList (void) {
  GGS_formalParameterListForGeneration result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameterListForGeneration  GGS_formalParameterListForGeneration::
constructor_listWithValue (const GGS_formalArgumentPassingModeAST& argument_0,
                                const GGS_unifiedTypeMapProxy & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_string& argument_3) {
  GGS_formalParameterListForGeneration result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2, argument_3) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_formalParameterListForGeneration::
internalSubListWithRange (GGS_formalParameterListForGeneration & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mFormalArgumentPassingMode, ptr->mFormalArgumentType, ptr->mFormalArgumentName, ptr->mFormalArgumentCppName) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_formalParameterListForGeneration GGS_formalParameterListForGeneration::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_formalParameterListForGeneration result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameterListForGeneration GGS_formalParameterListForGeneration::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_formalParameterListForGeneration result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_formalParameterListForGeneration::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@formalParameterListForGeneration", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_formalParameterListForGeneration::
method_first (C_Compiler & inLexique,
              GGS_formalArgumentPassingModeAST& _out_0,
              GGS_unifiedTypeMapProxy & _out_1,
              GGS_lstring & _out_2,
              GGS_string& _out_3
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mFormalArgumentPassingMode ;
    _out_1 = ptr->mFormalArgumentType ;
    _out_2 = ptr->mFormalArgumentName ;
    _out_3 = ptr->mFormalArgumentCppName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_formalParameterListForGeneration::
method_last (C_Compiler & inLexique,
             GGS_formalArgumentPassingModeAST& _out_0,
             GGS_unifiedTypeMapProxy & _out_1,
             GGS_lstring & _out_2,
             GGS_string& _out_3
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mFormalArgumentPassingMode ;
    _out_1 = ptr->mFormalArgumentType ;
    _out_2 = ptr->mFormalArgumentName ;
    _out_3 = ptr->mFormalArgumentCppName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_formalParameterListForGeneration::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_formalArgumentPassingModeAST& _out_0,
                 GGS_unifiedTypeMapProxy & _out_1,
                 GGS_lstring & _out_2,
                 GGS_string& _out_3
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mFormalArgumentPassingMode ;
    _out_1 = ptr->mFormalArgumentType ;
    _out_2 = ptr->mFormalArgumentName ;
    _out_3 = ptr->mFormalArgumentCppName ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_formalParameterListForGeneration::
modifier_popLast (C_Compiler & inLexique,
                GGS_formalArgumentPassingModeAST& _out_0,
                GGS_unifiedTypeMapProxy & _out_1,
                GGS_lstring & _out_2,
                GGS_string& _out_3
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mFormalArgumentPassingMode ;
    _out_1 = ptr->mFormalArgumentType ;
    _out_2 = ptr->mFormalArgumentName ;
    _out_3 = ptr->mFormalArgumentCppName ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_formalArgumentPassingModeAST GGS_formalParameterListForGeneration::
reader_mFormalArgumentPassingModeAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_formalArgumentPassingModeAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mFormalArgumentPassingMode ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapProxy  GGS_formalParameterListForGeneration::
reader_mFormalArgumentTypeAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_unifiedTypeMapProxy  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mFormalArgumentType ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_formalParameterListForGeneration::
reader_mFormalArgumentNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mFormalArgumentName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_formalParameterListForGeneration::
reader_mFormalArgumentCppNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_string result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mFormalArgumentCppName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_formalParameterListForGeneration::
modifier_setMFormalArgumentPassingModeAtIndex (C_Compiler & inLexique,
                              const GGS_formalArgumentPassingModeAST & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mFormalArgumentPassingMode = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_formalParameterListForGeneration::
modifier_setMFormalArgumentTypeAtIndex (C_Compiler & inLexique,
                              const GGS_unifiedTypeMapProxy  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mFormalArgumentType = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_formalParameterListForGeneration::
modifier_setMFormalArgumentNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mFormalArgumentName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_formalParameterListForGeneration::
modifier_setMFormalArgumentCppNameAtIndex (C_Compiler & inLexique,
                              const GGS_string & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mFormalArgumentCppName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_formalArgumentPassingModeAST & GGS_formalParameterListForGeneration::cEnumerator::_mFormalArgumentPassingMode (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mFormalArgumentPassingMode ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_unifiedTypeMapProxy  & GGS_formalParameterListForGeneration::cEnumerator::_mFormalArgumentType (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mFormalArgumentType ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_formalParameterListForGeneration::cEnumerator::_mFormalArgumentName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mFormalArgumentName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_formalParameterListForGeneration::cEnumerator::_mFormalArgumentCppName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mFormalArgumentCppName ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_formalParameterListForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_formalParameterListForGeneration * p = NULL ;
    macroMyNew (p, GGS_formalParameterListForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameterListForGeneration GGS_formalParameterListForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_formalParameterListForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_formalParameterListForGeneration * p = dynamic_cast <const GGS_formalParameterListForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_formalParameterListForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_formalParameterListForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_formalParameterListForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         Element of list '@formalInputParameterListForGeneration'          *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_formalInputParameterListForGeneration::
elementOf_GGS_formalInputParameterListForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_string& argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_bool& argument_3
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mFormalArgumentType (argument_0),
mFormalArgumentCppName (argument_1),
mFormalArgumentName (argument_2),
mIsUnused (argument_3) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_formalInputParameterListForGeneration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_formalInputParameterListForGeneration * ptr = dynamic_cast <const elementOf_GGS_formalInputParameterListForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mFormalArgumentType.operator_isEqual (ptr->mFormalArgumentType).boolValue ()
         && mFormalArgumentCppName.operator_isEqual (ptr->mFormalArgumentCppName).boolValue ()
         && mFormalArgumentName.operator_isEqual (ptr->mFormalArgumentName).boolValue ()
         && mIsUnused.operator_isEqual (ptr->mIsUnused).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_formalInputParameterListForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFormalArgumentType.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFormalArgumentCppName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFormalArgumentName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mIsUnused.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              List '@formalInputParameterListForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_formalInputParameterListForGeneration ("formalInputParameterListForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_formalInputParameterListForGeneration::
internalAppendValues (const GGS_unifiedTypeMapProxy & argument_0,
                    const GGS_string& argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_bool& argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_formalInputParameterListForGeneration::
internalPrependValues (const GGS_unifiedTypeMapProxy & argument_0,
                    const GGS_string& argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_bool& argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_formalInputParameterListForGeneration::
addAssign_operation (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_string& argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_bool& argument_3) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()&& argument_3.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_formalInputParameterListForGeneration GGS_formalInputParameterListForGeneration::
operator_concat (const GGS_formalInputParameterListForGeneration & inOperand) const {
  GGS_formalInputParameterListForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_formalInputParameterListForGeneration::
dotAssign_operation (const GGS_formalInputParameterListForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_formalInputParameterListForGeneration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_unifiedTypeMapProxy  p_0 = p->mFormalArgumentType ;
          GGS_string p_1 = p->mFormalArgumentCppName ;
          GGS_lstring  p_2 = p->mFormalArgumentName ;
          GGS_bool p_3 = p->mIsUnused ;
          internalAppendValues (p_0, p_1, p_2, p_3 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_formalInputParameterListForGeneration::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_unifiedTypeMapProxy & argument_0,
                     const GGS_string& argument_1,
                     const GGS_lstring & argument_2,
                     const GGS_bool& argument_3
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_formalInputParameterListForGeneration::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mFormalArgumentType,
                                ptr->mFormalArgumentCppName,
                                ptr->mFormalArgumentName,
                                ptr->mIsUnused
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_formalInputParameterListForGeneration  GGS_formalInputParameterListForGeneration::
constructor_emptyList (void) {
  GGS_formalInputParameterListForGeneration result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalInputParameterListForGeneration  GGS_formalInputParameterListForGeneration::
constructor_listWithValue (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_string& argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_bool& argument_3) {
  GGS_formalInputParameterListForGeneration result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2, argument_3) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_formalInputParameterListForGeneration::
internalSubListWithRange (GGS_formalInputParameterListForGeneration & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mFormalArgumentType, ptr->mFormalArgumentCppName, ptr->mFormalArgumentName, ptr->mIsUnused) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_formalInputParameterListForGeneration GGS_formalInputParameterListForGeneration::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_formalInputParameterListForGeneration result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalInputParameterListForGeneration GGS_formalInputParameterListForGeneration::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_formalInputParameterListForGeneration result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_formalInputParameterListForGeneration::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@formalInputParameterListForGeneration", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_formalInputParameterListForGeneration::
method_first (C_Compiler & inLexique,
              GGS_unifiedTypeMapProxy & _out_0,
              GGS_string& _out_1,
              GGS_lstring & _out_2,
              GGS_bool& _out_3
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mFormalArgumentType ;
    _out_1 = ptr->mFormalArgumentCppName ;
    _out_2 = ptr->mFormalArgumentName ;
    _out_3 = ptr->mIsUnused ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_formalInputParameterListForGeneration::
method_last (C_Compiler & inLexique,
             GGS_unifiedTypeMapProxy & _out_0,
             GGS_string& _out_1,
             GGS_lstring & _out_2,
             GGS_bool& _out_3
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mFormalArgumentType ;
    _out_1 = ptr->mFormalArgumentCppName ;
    _out_2 = ptr->mFormalArgumentName ;
    _out_3 = ptr->mIsUnused ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_formalInputParameterListForGeneration::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_unifiedTypeMapProxy & _out_0,
                 GGS_string& _out_1,
                 GGS_lstring & _out_2,
                 GGS_bool& _out_3
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mFormalArgumentType ;
    _out_1 = ptr->mFormalArgumentCppName ;
    _out_2 = ptr->mFormalArgumentName ;
    _out_3 = ptr->mIsUnused ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_formalInputParameterListForGeneration::
modifier_popLast (C_Compiler & inLexique,
                GGS_unifiedTypeMapProxy & _out_0,
                GGS_string& _out_1,
                GGS_lstring & _out_2,
                GGS_bool& _out_3
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mFormalArgumentType ;
    _out_1 = ptr->mFormalArgumentCppName ;
    _out_2 = ptr->mFormalArgumentName ;
    _out_3 = ptr->mIsUnused ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapProxy  GGS_formalInputParameterListForGeneration::
reader_mFormalArgumentTypeAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_unifiedTypeMapProxy  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mFormalArgumentType ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_formalInputParameterListForGeneration::
reader_mFormalArgumentCppNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_string result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mFormalArgumentCppName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_formalInputParameterListForGeneration::
reader_mFormalArgumentNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mFormalArgumentName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_formalInputParameterListForGeneration::
reader_mIsUnusedAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mIsUnused ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_formalInputParameterListForGeneration::
modifier_setMFormalArgumentTypeAtIndex (C_Compiler & inLexique,
                              const GGS_unifiedTypeMapProxy  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mFormalArgumentType = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_formalInputParameterListForGeneration::
modifier_setMFormalArgumentCppNameAtIndex (C_Compiler & inLexique,
                              const GGS_string & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mFormalArgumentCppName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_formalInputParameterListForGeneration::
modifier_setMFormalArgumentNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mFormalArgumentName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_formalInputParameterListForGeneration::
modifier_setMIsUnusedAtIndex (C_Compiler & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mIsUnused = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_unifiedTypeMapProxy  & GGS_formalInputParameterListForGeneration::cEnumerator::_mFormalArgumentType (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mFormalArgumentType ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_formalInputParameterListForGeneration::cEnumerator::_mFormalArgumentCppName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mFormalArgumentCppName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_formalInputParameterListForGeneration::cEnumerator::_mFormalArgumentName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mFormalArgumentName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_formalInputParameterListForGeneration::cEnumerator::_mIsUnused (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mIsUnused ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_formalInputParameterListForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_formalInputParameterListForGeneration * p = NULL ;
    macroMyNew (p, GGS_formalInputParameterListForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalInputParameterListForGeneration GGS_formalInputParameterListForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_formalInputParameterListForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_formalInputParameterListForGeneration * p = dynamic_cast <const GGS_formalInputParameterListForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_formalInputParameterListForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_formalInputParameterListForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_formalInputParameterListForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_actualParameterForGeneration'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_actualParameterForGeneration::
cPtr_actualParameterForGeneration (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_actualParameterForGeneration * GGS_actualParameterForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_actualParameterForGeneration) ;
    return (cPtr_actualParameterForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_actualParameterForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@actualParameterForGeneration:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_actualParameterForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_actualParameterForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_actualParameterForGeneration (& typeid (cPtr_actualParameterForGeneration), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_actualParameterForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__actualParameterForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_actualParameterForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_actualParameterForGeneration ("actualParameterForGeneration", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_actualParameterForGeneration::
GGS_actualParameterForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_actualParameterForGeneration::
GGS_actualParameterForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_actualParameterForGeneration GGS_actualParameterForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_actualParameterForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_actualParameterForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_actualParameterForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_actualParameterForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_actualParameterForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_actualParameterForGeneration::actualTypeName (void) const {
  return "actualParameterForGeneration" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_actualParameterForGeneration::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__actualParameterForGeneration ("actualParameterForGeneration", & kTypeDescriptor_GGS_actualParameterForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_actualParameterForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_actualParameterForGeneration * p = NULL ;
    macroMyNew (p, GGS_actualParameterForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameterForGeneration GGS_actualParameterForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_actualParameterForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_actualParameterForGeneration * p = dynamic_cast <const GGS_actualParameterForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_actualParameterForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_actualParameterForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_actualParameterForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_outputActualParameterForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_outputActualParameterForGeneration::
cPtr_outputActualParameterForGeneration (const GGS_semanticExpressionForGeneration & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_actualParameterForGeneration (THERE),
mOutputActualParameterExpression (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_outputActualParameterForGeneration * GGS_outputActualParameterForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_outputActualParameterForGeneration) ;
    return (cPtr_outputActualParameterForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_outputActualParameterForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_outputActualParameterForGeneration * ptr = dynamic_cast <const cPtr_outputActualParameterForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOutputActualParameterExpression.operator_isEqual (ptr->mOutputActualParameterExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_outputActualParameterForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@outputActualParameterForGeneration:"
           << mOutputActualParameterExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_outputActualParameterForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_outputActualParameterForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_outputActualParameterForGeneration (& typeid (cPtr_outputActualParameterForGeneration), & typeid (cPtr_actualParameterForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_outputActualParameterForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__outputActualParameterForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_outputActualParameterForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_outputActualParameterForGeneration (mOutputActualParameterExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_outputActualParameterForGeneration'            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_outputActualParameterForGeneration ("outputActualParameterForGeneration", true, & kTypeDescriptor_GGS_actualParameterForGeneration) ;

//---------------------------------------------------------------------------*

GGS_outputActualParameterForGeneration::
GGS_outputActualParameterForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_outputActualParameterForGeneration::
GGS_outputActualParameterForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_outputActualParameterForGeneration GGS_outputActualParameterForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_outputActualParameterForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_outputActualParameterForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_outputActualParameterForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_outputActualParameterForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_outputActualParameterForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_outputActualParameterForGeneration GGS_outputActualParameterForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_semanticExpressionForGeneration & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_outputActualParameterForGeneration result ;
  macroMyNew (result.mPointer, cPtr_outputActualParameterForGeneration (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_outputActualParameterForGeneration::
reader_mOutputActualParameterExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_outputActualParameterForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_outputActualParameterForGeneration *) mPointer)->mOutputActualParameterExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_outputActualParameterForGeneration::actualTypeName (void) const {
  return "outputActualParameterForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__outputActualParameterForGeneration ("outputActualParameterForGeneration", gClassInfoFor__actualParameterForGeneration, & kTypeDescriptor_GGS_outputActualParameterForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_outputActualParameterForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_outputActualParameterForGeneration * p = NULL ;
    macroMyNew (p, GGS_outputActualParameterForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_outputActualParameterForGeneration GGS_outputActualParameterForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_outputActualParameterForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_outputActualParameterForGeneration * p = dynamic_cast <const GGS_outputActualParameterForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_outputActualParameterForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_outputActualParameterForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_outputActualParameterForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           class 'cPtr_outputInputActualParameterForGeneration'            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_outputInputActualParameterForGeneration::
cPtr_outputInputActualParameterForGeneration (const GGS_string& argument_0,
                                const GGS_lstringlist & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_actualParameterForGeneration (THERE),
mOutputInputVariableCppName (argument_0),
mStructAttributeList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_outputInputActualParameterForGeneration * GGS_outputInputActualParameterForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_outputInputActualParameterForGeneration) ;
    return (cPtr_outputInputActualParameterForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_outputInputActualParameterForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_outputInputActualParameterForGeneration * ptr = dynamic_cast <const cPtr_outputInputActualParameterForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOutputInputVariableCppName.operator_isEqual (ptr->mOutputInputVariableCppName).boolValue ()
         && mStructAttributeList.operator_isEqual (ptr->mStructAttributeList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_outputInputActualParameterForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@outputInputActualParameterForGeneration:"
           << mOutputInputVariableCppName.reader_description (inIndentation + 1)
           << mStructAttributeList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_outputInputActualParameterForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_outputInputActualParameterForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_outputInputActualParameterForGeneration (& typeid (cPtr_outputInputActualParameterForGeneration), & typeid (cPtr_actualParameterForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_outputInputActualParameterForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__outputInputActualParameterForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_outputInputActualParameterForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_outputInputActualParameterForGeneration (mOutputInputVariableCppName, mStructAttributeList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        GALGAS class 'GGS_outputInputActualParameterForGeneration'         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_outputInputActualParameterForGeneration ("outputInputActualParameterForGeneration", true, & kTypeDescriptor_GGS_actualParameterForGeneration) ;

//---------------------------------------------------------------------------*

GGS_outputInputActualParameterForGeneration::
GGS_outputInputActualParameterForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_outputInputActualParameterForGeneration::
GGS_outputInputActualParameterForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_outputInputActualParameterForGeneration GGS_outputInputActualParameterForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_outputInputActualParameterForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_outputInputActualParameterForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_outputInputActualParameterForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_outputInputActualParameterForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_outputInputActualParameterForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_outputInputActualParameterForGeneration GGS_outputInputActualParameterForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0,
                 const GGS_lstringlist & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_outputInputActualParameterForGeneration result ;
  macroMyNew (result.mPointer, cPtr_outputInputActualParameterForGeneration (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_outputInputActualParameterForGeneration::
reader_mOutputInputVariableCppName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_outputInputActualParameterForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_outputInputActualParameterForGeneration *) mPointer)->mOutputInputVariableCppName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_outputInputActualParameterForGeneration::
reader_mStructAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_outputInputActualParameterForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_outputInputActualParameterForGeneration *) mPointer)->mStructAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_outputInputActualParameterForGeneration::actualTypeName (void) const {
  return "outputInputActualParameterForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__outputInputActualParameterForGeneration ("outputInputActualParameterForGeneration", gClassInfoFor__actualParameterForGeneration, & kTypeDescriptor_GGS_outputInputActualParameterForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_outputInputActualParameterForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_outputInputActualParameterForGeneration * p = NULL ;
    macroMyNew (p, GGS_outputInputActualParameterForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_outputInputActualParameterForGeneration GGS_outputInputActualParameterForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_outputInputActualParameterForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_outputInputActualParameterForGeneration * p = dynamic_cast <const GGS_outputInputActualParameterForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_outputInputActualParameterForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_outputInputActualParameterForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_outputInputActualParameterForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'cPtr_inputActualParameterForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_inputActualParameterForGeneration::
cPtr_inputActualParameterForGeneration (const GGS_string& argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_actualParameterForGeneration (THERE),
mInputActualCppName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_inputActualParameterForGeneration * GGS_inputActualParameterForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_inputActualParameterForGeneration) ;
    return (cPtr_inputActualParameterForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_inputActualParameterForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_inputActualParameterForGeneration * ptr = dynamic_cast <const cPtr_inputActualParameterForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInputActualCppName.operator_isEqual (ptr->mInputActualCppName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_inputActualParameterForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@inputActualParameterForGeneration:"
           << mInputActualCppName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_inputActualParameterForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_inputActualParameterForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_inputActualParameterForGeneration (& typeid (cPtr_inputActualParameterForGeneration), & typeid (cPtr_actualParameterForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_inputActualParameterForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__inputActualParameterForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_inputActualParameterForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_inputActualParameterForGeneration (mInputActualCppName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_inputActualParameterForGeneration'            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_inputActualParameterForGeneration ("inputActualParameterForGeneration", true, & kTypeDescriptor_GGS_actualParameterForGeneration) ;

//---------------------------------------------------------------------------*

GGS_inputActualParameterForGeneration::
GGS_inputActualParameterForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_inputActualParameterForGeneration::
GGS_inputActualParameterForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_inputActualParameterForGeneration GGS_inputActualParameterForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_inputActualParameterForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_inputActualParameterForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_inputActualParameterForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_inputActualParameterForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_inputActualParameterForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_inputActualParameterForGeneration GGS_inputActualParameterForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_inputActualParameterForGeneration result ;
  macroMyNew (result.mPointer, cPtr_inputActualParameterForGeneration (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_inputActualParameterForGeneration::
reader_mInputActualCppName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_inputActualParameterForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_inputActualParameterForGeneration *) mPointer)->mInputActualCppName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_inputActualParameterForGeneration::actualTypeName (void) const {
  return "inputActualParameterForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__inputActualParameterForGeneration ("inputActualParameterForGeneration", gClassInfoFor__actualParameterForGeneration, & kTypeDescriptor_GGS_inputActualParameterForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_inputActualParameterForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_inputActualParameterForGeneration * p = NULL ;
    macroMyNew (p, GGS_inputActualParameterForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_inputActualParameterForGeneration GGS_inputActualParameterForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_inputActualParameterForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_inputActualParameterForGeneration * p = dynamic_cast <const GGS_inputActualParameterForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_inputActualParameterForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_inputActualParameterForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_inputActualParameterForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'cPtr_inputJokerParameterForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_inputJokerParameterForGeneration::
cPtr_inputJokerParameterForGeneration (const GGS_string& argument_0,
                                const GGS_unifiedTypeMapProxy & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_actualParameterForGeneration (THERE),
mInputActualCppName (argument_0),
mFormalArgumentType (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_inputJokerParameterForGeneration * GGS_inputJokerParameterForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_inputJokerParameterForGeneration) ;
    return (cPtr_inputJokerParameterForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_inputJokerParameterForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_inputJokerParameterForGeneration * ptr = dynamic_cast <const cPtr_inputJokerParameterForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInputActualCppName.operator_isEqual (ptr->mInputActualCppName).boolValue ()
         && mFormalArgumentType.operator_isEqual (ptr->mFormalArgumentType).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_inputJokerParameterForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@inputJokerParameterForGeneration:"
           << mInputActualCppName.reader_description (inIndentation + 1)
           << mFormalArgumentType.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_inputJokerParameterForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_inputJokerParameterForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_inputJokerParameterForGeneration (& typeid (cPtr_inputJokerParameterForGeneration), & typeid (cPtr_actualParameterForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_inputJokerParameterForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__inputJokerParameterForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_inputJokerParameterForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_inputJokerParameterForGeneration (mInputActualCppName, mFormalArgumentType COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_inputJokerParameterForGeneration'             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_inputJokerParameterForGeneration ("inputJokerParameterForGeneration", true, & kTypeDescriptor_GGS_actualParameterForGeneration) ;

//---------------------------------------------------------------------------*

GGS_inputJokerParameterForGeneration::
GGS_inputJokerParameterForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_inputJokerParameterForGeneration::
GGS_inputJokerParameterForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_inputJokerParameterForGeneration GGS_inputJokerParameterForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_inputJokerParameterForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_inputJokerParameterForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_inputJokerParameterForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_inputJokerParameterForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_inputJokerParameterForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_inputJokerParameterForGeneration GGS_inputJokerParameterForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0,
                 const GGS_unifiedTypeMapProxy & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_inputJokerParameterForGeneration result ;
  macroMyNew (result.mPointer, cPtr_inputJokerParameterForGeneration (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_inputJokerParameterForGeneration::
reader_mInputActualCppName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_inputJokerParameterForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_inputJokerParameterForGeneration *) mPointer)->mInputActualCppName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapProxy  GGS_inputJokerParameterForGeneration::
reader_mFormalArgumentType (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_unifiedTypeMapProxy   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_inputJokerParameterForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_inputJokerParameterForGeneration *) mPointer)->mFormalArgumentType ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_inputJokerParameterForGeneration::actualTypeName (void) const {
  return "inputJokerParameterForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__inputJokerParameterForGeneration ("inputJokerParameterForGeneration", gClassInfoFor__actualParameterForGeneration, & kTypeDescriptor_GGS_inputJokerParameterForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_inputJokerParameterForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_inputJokerParameterForGeneration * p = NULL ;
    macroMyNew (p, GGS_inputJokerParameterForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_inputJokerParameterForGeneration GGS_inputJokerParameterForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_inputJokerParameterForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_inputJokerParameterForGeneration * p = dynamic_cast <const GGS_inputJokerParameterForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_inputJokerParameterForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_inputJokerParameterForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_inputJokerParameterForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Element of list '@actualParameterListForGeneration'             *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_actualParameterListForGeneration::
elementOf_GGS_actualParameterListForGeneration (const GGS_actualParameterForGeneration & argument_0
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mActualParameter (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_actualParameterListForGeneration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_actualParameterListForGeneration * ptr = dynamic_cast <const elementOf_GGS_actualParameterListForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mActualParameter.operator_isEqual (ptr->mActualParameter).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_actualParameterListForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mActualParameter.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 List '@actualParameterListForGeneration'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_actualParameterListForGeneration ("actualParameterListForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_actualParameterListForGeneration::
internalAppendValues (const GGS_actualParameterForGeneration & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_actualParameterListForGeneration::
internalPrependValues (const GGS_actualParameterForGeneration & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_actualParameterListForGeneration::
addAssign_operation (const GGS_actualParameterForGeneration & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_actualParameterListForGeneration GGS_actualParameterListForGeneration::
operator_concat (const GGS_actualParameterListForGeneration & inOperand) const {
  GGS_actualParameterListForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_actualParameterListForGeneration::
dotAssign_operation (const GGS_actualParameterListForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_actualParameterListForGeneration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_actualParameterForGeneration  p_0 = p->mActualParameter ;
          internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_actualParameterListForGeneration::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_actualParameterForGeneration & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_actualParameterListForGeneration::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mActualParameter
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_actualParameterListForGeneration  GGS_actualParameterListForGeneration::
constructor_emptyList (void) {
  GGS_actualParameterListForGeneration result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameterListForGeneration  GGS_actualParameterListForGeneration::
constructor_listWithValue (const GGS_actualParameterForGeneration & argument_0) {
  GGS_actualParameterListForGeneration result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_actualParameterListForGeneration::
internalSubListWithRange (GGS_actualParameterListForGeneration & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mActualParameter) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_actualParameterListForGeneration GGS_actualParameterListForGeneration::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_actualParameterListForGeneration result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameterListForGeneration GGS_actualParameterListForGeneration::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_actualParameterListForGeneration result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_actualParameterListForGeneration::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@actualParameterListForGeneration", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_actualParameterListForGeneration::
method_first (C_Compiler & inLexique,
              GGS_actualParameterForGeneration & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mActualParameter ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_actualParameterListForGeneration::
method_last (C_Compiler & inLexique,
             GGS_actualParameterForGeneration & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mActualParameter ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_actualParameterListForGeneration::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_actualParameterForGeneration & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mActualParameter ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_actualParameterListForGeneration::
modifier_popLast (C_Compiler & inLexique,
                GGS_actualParameterForGeneration & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mActualParameter ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_actualParameterForGeneration  GGS_actualParameterListForGeneration::
reader_mActualParameterAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_actualParameterForGeneration  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mActualParameter ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_actualParameterListForGeneration::
modifier_setMActualParameterAtIndex (C_Compiler & inLexique,
                              const GGS_actualParameterForGeneration  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mActualParameter = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_actualParameterForGeneration  & GGS_actualParameterListForGeneration::cEnumerator::_mActualParameter (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mActualParameter ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_actualParameterListForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_actualParameterListForGeneration * p = NULL ;
    macroMyNew (p, GGS_actualParameterListForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameterListForGeneration GGS_actualParameterListForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_actualParameterListForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_actualParameterListForGeneration * p = dynamic_cast <const GGS_actualParameterListForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_actualParameterListForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_actualParameterListForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_actualParameterListForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'cPtr_semanticInstructionForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_semanticInstructionForGeneration::
cPtr_semanticInstructionForGeneration (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_semanticInstructionForGeneration * GGS_semanticInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_semanticInstructionForGeneration) ;
    return (cPtr_semanticInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_semanticInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@semanticInstructionForGeneration:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_semanticInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_semanticInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_semanticInstructionForGeneration (& typeid (cPtr_semanticInstructionForGeneration), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_semanticInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__semanticInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_semanticInstructionForGeneration'             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_semanticInstructionForGeneration ("semanticInstructionForGeneration", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_semanticInstructionForGeneration::
GGS_semanticInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionForGeneration::
GGS_semanticInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_semanticInstructionForGeneration GGS_semanticInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_semanticInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_semanticInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_semanticInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_semanticInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_semanticInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_semanticInstructionForGeneration::actualTypeName (void) const {
  return "semanticInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_semanticInstructionForGeneration::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__semanticInstructionForGeneration ("semanticInstructionForGeneration", & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_semanticInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_semanticInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_semanticInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionForGeneration GGS_semanticInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_semanticInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_semanticInstructionForGeneration * p = dynamic_cast <const GGS_semanticInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_semanticInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_semanticInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_semanticInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         Element of list '@semanticInstructionListForGeneration'           *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_semanticInstructionListForGeneration::
elementOf_GGS_semanticInstructionListForGeneration (const GGS_semanticInstructionForGeneration & argument_0
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mInstruction (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_semanticInstructionListForGeneration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_semanticInstructionListForGeneration * ptr = dynamic_cast <const elementOf_GGS_semanticInstructionListForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstruction.operator_isEqual (ptr->mInstruction).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_semanticInstructionListForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstruction.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               List '@semanticInstructionListForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_semanticInstructionListForGeneration ("semanticInstructionListForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_semanticInstructionListForGeneration::
internalAppendValues (const GGS_semanticInstructionForGeneration & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionListForGeneration::
internalPrependValues (const GGS_semanticInstructionForGeneration & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionListForGeneration::
addAssign_operation (const GGS_semanticInstructionForGeneration & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration GGS_semanticInstructionListForGeneration::
operator_concat (const GGS_semanticInstructionListForGeneration & inOperand) const {
  GGS_semanticInstructionListForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionListForGeneration::
dotAssign_operation (const GGS_semanticInstructionListForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_semanticInstructionListForGeneration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_semanticInstructionForGeneration  p_0 = p->mInstruction ;
          internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionListForGeneration::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_semanticInstructionForGeneration & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionListForGeneration::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mInstruction
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration  GGS_semanticInstructionListForGeneration::
constructor_emptyList (void) {
  GGS_semanticInstructionListForGeneration result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration  GGS_semanticInstructionListForGeneration::
constructor_listWithValue (const GGS_semanticInstructionForGeneration & argument_0) {
  GGS_semanticInstructionListForGeneration result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionListForGeneration::
internalSubListWithRange (GGS_semanticInstructionListForGeneration & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mInstruction) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration GGS_semanticInstructionListForGeneration::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_semanticInstructionListForGeneration result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration GGS_semanticInstructionListForGeneration::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_semanticInstructionListForGeneration result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_semanticInstructionListForGeneration::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@semanticInstructionListForGeneration", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionListForGeneration::
method_first (C_Compiler & inLexique,
              GGS_semanticInstructionForGeneration & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInstruction ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionListForGeneration::
method_last (C_Compiler & inLexique,
             GGS_semanticInstructionForGeneration & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInstruction ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionListForGeneration::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_semanticInstructionForGeneration & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInstruction ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionListForGeneration::
modifier_popLast (C_Compiler & inLexique,
                GGS_semanticInstructionForGeneration & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInstruction ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionForGeneration  GGS_semanticInstructionListForGeneration::
reader_mInstructionAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticInstructionForGeneration  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstruction ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionListForGeneration::
modifier_setMInstructionAtIndex (C_Compiler & inLexique,
                              const GGS_semanticInstructionForGeneration  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstruction = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticInstructionForGeneration  & GGS_semanticInstructionListForGeneration::cEnumerator::_mInstruction (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mInstruction ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_semanticInstructionListForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_semanticInstructionListForGeneration * p = NULL ;
    macroMyNew (p, GGS_semanticInstructionListForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration GGS_semanticInstructionListForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_semanticInstructionListForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_semanticInstructionListForGeneration * p = dynamic_cast <const GGS_semanticInstructionListForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_semanticInstructionListForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_semanticInstructionListForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_semanticInstructionListForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Element of list '@listOfSemanticInstructionListForGeneration'        *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_listOfSemanticInstructionListForGeneration::
elementOf_GGS_listOfSemanticInstructionListForGeneration (const GGS_semanticInstructionListForGeneration & argument_0,
                                const GGS_location & argument_1
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mInstructionList (argument_0),
mEndOfInstructionList (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_listOfSemanticInstructionListForGeneration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_listOfSemanticInstructionListForGeneration * ptr = dynamic_cast <const elementOf_GGS_listOfSemanticInstructionListForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionList.operator_isEqual (ptr->mInstructionList).boolValue ()
         && mEndOfInstructionList.operator_isEqual (ptr->mEndOfInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_listOfSemanticInstructionListForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEndOfInstructionList.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            List '@listOfSemanticInstructionListForGeneration'             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_listOfSemanticInstructionListForGeneration ("listOfSemanticInstructionListForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_listOfSemanticInstructionListForGeneration::
internalAppendValues (const GGS_semanticInstructionListForGeneration & argument_0,
                    const GGS_location & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_listOfSemanticInstructionListForGeneration::
internalPrependValues (const GGS_semanticInstructionListForGeneration & argument_0,
                    const GGS_location & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_listOfSemanticInstructionListForGeneration::
addAssign_operation (const GGS_semanticInstructionListForGeneration & argument_0,
                                const GGS_location & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_listOfSemanticInstructionListForGeneration GGS_listOfSemanticInstructionListForGeneration::
operator_concat (const GGS_listOfSemanticInstructionListForGeneration & inOperand) const {
  GGS_listOfSemanticInstructionListForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_listOfSemanticInstructionListForGeneration::
dotAssign_operation (const GGS_listOfSemanticInstructionListForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_listOfSemanticInstructionListForGeneration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_semanticInstructionListForGeneration  p_0 = p->mInstructionList ;
          GGS_location  p_1 = p->mEndOfInstructionList ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_listOfSemanticInstructionListForGeneration::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_semanticInstructionListForGeneration & argument_0,
                     const GGS_location & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_listOfSemanticInstructionListForGeneration::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mInstructionList,
                                ptr->mEndOfInstructionList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_listOfSemanticInstructionListForGeneration  GGS_listOfSemanticInstructionListForGeneration::
constructor_emptyList (void) {
  GGS_listOfSemanticInstructionListForGeneration result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_listOfSemanticInstructionListForGeneration  GGS_listOfSemanticInstructionListForGeneration::
constructor_listWithValue (const GGS_semanticInstructionListForGeneration & argument_0,
                                const GGS_location & argument_1) {
  GGS_listOfSemanticInstructionListForGeneration result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_listOfSemanticInstructionListForGeneration::
internalSubListWithRange (GGS_listOfSemanticInstructionListForGeneration & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mInstructionList, ptr->mEndOfInstructionList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_listOfSemanticInstructionListForGeneration GGS_listOfSemanticInstructionListForGeneration::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_listOfSemanticInstructionListForGeneration result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_listOfSemanticInstructionListForGeneration GGS_listOfSemanticInstructionListForGeneration::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_listOfSemanticInstructionListForGeneration result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_listOfSemanticInstructionListForGeneration::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@listOfSemanticInstructionListForGeneration", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_listOfSemanticInstructionListForGeneration::
method_first (C_Compiler & inLexique,
              GGS_semanticInstructionListForGeneration & _out_0,
              GGS_location & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInstructionList ;
    _out_1 = ptr->mEndOfInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_listOfSemanticInstructionListForGeneration::
method_last (C_Compiler & inLexique,
             GGS_semanticInstructionListForGeneration & _out_0,
             GGS_location & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInstructionList ;
    _out_1 = ptr->mEndOfInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_listOfSemanticInstructionListForGeneration::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_semanticInstructionListForGeneration & _out_0,
                 GGS_location & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInstructionList ;
    _out_1 = ptr->mEndOfInstructionList ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_listOfSemanticInstructionListForGeneration::
modifier_popLast (C_Compiler & inLexique,
                GGS_semanticInstructionListForGeneration & _out_0,
                GGS_location & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInstructionList ;
    _out_1 = ptr->mEndOfInstructionList ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration  GGS_listOfSemanticInstructionListForGeneration::
reader_mInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticInstructionListForGeneration  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_listOfSemanticInstructionListForGeneration::
reader_mEndOfInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_location  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mEndOfInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_listOfSemanticInstructionListForGeneration::
modifier_setMInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_semanticInstructionListForGeneration  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_listOfSemanticInstructionListForGeneration::
modifier_setMEndOfInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_location  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mEndOfInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticInstructionListForGeneration  & GGS_listOfSemanticInstructionListForGeneration::cEnumerator::_mInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mInstructionList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_location  & GGS_listOfSemanticInstructionListForGeneration::cEnumerator::_mEndOfInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mEndOfInstructionList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_listOfSemanticInstructionListForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_listOfSemanticInstructionListForGeneration * p = NULL ;
    macroMyNew (p, GGS_listOfSemanticInstructionListForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_listOfSemanticInstructionListForGeneration GGS_listOfSemanticInstructionListForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_listOfSemanticInstructionListForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_listOfSemanticInstructionListForGeneration * p = dynamic_cast <const GGS_listOfSemanticInstructionListForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_listOfSemanticInstructionListForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_listOfSemanticInstructionListForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_listOfSemanticInstructionListForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'cPtr_semanticDeclarationForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_semanticDeclarationForGeneration::
cPtr_semanticDeclarationForGeneration (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_semanticDeclarationForGeneration * GGS_semanticDeclarationForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_semanticDeclarationForGeneration) ;
    return (cPtr_semanticDeclarationForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_semanticDeclarationForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@semanticDeclarationForGeneration:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_semanticDeclarationForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_semanticDeclarationForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_semanticDeclarationForGeneration (& typeid (cPtr_semanticDeclarationForGeneration), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_semanticDeclarationForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__semanticDeclarationForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_semanticDeclarationForGeneration'             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_semanticDeclarationForGeneration ("semanticDeclarationForGeneration", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_semanticDeclarationForGeneration::
GGS_semanticDeclarationForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationForGeneration::
GGS_semanticDeclarationForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_semanticDeclarationForGeneration GGS_semanticDeclarationForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_semanticDeclarationForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_semanticDeclarationForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_semanticDeclarationForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_semanticDeclarationForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_semanticDeclarationForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_semanticDeclarationForGeneration::actualTypeName (void) const {
  return "semanticDeclarationForGeneration" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_semanticDeclarationForGeneration::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__semanticDeclarationForGeneration ("semanticDeclarationForGeneration", & kTypeDescriptor_GGS_semanticDeclarationForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_semanticDeclarationForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_semanticDeclarationForGeneration * p = NULL ;
    macroMyNew (p, GGS_semanticDeclarationForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationForGeneration GGS_semanticDeclarationForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_semanticDeclarationForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_semanticDeclarationForGeneration * p = dynamic_cast <const GGS_semanticDeclarationForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_semanticDeclarationForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_semanticDeclarationForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_semanticDeclarationForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Element of list '@semanticDeclarationSortedListForGeneration'        *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_semanticDeclarationSortedListForGeneration::
elementOf_GGS_semanticDeclarationSortedListForGeneration (const GGS_semanticDeclarationForGeneration & argument_0,
                                const GGS_string& argument_1):
mDeclaration (argument_0),
mSortKey (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_semanticDeclarationSortedListForGeneration::
isEqualToObject (const cSortedListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_semanticDeclarationSortedListForGeneration * ptr = dynamic_cast <const elementOf_GGS_semanticDeclarationSortedListForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mDeclaration.operator_isEqual (ptr->mDeclaration).boolValue ()
         && mSortKey.operator_isEqual (ptr->mSortKey).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

PMSInt32 elementOf_GGS_semanticDeclarationSortedListForGeneration::
compareForSorting (const cSortedListElement * inOperand) const {
  const elementOf_GGS_semanticDeclarationSortedListForGeneration * operand = (const elementOf_GGS_semanticDeclarationSortedListForGeneration *) inOperand ;
  PMSInt32 result = mSortKey.genericObjectCompare (operand->mSortKey) ;
  return result ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_semanticDeclarationSortedListForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mDeclaration.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSortKey.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        Sorted list '@semanticDeclarationSortedListForGeneration'          *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_semanticDeclarationSortedListForGeneration ("semanticDeclarationSortedListForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

GGS_semanticDeclarationSortedListForGeneration::GGS_semanticDeclarationSortedListForGeneration (void): AC_GGS_sortedlist () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationSortedListForGeneration::
GGS_semanticDeclarationSortedListForGeneration (const GGS_semanticDeclarationSortedListForGeneration & inSource): AC_GGS_sortedlist (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_semanticDeclarationSortedListForGeneration::
operator_isEqual (const GGS_semanticDeclarationSortedListForGeneration & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_semanticDeclarationSortedListForGeneration::
operator_isNotEqual (const GGS_semanticDeclarationSortedListForGeneration & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationSortedListForGeneration::
internalAppendValues (const GGS_semanticDeclarationForGeneration & argument_0,
                    const GGS_string& argument_1) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationSortedListForGeneration::
addAssign_operation (const GGS_semanticDeclarationForGeneration & argument_0,
                                const GGS_string& argument_1) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationSortedListForGeneration GGS_semanticDeclarationSortedListForGeneration::
operator_concat (const GGS_semanticDeclarationSortedListForGeneration & inOperand) const {
  GGS_semanticDeclarationSortedListForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationSortedListForGeneration::
dotAssign_operation (const GGS_semanticDeclarationSortedListForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      *this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_semanticDeclarationSortedListForGeneration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_semanticDeclarationForGeneration  p_0 = p->mDeclaration ;
          GGS_string p_1 = p->mSortKey ;
          internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationSortedListForGeneration::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mDeclaration,
                                ptr->mSortKey) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationSortedListForGeneration  GGS_semanticDeclarationSortedListForGeneration::
constructor_emptySortedList (void) {
  GGS_semanticDeclarationSortedListForGeneration result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationSortedListForGeneration  GGS_semanticDeclarationSortedListForGeneration::
constructor_sortedListWithValue (const GGS_semanticDeclarationForGeneration & argument_0,
                           const GGS_string& argument_1) {
  GGS_semanticDeclarationSortedListForGeneration result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_semanticDeclarationSortedListForGeneration::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@semanticDeclarationSortedListForGeneration", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationSortedListForGeneration::
method_smallest (C_Compiler & inLexique,
                 GGS_semanticDeclarationForGeneration & _out_0,
                 GGS_string& _out_1
                 COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mDeclaration ;
    _out_1 = ptr->mSortKey ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationSortedListForGeneration::
method_greatest (C_Compiler & inLexique,
             GGS_semanticDeclarationForGeneration & _out_0,
             GGS_string& _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'greatest' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mDeclaration ;
    _out_1 = ptr->mSortKey ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationSortedListForGeneration::
modifier_popSmallest (C_Compiler & inLexique,
                 GGS_semanticDeclarationForGeneration & _out_0,
                 GGS_string& _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popSmallest' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mDeclaration ;
    _out_1 = ptr->mSortKey ;
    insulateList () ;
    _internalRemoveSmallest () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationSortedListForGeneration::
modifier_popGreatest (C_Compiler & inLexique,
                GGS_semanticDeclarationForGeneration & _out_0,
                GGS_string& _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popGreatest' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mDeclaration ;
    _out_1 = ptr->mSortKey ;
    insulateList () ;
    _internalRemoveGreatest () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticDeclarationForGeneration  & GGS_semanticDeclarationSortedListForGeneration::cEnumerator::_mDeclaration (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mDeclaration ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_semanticDeclarationSortedListForGeneration::cEnumerator::_mSortKey (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mSortKey ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_semanticDeclarationSortedListForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_semanticDeclarationSortedListForGeneration * p = NULL ;
    macroMyNew (p, GGS_semanticDeclarationSortedListForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationSortedListForGeneration GGS_semanticDeclarationSortedListForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_semanticDeclarationSortedListForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_semanticDeclarationSortedListForGeneration * p = dynamic_cast <const GGS_semanticDeclarationSortedListForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_semanticDeclarationSortedListForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_semanticDeclarationSortedListForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_semanticDeclarationSortedListForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_semanticTypeForGeneration'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_semanticTypeForGeneration::
cPtr_semanticTypeForGeneration (const GGS_unifiedTypeMapProxy & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_semanticDeclarationForGeneration (THERE),
mTypeIndex (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_semanticTypeForGeneration * GGS_semanticTypeForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_semanticTypeForGeneration) ;
    return (cPtr_semanticTypeForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_semanticTypeForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@semanticTypeForGeneration:"
           << mTypeIndex.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_semanticTypeForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_semanticTypeForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_semanticTypeForGeneration (& typeid (cPtr_semanticTypeForGeneration), & typeid (cPtr_semanticDeclarationForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_semanticTypeForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__semanticTypeForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_semanticTypeForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_semanticTypeForGeneration ("semanticTypeForGeneration", true, & kTypeDescriptor_GGS_semanticDeclarationForGeneration) ;

//---------------------------------------------------------------------------*

GGS_semanticTypeForGeneration::
GGS_semanticTypeForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_semanticTypeForGeneration::
GGS_semanticTypeForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_semanticTypeForGeneration GGS_semanticTypeForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_semanticTypeForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_semanticTypeForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_semanticTypeForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_semanticTypeForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_semanticTypeForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapProxy  GGS_semanticTypeForGeneration::
reader_mTypeIndex (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_unifiedTypeMapProxy   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_semanticTypeForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_semanticTypeForGeneration *) mPointer)->mTypeIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_semanticTypeForGeneration::actualTypeName (void) const {
  return "semanticTypeForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__semanticTypeForGeneration ("semanticTypeForGeneration", gClassInfoFor__semanticDeclarationForGeneration, & kTypeDescriptor_GGS_semanticTypeForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_semanticTypeForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_semanticTypeForGeneration * p = NULL ;
    macroMyNew (p, GGS_semanticTypeForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticTypeForGeneration GGS_semanticTypeForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_semanticTypeForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_semanticTypeForGeneration * p = dynamic_cast <const GGS_semanticTypeForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_semanticTypeForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_semanticTypeForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_semanticTypeForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          class 'cPtr_routinePrototypeDeclarationForGeneration'            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_routinePrototypeDeclarationForGeneration::
cPtr_routinePrototypeDeclarationForGeneration (const GGS_string& argument_0,
                                const GGS_formalParameterListForGeneration & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticDeclarationForGeneration (THERE),
mRoutineName (argument_0),
mFormalArgumentList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_routinePrototypeDeclarationForGeneration * GGS_routinePrototypeDeclarationForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_routinePrototypeDeclarationForGeneration) ;
    return (cPtr_routinePrototypeDeclarationForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_routinePrototypeDeclarationForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_routinePrototypeDeclarationForGeneration * ptr = dynamic_cast <const cPtr_routinePrototypeDeclarationForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mRoutineName.operator_isEqual (ptr->mRoutineName).boolValue ()
         && mFormalArgumentList.operator_isEqual (ptr->mFormalArgumentList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_routinePrototypeDeclarationForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@routinePrototypeDeclarationForGeneration:"
           << mRoutineName.reader_description (inIndentation + 1)
           << mFormalArgumentList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_routinePrototypeDeclarationForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_routinePrototypeDeclarationForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_routinePrototypeDeclarationForGeneration (& typeid (cPtr_routinePrototypeDeclarationForGeneration), & typeid (cPtr_semanticDeclarationForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_routinePrototypeDeclarationForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__routinePrototypeDeclarationForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_routinePrototypeDeclarationForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_routinePrototypeDeclarationForGeneration (mRoutineName, mFormalArgumentList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//       GALGAS class 'GGS_routinePrototypeDeclarationForGeneration'         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_routinePrototypeDeclarationForGeneration ("routinePrototypeDeclarationForGeneration", true, & kTypeDescriptor_GGS_semanticDeclarationForGeneration) ;

//---------------------------------------------------------------------------*

GGS_routinePrototypeDeclarationForGeneration::
GGS_routinePrototypeDeclarationForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_routinePrototypeDeclarationForGeneration::
GGS_routinePrototypeDeclarationForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_routinePrototypeDeclarationForGeneration GGS_routinePrototypeDeclarationForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_routinePrototypeDeclarationForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_routinePrototypeDeclarationForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_routinePrototypeDeclarationForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_routinePrototypeDeclarationForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_routinePrototypeDeclarationForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_routinePrototypeDeclarationForGeneration GGS_routinePrototypeDeclarationForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0,
                 const GGS_formalParameterListForGeneration & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_routinePrototypeDeclarationForGeneration result ;
  macroMyNew (result.mPointer, cPtr_routinePrototypeDeclarationForGeneration (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_routinePrototypeDeclarationForGeneration::
reader_mRoutineName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_routinePrototypeDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_routinePrototypeDeclarationForGeneration *) mPointer)->mRoutineName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameterListForGeneration  GGS_routinePrototypeDeclarationForGeneration::
reader_mFormalArgumentList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_formalParameterListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_routinePrototypeDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_routinePrototypeDeclarationForGeneration *) mPointer)->mFormalArgumentList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_routinePrototypeDeclarationForGeneration::actualTypeName (void) const {
  return "routinePrototypeDeclarationForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__routinePrototypeDeclarationForGeneration ("routinePrototypeDeclarationForGeneration", gClassInfoFor__semanticDeclarationForGeneration, & kTypeDescriptor_GGS_routinePrototypeDeclarationForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_routinePrototypeDeclarationForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_routinePrototypeDeclarationForGeneration * p = NULL ;
    macroMyNew (p, GGS_routinePrototypeDeclarationForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_routinePrototypeDeclarationForGeneration GGS_routinePrototypeDeclarationForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_routinePrototypeDeclarationForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_routinePrototypeDeclarationForGeneration * p = dynamic_cast <const GGS_routinePrototypeDeclarationForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_routinePrototypeDeclarationForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_routinePrototypeDeclarationForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_routinePrototypeDeclarationForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_routineImplementationForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_routineImplementationForGeneration::
cPtr_routineImplementationForGeneration (const GGS_string& argument_0,
                                const GGS_formalParameterListForGeneration & argument_1,
                                const GGS_semanticInstructionListForGeneration & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_routinePrototypeDeclarationForGeneration (argument_0, argument_1 COMMA_THERE),
mRoutineInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_routineImplementationForGeneration * GGS_routineImplementationForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_routineImplementationForGeneration) ;
    return (cPtr_routineImplementationForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_routineImplementationForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_routineImplementationForGeneration * ptr = dynamic_cast <const cPtr_routineImplementationForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mRoutineName.operator_isEqual (ptr->mRoutineName).boolValue ()
         && mFormalArgumentList.operator_isEqual (ptr->mFormalArgumentList).boolValue ()
         && mRoutineInstructionList.operator_isEqual (ptr->mRoutineInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_routineImplementationForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@routineImplementationForGeneration:"
           << mRoutineName.reader_description (inIndentation + 1)
           << mFormalArgumentList.reader_description (inIndentation + 1)
           << mRoutineInstructionList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_routineImplementationForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_routineImplementationForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_routineImplementationForGeneration (& typeid (cPtr_routineImplementationForGeneration), & typeid (cPtr_routinePrototypeDeclarationForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_routineImplementationForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__routineImplementationForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_routineImplementationForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_routineImplementationForGeneration (mRoutineName, mFormalArgumentList, mRoutineInstructionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_routineImplementationForGeneration'            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_routineImplementationForGeneration ("routineImplementationForGeneration", true, & kTypeDescriptor_GGS_routinePrototypeDeclarationForGeneration) ;

//---------------------------------------------------------------------------*

GGS_routineImplementationForGeneration::
GGS_routineImplementationForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_routineImplementationForGeneration::
GGS_routineImplementationForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_routineImplementationForGeneration GGS_routineImplementationForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_routineImplementationForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_routineImplementationForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_routineImplementationForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_routineImplementationForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_routineImplementationForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_routineImplementationForGeneration GGS_routineImplementationForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0,
                 const GGS_formalParameterListForGeneration & argument_1,
                 const GGS_semanticInstructionListForGeneration & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_routineImplementationForGeneration result ;
  macroMyNew (result.mPointer, cPtr_routineImplementationForGeneration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration  GGS_routineImplementationForGeneration::
reader_mRoutineInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_routineImplementationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_routineImplementationForGeneration *) mPointer)->mRoutineInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_routineImplementationForGeneration::actualTypeName (void) const {
  return "routineImplementationForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__routineImplementationForGeneration ("routineImplementationForGeneration", gClassInfoFor__routinePrototypeDeclarationForGeneration, & kTypeDescriptor_GGS_routineImplementationForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_routineImplementationForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_routineImplementationForGeneration * p = NULL ;
    macroMyNew (p, GGS_routineImplementationForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_routineImplementationForGeneration GGS_routineImplementationForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_routineImplementationForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_routineImplementationForGeneration * p = dynamic_cast <const GGS_routineImplementationForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_routineImplementationForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_routineImplementationForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_routineImplementationForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          class 'cPtr_functionPrototypeDeclarationForGeneration'           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_functionPrototypeDeclarationForGeneration::
cPtr_functionPrototypeDeclarationForGeneration (const GGS_string& argument_0,
                                const GGS_formalInputParameterListForGeneration & argument_1,
                                const GGS_unifiedTypeMapProxy & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticDeclarationForGeneration (THERE),
mFunctionName (argument_0),
mFormalArgumentList (argument_1),
mReturnType (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_functionPrototypeDeclarationForGeneration * GGS_functionPrototypeDeclarationForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_functionPrototypeDeclarationForGeneration) ;
    return (cPtr_functionPrototypeDeclarationForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_functionPrototypeDeclarationForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_functionPrototypeDeclarationForGeneration * ptr = dynamic_cast <const cPtr_functionPrototypeDeclarationForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mFunctionName.operator_isEqual (ptr->mFunctionName).boolValue ()
         && mFormalArgumentList.operator_isEqual (ptr->mFormalArgumentList).boolValue ()
         && mReturnType.operator_isEqual (ptr->mReturnType).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_functionPrototypeDeclarationForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@functionPrototypeDeclarationForGeneration:"
           << mFunctionName.reader_description (inIndentation + 1)
           << mFormalArgumentList.reader_description (inIndentation + 1)
           << mReturnType.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_functionPrototypeDeclarationForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_functionPrototypeDeclarationForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_functionPrototypeDeclarationForGeneration (& typeid (cPtr_functionPrototypeDeclarationForGeneration), & typeid (cPtr_semanticDeclarationForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_functionPrototypeDeclarationForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__functionPrototypeDeclarationForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_functionPrototypeDeclarationForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_functionPrototypeDeclarationForGeneration (mFunctionName, mFormalArgumentList, mReturnType COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//       GALGAS class 'GGS_functionPrototypeDeclarationForGeneration'        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_functionPrototypeDeclarationForGeneration ("functionPrototypeDeclarationForGeneration", true, & kTypeDescriptor_GGS_semanticDeclarationForGeneration) ;

//---------------------------------------------------------------------------*

GGS_functionPrototypeDeclarationForGeneration::
GGS_functionPrototypeDeclarationForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_functionPrototypeDeclarationForGeneration::
GGS_functionPrototypeDeclarationForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_functionPrototypeDeclarationForGeneration GGS_functionPrototypeDeclarationForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_functionPrototypeDeclarationForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_functionPrototypeDeclarationForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_functionPrototypeDeclarationForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_functionPrototypeDeclarationForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_functionPrototypeDeclarationForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_functionPrototypeDeclarationForGeneration GGS_functionPrototypeDeclarationForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0,
                 const GGS_formalInputParameterListForGeneration & argument_1,
                 const GGS_unifiedTypeMapProxy & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_functionPrototypeDeclarationForGeneration result ;
  macroMyNew (result.mPointer, cPtr_functionPrototypeDeclarationForGeneration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_functionPrototypeDeclarationForGeneration::
reader_mFunctionName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_functionPrototypeDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_functionPrototypeDeclarationForGeneration *) mPointer)->mFunctionName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalInputParameterListForGeneration  GGS_functionPrototypeDeclarationForGeneration::
reader_mFormalArgumentList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_formalInputParameterListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_functionPrototypeDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_functionPrototypeDeclarationForGeneration *) mPointer)->mFormalArgumentList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapProxy  GGS_functionPrototypeDeclarationForGeneration::
reader_mReturnType (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_unifiedTypeMapProxy   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_functionPrototypeDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_functionPrototypeDeclarationForGeneration *) mPointer)->mReturnType ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_functionPrototypeDeclarationForGeneration::actualTypeName (void) const {
  return "functionPrototypeDeclarationForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__functionPrototypeDeclarationForGeneration ("functionPrototypeDeclarationForGeneration", gClassInfoFor__semanticDeclarationForGeneration, & kTypeDescriptor_GGS_functionPrototypeDeclarationForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_functionPrototypeDeclarationForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_functionPrototypeDeclarationForGeneration * p = NULL ;
    macroMyNew (p, GGS_functionPrototypeDeclarationForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_functionPrototypeDeclarationForGeneration GGS_functionPrototypeDeclarationForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_functionPrototypeDeclarationForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_functionPrototypeDeclarationForGeneration * p = dynamic_cast <const GGS_functionPrototypeDeclarationForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_functionPrototypeDeclarationForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_functionPrototypeDeclarationForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_functionPrototypeDeclarationForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_functionImplementationForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_functionImplementationForGeneration::
cPtr_functionImplementationForGeneration (const GGS_string& argument_0,
                                const GGS_formalInputParameterListForGeneration & argument_1,
                                const GGS_unifiedTypeMapProxy & argument_2,
                                const GGS_string& argument_3,
                                const GGS_semanticInstructionListForGeneration & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_functionPrototypeDeclarationForGeneration (argument_0, argument_1, argument_2 COMMA_THERE),
mResultVariableCppName (argument_3),
mFunctionInstructionList (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_functionImplementationForGeneration * GGS_functionImplementationForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_functionImplementationForGeneration) ;
    return (cPtr_functionImplementationForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_functionImplementationForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_functionImplementationForGeneration * ptr = dynamic_cast <const cPtr_functionImplementationForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mFunctionName.operator_isEqual (ptr->mFunctionName).boolValue ()
         && mFormalArgumentList.operator_isEqual (ptr->mFormalArgumentList).boolValue ()
         && mReturnType.operator_isEqual (ptr->mReturnType).boolValue ()
         && mResultVariableCppName.operator_isEqual (ptr->mResultVariableCppName).boolValue ()
         && mFunctionInstructionList.operator_isEqual (ptr->mFunctionInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_functionImplementationForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@functionImplementationForGeneration:"
           << mFunctionName.reader_description (inIndentation + 1)
           << mFormalArgumentList.reader_description (inIndentation + 1)
           << mReturnType.reader_description (inIndentation + 1)
           << mResultVariableCppName.reader_description (inIndentation + 1)
           << mFunctionInstructionList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_functionImplementationForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_functionImplementationForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_functionImplementationForGeneration (& typeid (cPtr_functionImplementationForGeneration), & typeid (cPtr_functionPrototypeDeclarationForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_functionImplementationForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__functionImplementationForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_functionImplementationForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_functionImplementationForGeneration (mFunctionName, mFormalArgumentList, mReturnType, mResultVariableCppName, mFunctionInstructionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_functionImplementationForGeneration'           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_functionImplementationForGeneration ("functionImplementationForGeneration", true, & kTypeDescriptor_GGS_functionPrototypeDeclarationForGeneration) ;

//---------------------------------------------------------------------------*

GGS_functionImplementationForGeneration::
GGS_functionImplementationForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_functionImplementationForGeneration::
GGS_functionImplementationForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_functionImplementationForGeneration GGS_functionImplementationForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_functionImplementationForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_functionImplementationForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_functionImplementationForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_functionImplementationForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_functionImplementationForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_functionImplementationForGeneration GGS_functionImplementationForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0,
                 const GGS_formalInputParameterListForGeneration & argument_1,
                 const GGS_unifiedTypeMapProxy & argument_2,
                 const GGS_string& argument_3,
                 const GGS_semanticInstructionListForGeneration & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_functionImplementationForGeneration result ;
  macroMyNew (result.mPointer, cPtr_functionImplementationForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_functionImplementationForGeneration::
reader_mResultVariableCppName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_functionImplementationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_functionImplementationForGeneration *) mPointer)->mResultVariableCppName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration  GGS_functionImplementationForGeneration::
reader_mFunctionInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_functionImplementationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_functionImplementationForGeneration *) mPointer)->mFunctionInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_functionImplementationForGeneration::actualTypeName (void) const {
  return "functionImplementationForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__functionImplementationForGeneration ("functionImplementationForGeneration", gClassInfoFor__functionPrototypeDeclarationForGeneration, & kTypeDescriptor_GGS_functionImplementationForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_functionImplementationForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_functionImplementationForGeneration * p = NULL ;
    macroMyNew (p, GGS_functionImplementationForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_functionImplementationForGeneration GGS_functionImplementationForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_functionImplementationForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_functionImplementationForGeneration * p = dynamic_cast <const GGS_functionImplementationForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_functionImplementationForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_functionImplementationForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_functionImplementationForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            class 'cPtr_onceFunctionDeclarationForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_onceFunctionDeclarationForGeneration::
cPtr_onceFunctionDeclarationForGeneration (const GGS_string& argument_0,
                                const GGS_unifiedTypeMapProxy & argument_1,
                                const GGS_string& argument_2,
                                const GGS_semanticInstructionListForGeneration & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticDeclarationForGeneration (THERE),
mFunctionName (argument_0),
mReturnType (argument_1),
mResultVariableCppName (argument_2),
mFunctionInstructionList (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_onceFunctionDeclarationForGeneration * GGS_onceFunctionDeclarationForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_onceFunctionDeclarationForGeneration) ;
    return (cPtr_onceFunctionDeclarationForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_onceFunctionDeclarationForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_onceFunctionDeclarationForGeneration * ptr = dynamic_cast <const cPtr_onceFunctionDeclarationForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mFunctionName.operator_isEqual (ptr->mFunctionName).boolValue ()
         && mReturnType.operator_isEqual (ptr->mReturnType).boolValue ()
         && mResultVariableCppName.operator_isEqual (ptr->mResultVariableCppName).boolValue ()
         && mFunctionInstructionList.operator_isEqual (ptr->mFunctionInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_onceFunctionDeclarationForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@onceFunctionDeclarationForGeneration:"
           << mFunctionName.reader_description (inIndentation + 1)
           << mReturnType.reader_description (inIndentation + 1)
           << mResultVariableCppName.reader_description (inIndentation + 1)
           << mFunctionInstructionList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_onceFunctionDeclarationForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_onceFunctionDeclarationForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_onceFunctionDeclarationForGeneration (& typeid (cPtr_onceFunctionDeclarationForGeneration), & typeid (cPtr_semanticDeclarationForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_onceFunctionDeclarationForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__onceFunctionDeclarationForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_onceFunctionDeclarationForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_onceFunctionDeclarationForGeneration (mFunctionName, mReturnType, mResultVariableCppName, mFunctionInstructionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         GALGAS class 'GGS_onceFunctionDeclarationForGeneration'           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_onceFunctionDeclarationForGeneration ("onceFunctionDeclarationForGeneration", true, & kTypeDescriptor_GGS_semanticDeclarationForGeneration) ;

//---------------------------------------------------------------------------*

GGS_onceFunctionDeclarationForGeneration::
GGS_onceFunctionDeclarationForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_onceFunctionDeclarationForGeneration::
GGS_onceFunctionDeclarationForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_onceFunctionDeclarationForGeneration GGS_onceFunctionDeclarationForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_onceFunctionDeclarationForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_onceFunctionDeclarationForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_onceFunctionDeclarationForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_onceFunctionDeclarationForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_onceFunctionDeclarationForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_onceFunctionDeclarationForGeneration GGS_onceFunctionDeclarationForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0,
                 const GGS_unifiedTypeMapProxy & argument_1,
                 const GGS_string& argument_2,
                 const GGS_semanticInstructionListForGeneration & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_onceFunctionDeclarationForGeneration result ;
  macroMyNew (result.mPointer, cPtr_onceFunctionDeclarationForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_onceFunctionDeclarationForGeneration::
reader_mFunctionName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_onceFunctionDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_onceFunctionDeclarationForGeneration *) mPointer)->mFunctionName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapProxy  GGS_onceFunctionDeclarationForGeneration::
reader_mReturnType (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_unifiedTypeMapProxy   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_onceFunctionDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_onceFunctionDeclarationForGeneration *) mPointer)->mReturnType ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_onceFunctionDeclarationForGeneration::
reader_mResultVariableCppName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_onceFunctionDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_onceFunctionDeclarationForGeneration *) mPointer)->mResultVariableCppName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration  GGS_onceFunctionDeclarationForGeneration::
reader_mFunctionInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_onceFunctionDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_onceFunctionDeclarationForGeneration *) mPointer)->mFunctionInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_onceFunctionDeclarationForGeneration::actualTypeName (void) const {
  return "onceFunctionDeclarationForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__onceFunctionDeclarationForGeneration ("onceFunctionDeclarationForGeneration", gClassInfoFor__semanticDeclarationForGeneration, & kTypeDescriptor_GGS_onceFunctionDeclarationForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_onceFunctionDeclarationForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_onceFunctionDeclarationForGeneration * p = NULL ;
    macroMyNew (p, GGS_onceFunctionDeclarationForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_onceFunctionDeclarationForGeneration GGS_onceFunctionDeclarationForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_onceFunctionDeclarationForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_onceFunctionDeclarationForGeneration * p = dynamic_cast <const GGS_onceFunctionDeclarationForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_onceFunctionDeclarationForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_onceFunctionDeclarationForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_onceFunctionDeclarationForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            class 'cPtr_localVariableDeclarationForGeneration'             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_localVariableDeclarationForGeneration::
cPtr_localVariableDeclarationForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_string& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (THERE),
mVariableType (argument_0),
mCppVariableName (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_localVariableDeclarationForGeneration * GGS_localVariableDeclarationForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_localVariableDeclarationForGeneration) ;
    return (cPtr_localVariableDeclarationForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_localVariableDeclarationForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_localVariableDeclarationForGeneration * ptr = dynamic_cast <const cPtr_localVariableDeclarationForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mVariableType.operator_isEqual (ptr->mVariableType).boolValue ()
         && mCppVariableName.operator_isEqual (ptr->mCppVariableName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_localVariableDeclarationForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@localVariableDeclarationForGeneration:"
           << mVariableType.reader_description (inIndentation + 1)
           << mCppVariableName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_localVariableDeclarationForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_localVariableDeclarationForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_localVariableDeclarationForGeneration (& typeid (cPtr_localVariableDeclarationForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_localVariableDeclarationForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__localVariableDeclarationForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_localVariableDeclarationForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_localVariableDeclarationForGeneration (mVariableType, mCppVariableName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         GALGAS class 'GGS_localVariableDeclarationForGeneration'          *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_localVariableDeclarationForGeneration ("localVariableDeclarationForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_localVariableDeclarationForGeneration::
GGS_localVariableDeclarationForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_localVariableDeclarationForGeneration::
GGS_localVariableDeclarationForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_localVariableDeclarationForGeneration GGS_localVariableDeclarationForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_localVariableDeclarationForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_localVariableDeclarationForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_localVariableDeclarationForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_localVariableDeclarationForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_localVariableDeclarationForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_localVariableDeclarationForGeneration GGS_localVariableDeclarationForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_string& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_localVariableDeclarationForGeneration result ;
  macroMyNew (result.mPointer, cPtr_localVariableDeclarationForGeneration (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapProxy  GGS_localVariableDeclarationForGeneration::
reader_mVariableType (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_unifiedTypeMapProxy   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableDeclarationForGeneration *) mPointer)->mVariableType ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_localVariableDeclarationForGeneration::
reader_mCppVariableName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableDeclarationForGeneration *) mPointer)->mCppVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_localVariableDeclarationForGeneration::actualTypeName (void) const {
  return "localVariableDeclarationForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__localVariableDeclarationForGeneration ("localVariableDeclarationForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_localVariableDeclarationForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_localVariableDeclarationForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_localVariableDeclarationForGeneration * p = NULL ;
    macroMyNew (p, GGS_localVariableDeclarationForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_localVariableDeclarationForGeneration GGS_localVariableDeclarationForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_localVariableDeclarationForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_localVariableDeclarationForGeneration * p = dynamic_cast <const GGS_localVariableDeclarationForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_localVariableDeclarationForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_localVariableDeclarationForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_localVariableDeclarationForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//class 'cPtr_localVariableOrConstantDeclarationWithSourceExpressionForGeneration'*
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_localVariableOrConstantDeclarationWithSourceExpressionForGeneration::
cPtr_localVariableOrConstantDeclarationWithSourceExpressionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_bool& argument_1,
                                const GGS_string& argument_2,
                                const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (THERE),
mTargetType (argument_0),
mIsConstant (argument_1),
mCppVariableName (argument_2),
mSourceExpression (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_localVariableOrConstantDeclarationWithSourceExpressionForGeneration * GGS_localVariableOrConstantDeclarationWithSourceExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_localVariableOrConstantDeclarationWithSourceExpressionForGeneration) ;
    return (cPtr_localVariableOrConstantDeclarationWithSourceExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_localVariableOrConstantDeclarationWithSourceExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_localVariableOrConstantDeclarationWithSourceExpressionForGeneration * ptr = dynamic_cast <const cPtr_localVariableOrConstantDeclarationWithSourceExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTargetType.operator_isEqual (ptr->mTargetType).boolValue ()
         && mIsConstant.operator_isEqual (ptr->mIsConstant).boolValue ()
         && mCppVariableName.operator_isEqual (ptr->mCppVariableName).boolValue ()
         && mSourceExpression.operator_isEqual (ptr->mSourceExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_localVariableOrConstantDeclarationWithSourceExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@localVariableOrConstantDeclarationWithSourceExpressionForGeneration:"
           << mTargetType.reader_description (inIndentation + 1)
           << mIsConstant.reader_description (inIndentation + 1)
           << mCppVariableName.reader_description (inIndentation + 1)
           << mSourceExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_localVariableOrConstantDeclarationWithSourceExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_localVariableOrConstantDeclarationWithSourceExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_localVariableOrConstantDeclarationWithSourceExpressionForGeneration (& typeid (cPtr_localVariableOrConstantDeclarationWithSourceExpressionForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_localVariableOrConstantDeclarationWithSourceExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__localVariableOrConstantDeclarationWithSourceExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_localVariableOrConstantDeclarationWithSourceExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_localVariableOrConstantDeclarationWithSourceExpressionForGeneration (mTargetType, mIsConstant, mCppVariableName, mSourceExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//GALGAS class 'GGS_localVariableOrConstantDeclarationWithSourceExpressionForGeneration'*
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_localVariableOrConstantDeclarationWithSourceExpressionForGeneration ("localVariableOrConstantDeclarationWithSourceExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_localVariableOrConstantDeclarationWithSourceExpressionForGeneration::
GGS_localVariableOrConstantDeclarationWithSourceExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_localVariableOrConstantDeclarationWithSourceExpressionForGeneration::
GGS_localVariableOrConstantDeclarationWithSourceExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_localVariableOrConstantDeclarationWithSourceExpressionForGeneration GGS_localVariableOrConstantDeclarationWithSourceExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_localVariableOrConstantDeclarationWithSourceExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_localVariableOrConstantDeclarationWithSourceExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_localVariableOrConstantDeclarationWithSourceExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_localVariableOrConstantDeclarationWithSourceExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_localVariableOrConstantDeclarationWithSourceExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_localVariableOrConstantDeclarationWithSourceExpressionForGeneration GGS_localVariableOrConstantDeclarationWithSourceExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_bool& argument_1,
                 const GGS_string& argument_2,
                 const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_localVariableOrConstantDeclarationWithSourceExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_localVariableOrConstantDeclarationWithSourceExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapProxy  GGS_localVariableOrConstantDeclarationWithSourceExpressionForGeneration::
reader_mTargetType (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_unifiedTypeMapProxy   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableOrConstantDeclarationWithSourceExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableOrConstantDeclarationWithSourceExpressionForGeneration *) mPointer)->mTargetType ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_localVariableOrConstantDeclarationWithSourceExpressionForGeneration::
reader_mIsConstant (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableOrConstantDeclarationWithSourceExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableOrConstantDeclarationWithSourceExpressionForGeneration *) mPointer)->mIsConstant ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_localVariableOrConstantDeclarationWithSourceExpressionForGeneration::
reader_mCppVariableName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableOrConstantDeclarationWithSourceExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableOrConstantDeclarationWithSourceExpressionForGeneration *) mPointer)->mCppVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_localVariableOrConstantDeclarationWithSourceExpressionForGeneration::
reader_mSourceExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableOrConstantDeclarationWithSourceExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableOrConstantDeclarationWithSourceExpressionForGeneration *) mPointer)->mSourceExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_localVariableOrConstantDeclarationWithSourceExpressionForGeneration::actualTypeName (void) const {
  return "localVariableOrConstantDeclarationWithSourceExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__localVariableOrConstantDeclarationWithSourceExpressionForGeneration ("localVariableOrConstantDeclarationWithSourceExpressionForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_localVariableOrConstantDeclarationWithSourceExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_localVariableOrConstantDeclarationWithSourceExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_localVariableOrConstantDeclarationWithSourceExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_localVariableOrConstantDeclarationWithSourceExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_localVariableOrConstantDeclarationWithSourceExpressionForGeneration GGS_localVariableOrConstantDeclarationWithSourceExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_localVariableOrConstantDeclarationWithSourceExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_localVariableOrConstantDeclarationWithSourceExpressionForGeneration * p = dynamic_cast <const GGS_localVariableOrConstantDeclarationWithSourceExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_localVariableOrConstantDeclarationWithSourceExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_localVariableOrConstantDeclarationWithSourceExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_localVariableOrConstantDeclarationWithSourceExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//class 'cPtr_localVariableOrConstantDeclarationWithConstructorCallForGeneration'*
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_localVariableOrConstantDeclarationWithConstructorCallForGeneration::
cPtr_localVariableOrConstantDeclarationWithConstructorCallForGeneration (const GGS_location & argument_0,
                                const GGS_unifiedTypeMapProxy & argument_1,
                                const GGS_bool& argument_2,
                                const GGS_string& argument_3,
                                const GGS_string& argument_4,
                                const GGS_semanticExpressionListForGeneration & argument_5,
                                const GGS_bool& argument_6
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (THERE),
mInstructionLocation (argument_0),
mTargetType (argument_1),
mIsConstant (argument_2),
mTargetVariableCppName (argument_3),
mConstructorName (argument_4),
mConstructorArguments (argument_5),
mHasCompilerArgument (argument_6) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_localVariableOrConstantDeclarationWithConstructorCallForGeneration * GGS_localVariableOrConstantDeclarationWithConstructorCallForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_localVariableOrConstantDeclarationWithConstructorCallForGeneration) ;
    return (cPtr_localVariableOrConstantDeclarationWithConstructorCallForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_localVariableOrConstantDeclarationWithConstructorCallForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_localVariableOrConstantDeclarationWithConstructorCallForGeneration * ptr = dynamic_cast <const cPtr_localVariableOrConstantDeclarationWithConstructorCallForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mTargetType.operator_isEqual (ptr->mTargetType).boolValue ()
         && mIsConstant.operator_isEqual (ptr->mIsConstant).boolValue ()
         && mTargetVariableCppName.operator_isEqual (ptr->mTargetVariableCppName).boolValue ()
         && mConstructorName.operator_isEqual (ptr->mConstructorName).boolValue ()
         && mConstructorArguments.operator_isEqual (ptr->mConstructorArguments).boolValue ()
         && mHasCompilerArgument.operator_isEqual (ptr->mHasCompilerArgument).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_localVariableOrConstantDeclarationWithConstructorCallForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@localVariableOrConstantDeclarationWithConstructorCallForGeneration:"
           << mInstructionLocation.reader_description (inIndentation + 1)
           << mTargetType.reader_description (inIndentation + 1)
           << mIsConstant.reader_description (inIndentation + 1)
           << mTargetVariableCppName.reader_description (inIndentation + 1)
           << mConstructorName.reader_description (inIndentation + 1)
           << mConstructorArguments.reader_description (inIndentation + 1)
           << mHasCompilerArgument.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_localVariableOrConstantDeclarationWithConstructorCallForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_localVariableOrConstantDeclarationWithConstructorCallForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_localVariableOrConstantDeclarationWithConstructorCallForGeneration (& typeid (cPtr_localVariableOrConstantDeclarationWithConstructorCallForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_localVariableOrConstantDeclarationWithConstructorCallForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__localVariableOrConstantDeclarationWithConstructorCallForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_localVariableOrConstantDeclarationWithConstructorCallForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_localVariableOrConstantDeclarationWithConstructorCallForGeneration (mInstructionLocation, mTargetType, mIsConstant, mTargetVariableCppName, mConstructorName, mConstructorArguments, mHasCompilerArgument COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//GALGAS class 'GGS_localVariableOrConstantDeclarationWithConstructorCallForGeneration'*
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_localVariableOrConstantDeclarationWithConstructorCallForGeneration ("localVariableOrConstantDeclarationWithConstructorCallForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_localVariableOrConstantDeclarationWithConstructorCallForGeneration::
GGS_localVariableOrConstantDeclarationWithConstructorCallForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_localVariableOrConstantDeclarationWithConstructorCallForGeneration::
GGS_localVariableOrConstantDeclarationWithConstructorCallForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_localVariableOrConstantDeclarationWithConstructorCallForGeneration GGS_localVariableOrConstantDeclarationWithConstructorCallForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_localVariableOrConstantDeclarationWithConstructorCallForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_localVariableOrConstantDeclarationWithConstructorCallForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_localVariableOrConstantDeclarationWithConstructorCallForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_localVariableOrConstantDeclarationWithConstructorCallForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_localVariableOrConstantDeclarationWithConstructorCallForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_localVariableOrConstantDeclarationWithConstructorCallForGeneration GGS_localVariableOrConstantDeclarationWithConstructorCallForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_unifiedTypeMapProxy & argument_1,
                 const GGS_bool& argument_2,
                 const GGS_string& argument_3,
                 const GGS_string& argument_4,
                 const GGS_semanticExpressionListForGeneration & argument_5,
                 const GGS_bool& argument_6
                                COMMA_LOCATION_ARGS) {
  GGS_localVariableOrConstantDeclarationWithConstructorCallForGeneration result ;
  macroMyNew (result.mPointer, cPtr_localVariableOrConstantDeclarationWithConstructorCallForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_localVariableOrConstantDeclarationWithConstructorCallForGeneration::
reader_mInstructionLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableOrConstantDeclarationWithConstructorCallForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableOrConstantDeclarationWithConstructorCallForGeneration *) mPointer)->mInstructionLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapProxy  GGS_localVariableOrConstantDeclarationWithConstructorCallForGeneration::
reader_mTargetType (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_unifiedTypeMapProxy   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableOrConstantDeclarationWithConstructorCallForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableOrConstantDeclarationWithConstructorCallForGeneration *) mPointer)->mTargetType ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_localVariableOrConstantDeclarationWithConstructorCallForGeneration::
reader_mIsConstant (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableOrConstantDeclarationWithConstructorCallForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableOrConstantDeclarationWithConstructorCallForGeneration *) mPointer)->mIsConstant ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_localVariableOrConstantDeclarationWithConstructorCallForGeneration::
reader_mTargetVariableCppName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableOrConstantDeclarationWithConstructorCallForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableOrConstantDeclarationWithConstructorCallForGeneration *) mPointer)->mTargetVariableCppName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_localVariableOrConstantDeclarationWithConstructorCallForGeneration::
reader_mConstructorName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableOrConstantDeclarationWithConstructorCallForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableOrConstantDeclarationWithConstructorCallForGeneration *) mPointer)->mConstructorName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionListForGeneration  GGS_localVariableOrConstantDeclarationWithConstructorCallForGeneration::
reader_mConstructorArguments (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableOrConstantDeclarationWithConstructorCallForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableOrConstantDeclarationWithConstructorCallForGeneration *) mPointer)->mConstructorArguments ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_localVariableOrConstantDeclarationWithConstructorCallForGeneration::
reader_mHasCompilerArgument (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableOrConstantDeclarationWithConstructorCallForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableOrConstantDeclarationWithConstructorCallForGeneration *) mPointer)->mHasCompilerArgument ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_localVariableOrConstantDeclarationWithConstructorCallForGeneration::actualTypeName (void) const {
  return "localVariableOrConstantDeclarationWithConstructorCallForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__localVariableOrConstantDeclarationWithConstructorCallForGeneration ("localVariableOrConstantDeclarationWithConstructorCallForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_localVariableOrConstantDeclarationWithConstructorCallForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_localVariableOrConstantDeclarationWithConstructorCallForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_localVariableOrConstantDeclarationWithConstructorCallForGeneration * p = NULL ;
    macroMyNew (p, GGS_localVariableOrConstantDeclarationWithConstructorCallForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_localVariableOrConstantDeclarationWithConstructorCallForGeneration GGS_localVariableOrConstantDeclarationWithConstructorCallForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_localVariableOrConstantDeclarationWithConstructorCallForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_localVariableOrConstantDeclarationWithConstructorCallForGeneration * p = dynamic_cast <const GGS_localVariableOrConstantDeclarationWithConstructorCallForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_localVariableOrConstantDeclarationWithConstructorCallForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_localVariableOrConstantDeclarationWithConstructorCallForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_localVariableOrConstantDeclarationWithConstructorCallForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_assignmentInstructionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_assignmentInstructionForGeneration::
cPtr_assignmentInstructionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_string& argument_1,
                                const GGS_lstringlist & argument_2,
                                const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (THERE),
mTargetType (argument_0),
mTargetCppName (argument_1),
mStructAttributeList (argument_2),
mSourceExpression (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_assignmentInstructionForGeneration * GGS_assignmentInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_assignmentInstructionForGeneration) ;
    return (cPtr_assignmentInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_assignmentInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_assignmentInstructionForGeneration * ptr = dynamic_cast <const cPtr_assignmentInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTargetType.operator_isEqual (ptr->mTargetType).boolValue ()
         && mTargetCppName.operator_isEqual (ptr->mTargetCppName).boolValue ()
         && mStructAttributeList.operator_isEqual (ptr->mStructAttributeList).boolValue ()
         && mSourceExpression.operator_isEqual (ptr->mSourceExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_assignmentInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@assignmentInstructionForGeneration:"
           << mTargetType.reader_description (inIndentation + 1)
           << mTargetCppName.reader_description (inIndentation + 1)
           << mStructAttributeList.reader_description (inIndentation + 1)
           << mSourceExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_assignmentInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_assignmentInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_assignmentInstructionForGeneration (& typeid (cPtr_assignmentInstructionForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_assignmentInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__assignmentInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_assignmentInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_assignmentInstructionForGeneration (mTargetType, mTargetCppName, mStructAttributeList, mSourceExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_assignmentInstructionForGeneration'            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_assignmentInstructionForGeneration ("assignmentInstructionForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_assignmentInstructionForGeneration::
GGS_assignmentInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_assignmentInstructionForGeneration::
GGS_assignmentInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_assignmentInstructionForGeneration GGS_assignmentInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_assignmentInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_assignmentInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_assignmentInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_assignmentInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_assignmentInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_assignmentInstructionForGeneration GGS_assignmentInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_string& argument_1,
                 const GGS_lstringlist & argument_2,
                 const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_assignmentInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_assignmentInstructionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapProxy  GGS_assignmentInstructionForGeneration::
reader_mTargetType (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_unifiedTypeMapProxy   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_assignmentInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_assignmentInstructionForGeneration *) mPointer)->mTargetType ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_assignmentInstructionForGeneration::
reader_mTargetCppName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_assignmentInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_assignmentInstructionForGeneration *) mPointer)->mTargetCppName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_assignmentInstructionForGeneration::
reader_mStructAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_assignmentInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_assignmentInstructionForGeneration *) mPointer)->mStructAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_assignmentInstructionForGeneration::
reader_mSourceExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_assignmentInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_assignmentInstructionForGeneration *) mPointer)->mSourceExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_assignmentInstructionForGeneration::actualTypeName (void) const {
  return "assignmentInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__assignmentInstructionForGeneration ("assignmentInstructionForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_assignmentInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_assignmentInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_assignmentInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_assignmentInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_assignmentInstructionForGeneration GGS_assignmentInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_assignmentInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_assignmentInstructionForGeneration * p = dynamic_cast <const GGS_assignmentInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_assignmentInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_assignmentInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_assignmentInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_dropInstructionForGeneration'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_dropInstructionForGeneration::
cPtr_dropInstructionForGeneration (const GGS_stringlist & argument_0,
                                const GGS_string& argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (THERE),
mDropList (argument_0),
mComment (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_dropInstructionForGeneration * GGS_dropInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_dropInstructionForGeneration) ;
    return (cPtr_dropInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_dropInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_dropInstructionForGeneration * ptr = dynamic_cast <const cPtr_dropInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mDropList.operator_isEqual (ptr->mDropList).boolValue ()
         && mComment.operator_isEqual (ptr->mComment).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_dropInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@dropInstructionForGeneration:"
           << mDropList.reader_description (inIndentation + 1)
           << mComment.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_dropInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_dropInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_dropInstructionForGeneration (& typeid (cPtr_dropInstructionForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_dropInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__dropInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_dropInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_dropInstructionForGeneration (mDropList, mComment COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_dropInstructionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_dropInstructionForGeneration ("dropInstructionForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_dropInstructionForGeneration::
GGS_dropInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_dropInstructionForGeneration::
GGS_dropInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_dropInstructionForGeneration GGS_dropInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_dropInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_dropInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_dropInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_dropInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_dropInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_dropInstructionForGeneration GGS_dropInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_stringlist & argument_0,
                 const GGS_string& argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_dropInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_dropInstructionForGeneration (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringlist  GGS_dropInstructionForGeneration::
reader_mDropList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_stringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_dropInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_dropInstructionForGeneration *) mPointer)->mDropList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_dropInstructionForGeneration::
reader_mComment (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_dropInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_dropInstructionForGeneration *) mPointer)->mComment ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_dropInstructionForGeneration::actualTypeName (void) const {
  return "dropInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__dropInstructionForGeneration ("dropInstructionForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_dropInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_dropInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_dropInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_dropInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_dropInstructionForGeneration GGS_dropInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_dropInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_dropInstructionForGeneration * p = dynamic_cast <const GGS_dropInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_dropInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_dropInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_dropInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_appendInstructionForGeneration'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_appendInstructionForGeneration::
cPtr_appendInstructionForGeneration (const GGS_location & argument_0,
                                const GGS_unifiedTypeMapProxy & argument_1,
                                const GGS_string& argument_2,
                                const GGS_lstringlist & argument_3,
                                const GGS_semanticExpressionForGeneration & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (THERE),
mInstructionLocation (argument_0),
mTargetType (argument_1),
mTargetVariableCppName (argument_2),
mStructAttributeList (argument_3),
mSourceExpression (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_appendInstructionForGeneration * GGS_appendInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_appendInstructionForGeneration) ;
    return (cPtr_appendInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_appendInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_appendInstructionForGeneration * ptr = dynamic_cast <const cPtr_appendInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mTargetType.operator_isEqual (ptr->mTargetType).boolValue ()
         && mTargetVariableCppName.operator_isEqual (ptr->mTargetVariableCppName).boolValue ()
         && mStructAttributeList.operator_isEqual (ptr->mStructAttributeList).boolValue ()
         && mSourceExpression.operator_isEqual (ptr->mSourceExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_appendInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@appendInstructionForGeneration:"
           << mInstructionLocation.reader_description (inIndentation + 1)
           << mTargetType.reader_description (inIndentation + 1)
           << mTargetVariableCppName.reader_description (inIndentation + 1)
           << mStructAttributeList.reader_description (inIndentation + 1)
           << mSourceExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_appendInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_appendInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_appendInstructionForGeneration (& typeid (cPtr_appendInstructionForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_appendInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__appendInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_appendInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_appendInstructionForGeneration (mInstructionLocation, mTargetType, mTargetVariableCppName, mStructAttributeList, mSourceExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_appendInstructionForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_appendInstructionForGeneration ("appendInstructionForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_appendInstructionForGeneration::
GGS_appendInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_appendInstructionForGeneration::
GGS_appendInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_appendInstructionForGeneration GGS_appendInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_appendInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_appendInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_appendInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_appendInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_appendInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_appendInstructionForGeneration GGS_appendInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_unifiedTypeMapProxy & argument_1,
                 const GGS_string& argument_2,
                 const GGS_lstringlist & argument_3,
                 const GGS_semanticExpressionForGeneration & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_appendInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_appendInstructionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_appendInstructionForGeneration::
reader_mInstructionLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_appendInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_appendInstructionForGeneration *) mPointer)->mInstructionLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapProxy  GGS_appendInstructionForGeneration::
reader_mTargetType (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_unifiedTypeMapProxy   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_appendInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_appendInstructionForGeneration *) mPointer)->mTargetType ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_appendInstructionForGeneration::
reader_mTargetVariableCppName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_appendInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_appendInstructionForGeneration *) mPointer)->mTargetVariableCppName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_appendInstructionForGeneration::
reader_mStructAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_appendInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_appendInstructionForGeneration *) mPointer)->mStructAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_appendInstructionForGeneration::
reader_mSourceExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_appendInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_appendInstructionForGeneration *) mPointer)->mSourceExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_appendInstructionForGeneration::actualTypeName (void) const {
  return "appendInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__appendInstructionForGeneration ("appendInstructionForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_appendInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_appendInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_appendInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_appendInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_appendInstructionForGeneration GGS_appendInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_appendInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_appendInstructionForGeneration * p = dynamic_cast <const GGS_appendInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_appendInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_appendInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_appendInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_sendInstructionForGeneration'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_sendInstructionForGeneration::
cPtr_sendInstructionForGeneration (const GGS_semanticExpressionForGeneration & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (THERE),
mSourceExpression (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_sendInstructionForGeneration * GGS_sendInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_sendInstructionForGeneration) ;
    return (cPtr_sendInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_sendInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_sendInstructionForGeneration * ptr = dynamic_cast <const cPtr_sendInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mSourceExpression.operator_isEqual (ptr->mSourceExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_sendInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@sendInstructionForGeneration:"
           << mSourceExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_sendInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_sendInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_sendInstructionForGeneration (& typeid (cPtr_sendInstructionForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_sendInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__sendInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_sendInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_sendInstructionForGeneration (mSourceExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_sendInstructionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_sendInstructionForGeneration ("sendInstructionForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_sendInstructionForGeneration::
GGS_sendInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_sendInstructionForGeneration::
GGS_sendInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_sendInstructionForGeneration GGS_sendInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_sendInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_sendInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_sendInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_sendInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_sendInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sendInstructionForGeneration GGS_sendInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_semanticExpressionForGeneration & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_sendInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_sendInstructionForGeneration (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_sendInstructionForGeneration::
reader_mSourceExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sendInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sendInstructionForGeneration *) mPointer)->mSourceExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_sendInstructionForGeneration::actualTypeName (void) const {
  return "sendInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__sendInstructionForGeneration ("sendInstructionForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_sendInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_sendInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_sendInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_sendInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sendInstructionForGeneration GGS_sendInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_sendInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_sendInstructionForGeneration * p = dynamic_cast <const GGS_sendInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_sendInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_sendInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_sendInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//  Element of list '@foreachInstructionEnumeratedObjectListForGeneration'   *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_foreachInstructionEnumeratedObjectListForGeneration::
elementOf_GGS_foreachInstructionEnumeratedObjectListForGeneration (const GGS_bool& argument_0,
                                const GGS_semanticExpressionForGeneration & argument_1,
                                const GGS_string& argument_2
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mIsAscending (argument_0),
mEnumeratedExpression (argument_1),
mEnumeratorCppName (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_foreachInstructionEnumeratedObjectListForGeneration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_foreachInstructionEnumeratedObjectListForGeneration * ptr = dynamic_cast <const elementOf_GGS_foreachInstructionEnumeratedObjectListForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mIsAscending.operator_isEqual (ptr->mIsAscending).boolValue ()
         && mEnumeratedExpression.operator_isEqual (ptr->mEnumeratedExpression).boolValue ()
         && mEnumeratorCppName.operator_isEqual (ptr->mEnumeratorCppName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_foreachInstructionEnumeratedObjectListForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mIsAscending.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEnumeratedExpression.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEnumeratorCppName.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//       List '@foreachInstructionEnumeratedObjectListForGeneration'         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_foreachInstructionEnumeratedObjectListForGeneration ("foreachInstructionEnumeratedObjectListForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListForGeneration::
internalAppendValues (const GGS_bool& argument_0,
                    const GGS_semanticExpressionForGeneration & argument_1,
                    const GGS_string& argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListForGeneration::
internalPrependValues (const GGS_bool& argument_0,
                    const GGS_semanticExpressionForGeneration & argument_1,
                    const GGS_string& argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListForGeneration::
addAssign_operation (const GGS_bool& argument_0,
                                const GGS_semanticExpressionForGeneration & argument_1,
                                const GGS_string& argument_2) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectListForGeneration GGS_foreachInstructionEnumeratedObjectListForGeneration::
operator_concat (const GGS_foreachInstructionEnumeratedObjectListForGeneration & inOperand) const {
  GGS_foreachInstructionEnumeratedObjectListForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListForGeneration::
dotAssign_operation (const GGS_foreachInstructionEnumeratedObjectListForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_foreachInstructionEnumeratedObjectListForGeneration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_bool p_0 = p->mIsAscending ;
          GGS_semanticExpressionForGeneration  p_1 = p->mEnumeratedExpression ;
          GGS_string p_2 = p->mEnumeratorCppName ;
          internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListForGeneration::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_bool& argument_0,
                     const GGS_semanticExpressionForGeneration & argument_1,
                     const GGS_string& argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListForGeneration::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mIsAscending,
                                ptr->mEnumeratedExpression,
                                ptr->mEnumeratorCppName
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectListForGeneration  GGS_foreachInstructionEnumeratedObjectListForGeneration::
constructor_emptyList (void) {
  GGS_foreachInstructionEnumeratedObjectListForGeneration result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectListForGeneration  GGS_foreachInstructionEnumeratedObjectListForGeneration::
constructor_listWithValue (const GGS_bool& argument_0,
                                const GGS_semanticExpressionForGeneration & argument_1,
                                const GGS_string& argument_2) {
  GGS_foreachInstructionEnumeratedObjectListForGeneration result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListForGeneration::
internalSubListWithRange (GGS_foreachInstructionEnumeratedObjectListForGeneration & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mIsAscending, ptr->mEnumeratedExpression, ptr->mEnumeratorCppName) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectListForGeneration GGS_foreachInstructionEnumeratedObjectListForGeneration::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_foreachInstructionEnumeratedObjectListForGeneration result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectListForGeneration GGS_foreachInstructionEnumeratedObjectListForGeneration::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_foreachInstructionEnumeratedObjectListForGeneration result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_foreachInstructionEnumeratedObjectListForGeneration::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@foreachInstructionEnumeratedObjectListForGeneration", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListForGeneration::
method_first (C_Compiler & inLexique,
              GGS_bool& _out_0,
              GGS_semanticExpressionForGeneration & _out_1,
              GGS_string& _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mIsAscending ;
    _out_1 = ptr->mEnumeratedExpression ;
    _out_2 = ptr->mEnumeratorCppName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListForGeneration::
method_last (C_Compiler & inLexique,
             GGS_bool& _out_0,
             GGS_semanticExpressionForGeneration & _out_1,
             GGS_string& _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mIsAscending ;
    _out_1 = ptr->mEnumeratedExpression ;
    _out_2 = ptr->mEnumeratorCppName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListForGeneration::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_bool& _out_0,
                 GGS_semanticExpressionForGeneration & _out_1,
                 GGS_string& _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mIsAscending ;
    _out_1 = ptr->mEnumeratedExpression ;
    _out_2 = ptr->mEnumeratorCppName ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListForGeneration::
modifier_popLast (C_Compiler & inLexique,
                GGS_bool& _out_0,
                GGS_semanticExpressionForGeneration & _out_1,
                GGS_string& _out_2
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mIsAscending ;
    _out_1 = ptr->mEnumeratedExpression ;
    _out_2 = ptr->mEnumeratorCppName ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_bool GGS_foreachInstructionEnumeratedObjectListForGeneration::
reader_mIsAscendingAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mIsAscending ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_foreachInstructionEnumeratedObjectListForGeneration::
reader_mEnumeratedExpressionAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mEnumeratedExpression ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_foreachInstructionEnumeratedObjectListForGeneration::
reader_mEnumeratorCppNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_string result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mEnumeratorCppName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListForGeneration::
modifier_setMIsAscendingAtIndex (C_Compiler & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mIsAscending = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListForGeneration::
modifier_setMEnumeratedExpressionAtIndex (C_Compiler & inLexique,
                              const GGS_semanticExpressionForGeneration  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mEnumeratedExpression = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListForGeneration::
modifier_setMEnumeratorCppNameAtIndex (C_Compiler & inLexique,
                              const GGS_string & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mEnumeratorCppName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_foreachInstructionEnumeratedObjectListForGeneration::cEnumerator::_mIsAscending (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mIsAscending ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticExpressionForGeneration  & GGS_foreachInstructionEnumeratedObjectListForGeneration::cEnumerator::_mEnumeratedExpression (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mEnumeratedExpression ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_foreachInstructionEnumeratedObjectListForGeneration::cEnumerator::_mEnumeratorCppName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mEnumeratorCppName ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_foreachInstructionEnumeratedObjectListForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_foreachInstructionEnumeratedObjectListForGeneration * p = NULL ;
    macroMyNew (p, GGS_foreachInstructionEnumeratedObjectListForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectListForGeneration GGS_foreachInstructionEnumeratedObjectListForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_foreachInstructionEnumeratedObjectListForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_foreachInstructionEnumeratedObjectListForGeneration * p = dynamic_cast <const GGS_foreachInstructionEnumeratedObjectListForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_foreachInstructionEnumeratedObjectListForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_foreachInstructionEnumeratedObjectListForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_foreachInstructionEnumeratedObjectListForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_foreachInstructionForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_foreachInstructionForGeneration::
cPtr_foreachInstructionForGeneration (const GGS_location & argument_0,
                                const GGS_foreachInstructionEnumeratedObjectListForGeneration & argument_1,
                                const GGS_string& argument_2,
                                const GGS_semanticExpressionForGeneration & argument_3,
                                const GGS_semanticInstructionListForGeneration & argument_4,
                                const GGS_semanticInstructionListForGeneration & argument_5,
                                const GGS_semanticInstructionListForGeneration & argument_6,
                                const GGS_semanticInstructionListForGeneration & argument_7
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (THERE),
mInstructionLocation (argument_0),
mEnumeratedObjectList (argument_1),
mIndexVariableCppName (argument_2),
mWhileExpression (argument_3),
mBeforeInstructionList (argument_4),
mBetweenInstructionList (argument_5),
mDoInstructionList (argument_6),
mAfterInstructionList (argument_7) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_foreachInstructionForGeneration * GGS_foreachInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_foreachInstructionForGeneration) ;
    return (cPtr_foreachInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_foreachInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_foreachInstructionForGeneration * ptr = dynamic_cast <const cPtr_foreachInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mEnumeratedObjectList.operator_isEqual (ptr->mEnumeratedObjectList).boolValue ()
         && mIndexVariableCppName.operator_isEqual (ptr->mIndexVariableCppName).boolValue ()
         && mWhileExpression.operator_isEqual (ptr->mWhileExpression).boolValue ()
         && mBeforeInstructionList.operator_isEqual (ptr->mBeforeInstructionList).boolValue ()
         && mBetweenInstructionList.operator_isEqual (ptr->mBetweenInstructionList).boolValue ()
         && mDoInstructionList.operator_isEqual (ptr->mDoInstructionList).boolValue ()
         && mAfterInstructionList.operator_isEqual (ptr->mAfterInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_foreachInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@foreachInstructionForGeneration:"
           << mInstructionLocation.reader_description (inIndentation + 1)
           << mEnumeratedObjectList.reader_description (inIndentation + 1)
           << mIndexVariableCppName.reader_description (inIndentation + 1)
           << mWhileExpression.reader_description (inIndentation + 1)
           << mBeforeInstructionList.reader_description (inIndentation + 1)
           << mBetweenInstructionList.reader_description (inIndentation + 1)
           << mDoInstructionList.reader_description (inIndentation + 1)
           << mAfterInstructionList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_foreachInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_foreachInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_foreachInstructionForGeneration (& typeid (cPtr_foreachInstructionForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_foreachInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__foreachInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_foreachInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_foreachInstructionForGeneration (mInstructionLocation, mEnumeratedObjectList, mIndexVariableCppName, mWhileExpression, mBeforeInstructionList, mBetweenInstructionList, mDoInstructionList, mAfterInstructionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_foreachInstructionForGeneration'             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_foreachInstructionForGeneration ("foreachInstructionForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_foreachInstructionForGeneration::
GGS_foreachInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionForGeneration::
GGS_foreachInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_foreachInstructionForGeneration GGS_foreachInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_foreachInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_foreachInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_foreachInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_foreachInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_foreachInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionForGeneration GGS_foreachInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_foreachInstructionEnumeratedObjectListForGeneration & argument_1,
                 const GGS_string& argument_2,
                 const GGS_semanticExpressionForGeneration & argument_3,
                 const GGS_semanticInstructionListForGeneration & argument_4,
                 const GGS_semanticInstructionListForGeneration & argument_5,
                 const GGS_semanticInstructionListForGeneration & argument_6,
                 const GGS_semanticInstructionListForGeneration & argument_7
                                COMMA_LOCATION_ARGS) {
  GGS_foreachInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_foreachInstructionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_foreachInstructionForGeneration::
reader_mInstructionLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstructionForGeneration *) mPointer)->mInstructionLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectListForGeneration  GGS_foreachInstructionForGeneration::
reader_mEnumeratedObjectList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_foreachInstructionEnumeratedObjectListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstructionForGeneration *) mPointer)->mEnumeratedObjectList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_foreachInstructionForGeneration::
reader_mIndexVariableCppName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstructionForGeneration *) mPointer)->mIndexVariableCppName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_foreachInstructionForGeneration::
reader_mWhileExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstructionForGeneration *) mPointer)->mWhileExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration  GGS_foreachInstructionForGeneration::
reader_mBeforeInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstructionForGeneration *) mPointer)->mBeforeInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration  GGS_foreachInstructionForGeneration::
reader_mBetweenInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstructionForGeneration *) mPointer)->mBetweenInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration  GGS_foreachInstructionForGeneration::
reader_mDoInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstructionForGeneration *) mPointer)->mDoInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration  GGS_foreachInstructionForGeneration::
reader_mAfterInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstructionForGeneration *) mPointer)->mAfterInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_foreachInstructionForGeneration::actualTypeName (void) const {
  return "foreachInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__foreachInstructionForGeneration ("foreachInstructionForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_foreachInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_foreachInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_foreachInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_foreachInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionForGeneration GGS_foreachInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_foreachInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_foreachInstructionForGeneration * p = dynamic_cast <const GGS_foreachInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_foreachInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_foreachInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_foreachInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_ifInstructionForGeneration'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ifInstructionForGeneration::
cPtr_ifInstructionForGeneration (const GGS_location & argument_0,
                                const GGS_semanticExpressionForGeneration & argument_1,
                                const GGS_semanticInstructionListForGeneration & argument_2,
                                const GGS_semanticInstructionListForGeneration & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (THERE),
mInstructionLocation (argument_0),
mIFexpression (argument_1),
m_then_instructionList (argument_2),
m_else_instructionList (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ifInstructionForGeneration * GGS_ifInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_ifInstructionForGeneration) ;
    return (cPtr_ifInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ifInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ifInstructionForGeneration * ptr = dynamic_cast <const cPtr_ifInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mIFexpression.operator_isEqual (ptr->mIFexpression).boolValue ()
         && m_then_instructionList.operator_isEqual (ptr->m_then_instructionList).boolValue ()
         && m_else_instructionList.operator_isEqual (ptr->m_else_instructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ifInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@ifInstructionForGeneration:"
           << mInstructionLocation.reader_description (inIndentation + 1)
           << mIFexpression.reader_description (inIndentation + 1)
           << m_then_instructionList.reader_description (inIndentation + 1)
           << m_else_instructionList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ifInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ifInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ifInstructionForGeneration (& typeid (cPtr_ifInstructionForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_ifInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__ifInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_ifInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_ifInstructionForGeneration (mInstructionLocation, mIFexpression, m_then_instructionList, m_else_instructionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_ifInstructionForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_ifInstructionForGeneration ("ifInstructionForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_ifInstructionForGeneration::
GGS_ifInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ifInstructionForGeneration::
GGS_ifInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_ifInstructionForGeneration GGS_ifInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ifInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ifInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_ifInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_ifInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ifInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ifInstructionForGeneration GGS_ifInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionForGeneration & argument_1,
                 const GGS_semanticInstructionListForGeneration & argument_2,
                 const GGS_semanticInstructionListForGeneration & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_ifInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_ifInstructionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_ifInstructionForGeneration::
reader_mInstructionLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ifInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ifInstructionForGeneration *) mPointer)->mInstructionLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_ifInstructionForGeneration::
reader_mIFexpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ifInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ifInstructionForGeneration *) mPointer)->mIFexpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration  GGS_ifInstructionForGeneration::
reader_m_then_instructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ifInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ifInstructionForGeneration *) mPointer)->m_then_instructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration  GGS_ifInstructionForGeneration::
reader_m_else_instructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ifInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ifInstructionForGeneration *) mPointer)->m_else_instructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ifInstructionForGeneration::actualTypeName (void) const {
  return "ifInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__ifInstructionForGeneration ("ifInstructionForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_ifInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_ifInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_ifInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_ifInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ifInstructionForGeneration GGS_ifInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_ifInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_ifInstructionForGeneration * p = dynamic_cast <const GGS_ifInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_ifInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_ifInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_ifInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_errorInstructionForGeneration'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_errorInstructionForGeneration::
cPtr_errorInstructionForGeneration (const GGS_location & argument_0,
                                const GGS_semanticExpressionForGeneration & argument_1,
                                const GGS_bool& argument_2,
                                const GGS_semanticExpressionForGeneration & argument_3,
                                const GGS_stringlist & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (THERE),
mInstructionLocation (argument_0),
mReceiverExpression (argument_1),
mUseLocationReader (argument_2),
mErrorExpression (argument_3),
mBuiltVariableCppNameList (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_errorInstructionForGeneration * GGS_errorInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_errorInstructionForGeneration) ;
    return (cPtr_errorInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_errorInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_errorInstructionForGeneration * ptr = dynamic_cast <const cPtr_errorInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mReceiverExpression.operator_isEqual (ptr->mReceiverExpression).boolValue ()
         && mUseLocationReader.operator_isEqual (ptr->mUseLocationReader).boolValue ()
         && mErrorExpression.operator_isEqual (ptr->mErrorExpression).boolValue ()
         && mBuiltVariableCppNameList.operator_isEqual (ptr->mBuiltVariableCppNameList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_errorInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@errorInstructionForGeneration:"
           << mInstructionLocation.reader_description (inIndentation + 1)
           << mReceiverExpression.reader_description (inIndentation + 1)
           << mUseLocationReader.reader_description (inIndentation + 1)
           << mErrorExpression.reader_description (inIndentation + 1)
           << mBuiltVariableCppNameList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_errorInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_errorInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_errorInstructionForGeneration (& typeid (cPtr_errorInstructionForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_errorInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__errorInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_errorInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_errorInstructionForGeneration (mInstructionLocation, mReceiverExpression, mUseLocationReader, mErrorExpression, mBuiltVariableCppNameList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_errorInstructionForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_errorInstructionForGeneration ("errorInstructionForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_errorInstructionForGeneration::
GGS_errorInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_errorInstructionForGeneration::
GGS_errorInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_errorInstructionForGeneration GGS_errorInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_errorInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_errorInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_errorInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_errorInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_errorInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_errorInstructionForGeneration GGS_errorInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionForGeneration & argument_1,
                 const GGS_bool& argument_2,
                 const GGS_semanticExpressionForGeneration & argument_3,
                 const GGS_stringlist & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_errorInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_errorInstructionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_errorInstructionForGeneration::
reader_mInstructionLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_errorInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_errorInstructionForGeneration *) mPointer)->mInstructionLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_errorInstructionForGeneration::
reader_mReceiverExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_errorInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_errorInstructionForGeneration *) mPointer)->mReceiverExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_errorInstructionForGeneration::
reader_mUseLocationReader (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_errorInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_errorInstructionForGeneration *) mPointer)->mUseLocationReader ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_errorInstructionForGeneration::
reader_mErrorExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_errorInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_errorInstructionForGeneration *) mPointer)->mErrorExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringlist  GGS_errorInstructionForGeneration::
reader_mBuiltVariableCppNameList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_stringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_errorInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_errorInstructionForGeneration *) mPointer)->mBuiltVariableCppNameList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_errorInstructionForGeneration::actualTypeName (void) const {
  return "errorInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__errorInstructionForGeneration ("errorInstructionForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_errorInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_errorInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_errorInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_errorInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_errorInstructionForGeneration GGS_errorInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_errorInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_errorInstructionForGeneration * p = dynamic_cast <const GGS_errorInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_errorInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_errorInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_errorInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_warningInstructionForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_warningInstructionForGeneration::
cPtr_warningInstructionForGeneration (const GGS_location & argument_0,
                                const GGS_semanticExpressionForGeneration & argument_1,
                                const GGS_bool& argument_2,
                                const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (THERE),
mInstructionLocation (argument_0),
mReceiverExpression (argument_1),
mUseLocationReader (argument_2),
mWarningExpression (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_warningInstructionForGeneration * GGS_warningInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_warningInstructionForGeneration) ;
    return (cPtr_warningInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_warningInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_warningInstructionForGeneration * ptr = dynamic_cast <const cPtr_warningInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mReceiverExpression.operator_isEqual (ptr->mReceiverExpression).boolValue ()
         && mUseLocationReader.operator_isEqual (ptr->mUseLocationReader).boolValue ()
         && mWarningExpression.operator_isEqual (ptr->mWarningExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_warningInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@warningInstructionForGeneration:"
           << mInstructionLocation.reader_description (inIndentation + 1)
           << mReceiverExpression.reader_description (inIndentation + 1)
           << mUseLocationReader.reader_description (inIndentation + 1)
           << mWarningExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_warningInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_warningInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_warningInstructionForGeneration (& typeid (cPtr_warningInstructionForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_warningInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__warningInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_warningInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_warningInstructionForGeneration (mInstructionLocation, mReceiverExpression, mUseLocationReader, mWarningExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_warningInstructionForGeneration'             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_warningInstructionForGeneration ("warningInstructionForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_warningInstructionForGeneration::
GGS_warningInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_warningInstructionForGeneration::
GGS_warningInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_warningInstructionForGeneration GGS_warningInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_warningInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_warningInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_warningInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_warningInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_warningInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_warningInstructionForGeneration GGS_warningInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionForGeneration & argument_1,
                 const GGS_bool& argument_2,
                 const GGS_semanticExpressionForGeneration & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_warningInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_warningInstructionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_warningInstructionForGeneration::
reader_mInstructionLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_warningInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_warningInstructionForGeneration *) mPointer)->mInstructionLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_warningInstructionForGeneration::
reader_mReceiverExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_warningInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_warningInstructionForGeneration *) mPointer)->mReceiverExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_warningInstructionForGeneration::
reader_mUseLocationReader (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_warningInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_warningInstructionForGeneration *) mPointer)->mUseLocationReader ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_warningInstructionForGeneration::
reader_mWarningExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_warningInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_warningInstructionForGeneration *) mPointer)->mWarningExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_warningInstructionForGeneration::actualTypeName (void) const {
  return "warningInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__warningInstructionForGeneration ("warningInstructionForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_warningInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_warningInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_warningInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_warningInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_warningInstructionForGeneration GGS_warningInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_warningInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_warningInstructionForGeneration * p = dynamic_cast <const GGS_warningInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_warningInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_warningInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_warningInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_routineCallInstructionForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_routineCallInstructionForGeneration::
cPtr_routineCallInstructionForGeneration (const GGS_lstring & argument_0,
                                const GGS_actualParameterListForGeneration & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (THERE),
mRoutineName (argument_0),
mActualParameterList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_routineCallInstructionForGeneration * GGS_routineCallInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_routineCallInstructionForGeneration) ;
    return (cPtr_routineCallInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_routineCallInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_routineCallInstructionForGeneration * ptr = dynamic_cast <const cPtr_routineCallInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mRoutineName.operator_isEqual (ptr->mRoutineName).boolValue ()
         && mActualParameterList.operator_isEqual (ptr->mActualParameterList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_routineCallInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@routineCallInstructionForGeneration:"
           << mRoutineName.reader_description (inIndentation + 1)
           << mActualParameterList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_routineCallInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_routineCallInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_routineCallInstructionForGeneration (& typeid (cPtr_routineCallInstructionForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_routineCallInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__routineCallInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_routineCallInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_routineCallInstructionForGeneration (mRoutineName, mActualParameterList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_routineCallInstructionForGeneration'           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_routineCallInstructionForGeneration ("routineCallInstructionForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_routineCallInstructionForGeneration::
GGS_routineCallInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_routineCallInstructionForGeneration::
GGS_routineCallInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_routineCallInstructionForGeneration GGS_routineCallInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_routineCallInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_routineCallInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_routineCallInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_routineCallInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_routineCallInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_routineCallInstructionForGeneration GGS_routineCallInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_actualParameterListForGeneration & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_routineCallInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_routineCallInstructionForGeneration (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_routineCallInstructionForGeneration::
reader_mRoutineName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_routineCallInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_routineCallInstructionForGeneration *) mPointer)->mRoutineName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameterListForGeneration  GGS_routineCallInstructionForGeneration::
reader_mActualParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_actualParameterListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_routineCallInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_routineCallInstructionForGeneration *) mPointer)->mActualParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_routineCallInstructionForGeneration::actualTypeName (void) const {
  return "routineCallInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__routineCallInstructionForGeneration ("routineCallInstructionForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_routineCallInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_routineCallInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_routineCallInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_routineCallInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_routineCallInstructionForGeneration GGS_routineCallInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_routineCallInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_routineCallInstructionForGeneration * p = dynamic_cast <const GGS_routineCallInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_routineCallInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_routineCallInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_routineCallInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_typeMethodInstructionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeMethodInstructionForGeneration::
cPtr_typeMethodInstructionForGeneration (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_actualParameterListForGeneration & argument_2,
                                const GGS_bool& argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (THERE),
mTypeName (argument_0),
mMethodName (argument_1),
mActualParameterList (argument_2),
mHasCompilerArgument (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeMethodInstructionForGeneration * GGS_typeMethodInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeMethodInstructionForGeneration) ;
    return (cPtr_typeMethodInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeMethodInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeMethodInstructionForGeneration * ptr = dynamic_cast <const cPtr_typeMethodInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTypeName.operator_isEqual (ptr->mTypeName).boolValue ()
         && mMethodName.operator_isEqual (ptr->mMethodName).boolValue ()
         && mActualParameterList.operator_isEqual (ptr->mActualParameterList).boolValue ()
         && mHasCompilerArgument.operator_isEqual (ptr->mHasCompilerArgument).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeMethodInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeMethodInstructionForGeneration:"
           << mTypeName.reader_description (inIndentation + 1)
           << mMethodName.reader_description (inIndentation + 1)
           << mActualParameterList.reader_description (inIndentation + 1)
           << mHasCompilerArgument.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeMethodInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeMethodInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeMethodInstructionForGeneration (& typeid (cPtr_typeMethodInstructionForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeMethodInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__typeMethodInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeMethodInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeMethodInstructionForGeneration (mTypeName, mMethodName, mActualParameterList, mHasCompilerArgument COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_typeMethodInstructionForGeneration'            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeMethodInstructionForGeneration ("typeMethodInstructionForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_typeMethodInstructionForGeneration::
GGS_typeMethodInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeMethodInstructionForGeneration::
GGS_typeMethodInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeMethodInstructionForGeneration GGS_typeMethodInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeMethodInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeMethodInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_typeMethodInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeMethodInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeMethodInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeMethodInstructionForGeneration GGS_typeMethodInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_actualParameterListForGeneration & argument_2,
                 const GGS_bool& argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_typeMethodInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_typeMethodInstructionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeMethodInstructionForGeneration::
reader_mTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMethodInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMethodInstructionForGeneration *) mPointer)->mTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeMethodInstructionForGeneration::
reader_mMethodName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMethodInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMethodInstructionForGeneration *) mPointer)->mMethodName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameterListForGeneration  GGS_typeMethodInstructionForGeneration::
reader_mActualParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_actualParameterListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMethodInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMethodInstructionForGeneration *) mPointer)->mActualParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeMethodInstructionForGeneration::
reader_mHasCompilerArgument (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMethodInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMethodInstructionForGeneration *) mPointer)->mHasCompilerArgument ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeMethodInstructionForGeneration::actualTypeName (void) const {
  return "typeMethodInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeMethodInstructionForGeneration ("typeMethodInstructionForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_typeMethodInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeMethodInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeMethodInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_typeMethodInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeMethodInstructionForGeneration GGS_typeMethodInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeMethodInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeMethodInstructionForGeneration * p = dynamic_cast <const GGS_typeMethodInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeMethodInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeMethodInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeMethodInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_methodCallInstructionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_methodCallInstructionForGeneration::
cPtr_methodCallInstructionForGeneration (const GGS_location & argument_0,
                                const GGS_semanticExpressionForGeneration & argument_1,
                                const GGS_string& argument_2,
                                const GGS_bool& argument_3,
                                const GGS_actualParameterListForGeneration & argument_4,
                                const GGS_bool& argument_5
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (THERE),
mInstructionLocation (argument_0),
mReceiverExpression (argument_1),
mMethodName (argument_2),
mIsCategory (argument_3),
mActualParameterList (argument_4),
mHasCompilerArgument (argument_5) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_methodCallInstructionForGeneration * GGS_methodCallInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_methodCallInstructionForGeneration) ;
    return (cPtr_methodCallInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_methodCallInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_methodCallInstructionForGeneration * ptr = dynamic_cast <const cPtr_methodCallInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mReceiverExpression.operator_isEqual (ptr->mReceiverExpression).boolValue ()
         && mMethodName.operator_isEqual (ptr->mMethodName).boolValue ()
         && mIsCategory.operator_isEqual (ptr->mIsCategory).boolValue ()
         && mActualParameterList.operator_isEqual (ptr->mActualParameterList).boolValue ()
         && mHasCompilerArgument.operator_isEqual (ptr->mHasCompilerArgument).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_methodCallInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@methodCallInstructionForGeneration:"
           << mInstructionLocation.reader_description (inIndentation + 1)
           << mReceiverExpression.reader_description (inIndentation + 1)
           << mMethodName.reader_description (inIndentation + 1)
           << mIsCategory.reader_description (inIndentation + 1)
           << mActualParameterList.reader_description (inIndentation + 1)
           << mHasCompilerArgument.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_methodCallInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_methodCallInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_methodCallInstructionForGeneration (& typeid (cPtr_methodCallInstructionForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_methodCallInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__methodCallInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_methodCallInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_methodCallInstructionForGeneration (mInstructionLocation, mReceiverExpression, mMethodName, mIsCategory, mActualParameterList, mHasCompilerArgument COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_methodCallInstructionForGeneration'            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_methodCallInstructionForGeneration ("methodCallInstructionForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_methodCallInstructionForGeneration::
GGS_methodCallInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_methodCallInstructionForGeneration::
GGS_methodCallInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_methodCallInstructionForGeneration GGS_methodCallInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_methodCallInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_methodCallInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_methodCallInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_methodCallInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_methodCallInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_methodCallInstructionForGeneration GGS_methodCallInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionForGeneration & argument_1,
                 const GGS_string& argument_2,
                 const GGS_bool& argument_3,
                 const GGS_actualParameterListForGeneration & argument_4,
                 const GGS_bool& argument_5
                                COMMA_LOCATION_ARGS) {
  GGS_methodCallInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_methodCallInstructionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_methodCallInstructionForGeneration::
reader_mInstructionLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_methodCallInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_methodCallInstructionForGeneration *) mPointer)->mInstructionLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_methodCallInstructionForGeneration::
reader_mReceiverExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_methodCallInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_methodCallInstructionForGeneration *) mPointer)->mReceiverExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_methodCallInstructionForGeneration::
reader_mMethodName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_methodCallInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_methodCallInstructionForGeneration *) mPointer)->mMethodName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_methodCallInstructionForGeneration::
reader_mIsCategory (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_methodCallInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_methodCallInstructionForGeneration *) mPointer)->mIsCategory ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameterListForGeneration  GGS_methodCallInstructionForGeneration::
reader_mActualParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_actualParameterListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_methodCallInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_methodCallInstructionForGeneration *) mPointer)->mActualParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_methodCallInstructionForGeneration::
reader_mHasCompilerArgument (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_methodCallInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_methodCallInstructionForGeneration *) mPointer)->mHasCompilerArgument ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_methodCallInstructionForGeneration::actualTypeName (void) const {
  return "methodCallInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__methodCallInstructionForGeneration ("methodCallInstructionForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_methodCallInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_methodCallInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_methodCallInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_methodCallInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_methodCallInstructionForGeneration GGS_methodCallInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_methodCallInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_methodCallInstructionForGeneration * p = dynamic_cast <const GGS_methodCallInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_methodCallInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_methodCallInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_methodCallInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           class 'cPtr_thisMethodCallInstructionForGeneration'             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_thisMethodCallInstructionForGeneration::
cPtr_thisMethodCallInstructionForGeneration (const GGS_string& argument_0,
                                const GGS_location & argument_1,
                                const GGS_string& argument_2,
                                const GGS_bool& argument_3,
                                const GGS_actualParameterListForGeneration & argument_4,
                                const GGS_bool& argument_5
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (THERE),
mCurrentObjectCppPointer (argument_0),
mInstructionLocation (argument_1),
mMethodName (argument_2),
mIsCategory (argument_3),
mActualParameterList (argument_4),
mHasCompilerArgument (argument_5) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_thisMethodCallInstructionForGeneration * GGS_thisMethodCallInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_thisMethodCallInstructionForGeneration) ;
    return (cPtr_thisMethodCallInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_thisMethodCallInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_thisMethodCallInstructionForGeneration * ptr = dynamic_cast <const cPtr_thisMethodCallInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mCurrentObjectCppPointer.operator_isEqual (ptr->mCurrentObjectCppPointer).boolValue ()
         && mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mMethodName.operator_isEqual (ptr->mMethodName).boolValue ()
         && mIsCategory.operator_isEqual (ptr->mIsCategory).boolValue ()
         && mActualParameterList.operator_isEqual (ptr->mActualParameterList).boolValue ()
         && mHasCompilerArgument.operator_isEqual (ptr->mHasCompilerArgument).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_thisMethodCallInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@thisMethodCallInstructionForGeneration:"
           << mCurrentObjectCppPointer.reader_description (inIndentation + 1)
           << mInstructionLocation.reader_description (inIndentation + 1)
           << mMethodName.reader_description (inIndentation + 1)
           << mIsCategory.reader_description (inIndentation + 1)
           << mActualParameterList.reader_description (inIndentation + 1)
           << mHasCompilerArgument.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_thisMethodCallInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_thisMethodCallInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_thisMethodCallInstructionForGeneration (& typeid (cPtr_thisMethodCallInstructionForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_thisMethodCallInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__thisMethodCallInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_thisMethodCallInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_thisMethodCallInstructionForGeneration (mCurrentObjectCppPointer, mInstructionLocation, mMethodName, mIsCategory, mActualParameterList, mHasCompilerArgument COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        GALGAS class 'GGS_thisMethodCallInstructionForGeneration'          *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_thisMethodCallInstructionForGeneration ("thisMethodCallInstructionForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_thisMethodCallInstructionForGeneration::
GGS_thisMethodCallInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_thisMethodCallInstructionForGeneration::
GGS_thisMethodCallInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_thisMethodCallInstructionForGeneration GGS_thisMethodCallInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_thisMethodCallInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_thisMethodCallInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_thisMethodCallInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_thisMethodCallInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_thisMethodCallInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_thisMethodCallInstructionForGeneration GGS_thisMethodCallInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0,
                 const GGS_location & argument_1,
                 const GGS_string& argument_2,
                 const GGS_bool& argument_3,
                 const GGS_actualParameterListForGeneration & argument_4,
                 const GGS_bool& argument_5
                                COMMA_LOCATION_ARGS) {
  GGS_thisMethodCallInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_thisMethodCallInstructionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_thisMethodCallInstructionForGeneration::
reader_mCurrentObjectCppPointer (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_thisMethodCallInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_thisMethodCallInstructionForGeneration *) mPointer)->mCurrentObjectCppPointer ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_thisMethodCallInstructionForGeneration::
reader_mInstructionLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_thisMethodCallInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_thisMethodCallInstructionForGeneration *) mPointer)->mInstructionLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_thisMethodCallInstructionForGeneration::
reader_mMethodName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_thisMethodCallInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_thisMethodCallInstructionForGeneration *) mPointer)->mMethodName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_thisMethodCallInstructionForGeneration::
reader_mIsCategory (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_thisMethodCallInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_thisMethodCallInstructionForGeneration *) mPointer)->mIsCategory ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameterListForGeneration  GGS_thisMethodCallInstructionForGeneration::
reader_mActualParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_actualParameterListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_thisMethodCallInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_thisMethodCallInstructionForGeneration *) mPointer)->mActualParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_thisMethodCallInstructionForGeneration::
reader_mHasCompilerArgument (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_thisMethodCallInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_thisMethodCallInstructionForGeneration *) mPointer)->mHasCompilerArgument ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_thisMethodCallInstructionForGeneration::actualTypeName (void) const {
  return "thisMethodCallInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__thisMethodCallInstructionForGeneration ("thisMethodCallInstructionForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_thisMethodCallInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_thisMethodCallInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_thisMethodCallInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_thisMethodCallInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_thisMethodCallInstructionForGeneration GGS_thisMethodCallInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_thisMethodCallInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_thisMethodCallInstructionForGeneration * p = dynamic_cast <const GGS_thisMethodCallInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_thisMethodCallInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_thisMethodCallInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_thisMethodCallInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           class 'cPtr_superMethodCallInstructionForGeneration'            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_superMethodCallInstructionForGeneration::
cPtr_superMethodCallInstructionForGeneration (const GGS_location & argument_0,
                                const GGS_string& argument_1,
                                const GGS_string& argument_2,
                                const GGS_bool& argument_3,
                                const GGS_actualParameterListForGeneration & argument_4,
                                const GGS_bool& argument_5
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (THERE),
mInstructionLocation (argument_0),
mSuperClassThatImplementsMethod (argument_1),
mMethodName (argument_2),
mIsCategory (argument_3),
mActualParameterList (argument_4),
mHasCompilerArgument (argument_5) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_superMethodCallInstructionForGeneration * GGS_superMethodCallInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_superMethodCallInstructionForGeneration) ;
    return (cPtr_superMethodCallInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_superMethodCallInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_superMethodCallInstructionForGeneration * ptr = dynamic_cast <const cPtr_superMethodCallInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mSuperClassThatImplementsMethod.operator_isEqual (ptr->mSuperClassThatImplementsMethod).boolValue ()
         && mMethodName.operator_isEqual (ptr->mMethodName).boolValue ()
         && mIsCategory.operator_isEqual (ptr->mIsCategory).boolValue ()
         && mActualParameterList.operator_isEqual (ptr->mActualParameterList).boolValue ()
         && mHasCompilerArgument.operator_isEqual (ptr->mHasCompilerArgument).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_superMethodCallInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@superMethodCallInstructionForGeneration:"
           << mInstructionLocation.reader_description (inIndentation + 1)
           << mSuperClassThatImplementsMethod.reader_description (inIndentation + 1)
           << mMethodName.reader_description (inIndentation + 1)
           << mIsCategory.reader_description (inIndentation + 1)
           << mActualParameterList.reader_description (inIndentation + 1)
           << mHasCompilerArgument.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_superMethodCallInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_superMethodCallInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_superMethodCallInstructionForGeneration (& typeid (cPtr_superMethodCallInstructionForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_superMethodCallInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__superMethodCallInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_superMethodCallInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_superMethodCallInstructionForGeneration (mInstructionLocation, mSuperClassThatImplementsMethod, mMethodName, mIsCategory, mActualParameterList, mHasCompilerArgument COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        GALGAS class 'GGS_superMethodCallInstructionForGeneration'         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_superMethodCallInstructionForGeneration ("superMethodCallInstructionForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_superMethodCallInstructionForGeneration::
GGS_superMethodCallInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_superMethodCallInstructionForGeneration::
GGS_superMethodCallInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_superMethodCallInstructionForGeneration GGS_superMethodCallInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_superMethodCallInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_superMethodCallInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_superMethodCallInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_superMethodCallInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_superMethodCallInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_superMethodCallInstructionForGeneration GGS_superMethodCallInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_string& argument_1,
                 const GGS_string& argument_2,
                 const GGS_bool& argument_3,
                 const GGS_actualParameterListForGeneration & argument_4,
                 const GGS_bool& argument_5
                                COMMA_LOCATION_ARGS) {
  GGS_superMethodCallInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_superMethodCallInstructionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_superMethodCallInstructionForGeneration::
reader_mInstructionLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_superMethodCallInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_superMethodCallInstructionForGeneration *) mPointer)->mInstructionLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_superMethodCallInstructionForGeneration::
reader_mSuperClassThatImplementsMethod (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_superMethodCallInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_superMethodCallInstructionForGeneration *) mPointer)->mSuperClassThatImplementsMethod ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_superMethodCallInstructionForGeneration::
reader_mMethodName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_superMethodCallInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_superMethodCallInstructionForGeneration *) mPointer)->mMethodName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_superMethodCallInstructionForGeneration::
reader_mIsCategory (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_superMethodCallInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_superMethodCallInstructionForGeneration *) mPointer)->mIsCategory ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameterListForGeneration  GGS_superMethodCallInstructionForGeneration::
reader_mActualParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_actualParameterListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_superMethodCallInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_superMethodCallInstructionForGeneration *) mPointer)->mActualParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_superMethodCallInstructionForGeneration::
reader_mHasCompilerArgument (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_superMethodCallInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_superMethodCallInstructionForGeneration *) mPointer)->mHasCompilerArgument ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_superMethodCallInstructionForGeneration::actualTypeName (void) const {
  return "superMethodCallInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__superMethodCallInstructionForGeneration ("superMethodCallInstructionForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_superMethodCallInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_superMethodCallInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_superMethodCallInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_superMethodCallInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_superMethodCallInstructionForGeneration GGS_superMethodCallInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_superMethodCallInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_superMethodCallInstructionForGeneration * p = dynamic_cast <const GGS_superMethodCallInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_superMethodCallInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_superMethodCallInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_superMethodCallInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            class 'cPtr_modifierCallInstructionForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_modifierCallInstructionForGeneration::
cPtr_modifierCallInstructionForGeneration (const GGS_string& argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_unifiedTypeMapProxy & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_actualParameterListForGeneration & argument_4,
                                const GGS_bool& argument_5
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (THERE),
mReceiverCppName (argument_0),
mReceiverStructAttributes (argument_1),
mReceiverType (argument_2),
mModifierName (argument_3),
mActualParameterList (argument_4),
mHasCompilerArgument (argument_5) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_modifierCallInstructionForGeneration * GGS_modifierCallInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_modifierCallInstructionForGeneration) ;
    return (cPtr_modifierCallInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_modifierCallInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_modifierCallInstructionForGeneration * ptr = dynamic_cast <const cPtr_modifierCallInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mReceiverCppName.operator_isEqual (ptr->mReceiverCppName).boolValue ()
         && mReceiverStructAttributes.operator_isEqual (ptr->mReceiverStructAttributes).boolValue ()
         && mReceiverType.operator_isEqual (ptr->mReceiverType).boolValue ()
         && mModifierName.operator_isEqual (ptr->mModifierName).boolValue ()
         && mActualParameterList.operator_isEqual (ptr->mActualParameterList).boolValue ()
         && mHasCompilerArgument.operator_isEqual (ptr->mHasCompilerArgument).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_modifierCallInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@modifierCallInstructionForGeneration:"
           << mReceiverCppName.reader_description (inIndentation + 1)
           << mReceiverStructAttributes.reader_description (inIndentation + 1)
           << mReceiverType.reader_description (inIndentation + 1)
           << mModifierName.reader_description (inIndentation + 1)
           << mActualParameterList.reader_description (inIndentation + 1)
           << mHasCompilerArgument.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_modifierCallInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_modifierCallInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_modifierCallInstructionForGeneration (& typeid (cPtr_modifierCallInstructionForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_modifierCallInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__modifierCallInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_modifierCallInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_modifierCallInstructionForGeneration (mReceiverCppName, mReceiverStructAttributes, mReceiverType, mModifierName, mActualParameterList, mHasCompilerArgument COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         GALGAS class 'GGS_modifierCallInstructionForGeneration'           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_modifierCallInstructionForGeneration ("modifierCallInstructionForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_modifierCallInstructionForGeneration::
GGS_modifierCallInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_modifierCallInstructionForGeneration::
GGS_modifierCallInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_modifierCallInstructionForGeneration GGS_modifierCallInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_modifierCallInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_modifierCallInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_modifierCallInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_modifierCallInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_modifierCallInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_modifierCallInstructionForGeneration GGS_modifierCallInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0,
                 const GGS_lstringlist & argument_1,
                 const GGS_unifiedTypeMapProxy & argument_2,
                 const GGS_lstring & argument_3,
                 const GGS_actualParameterListForGeneration & argument_4,
                 const GGS_bool& argument_5
                                COMMA_LOCATION_ARGS) {
  GGS_modifierCallInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_modifierCallInstructionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_modifierCallInstructionForGeneration::
reader_mReceiverCppName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_modifierCallInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_modifierCallInstructionForGeneration *) mPointer)->mReceiverCppName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_modifierCallInstructionForGeneration::
reader_mReceiverStructAttributes (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_modifierCallInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_modifierCallInstructionForGeneration *) mPointer)->mReceiverStructAttributes ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapProxy  GGS_modifierCallInstructionForGeneration::
reader_mReceiverType (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_unifiedTypeMapProxy   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_modifierCallInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_modifierCallInstructionForGeneration *) mPointer)->mReceiverType ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_modifierCallInstructionForGeneration::
reader_mModifierName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_modifierCallInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_modifierCallInstructionForGeneration *) mPointer)->mModifierName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameterListForGeneration  GGS_modifierCallInstructionForGeneration::
reader_mActualParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_actualParameterListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_modifierCallInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_modifierCallInstructionForGeneration *) mPointer)->mActualParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_modifierCallInstructionForGeneration::
reader_mHasCompilerArgument (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_modifierCallInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_modifierCallInstructionForGeneration *) mPointer)->mHasCompilerArgument ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_modifierCallInstructionForGeneration::actualTypeName (void) const {
  return "modifierCallInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__modifierCallInstructionForGeneration ("modifierCallInstructionForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_modifierCallInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_modifierCallInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_modifierCallInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_modifierCallInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_modifierCallInstructionForGeneration GGS_modifierCallInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_modifierCallInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_modifierCallInstructionForGeneration * p = dynamic_cast <const GGS_modifierCallInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_modifierCallInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_modifierCallInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_modifierCallInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          class 'cPtr_thisModifierCallInstructionForGeneration'            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_thisModifierCallInstructionForGeneration::
cPtr_thisModifierCallInstructionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_actualParameterListForGeneration & argument_2,
                                const GGS_bool& argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (THERE),
mReceiverType (argument_0),
mModifierName (argument_1),
mActualParameterList (argument_2),
mHasCompilerArgument (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_thisModifierCallInstructionForGeneration * GGS_thisModifierCallInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_thisModifierCallInstructionForGeneration) ;
    return (cPtr_thisModifierCallInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_thisModifierCallInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_thisModifierCallInstructionForGeneration * ptr = dynamic_cast <const cPtr_thisModifierCallInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mReceiverType.operator_isEqual (ptr->mReceiverType).boolValue ()
         && mModifierName.operator_isEqual (ptr->mModifierName).boolValue ()
         && mActualParameterList.operator_isEqual (ptr->mActualParameterList).boolValue ()
         && mHasCompilerArgument.operator_isEqual (ptr->mHasCompilerArgument).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_thisModifierCallInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@thisModifierCallInstructionForGeneration:"
           << mReceiverType.reader_description (inIndentation + 1)
           << mModifierName.reader_description (inIndentation + 1)
           << mActualParameterList.reader_description (inIndentation + 1)
           << mHasCompilerArgument.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_thisModifierCallInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_thisModifierCallInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_thisModifierCallInstructionForGeneration (& typeid (cPtr_thisModifierCallInstructionForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_thisModifierCallInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__thisModifierCallInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_thisModifierCallInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_thisModifierCallInstructionForGeneration (mReceiverType, mModifierName, mActualParameterList, mHasCompilerArgument COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//       GALGAS class 'GGS_thisModifierCallInstructionForGeneration'         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_thisModifierCallInstructionForGeneration ("thisModifierCallInstructionForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_thisModifierCallInstructionForGeneration::
GGS_thisModifierCallInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_thisModifierCallInstructionForGeneration::
GGS_thisModifierCallInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_thisModifierCallInstructionForGeneration GGS_thisModifierCallInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_thisModifierCallInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_thisModifierCallInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_thisModifierCallInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_thisModifierCallInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_thisModifierCallInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_thisModifierCallInstructionForGeneration GGS_thisModifierCallInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_actualParameterListForGeneration & argument_2,
                 const GGS_bool& argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_thisModifierCallInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_thisModifierCallInstructionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapProxy  GGS_thisModifierCallInstructionForGeneration::
reader_mReceiverType (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_unifiedTypeMapProxy   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_thisModifierCallInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_thisModifierCallInstructionForGeneration *) mPointer)->mReceiverType ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_thisModifierCallInstructionForGeneration::
reader_mModifierName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_thisModifierCallInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_thisModifierCallInstructionForGeneration *) mPointer)->mModifierName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameterListForGeneration  GGS_thisModifierCallInstructionForGeneration::
reader_mActualParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_actualParameterListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_thisModifierCallInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_thisModifierCallInstructionForGeneration *) mPointer)->mActualParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_thisModifierCallInstructionForGeneration::
reader_mHasCompilerArgument (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_thisModifierCallInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_thisModifierCallInstructionForGeneration *) mPointer)->mHasCompilerArgument ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_thisModifierCallInstructionForGeneration::actualTypeName (void) const {
  return "thisModifierCallInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__thisModifierCallInstructionForGeneration ("thisModifierCallInstructionForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_thisModifierCallInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_thisModifierCallInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_thisModifierCallInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_thisModifierCallInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_thisModifierCallInstructionForGeneration GGS_thisModifierCallInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_thisModifierCallInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_thisModifierCallInstructionForGeneration * p = dynamic_cast <const GGS_thisModifierCallInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_thisModifierCallInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_thisModifierCallInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_thisModifierCallInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          class 'cPtr_superModifierCallInstructionForGeneration'           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_superModifierCallInstructionForGeneration::
cPtr_superModifierCallInstructionForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_string& argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_actualParameterListForGeneration & argument_3,
                                const GGS_bool& argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (THERE),
mReceiverType (argument_0),
mSuperClassThatImplementsModifier (argument_1),
mModifierName (argument_2),
mActualParameterList (argument_3),
mHasCompilerArgument (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_superModifierCallInstructionForGeneration * GGS_superModifierCallInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_superModifierCallInstructionForGeneration) ;
    return (cPtr_superModifierCallInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_superModifierCallInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_superModifierCallInstructionForGeneration * ptr = dynamic_cast <const cPtr_superModifierCallInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mReceiverType.operator_isEqual (ptr->mReceiverType).boolValue ()
         && mSuperClassThatImplementsModifier.operator_isEqual (ptr->mSuperClassThatImplementsModifier).boolValue ()
         && mModifierName.operator_isEqual (ptr->mModifierName).boolValue ()
         && mActualParameterList.operator_isEqual (ptr->mActualParameterList).boolValue ()
         && mHasCompilerArgument.operator_isEqual (ptr->mHasCompilerArgument).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_superModifierCallInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@superModifierCallInstructionForGeneration:"
           << mReceiverType.reader_description (inIndentation + 1)
           << mSuperClassThatImplementsModifier.reader_description (inIndentation + 1)
           << mModifierName.reader_description (inIndentation + 1)
           << mActualParameterList.reader_description (inIndentation + 1)
           << mHasCompilerArgument.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_superModifierCallInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_superModifierCallInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_superModifierCallInstructionForGeneration (& typeid (cPtr_superModifierCallInstructionForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_superModifierCallInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__superModifierCallInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_superModifierCallInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_superModifierCallInstructionForGeneration (mReceiverType, mSuperClassThatImplementsModifier, mModifierName, mActualParameterList, mHasCompilerArgument COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//       GALGAS class 'GGS_superModifierCallInstructionForGeneration'        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_superModifierCallInstructionForGeneration ("superModifierCallInstructionForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_superModifierCallInstructionForGeneration::
GGS_superModifierCallInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_superModifierCallInstructionForGeneration::
GGS_superModifierCallInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_superModifierCallInstructionForGeneration GGS_superModifierCallInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_superModifierCallInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_superModifierCallInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_superModifierCallInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_superModifierCallInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_superModifierCallInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_superModifierCallInstructionForGeneration GGS_superModifierCallInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_string& argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_actualParameterListForGeneration & argument_3,
                 const GGS_bool& argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_superModifierCallInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_superModifierCallInstructionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapProxy  GGS_superModifierCallInstructionForGeneration::
reader_mReceiverType (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_unifiedTypeMapProxy   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_superModifierCallInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_superModifierCallInstructionForGeneration *) mPointer)->mReceiverType ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_superModifierCallInstructionForGeneration::
reader_mSuperClassThatImplementsModifier (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_superModifierCallInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_superModifierCallInstructionForGeneration *) mPointer)->mSuperClassThatImplementsModifier ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_superModifierCallInstructionForGeneration::
reader_mModifierName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_superModifierCallInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_superModifierCallInstructionForGeneration *) mPointer)->mModifierName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameterListForGeneration  GGS_superModifierCallInstructionForGeneration::
reader_mActualParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_actualParameterListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_superModifierCallInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_superModifierCallInstructionForGeneration *) mPointer)->mActualParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_superModifierCallInstructionForGeneration::
reader_mHasCompilerArgument (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_superModifierCallInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_superModifierCallInstructionForGeneration *) mPointer)->mHasCompilerArgument ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_superModifierCallInstructionForGeneration::actualTypeName (void) const {
  return "superModifierCallInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__superModifierCallInstructionForGeneration ("superModifierCallInstructionForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_superModifierCallInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_superModifierCallInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_superModifierCallInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_superModifierCallInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_superModifierCallInstructionForGeneration GGS_superModifierCallInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_superModifierCallInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_superModifierCallInstructionForGeneration * p = dynamic_cast <const GGS_superModifierCallInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_superModifierCallInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_superModifierCallInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_superModifierCallInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@matchListForGeneration'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_matchListForGeneration::
elementOf_GGS_matchListForGeneration (const GGS_bool& argument_0,
                                const GGS_string& argument_1,
                                const GGS_string& argument_2
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mIsType (argument_0),
mTypeNameOrEnumerationConstantName (argument_1),
mLocalConstantName (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_matchListForGeneration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_matchListForGeneration * ptr = dynamic_cast <const elementOf_GGS_matchListForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mIsType.operator_isEqual (ptr->mIsType).boolValue ()
         && mTypeNameOrEnumerationConstantName.operator_isEqual (ptr->mTypeNameOrEnumerationConstantName).boolValue ()
         && mLocalConstantName.operator_isEqual (ptr->mLocalConstantName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_matchListForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mIsType.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTypeNameOrEnumerationConstantName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLocalConstantName.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@matchListForGeneration'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_matchListForGeneration ("matchListForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_matchListForGeneration::
internalAppendValues (const GGS_bool& argument_0,
                    const GGS_string& argument_1,
                    const GGS_string& argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_matchListForGeneration::
internalPrependValues (const GGS_bool& argument_0,
                    const GGS_string& argument_1,
                    const GGS_string& argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_matchListForGeneration::
addAssign_operation (const GGS_bool& argument_0,
                                const GGS_string& argument_1,
                                const GGS_string& argument_2) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_matchListForGeneration GGS_matchListForGeneration::
operator_concat (const GGS_matchListForGeneration & inOperand) const {
  GGS_matchListForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_matchListForGeneration::
dotAssign_operation (const GGS_matchListForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_matchListForGeneration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_bool p_0 = p->mIsType ;
          GGS_string p_1 = p->mTypeNameOrEnumerationConstantName ;
          GGS_string p_2 = p->mLocalConstantName ;
          internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_matchListForGeneration::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_bool& argument_0,
                     const GGS_string& argument_1,
                     const GGS_string& argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_matchListForGeneration::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mIsType,
                                ptr->mTypeNameOrEnumerationConstantName,
                                ptr->mLocalConstantName
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_matchListForGeneration  GGS_matchListForGeneration::
constructor_emptyList (void) {
  GGS_matchListForGeneration result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_matchListForGeneration  GGS_matchListForGeneration::
constructor_listWithValue (const GGS_bool& argument_0,
                                const GGS_string& argument_1,
                                const GGS_string& argument_2) {
  GGS_matchListForGeneration result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_matchListForGeneration::
internalSubListWithRange (GGS_matchListForGeneration & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mIsType, ptr->mTypeNameOrEnumerationConstantName, ptr->mLocalConstantName) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_matchListForGeneration GGS_matchListForGeneration::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_matchListForGeneration result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_matchListForGeneration GGS_matchListForGeneration::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_matchListForGeneration result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_matchListForGeneration::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@matchListForGeneration", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_matchListForGeneration::
method_first (C_Compiler & inLexique,
              GGS_bool& _out_0,
              GGS_string& _out_1,
              GGS_string& _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mIsType ;
    _out_1 = ptr->mTypeNameOrEnumerationConstantName ;
    _out_2 = ptr->mLocalConstantName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_matchListForGeneration::
method_last (C_Compiler & inLexique,
             GGS_bool& _out_0,
             GGS_string& _out_1,
             GGS_string& _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mIsType ;
    _out_1 = ptr->mTypeNameOrEnumerationConstantName ;
    _out_2 = ptr->mLocalConstantName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_matchListForGeneration::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_bool& _out_0,
                 GGS_string& _out_1,
                 GGS_string& _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mIsType ;
    _out_1 = ptr->mTypeNameOrEnumerationConstantName ;
    _out_2 = ptr->mLocalConstantName ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_matchListForGeneration::
modifier_popLast (C_Compiler & inLexique,
                GGS_bool& _out_0,
                GGS_string& _out_1,
                GGS_string& _out_2
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mIsType ;
    _out_1 = ptr->mTypeNameOrEnumerationConstantName ;
    _out_2 = ptr->mLocalConstantName ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_bool GGS_matchListForGeneration::
reader_mIsTypeAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mIsType ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_matchListForGeneration::
reader_mTypeNameOrEnumerationConstantNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_string result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mTypeNameOrEnumerationConstantName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_matchListForGeneration::
reader_mLocalConstantNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_string result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mLocalConstantName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_matchListForGeneration::
modifier_setMIsTypeAtIndex (C_Compiler & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mIsType = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_matchListForGeneration::
modifier_setMTypeNameOrEnumerationConstantNameAtIndex (C_Compiler & inLexique,
                              const GGS_string & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mTypeNameOrEnumerationConstantName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_matchListForGeneration::
modifier_setMLocalConstantNameAtIndex (C_Compiler & inLexique,
                              const GGS_string & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mLocalConstantName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_matchListForGeneration::cEnumerator::_mIsType (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mIsType ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_matchListForGeneration::cEnumerator::_mTypeNameOrEnumerationConstantName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mTypeNameOrEnumerationConstantName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_matchListForGeneration::cEnumerator::_mLocalConstantName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mLocalConstantName ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_matchListForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_matchListForGeneration * p = NULL ;
    macroMyNew (p, GGS_matchListForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_matchListForGeneration GGS_matchListForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_matchListForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_matchListForGeneration * p = dynamic_cast <const GGS_matchListForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_matchListForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_matchListForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_matchListForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        Element of list '@matchInstructionBranchListForGeneration'         *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_matchInstructionBranchListForGeneration::
elementOf_GGS_matchInstructionBranchListForGeneration (const GGS_matchListForGeneration & argument_0,
                                const GGS_semanticInstructionListForGeneration & argument_1
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mMatchListForGeneration (argument_0),
mMatchBranchInstructionList (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_matchInstructionBranchListForGeneration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_matchInstructionBranchListForGeneration * ptr = dynamic_cast <const elementOf_GGS_matchInstructionBranchListForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mMatchListForGeneration.operator_isEqual (ptr->mMatchListForGeneration).boolValue ()
         && mMatchBranchInstructionList.operator_isEqual (ptr->mMatchBranchInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_matchInstructionBranchListForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMatchListForGeneration.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMatchBranchInstructionList.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             List '@matchInstructionBranchListForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_matchInstructionBranchListForGeneration ("matchInstructionBranchListForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchListForGeneration::
internalAppendValues (const GGS_matchListForGeneration & argument_0,
                    const GGS_semanticInstructionListForGeneration & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchListForGeneration::
internalPrependValues (const GGS_matchListForGeneration & argument_0,
                    const GGS_semanticInstructionListForGeneration & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchListForGeneration::
addAssign_operation (const GGS_matchListForGeneration & argument_0,
                                const GGS_semanticInstructionListForGeneration & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_matchInstructionBranchListForGeneration GGS_matchInstructionBranchListForGeneration::
operator_concat (const GGS_matchInstructionBranchListForGeneration & inOperand) const {
  GGS_matchInstructionBranchListForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchListForGeneration::
dotAssign_operation (const GGS_matchInstructionBranchListForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_matchInstructionBranchListForGeneration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_matchListForGeneration  p_0 = p->mMatchListForGeneration ;
          GGS_semanticInstructionListForGeneration  p_1 = p->mMatchBranchInstructionList ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchListForGeneration::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_matchListForGeneration & argument_0,
                     const GGS_semanticInstructionListForGeneration & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchListForGeneration::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mMatchListForGeneration,
                                ptr->mMatchBranchInstructionList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_matchInstructionBranchListForGeneration  GGS_matchInstructionBranchListForGeneration::
constructor_emptyList (void) {
  GGS_matchInstructionBranchListForGeneration result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_matchInstructionBranchListForGeneration  GGS_matchInstructionBranchListForGeneration::
constructor_listWithValue (const GGS_matchListForGeneration & argument_0,
                                const GGS_semanticInstructionListForGeneration & argument_1) {
  GGS_matchInstructionBranchListForGeneration result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchListForGeneration::
internalSubListWithRange (GGS_matchInstructionBranchListForGeneration & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mMatchListForGeneration, ptr->mMatchBranchInstructionList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_matchInstructionBranchListForGeneration GGS_matchInstructionBranchListForGeneration::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_matchInstructionBranchListForGeneration result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_matchInstructionBranchListForGeneration GGS_matchInstructionBranchListForGeneration::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_matchInstructionBranchListForGeneration result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_matchInstructionBranchListForGeneration::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@matchInstructionBranchListForGeneration", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchListForGeneration::
method_first (C_Compiler & inLexique,
              GGS_matchListForGeneration & _out_0,
              GGS_semanticInstructionListForGeneration & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMatchListForGeneration ;
    _out_1 = ptr->mMatchBranchInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchListForGeneration::
method_last (C_Compiler & inLexique,
             GGS_matchListForGeneration & _out_0,
             GGS_semanticInstructionListForGeneration & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMatchListForGeneration ;
    _out_1 = ptr->mMatchBranchInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchListForGeneration::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_matchListForGeneration & _out_0,
                 GGS_semanticInstructionListForGeneration & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMatchListForGeneration ;
    _out_1 = ptr->mMatchBranchInstructionList ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchListForGeneration::
modifier_popLast (C_Compiler & inLexique,
                GGS_matchListForGeneration & _out_0,
                GGS_semanticInstructionListForGeneration & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMatchListForGeneration ;
    _out_1 = ptr->mMatchBranchInstructionList ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_matchListForGeneration  GGS_matchInstructionBranchListForGeneration::
reader_mMatchListForGenerationAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_matchListForGeneration  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mMatchListForGeneration ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration  GGS_matchInstructionBranchListForGeneration::
reader_mMatchBranchInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticInstructionListForGeneration  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mMatchBranchInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchListForGeneration::
modifier_setMMatchListForGenerationAtIndex (C_Compiler & inLexique,
                              const GGS_matchListForGeneration  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mMatchListForGeneration = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchListForGeneration::
modifier_setMMatchBranchInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_semanticInstructionListForGeneration  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mMatchBranchInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_matchListForGeneration  & GGS_matchInstructionBranchListForGeneration::cEnumerator::_mMatchListForGeneration (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mMatchListForGeneration ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticInstructionListForGeneration  & GGS_matchInstructionBranchListForGeneration::cEnumerator::_mMatchBranchInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mMatchBranchInstructionList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_matchInstructionBranchListForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_matchInstructionBranchListForGeneration * p = NULL ;
    macroMyNew (p, GGS_matchInstructionBranchListForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_matchInstructionBranchListForGeneration GGS_matchInstructionBranchListForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_matchInstructionBranchListForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_matchInstructionBranchListForGeneration * p = dynamic_cast <const GGS_matchInstructionBranchListForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_matchInstructionBranchListForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_matchInstructionBranchListForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_matchInstructionBranchListForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_matchInstructionForGeneration'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_matchInstructionForGeneration::
cPtr_matchInstructionForGeneration (const GGS_semanticExpressionListForGeneration & argument_0,
                                const GGS_matchInstructionBranchListForGeneration & argument_1,
                                const GGS_semanticInstructionListForGeneration & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (THERE),
mMatchedExpressionList (argument_0),
mMatchInstructionBranchList (argument_1),
mElseInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_matchInstructionForGeneration * GGS_matchInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_matchInstructionForGeneration) ;
    return (cPtr_matchInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_matchInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_matchInstructionForGeneration * ptr = dynamic_cast <const cPtr_matchInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mMatchedExpressionList.operator_isEqual (ptr->mMatchedExpressionList).boolValue ()
         && mMatchInstructionBranchList.operator_isEqual (ptr->mMatchInstructionBranchList).boolValue ()
         && mElseInstructionList.operator_isEqual (ptr->mElseInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_matchInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@matchInstructionForGeneration:"
           << mMatchedExpressionList.reader_description (inIndentation + 1)
           << mMatchInstructionBranchList.reader_description (inIndentation + 1)
           << mElseInstructionList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_matchInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_matchInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_matchInstructionForGeneration (& typeid (cPtr_matchInstructionForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_matchInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__matchInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_matchInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_matchInstructionForGeneration (mMatchedExpressionList, mMatchInstructionBranchList, mElseInstructionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_matchInstructionForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_matchInstructionForGeneration ("matchInstructionForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_matchInstructionForGeneration::
GGS_matchInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_matchInstructionForGeneration::
GGS_matchInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_matchInstructionForGeneration GGS_matchInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_matchInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_matchInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_matchInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_matchInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_matchInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_matchInstructionForGeneration GGS_matchInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_semanticExpressionListForGeneration & argument_0,
                 const GGS_matchInstructionBranchListForGeneration & argument_1,
                 const GGS_semanticInstructionListForGeneration & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_matchInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_matchInstructionForGeneration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionListForGeneration  GGS_matchInstructionForGeneration::
reader_mMatchedExpressionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_matchInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_matchInstructionForGeneration *) mPointer)->mMatchedExpressionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_matchInstructionBranchListForGeneration  GGS_matchInstructionForGeneration::
reader_mMatchInstructionBranchList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_matchInstructionBranchListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_matchInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_matchInstructionForGeneration *) mPointer)->mMatchInstructionBranchList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration  GGS_matchInstructionForGeneration::
reader_mElseInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_matchInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_matchInstructionForGeneration *) mPointer)->mElseInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_matchInstructionForGeneration::actualTypeName (void) const {
  return "matchInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__matchInstructionForGeneration ("matchInstructionForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_matchInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_matchInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_matchInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_matchInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_matchInstructionForGeneration GGS_matchInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_matchInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_matchInstructionForGeneration * p = dynamic_cast <const GGS_matchInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_matchInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_matchInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_matchInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        Element of list '@castInstructionBranchListForGeneration'          *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_castInstructionBranchListForGeneration::
elementOf_GGS_castInstructionBranchListForGeneration (const GGS_bool& argument_0,
                                const GGS_unifiedTypeMapProxy & argument_1,
                                const GGS_string& argument_2,
                                const GGS_semanticInstructionListForGeneration & argument_3
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mUseKindOfClass (argument_0),
mType (argument_1),
mCastedVarCppName (argument_2),
mInstructionList (argument_3) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_castInstructionBranchListForGeneration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_castInstructionBranchListForGeneration * ptr = dynamic_cast <const elementOf_GGS_castInstructionBranchListForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mUseKindOfClass.operator_isEqual (ptr->mUseKindOfClass).boolValue ()
         && mType.operator_isEqual (ptr->mType).boolValue ()
         && mCastedVarCppName.operator_isEqual (ptr->mCastedVarCppName).boolValue ()
         && mInstructionList.operator_isEqual (ptr->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_castInstructionBranchListForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mUseKindOfClass.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mType.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mCastedVarCppName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              List '@castInstructionBranchListForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_castInstructionBranchListForGeneration ("castInstructionBranchListForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListForGeneration::
internalAppendValues (const GGS_bool& argument_0,
                    const GGS_unifiedTypeMapProxy & argument_1,
                    const GGS_string& argument_2,
                    const GGS_semanticInstructionListForGeneration & argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListForGeneration::
internalPrependValues (const GGS_bool& argument_0,
                    const GGS_unifiedTypeMapProxy & argument_1,
                    const GGS_string& argument_2,
                    const GGS_semanticInstructionListForGeneration & argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListForGeneration::
addAssign_operation (const GGS_bool& argument_0,
                                const GGS_unifiedTypeMapProxy & argument_1,
                                const GGS_string& argument_2,
                                const GGS_semanticInstructionListForGeneration & argument_3) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()&& argument_3.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_castInstructionBranchListForGeneration GGS_castInstructionBranchListForGeneration::
operator_concat (const GGS_castInstructionBranchListForGeneration & inOperand) const {
  GGS_castInstructionBranchListForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListForGeneration::
dotAssign_operation (const GGS_castInstructionBranchListForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_castInstructionBranchListForGeneration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_bool p_0 = p->mUseKindOfClass ;
          GGS_unifiedTypeMapProxy  p_1 = p->mType ;
          GGS_string p_2 = p->mCastedVarCppName ;
          GGS_semanticInstructionListForGeneration  p_3 = p->mInstructionList ;
          internalAppendValues (p_0, p_1, p_2, p_3 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListForGeneration::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_bool& argument_0,
                     const GGS_unifiedTypeMapProxy & argument_1,
                     const GGS_string& argument_2,
                     const GGS_semanticInstructionListForGeneration & argument_3
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListForGeneration::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mUseKindOfClass,
                                ptr->mType,
                                ptr->mCastedVarCppName,
                                ptr->mInstructionList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_castInstructionBranchListForGeneration  GGS_castInstructionBranchListForGeneration::
constructor_emptyList (void) {
  GGS_castInstructionBranchListForGeneration result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_castInstructionBranchListForGeneration  GGS_castInstructionBranchListForGeneration::
constructor_listWithValue (const GGS_bool& argument_0,
                                const GGS_unifiedTypeMapProxy & argument_1,
                                const GGS_string& argument_2,
                                const GGS_semanticInstructionListForGeneration & argument_3) {
  GGS_castInstructionBranchListForGeneration result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2, argument_3) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListForGeneration::
internalSubListWithRange (GGS_castInstructionBranchListForGeneration & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mUseKindOfClass, ptr->mType, ptr->mCastedVarCppName, ptr->mInstructionList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_castInstructionBranchListForGeneration GGS_castInstructionBranchListForGeneration::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_castInstructionBranchListForGeneration result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_castInstructionBranchListForGeneration GGS_castInstructionBranchListForGeneration::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_castInstructionBranchListForGeneration result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_castInstructionBranchListForGeneration::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@castInstructionBranchListForGeneration", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListForGeneration::
method_first (C_Compiler & inLexique,
              GGS_bool& _out_0,
              GGS_unifiedTypeMapProxy & _out_1,
              GGS_string& _out_2,
              GGS_semanticInstructionListForGeneration & _out_3
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mUseKindOfClass ;
    _out_1 = ptr->mType ;
    _out_2 = ptr->mCastedVarCppName ;
    _out_3 = ptr->mInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListForGeneration::
method_last (C_Compiler & inLexique,
             GGS_bool& _out_0,
             GGS_unifiedTypeMapProxy & _out_1,
             GGS_string& _out_2,
             GGS_semanticInstructionListForGeneration & _out_3
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mUseKindOfClass ;
    _out_1 = ptr->mType ;
    _out_2 = ptr->mCastedVarCppName ;
    _out_3 = ptr->mInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListForGeneration::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_bool& _out_0,
                 GGS_unifiedTypeMapProxy & _out_1,
                 GGS_string& _out_2,
                 GGS_semanticInstructionListForGeneration & _out_3
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mUseKindOfClass ;
    _out_1 = ptr->mType ;
    _out_2 = ptr->mCastedVarCppName ;
    _out_3 = ptr->mInstructionList ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListForGeneration::
modifier_popLast (C_Compiler & inLexique,
                GGS_bool& _out_0,
                GGS_unifiedTypeMapProxy & _out_1,
                GGS_string& _out_2,
                GGS_semanticInstructionListForGeneration & _out_3
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mUseKindOfClass ;
    _out_1 = ptr->mType ;
    _out_2 = ptr->mCastedVarCppName ;
    _out_3 = ptr->mInstructionList ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_bool GGS_castInstructionBranchListForGeneration::
reader_mUseKindOfClassAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mUseKindOfClass ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapProxy  GGS_castInstructionBranchListForGeneration::
reader_mTypeAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_unifiedTypeMapProxy  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mType ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_castInstructionBranchListForGeneration::
reader_mCastedVarCppNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_string result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mCastedVarCppName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration  GGS_castInstructionBranchListForGeneration::
reader_mInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticInstructionListForGeneration  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListForGeneration::
modifier_setMUseKindOfClassAtIndex (C_Compiler & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mUseKindOfClass = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListForGeneration::
modifier_setMTypeAtIndex (C_Compiler & inLexique,
                              const GGS_unifiedTypeMapProxy  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mType = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListForGeneration::
modifier_setMCastedVarCppNameAtIndex (C_Compiler & inLexique,
                              const GGS_string & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mCastedVarCppName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListForGeneration::
modifier_setMInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_semanticInstructionListForGeneration  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_castInstructionBranchListForGeneration::cEnumerator::_mUseKindOfClass (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mUseKindOfClass ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_unifiedTypeMapProxy  & GGS_castInstructionBranchListForGeneration::cEnumerator::_mType (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mType ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_castInstructionBranchListForGeneration::cEnumerator::_mCastedVarCppName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mCastedVarCppName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticInstructionListForGeneration  & GGS_castInstructionBranchListForGeneration::cEnumerator::_mInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mInstructionList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_castInstructionBranchListForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_castInstructionBranchListForGeneration * p = NULL ;
    macroMyNew (p, GGS_castInstructionBranchListForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_castInstructionBranchListForGeneration GGS_castInstructionBranchListForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_castInstructionBranchListForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_castInstructionBranchListForGeneration * p = dynamic_cast <const GGS_castInstructionBranchListForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_castInstructionBranchListForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_castInstructionBranchListForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_castInstructionBranchListForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           class 'cPtr_structuredCastInstructionForGeneration'             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_structuredCastInstructionForGeneration::
cPtr_structuredCastInstructionForGeneration (const GGS_semanticExpressionForGeneration & argument_0,
                                const GGS_castInstructionBranchListForGeneration & argument_1,
                                const GGS_semanticInstructionListForGeneration & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (THERE),
mExpression (argument_0),
mCastBranchList (argument_1),
mElseInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_structuredCastInstructionForGeneration * GGS_structuredCastInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_structuredCastInstructionForGeneration) ;
    return (cPtr_structuredCastInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_structuredCastInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_structuredCastInstructionForGeneration * ptr = dynamic_cast <const cPtr_structuredCastInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mExpression.operator_isEqual (ptr->mExpression).boolValue ()
         && mCastBranchList.operator_isEqual (ptr->mCastBranchList).boolValue ()
         && mElseInstructionList.operator_isEqual (ptr->mElseInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_structuredCastInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@structuredCastInstructionForGeneration:"
           << mExpression.reader_description (inIndentation + 1)
           << mCastBranchList.reader_description (inIndentation + 1)
           << mElseInstructionList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_structuredCastInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_structuredCastInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_structuredCastInstructionForGeneration (& typeid (cPtr_structuredCastInstructionForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_structuredCastInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__structuredCastInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_structuredCastInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_structuredCastInstructionForGeneration (mExpression, mCastBranchList, mElseInstructionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        GALGAS class 'GGS_structuredCastInstructionForGeneration'          *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_structuredCastInstructionForGeneration ("structuredCastInstructionForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_structuredCastInstructionForGeneration::
GGS_structuredCastInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_structuredCastInstructionForGeneration::
GGS_structuredCastInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_structuredCastInstructionForGeneration GGS_structuredCastInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_structuredCastInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_structuredCastInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_structuredCastInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_structuredCastInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_structuredCastInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_structuredCastInstructionForGeneration GGS_structuredCastInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_semanticExpressionForGeneration & argument_0,
                 const GGS_castInstructionBranchListForGeneration & argument_1,
                 const GGS_semanticInstructionListForGeneration & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_structuredCastInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_structuredCastInstructionForGeneration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_structuredCastInstructionForGeneration::
reader_mExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_structuredCastInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_structuredCastInstructionForGeneration *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_castInstructionBranchListForGeneration  GGS_structuredCastInstructionForGeneration::
reader_mCastBranchList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_castInstructionBranchListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_structuredCastInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_structuredCastInstructionForGeneration *) mPointer)->mCastBranchList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration  GGS_structuredCastInstructionForGeneration::
reader_mElseInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_structuredCastInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_structuredCastInstructionForGeneration *) mPointer)->mElseInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_structuredCastInstructionForGeneration::actualTypeName (void) const {
  return "structuredCastInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__structuredCastInstructionForGeneration ("structuredCastInstructionForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_structuredCastInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_structuredCastInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_structuredCastInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_structuredCastInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_structuredCastInstructionForGeneration GGS_structuredCastInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_structuredCastInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_structuredCastInstructionForGeneration * p = dynamic_cast <const GGS_structuredCastInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_structuredCastInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_structuredCastInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_structuredCastInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'cPtr_addAssignInstructionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_addAssignInstructionForGeneration::
cPtr_addAssignInstructionForGeneration (const GGS_string& argument_0,
                                const GGS_unifiedTypeMapProxy & argument_1,
                                const GGS_location & argument_2,
                                const GGS_lstringlist & argument_3,
                                const GGS_semanticExpressionListForGeneration & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (THERE),
mReceiverCppName (argument_0),
mTargetType (argument_1),
mInstructionLocation (argument_2),
mStructAttributeList (argument_3),
mExpressionList (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_addAssignInstructionForGeneration * GGS_addAssignInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_addAssignInstructionForGeneration) ;
    return (cPtr_addAssignInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_addAssignInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_addAssignInstructionForGeneration * ptr = dynamic_cast <const cPtr_addAssignInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mReceiverCppName.operator_isEqual (ptr->mReceiverCppName).boolValue ()
         && mTargetType.operator_isEqual (ptr->mTargetType).boolValue ()
         && mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mStructAttributeList.operator_isEqual (ptr->mStructAttributeList).boolValue ()
         && mExpressionList.operator_isEqual (ptr->mExpressionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_addAssignInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@addAssignInstructionForGeneration:"
           << mReceiverCppName.reader_description (inIndentation + 1)
           << mTargetType.reader_description (inIndentation + 1)
           << mInstructionLocation.reader_description (inIndentation + 1)
           << mStructAttributeList.reader_description (inIndentation + 1)
           << mExpressionList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_addAssignInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_addAssignInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_addAssignInstructionForGeneration (& typeid (cPtr_addAssignInstructionForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_addAssignInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__addAssignInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_addAssignInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_addAssignInstructionForGeneration (mReceiverCppName, mTargetType, mInstructionLocation, mStructAttributeList, mExpressionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_addAssignInstructionForGeneration'            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_addAssignInstructionForGeneration ("addAssignInstructionForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_addAssignInstructionForGeneration::
GGS_addAssignInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_addAssignInstructionForGeneration::
GGS_addAssignInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_addAssignInstructionForGeneration GGS_addAssignInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_addAssignInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_addAssignInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_addAssignInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_addAssignInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_addAssignInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_addAssignInstructionForGeneration GGS_addAssignInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0,
                 const GGS_unifiedTypeMapProxy & argument_1,
                 const GGS_location & argument_2,
                 const GGS_lstringlist & argument_3,
                 const GGS_semanticExpressionListForGeneration & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_addAssignInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_addAssignInstructionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_addAssignInstructionForGeneration::
reader_mReceiverCppName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_addAssignInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_addAssignInstructionForGeneration *) mPointer)->mReceiverCppName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapProxy  GGS_addAssignInstructionForGeneration::
reader_mTargetType (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_unifiedTypeMapProxy   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_addAssignInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_addAssignInstructionForGeneration *) mPointer)->mTargetType ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_addAssignInstructionForGeneration::
reader_mInstructionLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_addAssignInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_addAssignInstructionForGeneration *) mPointer)->mInstructionLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_addAssignInstructionForGeneration::
reader_mStructAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_addAssignInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_addAssignInstructionForGeneration *) mPointer)->mStructAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionListForGeneration  GGS_addAssignInstructionForGeneration::
reader_mExpressionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_addAssignInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_addAssignInstructionForGeneration *) mPointer)->mExpressionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_addAssignInstructionForGeneration::actualTypeName (void) const {
  return "addAssignInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__addAssignInstructionForGeneration ("addAssignInstructionForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_addAssignInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_addAssignInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_addAssignInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_addAssignInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_addAssignInstructionForGeneration GGS_addAssignInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_addAssignInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_addAssignInstructionForGeneration * p = dynamic_cast <const GGS_addAssignInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_addAssignInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_addAssignInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_addAssignInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'cPtr_incrementInstructionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_incrementInstructionForGeneration::
cPtr_incrementInstructionForGeneration (const GGS_location & argument_0,
                                const GGS_string& argument_1,
                                const GGS_unifiedTypeMapProxy & argument_2,
                                const GGS_lstringlist & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (THERE),
mInstructionLocation (argument_0),
mReceiverCppName (argument_1),
mReceiverType (argument_2),
mStructAttributeList (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_incrementInstructionForGeneration * GGS_incrementInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_incrementInstructionForGeneration) ;
    return (cPtr_incrementInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_incrementInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_incrementInstructionForGeneration * ptr = dynamic_cast <const cPtr_incrementInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mReceiverCppName.operator_isEqual (ptr->mReceiverCppName).boolValue ()
         && mReceiverType.operator_isEqual (ptr->mReceiverType).boolValue ()
         && mStructAttributeList.operator_isEqual (ptr->mStructAttributeList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_incrementInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@incrementInstructionForGeneration:"
           << mInstructionLocation.reader_description (inIndentation + 1)
           << mReceiverCppName.reader_description (inIndentation + 1)
           << mReceiverType.reader_description (inIndentation + 1)
           << mStructAttributeList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_incrementInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_incrementInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_incrementInstructionForGeneration (& typeid (cPtr_incrementInstructionForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_incrementInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__incrementInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_incrementInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_incrementInstructionForGeneration (mInstructionLocation, mReceiverCppName, mReceiverType, mStructAttributeList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_incrementInstructionForGeneration'            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_incrementInstructionForGeneration ("incrementInstructionForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_incrementInstructionForGeneration::
GGS_incrementInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_incrementInstructionForGeneration::
GGS_incrementInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_incrementInstructionForGeneration GGS_incrementInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_incrementInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_incrementInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_incrementInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_incrementInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_incrementInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_incrementInstructionForGeneration GGS_incrementInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_string& argument_1,
                 const GGS_unifiedTypeMapProxy & argument_2,
                 const GGS_lstringlist & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_incrementInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_incrementInstructionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_incrementInstructionForGeneration::
reader_mInstructionLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_incrementInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_incrementInstructionForGeneration *) mPointer)->mInstructionLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_incrementInstructionForGeneration::
reader_mReceiverCppName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_incrementInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_incrementInstructionForGeneration *) mPointer)->mReceiverCppName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapProxy  GGS_incrementInstructionForGeneration::
reader_mReceiverType (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_unifiedTypeMapProxy   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_incrementInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_incrementInstructionForGeneration *) mPointer)->mReceiverType ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_incrementInstructionForGeneration::
reader_mStructAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_incrementInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_incrementInstructionForGeneration *) mPointer)->mStructAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_incrementInstructionForGeneration::actualTypeName (void) const {
  return "incrementInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__incrementInstructionForGeneration ("incrementInstructionForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_incrementInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_incrementInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_incrementInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_incrementInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_incrementInstructionForGeneration GGS_incrementInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_incrementInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_incrementInstructionForGeneration * p = dynamic_cast <const GGS_incrementInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_incrementInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_incrementInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_incrementInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'cPtr_decrementInstructionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_decrementInstructionForGeneration::
cPtr_decrementInstructionForGeneration (const GGS_location & argument_0,
                                const GGS_string& argument_1,
                                const GGS_unifiedTypeMapProxy & argument_2,
                                const GGS_lstringlist & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (THERE),
mInstructionLocation (argument_0),
mReceiverCppName (argument_1),
mReceiverType (argument_2),
mStructAttributeList (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_decrementInstructionForGeneration * GGS_decrementInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_decrementInstructionForGeneration) ;
    return (cPtr_decrementInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_decrementInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_decrementInstructionForGeneration * ptr = dynamic_cast <const cPtr_decrementInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mReceiverCppName.operator_isEqual (ptr->mReceiverCppName).boolValue ()
         && mReceiverType.operator_isEqual (ptr->mReceiverType).boolValue ()
         && mStructAttributeList.operator_isEqual (ptr->mStructAttributeList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_decrementInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@decrementInstructionForGeneration:"
           << mInstructionLocation.reader_description (inIndentation + 1)
           << mReceiverCppName.reader_description (inIndentation + 1)
           << mReceiverType.reader_description (inIndentation + 1)
           << mStructAttributeList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_decrementInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_decrementInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_decrementInstructionForGeneration (& typeid (cPtr_decrementInstructionForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_decrementInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__decrementInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_decrementInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_decrementInstructionForGeneration (mInstructionLocation, mReceiverCppName, mReceiverType, mStructAttributeList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_decrementInstructionForGeneration'            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_decrementInstructionForGeneration ("decrementInstructionForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_decrementInstructionForGeneration::
GGS_decrementInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_decrementInstructionForGeneration::
GGS_decrementInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_decrementInstructionForGeneration GGS_decrementInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_decrementInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_decrementInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_decrementInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_decrementInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_decrementInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_decrementInstructionForGeneration GGS_decrementInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_string& argument_1,
                 const GGS_unifiedTypeMapProxy & argument_2,
                 const GGS_lstringlist & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_decrementInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_decrementInstructionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_decrementInstructionForGeneration::
reader_mInstructionLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_decrementInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_decrementInstructionForGeneration *) mPointer)->mInstructionLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_decrementInstructionForGeneration::
reader_mReceiverCppName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_decrementInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_decrementInstructionForGeneration *) mPointer)->mReceiverCppName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapProxy  GGS_decrementInstructionForGeneration::
reader_mReceiverType (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_unifiedTypeMapProxy   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_decrementInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_decrementInstructionForGeneration *) mPointer)->mReceiverType ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_decrementInstructionForGeneration::
reader_mStructAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_decrementInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_decrementInstructionForGeneration *) mPointer)->mStructAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_decrementInstructionForGeneration::actualTypeName (void) const {
  return "decrementInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__decrementInstructionForGeneration ("decrementInstructionForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_decrementInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_decrementInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_decrementInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_decrementInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_decrementInstructionForGeneration GGS_decrementInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_decrementInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_decrementInstructionForGeneration * p = dynamic_cast <const GGS_decrementInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_decrementInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_decrementInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_decrementInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_loopInstructionForGeneration'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_loopInstructionForGeneration::
cPtr_loopInstructionForGeneration (const GGS_location & argument_0,
                                const GGS_semanticExpressionForGeneration & argument_1,
                                const GGS_semanticInstructionListForGeneration & argument_2,
                                const GGS_semanticExpressionForGeneration & argument_3,
                                const GGS_semanticInstructionListForGeneration & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (THERE),
mInstructionLocation (argument_0),
mVariantExpression (argument_1),
mFirstInstructions (argument_2),
mLoopExpression (argument_3),
mSecondInstructions (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_loopInstructionForGeneration * GGS_loopInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_loopInstructionForGeneration) ;
    return (cPtr_loopInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_loopInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_loopInstructionForGeneration * ptr = dynamic_cast <const cPtr_loopInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mVariantExpression.operator_isEqual (ptr->mVariantExpression).boolValue ()
         && mFirstInstructions.operator_isEqual (ptr->mFirstInstructions).boolValue ()
         && mLoopExpression.operator_isEqual (ptr->mLoopExpression).boolValue ()
         && mSecondInstructions.operator_isEqual (ptr->mSecondInstructions).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_loopInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@loopInstructionForGeneration:"
           << mInstructionLocation.reader_description (inIndentation + 1)
           << mVariantExpression.reader_description (inIndentation + 1)
           << mFirstInstructions.reader_description (inIndentation + 1)
           << mLoopExpression.reader_description (inIndentation + 1)
           << mSecondInstructions.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_loopInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_loopInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_loopInstructionForGeneration (& typeid (cPtr_loopInstructionForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_loopInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__loopInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_loopInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_loopInstructionForGeneration (mInstructionLocation, mVariantExpression, mFirstInstructions, mLoopExpression, mSecondInstructions COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_loopInstructionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_loopInstructionForGeneration ("loopInstructionForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_loopInstructionForGeneration::
GGS_loopInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_loopInstructionForGeneration::
GGS_loopInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_loopInstructionForGeneration GGS_loopInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_loopInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_loopInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_loopInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_loopInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_loopInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_loopInstructionForGeneration GGS_loopInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionForGeneration & argument_1,
                 const GGS_semanticInstructionListForGeneration & argument_2,
                 const GGS_semanticExpressionForGeneration & argument_3,
                 const GGS_semanticInstructionListForGeneration & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_loopInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_loopInstructionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_loopInstructionForGeneration::
reader_mInstructionLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_loopInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_loopInstructionForGeneration *) mPointer)->mInstructionLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_loopInstructionForGeneration::
reader_mVariantExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_loopInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_loopInstructionForGeneration *) mPointer)->mVariantExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration  GGS_loopInstructionForGeneration::
reader_mFirstInstructions (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_loopInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_loopInstructionForGeneration *) mPointer)->mFirstInstructions ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_loopInstructionForGeneration::
reader_mLoopExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_loopInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_loopInstructionForGeneration *) mPointer)->mLoopExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration  GGS_loopInstructionForGeneration::
reader_mSecondInstructions (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_loopInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_loopInstructionForGeneration *) mPointer)->mSecondInstructions ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_loopInstructionForGeneration::actualTypeName (void) const {
  return "loopInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__loopInstructionForGeneration ("loopInstructionForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_loopInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_loopInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_loopInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_loopInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_loopInstructionForGeneration GGS_loopInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_loopInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_loopInstructionForGeneration * p = dynamic_cast <const GGS_loopInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_loopInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_loopInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_loopInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_messageInstructionForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_messageInstructionForGeneration::
cPtr_messageInstructionForGeneration (const GGS_semanticExpressionForGeneration & argument_0,
                                const GGS_location & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (THERE),
mExpression (argument_0),
mInstructionLocation (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_messageInstructionForGeneration * GGS_messageInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_messageInstructionForGeneration) ;
    return (cPtr_messageInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_messageInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_messageInstructionForGeneration * ptr = dynamic_cast <const cPtr_messageInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mExpression.operator_isEqual (ptr->mExpression).boolValue ()
         && mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_messageInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@messageInstructionForGeneration:"
           << mExpression.reader_description (inIndentation + 1)
           << mInstructionLocation.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_messageInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_messageInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_messageInstructionForGeneration (& typeid (cPtr_messageInstructionForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_messageInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__messageInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_messageInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_messageInstructionForGeneration (mExpression, mInstructionLocation COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_messageInstructionForGeneration'             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_messageInstructionForGeneration ("messageInstructionForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_messageInstructionForGeneration::
GGS_messageInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_messageInstructionForGeneration::
GGS_messageInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_messageInstructionForGeneration GGS_messageInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_messageInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_messageInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_messageInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_messageInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_messageInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_messageInstructionForGeneration GGS_messageInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_semanticExpressionForGeneration & argument_0,
                 const GGS_location & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_messageInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_messageInstructionForGeneration (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_messageInstructionForGeneration::
reader_mExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_messageInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_messageInstructionForGeneration *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_messageInstructionForGeneration::
reader_mInstructionLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_messageInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_messageInstructionForGeneration *) mPointer)->mInstructionLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_messageInstructionForGeneration::actualTypeName (void) const {
  return "messageInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__messageInstructionForGeneration ("messageInstructionForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_messageInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_messageInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_messageInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_messageInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_messageInstructionForGeneration GGS_messageInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_messageInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_messageInstructionForGeneration * p = dynamic_cast <const GGS_messageInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_messageInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_messageInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_messageInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_logInstructionForGeneration'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_logInstructionForGeneration::
cPtr_logInstructionForGeneration (const GGS_string& argument_0,
                                const GGS_semanticExpressionForGeneration & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (THERE),
mLogMessage (argument_0),
mLogExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_logInstructionForGeneration * GGS_logInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_logInstructionForGeneration) ;
    return (cPtr_logInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_logInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_logInstructionForGeneration * ptr = dynamic_cast <const cPtr_logInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLogMessage.operator_isEqual (ptr->mLogMessage).boolValue ()
         && mLogExpression.operator_isEqual (ptr->mLogExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_logInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@logInstructionForGeneration:"
           << mLogMessage.reader_description (inIndentation + 1)
           << mLogExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_logInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_logInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_logInstructionForGeneration (& typeid (cPtr_logInstructionForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_logInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__logInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_logInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_logInstructionForGeneration (mLogMessage, mLogExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_logInstructionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_logInstructionForGeneration ("logInstructionForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_logInstructionForGeneration::
GGS_logInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_logInstructionForGeneration::
GGS_logInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_logInstructionForGeneration GGS_logInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_logInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_logInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_logInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_logInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_logInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_logInstructionForGeneration GGS_logInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0,
                 const GGS_semanticExpressionForGeneration & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_logInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_logInstructionForGeneration (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_logInstructionForGeneration::
reader_mLogMessage (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_logInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_logInstructionForGeneration *) mPointer)->mLogMessage ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_logInstructionForGeneration::
reader_mLogExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_logInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_logInstructionForGeneration *) mPointer)->mLogExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_logInstructionForGeneration::actualTypeName (void) const {
  return "logInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__logInstructionForGeneration ("logInstructionForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_logInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_logInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_logInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_logInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_logInstructionForGeneration GGS_logInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_logInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_logInstructionForGeneration * p = dynamic_cast <const GGS_logInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_logInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_logInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_logInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        class 'cPtr_grammarInstructionWithSourceFileForGeneration'         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_grammarInstructionWithSourceFileForGeneration::
cPtr_grammarInstructionWithSourceFileForGeneration (const GGS_location & argument_0,
                                const GGS_string& argument_1,
                                const GGS_string& argument_2,
                                const GGS_semanticExpressionForGeneration & argument_3,
                                const GGS_actualParameterListForGeneration & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (THERE),
mInstructionLocation (argument_0),
mGrammarName (argument_1),
mLabelName (argument_2),
mSourceFileExpression (argument_3),
mActualParameterList (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_grammarInstructionWithSourceFileForGeneration * GGS_grammarInstructionWithSourceFileForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_grammarInstructionWithSourceFileForGeneration) ;
    return (cPtr_grammarInstructionWithSourceFileForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_grammarInstructionWithSourceFileForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_grammarInstructionWithSourceFileForGeneration * ptr = dynamic_cast <const cPtr_grammarInstructionWithSourceFileForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mGrammarName.operator_isEqual (ptr->mGrammarName).boolValue ()
         && mLabelName.operator_isEqual (ptr->mLabelName).boolValue ()
         && mSourceFileExpression.operator_isEqual (ptr->mSourceFileExpression).boolValue ()
         && mActualParameterList.operator_isEqual (ptr->mActualParameterList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_grammarInstructionWithSourceFileForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@grammarInstructionWithSourceFileForGeneration:"
           << mInstructionLocation.reader_description (inIndentation + 1)
           << mGrammarName.reader_description (inIndentation + 1)
           << mLabelName.reader_description (inIndentation + 1)
           << mSourceFileExpression.reader_description (inIndentation + 1)
           << mActualParameterList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_grammarInstructionWithSourceFileForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_grammarInstructionWithSourceFileForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_grammarInstructionWithSourceFileForGeneration (& typeid (cPtr_grammarInstructionWithSourceFileForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_grammarInstructionWithSourceFileForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__grammarInstructionWithSourceFileForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_grammarInstructionWithSourceFileForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_grammarInstructionWithSourceFileForGeneration (mInstructionLocation, mGrammarName, mLabelName, mSourceFileExpression, mActualParameterList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//     GALGAS class 'GGS_grammarInstructionWithSourceFileForGeneration'      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_grammarInstructionWithSourceFileForGeneration ("grammarInstructionWithSourceFileForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_grammarInstructionWithSourceFileForGeneration::
GGS_grammarInstructionWithSourceFileForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_grammarInstructionWithSourceFileForGeneration::
GGS_grammarInstructionWithSourceFileForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_grammarInstructionWithSourceFileForGeneration GGS_grammarInstructionWithSourceFileForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_grammarInstructionWithSourceFileForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_grammarInstructionWithSourceFileForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_grammarInstructionWithSourceFileForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_grammarInstructionWithSourceFileForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_grammarInstructionWithSourceFileForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_grammarInstructionWithSourceFileForGeneration GGS_grammarInstructionWithSourceFileForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_string& argument_1,
                 const GGS_string& argument_2,
                 const GGS_semanticExpressionForGeneration & argument_3,
                 const GGS_actualParameterListForGeneration & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_grammarInstructionWithSourceFileForGeneration result ;
  macroMyNew (result.mPointer, cPtr_grammarInstructionWithSourceFileForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_grammarInstructionWithSourceFileForGeneration::
reader_mInstructionLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_grammarInstructionWithSourceFileForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_grammarInstructionWithSourceFileForGeneration *) mPointer)->mInstructionLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_grammarInstructionWithSourceFileForGeneration::
reader_mGrammarName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_grammarInstructionWithSourceFileForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_grammarInstructionWithSourceFileForGeneration *) mPointer)->mGrammarName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_grammarInstructionWithSourceFileForGeneration::
reader_mLabelName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_grammarInstructionWithSourceFileForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_grammarInstructionWithSourceFileForGeneration *) mPointer)->mLabelName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_grammarInstructionWithSourceFileForGeneration::
reader_mSourceFileExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_grammarInstructionWithSourceFileForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_grammarInstructionWithSourceFileForGeneration *) mPointer)->mSourceFileExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameterListForGeneration  GGS_grammarInstructionWithSourceFileForGeneration::
reader_mActualParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_actualParameterListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_grammarInstructionWithSourceFileForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_grammarInstructionWithSourceFileForGeneration *) mPointer)->mActualParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_grammarInstructionWithSourceFileForGeneration::actualTypeName (void) const {
  return "grammarInstructionWithSourceFileForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__grammarInstructionWithSourceFileForGeneration ("grammarInstructionWithSourceFileForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_grammarInstructionWithSourceFileForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_grammarInstructionWithSourceFileForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_grammarInstructionWithSourceFileForGeneration * p = NULL ;
    macroMyNew (p, GGS_grammarInstructionWithSourceFileForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_grammarInstructionWithSourceFileForGeneration GGS_grammarInstructionWithSourceFileForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_grammarInstructionWithSourceFileForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_grammarInstructionWithSourceFileForGeneration * p = dynamic_cast <const GGS_grammarInstructionWithSourceFileForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_grammarInstructionWithSourceFileForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_grammarInstructionWithSourceFileForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_grammarInstructionWithSourceFileForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//     class 'cPtr_grammarInstructionWithSourceExpressionForGeneration'      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_grammarInstructionWithSourceExpressionForGeneration::
cPtr_grammarInstructionWithSourceExpressionForGeneration (const GGS_location & argument_0,
                                const GGS_string& argument_1,
                                const GGS_string& argument_2,
                                const GGS_semanticExpressionForGeneration & argument_3,
                                const GGS_actualParameterListForGeneration & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (THERE),
mInstructionLocation (argument_0),
mGrammarName (argument_1),
mLabelName (argument_2),
mSourceStringExpression (argument_3),
mActualParameterList (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_grammarInstructionWithSourceExpressionForGeneration * GGS_grammarInstructionWithSourceExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_grammarInstructionWithSourceExpressionForGeneration) ;
    return (cPtr_grammarInstructionWithSourceExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_grammarInstructionWithSourceExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_grammarInstructionWithSourceExpressionForGeneration * ptr = dynamic_cast <const cPtr_grammarInstructionWithSourceExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mGrammarName.operator_isEqual (ptr->mGrammarName).boolValue ()
         && mLabelName.operator_isEqual (ptr->mLabelName).boolValue ()
         && mSourceStringExpression.operator_isEqual (ptr->mSourceStringExpression).boolValue ()
         && mActualParameterList.operator_isEqual (ptr->mActualParameterList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_grammarInstructionWithSourceExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@grammarInstructionWithSourceExpressionForGeneration:"
           << mInstructionLocation.reader_description (inIndentation + 1)
           << mGrammarName.reader_description (inIndentation + 1)
           << mLabelName.reader_description (inIndentation + 1)
           << mSourceStringExpression.reader_description (inIndentation + 1)
           << mActualParameterList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_grammarInstructionWithSourceExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_grammarInstructionWithSourceExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_grammarInstructionWithSourceExpressionForGeneration (& typeid (cPtr_grammarInstructionWithSourceExpressionForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_grammarInstructionWithSourceExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__grammarInstructionWithSourceExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_grammarInstructionWithSourceExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_grammarInstructionWithSourceExpressionForGeneration (mInstructionLocation, mGrammarName, mLabelName, mSourceStringExpression, mActualParameterList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//  GALGAS class 'GGS_grammarInstructionWithSourceExpressionForGeneration'   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_grammarInstructionWithSourceExpressionForGeneration ("grammarInstructionWithSourceExpressionForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_grammarInstructionWithSourceExpressionForGeneration::
GGS_grammarInstructionWithSourceExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_grammarInstructionWithSourceExpressionForGeneration::
GGS_grammarInstructionWithSourceExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_grammarInstructionWithSourceExpressionForGeneration GGS_grammarInstructionWithSourceExpressionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_grammarInstructionWithSourceExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_grammarInstructionWithSourceExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_grammarInstructionWithSourceExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_grammarInstructionWithSourceExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_grammarInstructionWithSourceExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_grammarInstructionWithSourceExpressionForGeneration GGS_grammarInstructionWithSourceExpressionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_string& argument_1,
                 const GGS_string& argument_2,
                 const GGS_semanticExpressionForGeneration & argument_3,
                 const GGS_actualParameterListForGeneration & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_grammarInstructionWithSourceExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_grammarInstructionWithSourceExpressionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_grammarInstructionWithSourceExpressionForGeneration::
reader_mInstructionLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_grammarInstructionWithSourceExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_grammarInstructionWithSourceExpressionForGeneration *) mPointer)->mInstructionLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_grammarInstructionWithSourceExpressionForGeneration::
reader_mGrammarName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_grammarInstructionWithSourceExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_grammarInstructionWithSourceExpressionForGeneration *) mPointer)->mGrammarName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_grammarInstructionWithSourceExpressionForGeneration::
reader_mLabelName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_grammarInstructionWithSourceExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_grammarInstructionWithSourceExpressionForGeneration *) mPointer)->mLabelName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_grammarInstructionWithSourceExpressionForGeneration::
reader_mSourceStringExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_grammarInstructionWithSourceExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_grammarInstructionWithSourceExpressionForGeneration *) mPointer)->mSourceStringExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameterListForGeneration  GGS_grammarInstructionWithSourceExpressionForGeneration::
reader_mActualParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_actualParameterListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_grammarInstructionWithSourceExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_grammarInstructionWithSourceExpressionForGeneration *) mPointer)->mActualParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_grammarInstructionWithSourceExpressionForGeneration::actualTypeName (void) const {
  return "grammarInstructionWithSourceExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__grammarInstructionWithSourceExpressionForGeneration ("grammarInstructionWithSourceExpressionForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_grammarInstructionWithSourceExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_grammarInstructionWithSourceExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_grammarInstructionWithSourceExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_grammarInstructionWithSourceExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_grammarInstructionWithSourceExpressionForGeneration GGS_grammarInstructionWithSourceExpressionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_grammarInstructionWithSourceExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_grammarInstructionWithSourceExpressionForGeneration * p = dynamic_cast <const GGS_grammarInstructionWithSourceExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_grammarInstructionWithSourceExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_grammarInstructionWithSourceExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_grammarInstructionWithSourceExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            class 'cPtr_readWriteWithInstructionForGeneration'             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_readWriteWithInstructionForGeneration::
cPtr_readWriteWithInstructionForGeneration (const GGS_string& argument_0,
                                const GGS_unifiedTypeMapProxy & argument_1,
                                const GGS_lstringlist & argument_2,
                                const GGS_string& argument_3,
                                const GGS_string& argument_4,
                                const GGS_semanticExpressionForGeneration & argument_5,
                                const GGS_semanticInstructionListForGeneration & argument_6,
                                const GGS_semanticInstructionListForGeneration & argument_7
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (THERE),
mReceiverVariableCppName (argument_0),
mReceiverType (argument_1),
mStructAttributeList (argument_2),
mAccessName (argument_3),
mObjectArrayCppName (argument_4),
mKeyExpression (argument_5),
mDoBranchInstructions (argument_6),
mElseBranchInstructions (argument_7) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_readWriteWithInstructionForGeneration * GGS_readWriteWithInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_readWriteWithInstructionForGeneration) ;
    return (cPtr_readWriteWithInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_readWriteWithInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_readWriteWithInstructionForGeneration * ptr = dynamic_cast <const cPtr_readWriteWithInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mReceiverVariableCppName.operator_isEqual (ptr->mReceiverVariableCppName).boolValue ()
         && mReceiverType.operator_isEqual (ptr->mReceiverType).boolValue ()
         && mStructAttributeList.operator_isEqual (ptr->mStructAttributeList).boolValue ()
         && mAccessName.operator_isEqual (ptr->mAccessName).boolValue ()
         && mObjectArrayCppName.operator_isEqual (ptr->mObjectArrayCppName).boolValue ()
         && mKeyExpression.operator_isEqual (ptr->mKeyExpression).boolValue ()
         && mDoBranchInstructions.operator_isEqual (ptr->mDoBranchInstructions).boolValue ()
         && mElseBranchInstructions.operator_isEqual (ptr->mElseBranchInstructions).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_readWriteWithInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@readWriteWithInstructionForGeneration:"
           << mReceiverVariableCppName.reader_description (inIndentation + 1)
           << mReceiverType.reader_description (inIndentation + 1)
           << mStructAttributeList.reader_description (inIndentation + 1)
           << mAccessName.reader_description (inIndentation + 1)
           << mObjectArrayCppName.reader_description (inIndentation + 1)
           << mKeyExpression.reader_description (inIndentation + 1)
           << mDoBranchInstructions.reader_description (inIndentation + 1)
           << mElseBranchInstructions.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_readWriteWithInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_readWriteWithInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_readWriteWithInstructionForGeneration (& typeid (cPtr_readWriteWithInstructionForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_readWriteWithInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__readWriteWithInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_readWriteWithInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_readWriteWithInstructionForGeneration (mReceiverVariableCppName, mReceiverType, mStructAttributeList, mAccessName, mObjectArrayCppName, mKeyExpression, mDoBranchInstructions, mElseBranchInstructions COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         GALGAS class 'GGS_readWriteWithInstructionForGeneration'          *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_readWriteWithInstructionForGeneration ("readWriteWithInstructionForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_readWriteWithInstructionForGeneration::
GGS_readWriteWithInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_readWriteWithInstructionForGeneration::
GGS_readWriteWithInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_readWriteWithInstructionForGeneration GGS_readWriteWithInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_readWriteWithInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_readWriteWithInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_readWriteWithInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_readWriteWithInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_readWriteWithInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_readWriteWithInstructionForGeneration GGS_readWriteWithInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0,
                 const GGS_unifiedTypeMapProxy & argument_1,
                 const GGS_lstringlist & argument_2,
                 const GGS_string& argument_3,
                 const GGS_string& argument_4,
                 const GGS_semanticExpressionForGeneration & argument_5,
                 const GGS_semanticInstructionListForGeneration & argument_6,
                 const GGS_semanticInstructionListForGeneration & argument_7
                                COMMA_LOCATION_ARGS) {
  GGS_readWriteWithInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_readWriteWithInstructionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_readWriteWithInstructionForGeneration::
reader_mReceiverVariableCppName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_readWriteWithInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_readWriteWithInstructionForGeneration *) mPointer)->mReceiverVariableCppName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapProxy  GGS_readWriteWithInstructionForGeneration::
reader_mReceiverType (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_unifiedTypeMapProxy   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_readWriteWithInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_readWriteWithInstructionForGeneration *) mPointer)->mReceiverType ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_readWriteWithInstructionForGeneration::
reader_mStructAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_readWriteWithInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_readWriteWithInstructionForGeneration *) mPointer)->mStructAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_readWriteWithInstructionForGeneration::
reader_mAccessName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_readWriteWithInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_readWriteWithInstructionForGeneration *) mPointer)->mAccessName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_readWriteWithInstructionForGeneration::
reader_mObjectArrayCppName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_readWriteWithInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_readWriteWithInstructionForGeneration *) mPointer)->mObjectArrayCppName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_readWriteWithInstructionForGeneration::
reader_mKeyExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_readWriteWithInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_readWriteWithInstructionForGeneration *) mPointer)->mKeyExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration  GGS_readWriteWithInstructionForGeneration::
reader_mDoBranchInstructions (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_readWriteWithInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_readWriteWithInstructionForGeneration *) mPointer)->mDoBranchInstructions ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration  GGS_readWriteWithInstructionForGeneration::
reader_mElseBranchInstructions (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_readWriteWithInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_readWriteWithInstructionForGeneration *) mPointer)->mElseBranchInstructions ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_readWriteWithInstructionForGeneration::actualTypeName (void) const {
  return "readWriteWithInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__readWriteWithInstructionForGeneration ("readWriteWithInstructionForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_readWriteWithInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_readWriteWithInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_readWriteWithInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_readWriteWithInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_readWriteWithInstructionForGeneration GGS_readWriteWithInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_readWriteWithInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_readWriteWithInstructionForGeneration * p = dynamic_cast <const GGS_readWriteWithInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_readWriteWithInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_readWriteWithInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_readWriteWithInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            class 'cPtr_readOnlyWithInstructionForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_readOnlyWithInstructionForGeneration::
cPtr_readOnlyWithInstructionForGeneration (const GGS_semanticExpressionForGeneration & argument_0,
                                const GGS_string& argument_1,
                                const GGS_string& argument_2,
                                const GGS_semanticExpressionForGeneration & argument_3,
                                const GGS_semanticInstructionListForGeneration & argument_4,
                                const GGS_semanticInstructionListForGeneration & argument_5
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (THERE),
mReceiverExpression (argument_0),
mAccessName (argument_1),
mObjectArrayCppName (argument_2),
mKeyExpression (argument_3),
mDoBranchInstructions (argument_4),
mElseBranchInstructions (argument_5) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_readOnlyWithInstructionForGeneration * GGS_readOnlyWithInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_readOnlyWithInstructionForGeneration) ;
    return (cPtr_readOnlyWithInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_readOnlyWithInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_readOnlyWithInstructionForGeneration * ptr = dynamic_cast <const cPtr_readOnlyWithInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mReceiverExpression.operator_isEqual (ptr->mReceiverExpression).boolValue ()
         && mAccessName.operator_isEqual (ptr->mAccessName).boolValue ()
         && mObjectArrayCppName.operator_isEqual (ptr->mObjectArrayCppName).boolValue ()
         && mKeyExpression.operator_isEqual (ptr->mKeyExpression).boolValue ()
         && mDoBranchInstructions.operator_isEqual (ptr->mDoBranchInstructions).boolValue ()
         && mElseBranchInstructions.operator_isEqual (ptr->mElseBranchInstructions).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_readOnlyWithInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@readOnlyWithInstructionForGeneration:"
           << mReceiverExpression.reader_description (inIndentation + 1)
           << mAccessName.reader_description (inIndentation + 1)
           << mObjectArrayCppName.reader_description (inIndentation + 1)
           << mKeyExpression.reader_description (inIndentation + 1)
           << mDoBranchInstructions.reader_description (inIndentation + 1)
           << mElseBranchInstructions.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_readOnlyWithInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_readOnlyWithInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_readOnlyWithInstructionForGeneration (& typeid (cPtr_readOnlyWithInstructionForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_readOnlyWithInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__readOnlyWithInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_readOnlyWithInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_readOnlyWithInstructionForGeneration (mReceiverExpression, mAccessName, mObjectArrayCppName, mKeyExpression, mDoBranchInstructions, mElseBranchInstructions COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         GALGAS class 'GGS_readOnlyWithInstructionForGeneration'           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_readOnlyWithInstructionForGeneration ("readOnlyWithInstructionForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_readOnlyWithInstructionForGeneration::
GGS_readOnlyWithInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_readOnlyWithInstructionForGeneration::
GGS_readOnlyWithInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_readOnlyWithInstructionForGeneration GGS_readOnlyWithInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_readOnlyWithInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_readOnlyWithInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_readOnlyWithInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_readOnlyWithInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_readOnlyWithInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_readOnlyWithInstructionForGeneration GGS_readOnlyWithInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_semanticExpressionForGeneration & argument_0,
                 const GGS_string& argument_1,
                 const GGS_string& argument_2,
                 const GGS_semanticExpressionForGeneration & argument_3,
                 const GGS_semanticInstructionListForGeneration & argument_4,
                 const GGS_semanticInstructionListForGeneration & argument_5
                                COMMA_LOCATION_ARGS) {
  GGS_readOnlyWithInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_readOnlyWithInstructionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_readOnlyWithInstructionForGeneration::
reader_mReceiverExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_readOnlyWithInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_readOnlyWithInstructionForGeneration *) mPointer)->mReceiverExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_readOnlyWithInstructionForGeneration::
reader_mAccessName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_readOnlyWithInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_readOnlyWithInstructionForGeneration *) mPointer)->mAccessName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_readOnlyWithInstructionForGeneration::
reader_mObjectArrayCppName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_readOnlyWithInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_readOnlyWithInstructionForGeneration *) mPointer)->mObjectArrayCppName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_readOnlyWithInstructionForGeneration::
reader_mKeyExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_readOnlyWithInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_readOnlyWithInstructionForGeneration *) mPointer)->mKeyExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration  GGS_readOnlyWithInstructionForGeneration::
reader_mDoBranchInstructions (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_readOnlyWithInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_readOnlyWithInstructionForGeneration *) mPointer)->mDoBranchInstructions ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration  GGS_readOnlyWithInstructionForGeneration::
reader_mElseBranchInstructions (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_readOnlyWithInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_readOnlyWithInstructionForGeneration *) mPointer)->mElseBranchInstructions ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_readOnlyWithInstructionForGeneration::actualTypeName (void) const {
  return "readOnlyWithInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__readOnlyWithInstructionForGeneration ("readOnlyWithInstructionForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_readOnlyWithInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_readOnlyWithInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_readOnlyWithInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_readOnlyWithInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_readOnlyWithInstructionForGeneration GGS_readOnlyWithInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_readOnlyWithInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_readOnlyWithInstructionForGeneration * p = dynamic_cast <const GGS_readOnlyWithInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_readOnlyWithInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_readOnlyWithInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_readOnlyWithInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@terminalCheckAssignementList'               *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_terminalCheckAssignementList::
elementOf_GGS_terminalCheckAssignementList (const GGS_string& argument_0,
                                const GGS_string& argument_1,
                                const GGS_string& argument_2
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mTypeName (argument_0),
mTargetVarCppName (argument_1),
mSourceLexicalAttributeName (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_terminalCheckAssignementList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_terminalCheckAssignementList * ptr = dynamic_cast <const elementOf_GGS_terminalCheckAssignementList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTypeName.operator_isEqual (ptr->mTypeName).boolValue ()
         && mTargetVarCppName.operator_isEqual (ptr->mTargetVarCppName).boolValue ()
         && mSourceLexicalAttributeName.operator_isEqual (ptr->mSourceLexicalAttributeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_terminalCheckAssignementList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTypeName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTargetVarCppName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSourceLexicalAttributeName.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@terminalCheckAssignementList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_terminalCheckAssignementList ("terminalCheckAssignementList", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_terminalCheckAssignementList::
internalAppendValues (const GGS_string& argument_0,
                    const GGS_string& argument_1,
                    const GGS_string& argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_terminalCheckAssignementList::
internalPrependValues (const GGS_string& argument_0,
                    const GGS_string& argument_1,
                    const GGS_string& argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_terminalCheckAssignementList::
addAssign_operation (const GGS_string& argument_0,
                                const GGS_string& argument_1,
                                const GGS_string& argument_2) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_terminalCheckAssignementList GGS_terminalCheckAssignementList::
operator_concat (const GGS_terminalCheckAssignementList & inOperand) const {
  GGS_terminalCheckAssignementList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_terminalCheckAssignementList::
dotAssign_operation (const GGS_terminalCheckAssignementList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_terminalCheckAssignementList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_string p_0 = p->mTypeName ;
          GGS_string p_1 = p->mTargetVarCppName ;
          GGS_string p_2 = p->mSourceLexicalAttributeName ;
          internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_terminalCheckAssignementList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_string& argument_0,
                     const GGS_string& argument_1,
                     const GGS_string& argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_terminalCheckAssignementList::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mTypeName,
                                ptr->mTargetVarCppName,
                                ptr->mSourceLexicalAttributeName
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_terminalCheckAssignementList  GGS_terminalCheckAssignementList::
constructor_emptyList (void) {
  GGS_terminalCheckAssignementList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_terminalCheckAssignementList  GGS_terminalCheckAssignementList::
constructor_listWithValue (const GGS_string& argument_0,
                                const GGS_string& argument_1,
                                const GGS_string& argument_2) {
  GGS_terminalCheckAssignementList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_terminalCheckAssignementList::
internalSubListWithRange (GGS_terminalCheckAssignementList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mTypeName, ptr->mTargetVarCppName, ptr->mSourceLexicalAttributeName) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_terminalCheckAssignementList GGS_terminalCheckAssignementList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_terminalCheckAssignementList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_terminalCheckAssignementList GGS_terminalCheckAssignementList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_terminalCheckAssignementList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_terminalCheckAssignementList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@terminalCheckAssignementList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_terminalCheckAssignementList::
method_first (C_Compiler & inLexique,
              GGS_string& _out_0,
              GGS_string& _out_1,
              GGS_string& _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mTypeName ;
    _out_1 = ptr->mTargetVarCppName ;
    _out_2 = ptr->mSourceLexicalAttributeName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_terminalCheckAssignementList::
method_last (C_Compiler & inLexique,
             GGS_string& _out_0,
             GGS_string& _out_1,
             GGS_string& _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mTypeName ;
    _out_1 = ptr->mTargetVarCppName ;
    _out_2 = ptr->mSourceLexicalAttributeName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_terminalCheckAssignementList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_string& _out_0,
                 GGS_string& _out_1,
                 GGS_string& _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mTypeName ;
    _out_1 = ptr->mTargetVarCppName ;
    _out_2 = ptr->mSourceLexicalAttributeName ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_terminalCheckAssignementList::
modifier_popLast (C_Compiler & inLexique,
                GGS_string& _out_0,
                GGS_string& _out_1,
                GGS_string& _out_2
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mTypeName ;
    _out_1 = ptr->mTargetVarCppName ;
    _out_2 = ptr->mSourceLexicalAttributeName ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_string GGS_terminalCheckAssignementList::
reader_mTypeNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_string result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mTypeName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_terminalCheckAssignementList::
reader_mTargetVarCppNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_string result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mTargetVarCppName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_terminalCheckAssignementList::
reader_mSourceLexicalAttributeNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_string result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSourceLexicalAttributeName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_terminalCheckAssignementList::
modifier_setMTypeNameAtIndex (C_Compiler & inLexique,
                              const GGS_string & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mTypeName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_terminalCheckAssignementList::
modifier_setMTargetVarCppNameAtIndex (C_Compiler & inLexique,
                              const GGS_string & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mTargetVarCppName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_terminalCheckAssignementList::
modifier_setMSourceLexicalAttributeNameAtIndex (C_Compiler & inLexique,
                              const GGS_string & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSourceLexicalAttributeName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_terminalCheckAssignementList::cEnumerator::_mTypeName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mTypeName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_terminalCheckAssignementList::cEnumerator::_mTargetVarCppName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mTargetVarCppName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_terminalCheckAssignementList::cEnumerator::_mSourceLexicalAttributeName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mSourceLexicalAttributeName ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_terminalCheckAssignementList::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_terminalCheckAssignementList * p = NULL ;
    macroMyNew (p, GGS_terminalCheckAssignementList (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_terminalCheckAssignementList GGS_terminalCheckAssignementList::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_terminalCheckAssignementList result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_terminalCheckAssignementList * p = dynamic_cast <const GGS_terminalCheckAssignementList *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_terminalCheckAssignementList, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_terminalCheckAssignementList::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_terminalCheckAssignementList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_syntaxInstructionForGeneration'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_syntaxInstructionForGeneration::
cPtr_syntaxInstructionForGeneration (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (THERE),
mInstructionLocation (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_syntaxInstructionForGeneration * GGS_syntaxInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_syntaxInstructionForGeneration) ;
    return (cPtr_syntaxInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_syntaxInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@syntaxInstructionForGeneration:"
           << mInstructionLocation.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_syntaxInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_syntaxInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_syntaxInstructionForGeneration (& typeid (cPtr_syntaxInstructionForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_syntaxInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__syntaxInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_syntaxInstructionForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_syntaxInstructionForGeneration ("syntaxInstructionForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_syntaxInstructionForGeneration::
GGS_syntaxInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_syntaxInstructionForGeneration::
GGS_syntaxInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_syntaxInstructionForGeneration GGS_syntaxInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_syntaxInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_syntaxInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_syntaxInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_syntaxInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_syntaxInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_syntaxInstructionForGeneration::
reader_mInstructionLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_syntaxInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_syntaxInstructionForGeneration *) mPointer)->mInstructionLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_syntaxInstructionForGeneration::actualTypeName (void) const {
  return "syntaxInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__syntaxInstructionForGeneration ("syntaxInstructionForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_syntaxInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_syntaxInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_syntaxInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_syntaxInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_syntaxInstructionForGeneration GGS_syntaxInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_syntaxInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_syntaxInstructionForGeneration * p = dynamic_cast <const GGS_syntaxInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_syntaxInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_syntaxInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_syntaxInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            class 'cPtr_terminalCheckInstructionForGeneration'             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_terminalCheckInstructionForGeneration::
cPtr_terminalCheckInstructionForGeneration (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_string& argument_2,
                                const GGS_terminalCheckAssignementList & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_syntaxInstructionForGeneration (argument_0 COMMA_THERE),
mTerminalName (argument_1),
mLexiqueIdentifier (argument_2),
mTerminalCheckAssignementList (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_terminalCheckInstructionForGeneration * GGS_terminalCheckInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_terminalCheckInstructionForGeneration) ;
    return (cPtr_terminalCheckInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_terminalCheckInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_terminalCheckInstructionForGeneration * ptr = dynamic_cast <const cPtr_terminalCheckInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mTerminalName.operator_isEqual (ptr->mTerminalName).boolValue ()
         && mLexiqueIdentifier.operator_isEqual (ptr->mLexiqueIdentifier).boolValue ()
         && mTerminalCheckAssignementList.operator_isEqual (ptr->mTerminalCheckAssignementList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_terminalCheckInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@terminalCheckInstructionForGeneration:"
           << mInstructionLocation.reader_description (inIndentation + 1)
           << mTerminalName.reader_description (inIndentation + 1)
           << mLexiqueIdentifier.reader_description (inIndentation + 1)
           << mTerminalCheckAssignementList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_terminalCheckInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_terminalCheckInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_terminalCheckInstructionForGeneration (& typeid (cPtr_terminalCheckInstructionForGeneration), & typeid (cPtr_syntaxInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_terminalCheckInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__terminalCheckInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_terminalCheckInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_terminalCheckInstructionForGeneration (mInstructionLocation, mTerminalName, mLexiqueIdentifier, mTerminalCheckAssignementList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         GALGAS class 'GGS_terminalCheckInstructionForGeneration'          *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_terminalCheckInstructionForGeneration ("terminalCheckInstructionForGeneration", true, & kTypeDescriptor_GGS_syntaxInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_terminalCheckInstructionForGeneration::
GGS_terminalCheckInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_terminalCheckInstructionForGeneration::
GGS_terminalCheckInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_terminalCheckInstructionForGeneration GGS_terminalCheckInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_terminalCheckInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_terminalCheckInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_terminalCheckInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_terminalCheckInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_terminalCheckInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_terminalCheckInstructionForGeneration GGS_terminalCheckInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_string& argument_2,
                 const GGS_terminalCheckAssignementList & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_terminalCheckInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_terminalCheckInstructionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_terminalCheckInstructionForGeneration::
reader_mTerminalName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_terminalCheckInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_terminalCheckInstructionForGeneration *) mPointer)->mTerminalName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_terminalCheckInstructionForGeneration::
reader_mLexiqueIdentifier (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_terminalCheckInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_terminalCheckInstructionForGeneration *) mPointer)->mLexiqueIdentifier ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_terminalCheckAssignementList  GGS_terminalCheckInstructionForGeneration::
reader_mTerminalCheckAssignementList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_terminalCheckAssignementList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_terminalCheckInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_terminalCheckInstructionForGeneration *) mPointer)->mTerminalCheckAssignementList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_terminalCheckInstructionForGeneration::actualTypeName (void) const {
  return "terminalCheckInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__terminalCheckInstructionForGeneration ("terminalCheckInstructionForGeneration", gClassInfoFor__syntaxInstructionForGeneration, & kTypeDescriptor_GGS_terminalCheckInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_terminalCheckInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_terminalCheckInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_terminalCheckInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_terminalCheckInstructionForGeneration GGS_terminalCheckInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_terminalCheckInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_terminalCheckInstructionForGeneration * p = dynamic_cast <const GGS_terminalCheckInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_terminalCheckInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_terminalCheckInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_terminalCheckInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_nonterminalInstructionForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_nonterminalInstructionForGeneration::
cPtr_nonterminalInstructionForGeneration (const GGS_location & argument_0,
                                const GGS_string& argument_1,
                                const GGS_string& argument_2,
                                const GGS_actualParameterListForGeneration & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_syntaxInstructionForGeneration (argument_0 COMMA_THERE),
mNonterminalName (argument_1),
mLabelName (argument_2),
mActualParameterList (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_nonterminalInstructionForGeneration * GGS_nonterminalInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_nonterminalInstructionForGeneration) ;
    return (cPtr_nonterminalInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_nonterminalInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_nonterminalInstructionForGeneration * ptr = dynamic_cast <const cPtr_nonterminalInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mNonterminalName.operator_isEqual (ptr->mNonterminalName).boolValue ()
         && mLabelName.operator_isEqual (ptr->mLabelName).boolValue ()
         && mActualParameterList.operator_isEqual (ptr->mActualParameterList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_nonterminalInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@nonterminalInstructionForGeneration:"
           << mInstructionLocation.reader_description (inIndentation + 1)
           << mNonterminalName.reader_description (inIndentation + 1)
           << mLabelName.reader_description (inIndentation + 1)
           << mActualParameterList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_nonterminalInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_nonterminalInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_nonterminalInstructionForGeneration (& typeid (cPtr_nonterminalInstructionForGeneration), & typeid (cPtr_syntaxInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_nonterminalInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__nonterminalInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_nonterminalInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_nonterminalInstructionForGeneration (mInstructionLocation, mNonterminalName, mLabelName, mActualParameterList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_nonterminalInstructionForGeneration'           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_nonterminalInstructionForGeneration ("nonterminalInstructionForGeneration", true, & kTypeDescriptor_GGS_syntaxInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_nonterminalInstructionForGeneration::
GGS_nonterminalInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_nonterminalInstructionForGeneration::
GGS_nonterminalInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_nonterminalInstructionForGeneration GGS_nonterminalInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_nonterminalInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_nonterminalInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_nonterminalInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_nonterminalInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_nonterminalInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_nonterminalInstructionForGeneration GGS_nonterminalInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_string& argument_1,
                 const GGS_string& argument_2,
                 const GGS_actualParameterListForGeneration & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_nonterminalInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_nonterminalInstructionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_nonterminalInstructionForGeneration::
reader_mNonterminalName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_nonterminalInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_nonterminalInstructionForGeneration *) mPointer)->mNonterminalName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_nonterminalInstructionForGeneration::
reader_mLabelName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_nonterminalInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_nonterminalInstructionForGeneration *) mPointer)->mLabelName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameterListForGeneration  GGS_nonterminalInstructionForGeneration::
reader_mActualParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_actualParameterListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_nonterminalInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_nonterminalInstructionForGeneration *) mPointer)->mActualParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_nonterminalInstructionForGeneration::actualTypeName (void) const {
  return "nonterminalInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__nonterminalInstructionForGeneration ("nonterminalInstructionForGeneration", gClassInfoFor__syntaxInstructionForGeneration, & kTypeDescriptor_GGS_nonterminalInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_nonterminalInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_nonterminalInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_nonterminalInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_nonterminalInstructionForGeneration GGS_nonterminalInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_nonterminalInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_nonterminalInstructionForGeneration * p = dynamic_cast <const GGS_nonterminalInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_nonterminalInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_nonterminalInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_nonterminalInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_repeatInstructionForGeneration'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_repeatInstructionForGeneration::
cPtr_repeatInstructionForGeneration (const GGS_location & argument_0,
                                const GGS_string& argument_1,
                                const GGS_uint & argument_2,
                                const GGS_semanticInstructionListForGeneration & argument_3,
                                const GGS_location & argument_4,
                                const GGS_listOfSemanticInstructionListForGeneration & argument_5
                                COMMA_LOCATION_ARGS)
:cPtr_syntaxInstructionForGeneration (argument_0 COMMA_THERE),
mSyntaxComponentName (argument_1),
mChoiceIndex (argument_2),
m_repeated_instructionList (argument_3),
mEndOfRepeatedInstructions (argument_4),
mListOfSemanticInstructionListForGeneration (argument_5) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_repeatInstructionForGeneration * GGS_repeatInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_repeatInstructionForGeneration) ;
    return (cPtr_repeatInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_repeatInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_repeatInstructionForGeneration * ptr = dynamic_cast <const cPtr_repeatInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mSyntaxComponentName.operator_isEqual (ptr->mSyntaxComponentName).boolValue ()
         && mChoiceIndex.operator_isEqual (ptr->mChoiceIndex).boolValue ()
         && m_repeated_instructionList.operator_isEqual (ptr->m_repeated_instructionList).boolValue ()
         && mEndOfRepeatedInstructions.operator_isEqual (ptr->mEndOfRepeatedInstructions).boolValue ()
         && mListOfSemanticInstructionListForGeneration.operator_isEqual (ptr->mListOfSemanticInstructionListForGeneration).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_repeatInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@repeatInstructionForGeneration:"
           << mInstructionLocation.reader_description (inIndentation + 1)
           << mSyntaxComponentName.reader_description (inIndentation + 1)
           << mChoiceIndex.reader_description (inIndentation + 1)
           << m_repeated_instructionList.reader_description (inIndentation + 1)
           << mEndOfRepeatedInstructions.reader_description (inIndentation + 1)
           << mListOfSemanticInstructionListForGeneration.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_repeatInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_repeatInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_repeatInstructionForGeneration (& typeid (cPtr_repeatInstructionForGeneration), & typeid (cPtr_syntaxInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_repeatInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__repeatInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_repeatInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_repeatInstructionForGeneration (mInstructionLocation, mSyntaxComponentName, mChoiceIndex, m_repeated_instructionList, mEndOfRepeatedInstructions, mListOfSemanticInstructionListForGeneration COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_repeatInstructionForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_repeatInstructionForGeneration ("repeatInstructionForGeneration", true, & kTypeDescriptor_GGS_syntaxInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_repeatInstructionForGeneration::
GGS_repeatInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_repeatInstructionForGeneration::
GGS_repeatInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_repeatInstructionForGeneration GGS_repeatInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_repeatInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_repeatInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_repeatInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_repeatInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_repeatInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_repeatInstructionForGeneration GGS_repeatInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_string& argument_1,
                 const GGS_uint & argument_2,
                 const GGS_semanticInstructionListForGeneration & argument_3,
                 const GGS_location & argument_4,
                 const GGS_listOfSemanticInstructionListForGeneration & argument_5
                                COMMA_LOCATION_ARGS) {
  GGS_repeatInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_repeatInstructionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_repeatInstructionForGeneration::
reader_mSyntaxComponentName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_repeatInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_repeatInstructionForGeneration *) mPointer)->mSyntaxComponentName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_repeatInstructionForGeneration::
reader_mChoiceIndex (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_repeatInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_repeatInstructionForGeneration *) mPointer)->mChoiceIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration  GGS_repeatInstructionForGeneration::
reader_m_repeated_instructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_repeatInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_repeatInstructionForGeneration *) mPointer)->m_repeated_instructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_repeatInstructionForGeneration::
reader_mEndOfRepeatedInstructions (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_repeatInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_repeatInstructionForGeneration *) mPointer)->mEndOfRepeatedInstructions ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_listOfSemanticInstructionListForGeneration  GGS_repeatInstructionForGeneration::
reader_mListOfSemanticInstructionListForGeneration (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_listOfSemanticInstructionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_repeatInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_repeatInstructionForGeneration *) mPointer)->mListOfSemanticInstructionListForGeneration ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_repeatInstructionForGeneration::actualTypeName (void) const {
  return "repeatInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__repeatInstructionForGeneration ("repeatInstructionForGeneration", gClassInfoFor__syntaxInstructionForGeneration, & kTypeDescriptor_GGS_repeatInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_repeatInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_repeatInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_repeatInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_repeatInstructionForGeneration GGS_repeatInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_repeatInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_repeatInstructionForGeneration * p = dynamic_cast <const GGS_repeatInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_repeatInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_repeatInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_repeatInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_selectInstructionForGeneration'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_selectInstructionForGeneration::
cPtr_selectInstructionForGeneration (const GGS_location & argument_0,
                                const GGS_string& argument_1,
                                const GGS_uint & argument_2,
                                const GGS_listOfSemanticInstructionListForGeneration & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_syntaxInstructionForGeneration (argument_0 COMMA_THERE),
mSyntaxComponentName (argument_1),
mChoiceIndex (argument_2),
mListOfSemanticInstructionListForGeneration (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_selectInstructionForGeneration * GGS_selectInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_selectInstructionForGeneration) ;
    return (cPtr_selectInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_selectInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_selectInstructionForGeneration * ptr = dynamic_cast <const cPtr_selectInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mSyntaxComponentName.operator_isEqual (ptr->mSyntaxComponentName).boolValue ()
         && mChoiceIndex.operator_isEqual (ptr->mChoiceIndex).boolValue ()
         && mListOfSemanticInstructionListForGeneration.operator_isEqual (ptr->mListOfSemanticInstructionListForGeneration).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_selectInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@selectInstructionForGeneration:"
           << mInstructionLocation.reader_description (inIndentation + 1)
           << mSyntaxComponentName.reader_description (inIndentation + 1)
           << mChoiceIndex.reader_description (inIndentation + 1)
           << mListOfSemanticInstructionListForGeneration.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_selectInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_selectInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_selectInstructionForGeneration (& typeid (cPtr_selectInstructionForGeneration), & typeid (cPtr_syntaxInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_selectInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__selectInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_selectInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_selectInstructionForGeneration (mInstructionLocation, mSyntaxComponentName, mChoiceIndex, mListOfSemanticInstructionListForGeneration COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_selectInstructionForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_selectInstructionForGeneration ("selectInstructionForGeneration", true, & kTypeDescriptor_GGS_syntaxInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_selectInstructionForGeneration::
GGS_selectInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_selectInstructionForGeneration::
GGS_selectInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_selectInstructionForGeneration GGS_selectInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_selectInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_selectInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_selectInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_selectInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_selectInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_selectInstructionForGeneration GGS_selectInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_string& argument_1,
                 const GGS_uint & argument_2,
                 const GGS_listOfSemanticInstructionListForGeneration & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_selectInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_selectInstructionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_selectInstructionForGeneration::
reader_mSyntaxComponentName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_selectInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_selectInstructionForGeneration *) mPointer)->mSyntaxComponentName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_selectInstructionForGeneration::
reader_mChoiceIndex (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_selectInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_selectInstructionForGeneration *) mPointer)->mChoiceIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_listOfSemanticInstructionListForGeneration  GGS_selectInstructionForGeneration::
reader_mListOfSemanticInstructionListForGeneration (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_listOfSemanticInstructionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_selectInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_selectInstructionForGeneration *) mPointer)->mListOfSemanticInstructionListForGeneration ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_selectInstructionForGeneration::actualTypeName (void) const {
  return "selectInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__selectInstructionForGeneration ("selectInstructionForGeneration", gClassInfoFor__syntaxInstructionForGeneration, & kTypeDescriptor_GGS_selectInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_selectInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_selectInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_selectInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_selectInstructionForGeneration GGS_selectInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_selectInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_selectInstructionForGeneration * p = dynamic_cast <const GGS_selectInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_selectInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_selectInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_selectInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_parseRewindInstructionForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_parseRewindInstructionForGeneration::
cPtr_parseRewindInstructionForGeneration (const GGS_location & argument_0,
                                const GGS_listOfSemanticInstructionListForGeneration & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_syntaxInstructionForGeneration (argument_0 COMMA_THERE),
mListOfSemanticInstructionListForGeneration (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_parseRewindInstructionForGeneration * GGS_parseRewindInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_parseRewindInstructionForGeneration) ;
    return (cPtr_parseRewindInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_parseRewindInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_parseRewindInstructionForGeneration * ptr = dynamic_cast <const cPtr_parseRewindInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mListOfSemanticInstructionListForGeneration.operator_isEqual (ptr->mListOfSemanticInstructionListForGeneration).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_parseRewindInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@parseRewindInstructionForGeneration:"
           << mInstructionLocation.reader_description (inIndentation + 1)
           << mListOfSemanticInstructionListForGeneration.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_parseRewindInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_parseRewindInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_parseRewindInstructionForGeneration (& typeid (cPtr_parseRewindInstructionForGeneration), & typeid (cPtr_syntaxInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_parseRewindInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__parseRewindInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_parseRewindInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_parseRewindInstructionForGeneration (mInstructionLocation, mListOfSemanticInstructionListForGeneration COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_parseRewindInstructionForGeneration'           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_parseRewindInstructionForGeneration ("parseRewindInstructionForGeneration", true, & kTypeDescriptor_GGS_syntaxInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_parseRewindInstructionForGeneration::
GGS_parseRewindInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_parseRewindInstructionForGeneration::
GGS_parseRewindInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_parseRewindInstructionForGeneration GGS_parseRewindInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_parseRewindInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_parseRewindInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_parseRewindInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_parseRewindInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_parseRewindInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_parseRewindInstructionForGeneration GGS_parseRewindInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_listOfSemanticInstructionListForGeneration & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_parseRewindInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_parseRewindInstructionForGeneration (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_listOfSemanticInstructionListForGeneration  GGS_parseRewindInstructionForGeneration::
reader_mListOfSemanticInstructionListForGeneration (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_listOfSemanticInstructionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_parseRewindInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_parseRewindInstructionForGeneration *) mPointer)->mListOfSemanticInstructionListForGeneration ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_parseRewindInstructionForGeneration::actualTypeName (void) const {
  return "parseRewindInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__parseRewindInstructionForGeneration ("parseRewindInstructionForGeneration", gClassInfoFor__syntaxInstructionForGeneration, & kTypeDescriptor_GGS_parseRewindInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_parseRewindInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_parseRewindInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_parseRewindInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_parseRewindInstructionForGeneration GGS_parseRewindInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_parseRewindInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_parseRewindInstructionForGeneration * p = dynamic_cast <const GGS_parseRewindInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_parseRewindInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_parseRewindInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_parseRewindInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'cPtr_parseLoopInstructionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_parseLoopInstructionForGeneration::
cPtr_parseLoopInstructionForGeneration (const GGS_location & argument_0,
                                const GGS_semanticExpressionForGeneration & argument_1,
                                const GGS_semanticExpressionForGeneration & argument_2,
                                const GGS_semanticInstructionListForGeneration & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_syntaxInstructionForGeneration (argument_0 COMMA_THERE),
mVariantExpression (argument_1),
mWhileExpression (argument_2),
mInstructionList (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_parseLoopInstructionForGeneration * GGS_parseLoopInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_parseLoopInstructionForGeneration) ;
    return (cPtr_parseLoopInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_parseLoopInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_parseLoopInstructionForGeneration * ptr = dynamic_cast <const cPtr_parseLoopInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mVariantExpression.operator_isEqual (ptr->mVariantExpression).boolValue ()
         && mWhileExpression.operator_isEqual (ptr->mWhileExpression).boolValue ()
         && mInstructionList.operator_isEqual (ptr->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_parseLoopInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@parseLoopInstructionForGeneration:"
           << mInstructionLocation.reader_description (inIndentation + 1)
           << mVariantExpression.reader_description (inIndentation + 1)
           << mWhileExpression.reader_description (inIndentation + 1)
           << mInstructionList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_parseLoopInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_parseLoopInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_parseLoopInstructionForGeneration (& typeid (cPtr_parseLoopInstructionForGeneration), & typeid (cPtr_syntaxInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_parseLoopInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__parseLoopInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_parseLoopInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_parseLoopInstructionForGeneration (mInstructionLocation, mVariantExpression, mWhileExpression, mInstructionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_parseLoopInstructionForGeneration'            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_parseLoopInstructionForGeneration ("parseLoopInstructionForGeneration", true, & kTypeDescriptor_GGS_syntaxInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_parseLoopInstructionForGeneration::
GGS_parseLoopInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_parseLoopInstructionForGeneration::
GGS_parseLoopInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_parseLoopInstructionForGeneration GGS_parseLoopInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_parseLoopInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_parseLoopInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_parseLoopInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_parseLoopInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_parseLoopInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_parseLoopInstructionForGeneration GGS_parseLoopInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionForGeneration & argument_1,
                 const GGS_semanticExpressionForGeneration & argument_2,
                 const GGS_semanticInstructionListForGeneration & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_parseLoopInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_parseLoopInstructionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_parseLoopInstructionForGeneration::
reader_mVariantExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_parseLoopInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_parseLoopInstructionForGeneration *) mPointer)->mVariantExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_parseLoopInstructionForGeneration::
reader_mWhileExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_parseLoopInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_parseLoopInstructionForGeneration *) mPointer)->mWhileExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration  GGS_parseLoopInstructionForGeneration::
reader_mInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_parseLoopInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_parseLoopInstructionForGeneration *) mPointer)->mInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_parseLoopInstructionForGeneration::actualTypeName (void) const {
  return "parseLoopInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__parseLoopInstructionForGeneration ("parseLoopInstructionForGeneration", gClassInfoFor__syntaxInstructionForGeneration, & kTypeDescriptor_GGS_parseLoopInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_parseLoopInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_parseLoopInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_parseLoopInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_parseLoopInstructionForGeneration GGS_parseLoopInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_parseLoopInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_parseLoopInstructionForGeneration * p = dynamic_cast <const GGS_parseLoopInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_parseLoopInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_parseLoopInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_parseLoopInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'cPtr_parseWhenInstructionForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_parseWhenInstructionForGeneration::
cPtr_parseWhenInstructionForGeneration (const GGS_location & argument_0,
                                const GGS_semanticExpressionForGeneration & argument_1,
                                const GGS_semanticInstructionListForGeneration & argument_2,
                                const GGS_semanticInstructionListForGeneration & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_syntaxInstructionForGeneration (argument_0 COMMA_THERE),
mWhenExpression (argument_1),
mInstructionList (argument_2),
mElseInstructionList (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_parseWhenInstructionForGeneration * GGS_parseWhenInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_parseWhenInstructionForGeneration) ;
    return (cPtr_parseWhenInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_parseWhenInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_parseWhenInstructionForGeneration * ptr = dynamic_cast <const cPtr_parseWhenInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mWhenExpression.operator_isEqual (ptr->mWhenExpression).boolValue ()
         && mInstructionList.operator_isEqual (ptr->mInstructionList).boolValue ()
         && mElseInstructionList.operator_isEqual (ptr->mElseInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_parseWhenInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@parseWhenInstructionForGeneration:"
           << mInstructionLocation.reader_description (inIndentation + 1)
           << mWhenExpression.reader_description (inIndentation + 1)
           << mInstructionList.reader_description (inIndentation + 1)
           << mElseInstructionList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_parseWhenInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_parseWhenInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_parseWhenInstructionForGeneration (& typeid (cPtr_parseWhenInstructionForGeneration), & typeid (cPtr_syntaxInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_parseWhenInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__parseWhenInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_parseWhenInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_parseWhenInstructionForGeneration (mInstructionLocation, mWhenExpression, mInstructionList, mElseInstructionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_parseWhenInstructionForGeneration'            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_parseWhenInstructionForGeneration ("parseWhenInstructionForGeneration", true, & kTypeDescriptor_GGS_syntaxInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_parseWhenInstructionForGeneration::
GGS_parseWhenInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_parseWhenInstructionForGeneration::
GGS_parseWhenInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_parseWhenInstructionForGeneration GGS_parseWhenInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_parseWhenInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_parseWhenInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_parseWhenInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_parseWhenInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_parseWhenInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_parseWhenInstructionForGeneration GGS_parseWhenInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionForGeneration & argument_1,
                 const GGS_semanticInstructionListForGeneration & argument_2,
                 const GGS_semanticInstructionListForGeneration & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_parseWhenInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_parseWhenInstructionForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_parseWhenInstructionForGeneration::
reader_mWhenExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_parseWhenInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_parseWhenInstructionForGeneration *) mPointer)->mWhenExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration  GGS_parseWhenInstructionForGeneration::
reader_mInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_parseWhenInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_parseWhenInstructionForGeneration *) mPointer)->mInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration  GGS_parseWhenInstructionForGeneration::
reader_mElseInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_parseWhenInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_parseWhenInstructionForGeneration *) mPointer)->mElseInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_parseWhenInstructionForGeneration::actualTypeName (void) const {
  return "parseWhenInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__parseWhenInstructionForGeneration ("parseWhenInstructionForGeneration", gClassInfoFor__syntaxInstructionForGeneration, & kTypeDescriptor_GGS_parseWhenInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_parseWhenInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_parseWhenInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_parseWhenInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_parseWhenInstructionForGeneration GGS_parseWhenInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_parseWhenInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_parseWhenInstructionForGeneration * p = dynamic_cast <const GGS_parseWhenInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_parseWhenInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_parseWhenInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_parseWhenInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@switchBranchesForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_switchBranchesForGeneration::
elementOf_GGS_switchBranchesForGeneration (const GGS_lstringlist & argument_0,
                                const GGS_semanticInstructionListForGeneration & argument_1
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mSwitchConstantList (argument_0),
mInstructions (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_switchBranchesForGeneration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_switchBranchesForGeneration * ptr = dynamic_cast <const elementOf_GGS_switchBranchesForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mSwitchConstantList.operator_isEqual (ptr->mSwitchConstantList).boolValue ()
         && mInstructions.operator_isEqual (ptr->mInstructions).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_switchBranchesForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSwitchConstantList.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructions.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@switchBranchesForGeneration'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_switchBranchesForGeneration ("switchBranchesForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_switchBranchesForGeneration::
internalAppendValues (const GGS_lstringlist & argument_0,
                    const GGS_semanticInstructionListForGeneration & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_switchBranchesForGeneration::
internalPrependValues (const GGS_lstringlist & argument_0,
                    const GGS_semanticInstructionListForGeneration & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_switchBranchesForGeneration::
addAssign_operation (const GGS_lstringlist & argument_0,
                                const GGS_semanticInstructionListForGeneration & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_switchBranchesForGeneration GGS_switchBranchesForGeneration::
operator_concat (const GGS_switchBranchesForGeneration & inOperand) const {
  GGS_switchBranchesForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_switchBranchesForGeneration::
dotAssign_operation (const GGS_switchBranchesForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_switchBranchesForGeneration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstringlist  p_0 = p->mSwitchConstantList ;
          GGS_semanticInstructionListForGeneration  p_1 = p->mInstructions ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_switchBranchesForGeneration::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstringlist & argument_0,
                     const GGS_semanticInstructionListForGeneration & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_switchBranchesForGeneration::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mSwitchConstantList,
                                ptr->mInstructions
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_switchBranchesForGeneration  GGS_switchBranchesForGeneration::
constructor_emptyList (void) {
  GGS_switchBranchesForGeneration result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_switchBranchesForGeneration  GGS_switchBranchesForGeneration::
constructor_listWithValue (const GGS_lstringlist & argument_0,
                                const GGS_semanticInstructionListForGeneration & argument_1) {
  GGS_switchBranchesForGeneration result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_switchBranchesForGeneration::
internalSubListWithRange (GGS_switchBranchesForGeneration & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mSwitchConstantList, ptr->mInstructions) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_switchBranchesForGeneration GGS_switchBranchesForGeneration::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_switchBranchesForGeneration result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_switchBranchesForGeneration GGS_switchBranchesForGeneration::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_switchBranchesForGeneration result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_switchBranchesForGeneration::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@switchBranchesForGeneration", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_switchBranchesForGeneration::
method_first (C_Compiler & inLexique,
              GGS_lstringlist & _out_0,
              GGS_semanticInstructionListForGeneration & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSwitchConstantList ;
    _out_1 = ptr->mInstructions ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_switchBranchesForGeneration::
method_last (C_Compiler & inLexique,
             GGS_lstringlist & _out_0,
             GGS_semanticInstructionListForGeneration & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSwitchConstantList ;
    _out_1 = ptr->mInstructions ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_switchBranchesForGeneration::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstringlist & _out_0,
                 GGS_semanticInstructionListForGeneration & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSwitchConstantList ;
    _out_1 = ptr->mInstructions ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_switchBranchesForGeneration::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstringlist & _out_0,
                GGS_semanticInstructionListForGeneration & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSwitchConstantList ;
    _out_1 = ptr->mInstructions ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_switchBranchesForGeneration::
reader_mSwitchConstantListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstringlist  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSwitchConstantList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration  GGS_switchBranchesForGeneration::
reader_mInstructionsAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticInstructionListForGeneration  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstructions ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_switchBranchesForGeneration::
modifier_setMSwitchConstantListAtIndex (C_Compiler & inLexique,
                              const GGS_lstringlist  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSwitchConstantList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_switchBranchesForGeneration::
modifier_setMInstructionsAtIndex (C_Compiler & inLexique,
                              const GGS_semanticInstructionListForGeneration  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstructions = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstringlist  & GGS_switchBranchesForGeneration::cEnumerator::_mSwitchConstantList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mSwitchConstantList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticInstructionListForGeneration  & GGS_switchBranchesForGeneration::cEnumerator::_mInstructions (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mInstructions ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_switchBranchesForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_switchBranchesForGeneration * p = NULL ;
    macroMyNew (p, GGS_switchBranchesForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_switchBranchesForGeneration GGS_switchBranchesForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_switchBranchesForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_switchBranchesForGeneration * p = dynamic_cast <const GGS_switchBranchesForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_switchBranchesForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_switchBranchesForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_switchBranchesForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_switchInstructionForGeneration'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_switchInstructionForGeneration::
cPtr_switchInstructionForGeneration (const GGS_semanticExpressionForGeneration & argument_0,
                                const GGS_switchBranchesForGeneration & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionForGeneration (THERE),
mSwitchExpression (argument_0),
mBranches (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_switchInstructionForGeneration * GGS_switchInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_switchInstructionForGeneration) ;
    return (cPtr_switchInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_switchInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_switchInstructionForGeneration * ptr = dynamic_cast <const cPtr_switchInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mSwitchExpression.operator_isEqual (ptr->mSwitchExpression).boolValue ()
         && mBranches.operator_isEqual (ptr->mBranches).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_switchInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@switchInstructionForGeneration:"
           << mSwitchExpression.reader_description (inIndentation + 1)
           << mBranches.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_switchInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_switchInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_switchInstructionForGeneration (& typeid (cPtr_switchInstructionForGeneration), & typeid (cPtr_semanticInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_switchInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__switchInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_switchInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_switchInstructionForGeneration (mSwitchExpression, mBranches COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_switchInstructionForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_switchInstructionForGeneration ("switchInstructionForGeneration", true, & kTypeDescriptor_GGS_semanticInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_switchInstructionForGeneration::
GGS_switchInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_switchInstructionForGeneration::
GGS_switchInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_switchInstructionForGeneration GGS_switchInstructionForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_switchInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_switchInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_switchInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_switchInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_switchInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_switchInstructionForGeneration GGS_switchInstructionForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_semanticExpressionForGeneration & argument_0,
                 const GGS_switchBranchesForGeneration & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_switchInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_switchInstructionForGeneration (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_switchInstructionForGeneration::
reader_mSwitchExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_switchInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_switchInstructionForGeneration *) mPointer)->mSwitchExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_switchBranchesForGeneration  GGS_switchInstructionForGeneration::
reader_mBranches (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_switchBranchesForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_switchInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_switchInstructionForGeneration *) mPointer)->mBranches ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_switchInstructionForGeneration::actualTypeName (void) const {
  return "switchInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__switchInstructionForGeneration ("switchInstructionForGeneration", gClassInfoFor__semanticInstructionForGeneration, & kTypeDescriptor_GGS_switchInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_switchInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_switchInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_switchInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_switchInstructionForGeneration GGS_switchInstructionForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_switchInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_switchInstructionForGeneration * p = dynamic_cast <const GGS_switchInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_switchInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_switchInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_switchInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_mapTypeForGeneration'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_mapTypeForGeneration::
cPtr_mapTypeForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typedAttributeList & argument_2,
                                const GGS_insertMethodListAST & argument_3,
                                const GGS_mapSearchMethodListAST & argument_4,
                                const GGS_mapRemoveMethodListAST & argument_5,
                                const GGS_bool& argument_6,
                                const GGS_withAccessorMap & argument_7
                                COMMA_LOCATION_ARGS)
:cPtr_semanticTypeForGeneration (argument_0 COMMA_THERE),
mMapTypeName (argument_1),
mTypedAttributeList (argument_2),
mInsertMethodList (argument_3),
mSearchMethodList (argument_4),
mRemoveMethodList (argument_5),
mHasInsertOrReplaceModifier (argument_6),
mWithAccessorMap (argument_7) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_mapTypeForGeneration * GGS_mapTypeForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_mapTypeForGeneration) ;
    return (cPtr_mapTypeForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_mapTypeForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_mapTypeForGeneration * ptr = dynamic_cast <const cPtr_mapTypeForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTypeIndex.operator_isEqual (ptr->mTypeIndex).boolValue ()
         && mMapTypeName.operator_isEqual (ptr->mMapTypeName).boolValue ()
         && mTypedAttributeList.operator_isEqual (ptr->mTypedAttributeList).boolValue ()
         && mInsertMethodList.operator_isEqual (ptr->mInsertMethodList).boolValue ()
         && mSearchMethodList.operator_isEqual (ptr->mSearchMethodList).boolValue ()
         && mRemoveMethodList.operator_isEqual (ptr->mRemoveMethodList).boolValue ()
         && mHasInsertOrReplaceModifier.operator_isEqual (ptr->mHasInsertOrReplaceModifier).boolValue ()
         && mWithAccessorMap.operator_isEqual (ptr->mWithAccessorMap).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_mapTypeForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@mapTypeForGeneration:"
           << mTypeIndex.reader_description (inIndentation + 1)
           << mMapTypeName.reader_description (inIndentation + 1)
           << mTypedAttributeList.reader_description (inIndentation + 1)
           << mInsertMethodList.reader_description (inIndentation + 1)
           << mSearchMethodList.reader_description (inIndentation + 1)
           << mRemoveMethodList.reader_description (inIndentation + 1)
           << mHasInsertOrReplaceModifier.reader_description (inIndentation + 1)
           << mWithAccessorMap.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_mapTypeForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_mapTypeForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_mapTypeForGeneration (& typeid (cPtr_mapTypeForGeneration), & typeid (cPtr_semanticTypeForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_mapTypeForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__mapTypeForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_mapTypeForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_mapTypeForGeneration (mTypeIndex, mMapTypeName, mTypedAttributeList, mInsertMethodList, mSearchMethodList, mRemoveMethodList, mHasInsertOrReplaceModifier, mWithAccessorMap COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_mapTypeForGeneration'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_mapTypeForGeneration ("mapTypeForGeneration", true, & kTypeDescriptor_GGS_semanticTypeForGeneration) ;

//---------------------------------------------------------------------------*

GGS_mapTypeForGeneration::
GGS_mapTypeForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_mapTypeForGeneration::
GGS_mapTypeForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_mapTypeForGeneration GGS_mapTypeForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_mapTypeForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_mapTypeForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_mapTypeForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_mapTypeForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_mapTypeForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapTypeForGeneration GGS_mapTypeForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_typedAttributeList & argument_2,
                 const GGS_insertMethodListAST & argument_3,
                 const GGS_mapSearchMethodListAST & argument_4,
                 const GGS_mapRemoveMethodListAST & argument_5,
                 const GGS_bool& argument_6,
                 const GGS_withAccessorMap & argument_7
                                COMMA_LOCATION_ARGS) {
  GGS_mapTypeForGeneration result ;
  macroMyNew (result.mPointer, cPtr_mapTypeForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapTypeForGeneration::
reader_mMapTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapTypeForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapTypeForGeneration *) mPointer)->mMapTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typedAttributeList  GGS_mapTypeForGeneration::
reader_mTypedAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typedAttributeList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapTypeForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapTypeForGeneration *) mPointer)->mTypedAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_insertMethodListAST  GGS_mapTypeForGeneration::
reader_mInsertMethodList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_insertMethodListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapTypeForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapTypeForGeneration *) mPointer)->mInsertMethodList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapSearchMethodListAST  GGS_mapTypeForGeneration::
reader_mSearchMethodList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_mapSearchMethodListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapTypeForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapTypeForGeneration *) mPointer)->mSearchMethodList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapRemoveMethodListAST  GGS_mapTypeForGeneration::
reader_mRemoveMethodList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_mapRemoveMethodListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapTypeForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapTypeForGeneration *) mPointer)->mRemoveMethodList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_mapTypeForGeneration::
reader_mHasInsertOrReplaceModifier (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapTypeForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapTypeForGeneration *) mPointer)->mHasInsertOrReplaceModifier ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_withAccessorMap  GGS_mapTypeForGeneration::
reader_mWithAccessorMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_withAccessorMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapTypeForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapTypeForGeneration *) mPointer)->mWithAccessorMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_mapTypeForGeneration::actualTypeName (void) const {
  return "mapTypeForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__mapTypeForGeneration ("mapTypeForGeneration", gClassInfoFor__semanticTypeForGeneration, & kTypeDescriptor_GGS_mapTypeForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_mapTypeForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_mapTypeForGeneration * p = NULL ;
    macroMyNew (p, GGS_mapTypeForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapTypeForGeneration GGS_mapTypeForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_mapTypeForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_mapTypeForGeneration * p = dynamic_cast <const GGS_mapTypeForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_mapTypeForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_mapTypeForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_mapTypeForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_mapProxyTypeForGeneration'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_mapProxyTypeForGeneration::
cPtr_mapProxyTypeForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_unifiedTypeMapProxy & argument_1,
                                const GGS_typedAttributeList & argument_2,
                                const GGS_mapSearchMethodListAST & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticTypeForGeneration (argument_0 COMMA_THERE),
mAssociatedMapTypeProxy (argument_1),
mAssociatedMapTypedAttributeList (argument_2),
mSearchMethodList (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_mapProxyTypeForGeneration * GGS_mapProxyTypeForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_mapProxyTypeForGeneration) ;
    return (cPtr_mapProxyTypeForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_mapProxyTypeForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_mapProxyTypeForGeneration * ptr = dynamic_cast <const cPtr_mapProxyTypeForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTypeIndex.operator_isEqual (ptr->mTypeIndex).boolValue ()
         && mAssociatedMapTypeProxy.operator_isEqual (ptr->mAssociatedMapTypeProxy).boolValue ()
         && mAssociatedMapTypedAttributeList.operator_isEqual (ptr->mAssociatedMapTypedAttributeList).boolValue ()
         && mSearchMethodList.operator_isEqual (ptr->mSearchMethodList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_mapProxyTypeForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@mapProxyTypeForGeneration:"
           << mTypeIndex.reader_description (inIndentation + 1)
           << mAssociatedMapTypeProxy.reader_description (inIndentation + 1)
           << mAssociatedMapTypedAttributeList.reader_description (inIndentation + 1)
           << mSearchMethodList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_mapProxyTypeForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_mapProxyTypeForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_mapProxyTypeForGeneration (& typeid (cPtr_mapProxyTypeForGeneration), & typeid (cPtr_semanticTypeForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_mapProxyTypeForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__mapProxyTypeForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_mapProxyTypeForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_mapProxyTypeForGeneration (mTypeIndex, mAssociatedMapTypeProxy, mAssociatedMapTypedAttributeList, mSearchMethodList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_mapProxyTypeForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_mapProxyTypeForGeneration ("mapProxyTypeForGeneration", true, & kTypeDescriptor_GGS_semanticTypeForGeneration) ;

//---------------------------------------------------------------------------*

GGS_mapProxyTypeForGeneration::
GGS_mapProxyTypeForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_mapProxyTypeForGeneration::
GGS_mapProxyTypeForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_mapProxyTypeForGeneration GGS_mapProxyTypeForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_mapProxyTypeForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_mapProxyTypeForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_mapProxyTypeForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_mapProxyTypeForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_mapProxyTypeForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapProxyTypeForGeneration GGS_mapProxyTypeForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_unifiedTypeMapProxy & argument_1,
                 const GGS_typedAttributeList & argument_2,
                 const GGS_mapSearchMethodListAST & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_mapProxyTypeForGeneration result ;
  macroMyNew (result.mPointer, cPtr_mapProxyTypeForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapProxy  GGS_mapProxyTypeForGeneration::
reader_mAssociatedMapTypeProxy (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_unifiedTypeMapProxy   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapProxyTypeForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapProxyTypeForGeneration *) mPointer)->mAssociatedMapTypeProxy ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typedAttributeList  GGS_mapProxyTypeForGeneration::
reader_mAssociatedMapTypedAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typedAttributeList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapProxyTypeForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapProxyTypeForGeneration *) mPointer)->mAssociatedMapTypedAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapSearchMethodListAST  GGS_mapProxyTypeForGeneration::
reader_mSearchMethodList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_mapSearchMethodListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapProxyTypeForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapProxyTypeForGeneration *) mPointer)->mSearchMethodList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_mapProxyTypeForGeneration::actualTypeName (void) const {
  return "mapProxyTypeForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__mapProxyTypeForGeneration ("mapProxyTypeForGeneration", gClassInfoFor__semanticTypeForGeneration, & kTypeDescriptor_GGS_mapProxyTypeForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_mapProxyTypeForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_mapProxyTypeForGeneration * p = NULL ;
    macroMyNew (p, GGS_mapProxyTypeForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapProxyTypeForGeneration GGS_mapProxyTypeForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_mapProxyTypeForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_mapProxyTypeForGeneration * p = dynamic_cast <const GGS_mapProxyTypeForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_mapProxyTypeForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_mapProxyTypeForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_mapProxyTypeForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//       Element of list '@abstractMethodDefinitionListForGeneration'        *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_abstractMethodDefinitionListForGeneration::
elementOf_GGS_abstractMethodDefinitionListForGeneration (const GGS_bool& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_formalParameterListForGeneration & argument_2
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mIsOverriding (argument_0),
mMethodName (argument_1),
mSignature (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_abstractMethodDefinitionListForGeneration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_abstractMethodDefinitionListForGeneration * ptr = dynamic_cast <const elementOf_GGS_abstractMethodDefinitionListForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mIsOverriding.operator_isEqual (ptr->mIsOverriding).boolValue ()
         && mMethodName.operator_isEqual (ptr->mMethodName).boolValue ()
         && mSignature.operator_isEqual (ptr->mSignature).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_abstractMethodDefinitionListForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mIsOverriding.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMethodName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSignature.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            List '@abstractMethodDefinitionListForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_abstractMethodDefinitionListForGeneration ("abstractMethodDefinitionListForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionListForGeneration::
internalAppendValues (const GGS_bool& argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_formalParameterListForGeneration & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionListForGeneration::
internalPrependValues (const GGS_bool& argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_formalParameterListForGeneration & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionListForGeneration::
addAssign_operation (const GGS_bool& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_formalParameterListForGeneration & argument_2) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_abstractMethodDefinitionListForGeneration GGS_abstractMethodDefinitionListForGeneration::
operator_concat (const GGS_abstractMethodDefinitionListForGeneration & inOperand) const {
  GGS_abstractMethodDefinitionListForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionListForGeneration::
dotAssign_operation (const GGS_abstractMethodDefinitionListForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_abstractMethodDefinitionListForGeneration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_bool p_0 = p->mIsOverriding ;
          GGS_lstring  p_1 = p->mMethodName ;
          GGS_formalParameterListForGeneration  p_2 = p->mSignature ;
          internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionListForGeneration::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_bool& argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_formalParameterListForGeneration & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionListForGeneration::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mIsOverriding,
                                ptr->mMethodName,
                                ptr->mSignature
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_abstractMethodDefinitionListForGeneration  GGS_abstractMethodDefinitionListForGeneration::
constructor_emptyList (void) {
  GGS_abstractMethodDefinitionListForGeneration result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_abstractMethodDefinitionListForGeneration  GGS_abstractMethodDefinitionListForGeneration::
constructor_listWithValue (const GGS_bool& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_formalParameterListForGeneration & argument_2) {
  GGS_abstractMethodDefinitionListForGeneration result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionListForGeneration::
internalSubListWithRange (GGS_abstractMethodDefinitionListForGeneration & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mIsOverriding, ptr->mMethodName, ptr->mSignature) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_abstractMethodDefinitionListForGeneration GGS_abstractMethodDefinitionListForGeneration::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_abstractMethodDefinitionListForGeneration result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_abstractMethodDefinitionListForGeneration GGS_abstractMethodDefinitionListForGeneration::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_abstractMethodDefinitionListForGeneration result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_abstractMethodDefinitionListForGeneration::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@abstractMethodDefinitionListForGeneration", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionListForGeneration::
method_first (C_Compiler & inLexique,
              GGS_bool& _out_0,
              GGS_lstring & _out_1,
              GGS_formalParameterListForGeneration & _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mIsOverriding ;
    _out_1 = ptr->mMethodName ;
    _out_2 = ptr->mSignature ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionListForGeneration::
method_last (C_Compiler & inLexique,
             GGS_bool& _out_0,
             GGS_lstring & _out_1,
             GGS_formalParameterListForGeneration & _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mIsOverriding ;
    _out_1 = ptr->mMethodName ;
    _out_2 = ptr->mSignature ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionListForGeneration::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_bool& _out_0,
                 GGS_lstring & _out_1,
                 GGS_formalParameterListForGeneration & _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mIsOverriding ;
    _out_1 = ptr->mMethodName ;
    _out_2 = ptr->mSignature ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionListForGeneration::
modifier_popLast (C_Compiler & inLexique,
                GGS_bool& _out_0,
                GGS_lstring & _out_1,
                GGS_formalParameterListForGeneration & _out_2
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mIsOverriding ;
    _out_1 = ptr->mMethodName ;
    _out_2 = ptr->mSignature ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_bool GGS_abstractMethodDefinitionListForGeneration::
reader_mIsOverridingAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mIsOverriding ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_abstractMethodDefinitionListForGeneration::
reader_mMethodNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mMethodName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameterListForGeneration  GGS_abstractMethodDefinitionListForGeneration::
reader_mSignatureAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_formalParameterListForGeneration  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSignature ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionListForGeneration::
modifier_setMIsOverridingAtIndex (C_Compiler & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mIsOverriding = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionListForGeneration::
modifier_setMMethodNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mMethodName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionListForGeneration::
modifier_setMSignatureAtIndex (C_Compiler & inLexique,
                              const GGS_formalParameterListForGeneration  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSignature = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_abstractMethodDefinitionListForGeneration::cEnumerator::_mIsOverriding (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mIsOverriding ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_abstractMethodDefinitionListForGeneration::cEnumerator::_mMethodName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mMethodName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_formalParameterListForGeneration  & GGS_abstractMethodDefinitionListForGeneration::cEnumerator::_mSignature (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mSignature ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_abstractMethodDefinitionListForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_abstractMethodDefinitionListForGeneration * p = NULL ;
    macroMyNew (p, GGS_abstractMethodDefinitionListForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_abstractMethodDefinitionListForGeneration GGS_abstractMethodDefinitionListForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_abstractMethodDefinitionListForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_abstractMethodDefinitionListForGeneration * p = dynamic_cast <const GGS_abstractMethodDefinitionListForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_abstractMethodDefinitionListForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_abstractMethodDefinitionListForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_abstractMethodDefinitionListForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Element of list '@methodDefinitionListForGeneration'            *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_methodDefinitionListForGeneration::
elementOf_GGS_methodDefinitionListForGeneration (const GGS_bool& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_formalParameterListForGeneration & argument_2,
                                const GGS_semanticInstructionListForGeneration & argument_3
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mIsOverriding (argument_0),
mMethodName (argument_1),
mSignature (argument_2),
mInstructionList (argument_3) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_methodDefinitionListForGeneration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_methodDefinitionListForGeneration * ptr = dynamic_cast <const elementOf_GGS_methodDefinitionListForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mIsOverriding.operator_isEqual (ptr->mIsOverriding).boolValue ()
         && mMethodName.operator_isEqual (ptr->mMethodName).boolValue ()
         && mSignature.operator_isEqual (ptr->mSignature).boolValue ()
         && mInstructionList.operator_isEqual (ptr->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_methodDefinitionListForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mIsOverriding.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMethodName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSignature.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                List '@methodDefinitionListForGeneration'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_methodDefinitionListForGeneration ("methodDefinitionListForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_methodDefinitionListForGeneration::
internalAppendValues (const GGS_bool& argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_formalParameterListForGeneration & argument_2,
                    const GGS_semanticInstructionListForGeneration & argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionListForGeneration::
internalPrependValues (const GGS_bool& argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_formalParameterListForGeneration & argument_2,
                    const GGS_semanticInstructionListForGeneration & argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionListForGeneration::
addAssign_operation (const GGS_bool& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_formalParameterListForGeneration & argument_2,
                                const GGS_semanticInstructionListForGeneration & argument_3) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()&& argument_3.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_methodDefinitionListForGeneration GGS_methodDefinitionListForGeneration::
operator_concat (const GGS_methodDefinitionListForGeneration & inOperand) const {
  GGS_methodDefinitionListForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionListForGeneration::
dotAssign_operation (const GGS_methodDefinitionListForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_methodDefinitionListForGeneration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_bool p_0 = p->mIsOverriding ;
          GGS_lstring  p_1 = p->mMethodName ;
          GGS_formalParameterListForGeneration  p_2 = p->mSignature ;
          GGS_semanticInstructionListForGeneration  p_3 = p->mInstructionList ;
          internalAppendValues (p_0, p_1, p_2, p_3 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionListForGeneration::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_bool& argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_formalParameterListForGeneration & argument_2,
                     const GGS_semanticInstructionListForGeneration & argument_3
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionListForGeneration::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mIsOverriding,
                                ptr->mMethodName,
                                ptr->mSignature,
                                ptr->mInstructionList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_methodDefinitionListForGeneration  GGS_methodDefinitionListForGeneration::
constructor_emptyList (void) {
  GGS_methodDefinitionListForGeneration result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_methodDefinitionListForGeneration  GGS_methodDefinitionListForGeneration::
constructor_listWithValue (const GGS_bool& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_formalParameterListForGeneration & argument_2,
                                const GGS_semanticInstructionListForGeneration & argument_3) {
  GGS_methodDefinitionListForGeneration result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2, argument_3) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionListForGeneration::
internalSubListWithRange (GGS_methodDefinitionListForGeneration & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mIsOverriding, ptr->mMethodName, ptr->mSignature, ptr->mInstructionList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_methodDefinitionListForGeneration GGS_methodDefinitionListForGeneration::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_methodDefinitionListForGeneration result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_methodDefinitionListForGeneration GGS_methodDefinitionListForGeneration::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_methodDefinitionListForGeneration result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_methodDefinitionListForGeneration::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@methodDefinitionListForGeneration", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionListForGeneration::
method_first (C_Compiler & inLexique,
              GGS_bool& _out_0,
              GGS_lstring & _out_1,
              GGS_formalParameterListForGeneration & _out_2,
              GGS_semanticInstructionListForGeneration & _out_3
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mIsOverriding ;
    _out_1 = ptr->mMethodName ;
    _out_2 = ptr->mSignature ;
    _out_3 = ptr->mInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionListForGeneration::
method_last (C_Compiler & inLexique,
             GGS_bool& _out_0,
             GGS_lstring & _out_1,
             GGS_formalParameterListForGeneration & _out_2,
             GGS_semanticInstructionListForGeneration & _out_3
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mIsOverriding ;
    _out_1 = ptr->mMethodName ;
    _out_2 = ptr->mSignature ;
    _out_3 = ptr->mInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionListForGeneration::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_bool& _out_0,
                 GGS_lstring & _out_1,
                 GGS_formalParameterListForGeneration & _out_2,
                 GGS_semanticInstructionListForGeneration & _out_3
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mIsOverriding ;
    _out_1 = ptr->mMethodName ;
    _out_2 = ptr->mSignature ;
    _out_3 = ptr->mInstructionList ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionListForGeneration::
modifier_popLast (C_Compiler & inLexique,
                GGS_bool& _out_0,
                GGS_lstring & _out_1,
                GGS_formalParameterListForGeneration & _out_2,
                GGS_semanticInstructionListForGeneration & _out_3
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mIsOverriding ;
    _out_1 = ptr->mMethodName ;
    _out_2 = ptr->mSignature ;
    _out_3 = ptr->mInstructionList ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_bool GGS_methodDefinitionListForGeneration::
reader_mIsOverridingAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mIsOverriding ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_methodDefinitionListForGeneration::
reader_mMethodNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mMethodName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameterListForGeneration  GGS_methodDefinitionListForGeneration::
reader_mSignatureAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_formalParameterListForGeneration  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSignature ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration  GGS_methodDefinitionListForGeneration::
reader_mInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticInstructionListForGeneration  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionListForGeneration::
modifier_setMIsOverridingAtIndex (C_Compiler & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mIsOverriding = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionListForGeneration::
modifier_setMMethodNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mMethodName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionListForGeneration::
modifier_setMSignatureAtIndex (C_Compiler & inLexique,
                              const GGS_formalParameterListForGeneration  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSignature = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionListForGeneration::
modifier_setMInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_semanticInstructionListForGeneration  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_methodDefinitionListForGeneration::cEnumerator::_mIsOverriding (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mIsOverriding ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_methodDefinitionListForGeneration::cEnumerator::_mMethodName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mMethodName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_formalParameterListForGeneration  & GGS_methodDefinitionListForGeneration::cEnumerator::_mSignature (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mSignature ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticInstructionListForGeneration  & GGS_methodDefinitionListForGeneration::cEnumerator::_mInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mInstructionList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_methodDefinitionListForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_methodDefinitionListForGeneration * p = NULL ;
    macroMyNew (p, GGS_methodDefinitionListForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_methodDefinitionListForGeneration GGS_methodDefinitionListForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_methodDefinitionListForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_methodDefinitionListForGeneration * p = dynamic_cast <const GGS_methodDefinitionListForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_methodDefinitionListForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_methodDefinitionListForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_methodDefinitionListForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_classTypeForGeneration'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_classTypeForGeneration::
cPtr_classTypeForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_bool& argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_unifiedTypeMapProxy & argument_3,
                                const GGS_typedAttributeList & argument_4,
                                const GGS_typedAttributeList & argument_5,
                                const GGS_abstractMethodDefinitionListForGeneration & argument_6,
                                const GGS_methodDefinitionListForGeneration & argument_7,
                                const GGS_instanceMethodMap & argument_8
                                COMMA_LOCATION_ARGS)
:cPtr_semanticTypeForGeneration (argument_0 COMMA_THERE),
mIsAbstract (argument_1),
mClassTypeName (argument_2),
mSuperClass (argument_3),
mAllTypedAttributeList (argument_4),
mTypedAttributeList (argument_5),
mAbstractMethodList (argument_6),
mMethodList (argument_7),
mInstanceMethodMap (argument_8) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_classTypeForGeneration * GGS_classTypeForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_classTypeForGeneration) ;
    return (cPtr_classTypeForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_classTypeForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_classTypeForGeneration * ptr = dynamic_cast <const cPtr_classTypeForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTypeIndex.operator_isEqual (ptr->mTypeIndex).boolValue ()
         && mIsAbstract.operator_isEqual (ptr->mIsAbstract).boolValue ()
         && mClassTypeName.operator_isEqual (ptr->mClassTypeName).boolValue ()
         && mSuperClass.operator_isEqual (ptr->mSuperClass).boolValue ()
         && mAllTypedAttributeList.operator_isEqual (ptr->mAllTypedAttributeList).boolValue ()
         && mTypedAttributeList.operator_isEqual (ptr->mTypedAttributeList).boolValue ()
         && mAbstractMethodList.operator_isEqual (ptr->mAbstractMethodList).boolValue ()
         && mMethodList.operator_isEqual (ptr->mMethodList).boolValue ()
         && mInstanceMethodMap.operator_isEqual (ptr->mInstanceMethodMap).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_classTypeForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@classTypeForGeneration:"
           << mTypeIndex.reader_description (inIndentation + 1)
           << mIsAbstract.reader_description (inIndentation + 1)
           << mClassTypeName.reader_description (inIndentation + 1)
           << mSuperClass.reader_description (inIndentation + 1)
           << mAllTypedAttributeList.reader_description (inIndentation + 1)
           << mTypedAttributeList.reader_description (inIndentation + 1)
           << mAbstractMethodList.reader_description (inIndentation + 1)
           << mMethodList.reader_description (inIndentation + 1)
           << mInstanceMethodMap.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_classTypeForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_classTypeForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_classTypeForGeneration (& typeid (cPtr_classTypeForGeneration), & typeid (cPtr_semanticTypeForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_classTypeForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__classTypeForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_classTypeForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_classTypeForGeneration (mTypeIndex, mIsAbstract, mClassTypeName, mSuperClass, mAllTypedAttributeList, mTypedAttributeList, mAbstractMethodList, mMethodList, mInstanceMethodMap COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_classTypeForGeneration'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_classTypeForGeneration ("classTypeForGeneration", true, & kTypeDescriptor_GGS_semanticTypeForGeneration) ;

//---------------------------------------------------------------------------*

GGS_classTypeForGeneration::
GGS_classTypeForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_classTypeForGeneration::
GGS_classTypeForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_classTypeForGeneration GGS_classTypeForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_classTypeForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_classTypeForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_classTypeForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_classTypeForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_classTypeForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_classTypeForGeneration GGS_classTypeForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_bool& argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_unifiedTypeMapProxy & argument_3,
                 const GGS_typedAttributeList & argument_4,
                 const GGS_typedAttributeList & argument_5,
                 const GGS_abstractMethodDefinitionListForGeneration & argument_6,
                 const GGS_methodDefinitionListForGeneration & argument_7,
                 const GGS_instanceMethodMap & argument_8
                                COMMA_LOCATION_ARGS) {
  GGS_classTypeForGeneration result ;
  macroMyNew (result.mPointer, cPtr_classTypeForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7,
                                argument_8 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_classTypeForGeneration::
reader_mIsAbstract (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classTypeForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classTypeForGeneration *) mPointer)->mIsAbstract ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_classTypeForGeneration::
reader_mClassTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classTypeForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classTypeForGeneration *) mPointer)->mClassTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapProxy  GGS_classTypeForGeneration::
reader_mSuperClass (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_unifiedTypeMapProxy   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classTypeForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classTypeForGeneration *) mPointer)->mSuperClass ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typedAttributeList  GGS_classTypeForGeneration::
reader_mAllTypedAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typedAttributeList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classTypeForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classTypeForGeneration *) mPointer)->mAllTypedAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typedAttributeList  GGS_classTypeForGeneration::
reader_mTypedAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typedAttributeList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classTypeForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classTypeForGeneration *) mPointer)->mTypedAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_abstractMethodDefinitionListForGeneration  GGS_classTypeForGeneration::
reader_mAbstractMethodList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_abstractMethodDefinitionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classTypeForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classTypeForGeneration *) mPointer)->mAbstractMethodList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_methodDefinitionListForGeneration  GGS_classTypeForGeneration::
reader_mMethodList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_methodDefinitionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classTypeForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classTypeForGeneration *) mPointer)->mMethodList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_instanceMethodMap  GGS_classTypeForGeneration::
reader_mInstanceMethodMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_instanceMethodMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classTypeForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classTypeForGeneration *) mPointer)->mInstanceMethodMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_classTypeForGeneration::actualTypeName (void) const {
  return "classTypeForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__classTypeForGeneration ("classTypeForGeneration", gClassInfoFor__semanticTypeForGeneration, & kTypeDescriptor_GGS_classTypeForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_classTypeForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_classTypeForGeneration * p = NULL ;
    macroMyNew (p, GGS_classTypeForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_classTypeForGeneration GGS_classTypeForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_classTypeForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_classTypeForGeneration * p = dynamic_cast <const GGS_classTypeForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_classTypeForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_classTypeForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_classTypeForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_listmapTypeForGeneration'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_listmapTypeForGeneration::
cPtr_listmapTypeForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_unifiedTypeMapProxy & argument_1,
                                const GGS_typedAttributeList & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticTypeForGeneration (argument_0 COMMA_THERE),
mAssociatedListTypeIndex (argument_1),
mAssociatedListTypedAttributeList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_listmapTypeForGeneration * GGS_listmapTypeForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_listmapTypeForGeneration) ;
    return (cPtr_listmapTypeForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_listmapTypeForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_listmapTypeForGeneration * ptr = dynamic_cast <const cPtr_listmapTypeForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTypeIndex.operator_isEqual (ptr->mTypeIndex).boolValue ()
         && mAssociatedListTypeIndex.operator_isEqual (ptr->mAssociatedListTypeIndex).boolValue ()
         && mAssociatedListTypedAttributeList.operator_isEqual (ptr->mAssociatedListTypedAttributeList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_listmapTypeForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@listmapTypeForGeneration:"
           << mTypeIndex.reader_description (inIndentation + 1)
           << mAssociatedListTypeIndex.reader_description (inIndentation + 1)
           << mAssociatedListTypedAttributeList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_listmapTypeForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_listmapTypeForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_listmapTypeForGeneration (& typeid (cPtr_listmapTypeForGeneration), & typeid (cPtr_semanticTypeForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_listmapTypeForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__listmapTypeForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_listmapTypeForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_listmapTypeForGeneration (mTypeIndex, mAssociatedListTypeIndex, mAssociatedListTypedAttributeList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_listmapTypeForGeneration'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_listmapTypeForGeneration ("listmapTypeForGeneration", true, & kTypeDescriptor_GGS_semanticTypeForGeneration) ;

//---------------------------------------------------------------------------*

GGS_listmapTypeForGeneration::
GGS_listmapTypeForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_listmapTypeForGeneration::
GGS_listmapTypeForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_listmapTypeForGeneration GGS_listmapTypeForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_listmapTypeForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_listmapTypeForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_listmapTypeForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_listmapTypeForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_listmapTypeForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_listmapTypeForGeneration GGS_listmapTypeForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_unifiedTypeMapProxy & argument_1,
                 const GGS_typedAttributeList & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_listmapTypeForGeneration result ;
  macroMyNew (result.mPointer, cPtr_listmapTypeForGeneration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapProxy  GGS_listmapTypeForGeneration::
reader_mAssociatedListTypeIndex (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_unifiedTypeMapProxy   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_listmapTypeForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_listmapTypeForGeneration *) mPointer)->mAssociatedListTypeIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typedAttributeList  GGS_listmapTypeForGeneration::
reader_mAssociatedListTypedAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typedAttributeList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_listmapTypeForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_listmapTypeForGeneration *) mPointer)->mAssociatedListTypedAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_listmapTypeForGeneration::actualTypeName (void) const {
  return "listmapTypeForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__listmapTypeForGeneration ("listmapTypeForGeneration", gClassInfoFor__semanticTypeForGeneration, & kTypeDescriptor_GGS_listmapTypeForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_listmapTypeForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_listmapTypeForGeneration * p = NULL ;
    macroMyNew (p, GGS_listmapTypeForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_listmapTypeForGeneration GGS_listmapTypeForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_listmapTypeForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_listmapTypeForGeneration * p = dynamic_cast <const GGS_listmapTypeForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_listmapTypeForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_listmapTypeForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_listmapTypeForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_primitiveTypeForGeneration'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_primitiveTypeForGeneration::
cPtr_primitiveTypeForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_string& argument_1,
                                const GGS_predefinedTypeKindEnum& argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticTypeForGeneration (argument_0 COMMA_THERE),
mPredefinedTypeName (argument_1),
mKind (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_primitiveTypeForGeneration * GGS_primitiveTypeForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_primitiveTypeForGeneration) ;
    return (cPtr_primitiveTypeForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_primitiveTypeForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_primitiveTypeForGeneration * ptr = dynamic_cast <const cPtr_primitiveTypeForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTypeIndex.operator_isEqual (ptr->mTypeIndex).boolValue ()
         && mPredefinedTypeName.operator_isEqual (ptr->mPredefinedTypeName).boolValue ()
         && mKind.operator_isEqual (ptr->mKind).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_primitiveTypeForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@primitiveTypeForGeneration:"
           << mTypeIndex.reader_description (inIndentation + 1)
           << mPredefinedTypeName.reader_description (inIndentation + 1)
           << mKind.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_primitiveTypeForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_primitiveTypeForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_primitiveTypeForGeneration (& typeid (cPtr_primitiveTypeForGeneration), & typeid (cPtr_semanticTypeForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_primitiveTypeForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__primitiveTypeForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_primitiveTypeForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_primitiveTypeForGeneration (mTypeIndex, mPredefinedTypeName, mKind COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_primitiveTypeForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_primitiveTypeForGeneration ("primitiveTypeForGeneration", true, & kTypeDescriptor_GGS_semanticTypeForGeneration) ;

//---------------------------------------------------------------------------*

GGS_primitiveTypeForGeneration::
GGS_primitiveTypeForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_primitiveTypeForGeneration::
GGS_primitiveTypeForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_primitiveTypeForGeneration GGS_primitiveTypeForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_primitiveTypeForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_primitiveTypeForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_primitiveTypeForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_primitiveTypeForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_primitiveTypeForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_primitiveTypeForGeneration GGS_primitiveTypeForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_string& argument_1,
                 const GGS_predefinedTypeKindEnum& argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_primitiveTypeForGeneration result ;
  macroMyNew (result.mPointer, cPtr_primitiveTypeForGeneration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_primitiveTypeForGeneration::
reader_mPredefinedTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_primitiveTypeForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_primitiveTypeForGeneration *) mPointer)->mPredefinedTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_predefinedTypeKindEnum GGS_primitiveTypeForGeneration::
reader_mKind (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_predefinedTypeKindEnum  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_primitiveTypeForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_primitiveTypeForGeneration *) mPointer)->mKind ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_primitiveTypeForGeneration::actualTypeName (void) const {
  return "primitiveTypeForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__primitiveTypeForGeneration ("primitiveTypeForGeneration", gClassInfoFor__semanticTypeForGeneration, & kTypeDescriptor_GGS_primitiveTypeForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_primitiveTypeForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_primitiveTypeForGeneration * p = NULL ;
    macroMyNew (p, GGS_primitiveTypeForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_primitiveTypeForGeneration GGS_primitiveTypeForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_primitiveTypeForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_primitiveTypeForGeneration * p = dynamic_cast <const GGS_primitiveTypeForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_primitiveTypeForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_primitiveTypeForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_primitiveTypeForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_listTypeForGeneration'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_listTypeForGeneration::
cPtr_listTypeForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_typedAttributeList & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticTypeForGeneration (argument_0 COMMA_THERE),
mTypedAttributeList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_listTypeForGeneration * GGS_listTypeForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_listTypeForGeneration) ;
    return (cPtr_listTypeForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_listTypeForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_listTypeForGeneration * ptr = dynamic_cast <const cPtr_listTypeForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTypeIndex.operator_isEqual (ptr->mTypeIndex).boolValue ()
         && mTypedAttributeList.operator_isEqual (ptr->mTypedAttributeList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_listTypeForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@listTypeForGeneration:"
           << mTypeIndex.reader_description (inIndentation + 1)
           << mTypedAttributeList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_listTypeForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_listTypeForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_listTypeForGeneration (& typeid (cPtr_listTypeForGeneration), & typeid (cPtr_semanticTypeForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_listTypeForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__listTypeForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_listTypeForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_listTypeForGeneration (mTypeIndex, mTypedAttributeList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_listTypeForGeneration'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_listTypeForGeneration ("listTypeForGeneration", true, & kTypeDescriptor_GGS_semanticTypeForGeneration) ;

//---------------------------------------------------------------------------*

GGS_listTypeForGeneration::
GGS_listTypeForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_listTypeForGeneration::
GGS_listTypeForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_listTypeForGeneration GGS_listTypeForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_listTypeForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_listTypeForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_listTypeForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_listTypeForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_listTypeForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_listTypeForGeneration GGS_listTypeForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_typedAttributeList & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_listTypeForGeneration result ;
  macroMyNew (result.mPointer, cPtr_listTypeForGeneration (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typedAttributeList  GGS_listTypeForGeneration::
reader_mTypedAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typedAttributeList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_listTypeForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_listTypeForGeneration *) mPointer)->mTypedAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_listTypeForGeneration::actualTypeName (void) const {
  return "listTypeForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__listTypeForGeneration ("listTypeForGeneration", gClassInfoFor__semanticTypeForGeneration, & kTypeDescriptor_GGS_listTypeForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_listTypeForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_listTypeForGeneration * p = NULL ;
    macroMyNew (p, GGS_listTypeForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_listTypeForGeneration GGS_listTypeForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_listTypeForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_listTypeForGeneration * p = dynamic_cast <const GGS_listTypeForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_listTypeForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_listTypeForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_listTypeForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_structTypeForGeneration'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_structTypeForGeneration::
cPtr_structTypeForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_typedAttributeList & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticTypeForGeneration (argument_0 COMMA_THERE),
mTypedAttributeList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_structTypeForGeneration * GGS_structTypeForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_structTypeForGeneration) ;
    return (cPtr_structTypeForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_structTypeForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_structTypeForGeneration * ptr = dynamic_cast <const cPtr_structTypeForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTypeIndex.operator_isEqual (ptr->mTypeIndex).boolValue ()
         && mTypedAttributeList.operator_isEqual (ptr->mTypedAttributeList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_structTypeForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@structTypeForGeneration:"
           << mTypeIndex.reader_description (inIndentation + 1)
           << mTypedAttributeList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_structTypeForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_structTypeForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_structTypeForGeneration (& typeid (cPtr_structTypeForGeneration), & typeid (cPtr_semanticTypeForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_structTypeForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__structTypeForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_structTypeForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_structTypeForGeneration (mTypeIndex, mTypedAttributeList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_structTypeForGeneration'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_structTypeForGeneration ("structTypeForGeneration", true, & kTypeDescriptor_GGS_semanticTypeForGeneration) ;

//---------------------------------------------------------------------------*

GGS_structTypeForGeneration::
GGS_structTypeForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_structTypeForGeneration::
GGS_structTypeForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_structTypeForGeneration GGS_structTypeForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_structTypeForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_structTypeForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_structTypeForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_structTypeForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_structTypeForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_structTypeForGeneration GGS_structTypeForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_typedAttributeList & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_structTypeForGeneration result ;
  macroMyNew (result.mPointer, cPtr_structTypeForGeneration (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typedAttributeList  GGS_structTypeForGeneration::
reader_mTypedAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typedAttributeList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_structTypeForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_structTypeForGeneration *) mPointer)->mTypedAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_structTypeForGeneration::actualTypeName (void) const {
  return "structTypeForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__structTypeForGeneration ("structTypeForGeneration", gClassInfoFor__semanticTypeForGeneration, & kTypeDescriptor_GGS_structTypeForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_structTypeForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_structTypeForGeneration * p = NULL ;
    macroMyNew (p, GGS_structTypeForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_structTypeForGeneration GGS_structTypeForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_structTypeForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_structTypeForGeneration * p = dynamic_cast <const GGS_structTypeForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_structTypeForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_structTypeForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_structTypeForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Element of list '@sortDescriptorListForGeneration'             *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_sortDescriptorListForGeneration::
elementOf_GGS_sortDescriptorListForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_string& argument_1,
                                const GGS_bool& argument_2
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mAttributeTypeIndex (argument_0),
mAttributeName (argument_1),
mAscendingOrder (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_sortDescriptorListForGeneration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_sortDescriptorListForGeneration * ptr = dynamic_cast <const elementOf_GGS_sortDescriptorListForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mAttributeTypeIndex.operator_isEqual (ptr->mAttributeTypeIndex).boolValue ()
         && mAttributeName.operator_isEqual (ptr->mAttributeName).boolValue ()
         && mAscendingOrder.operator_isEqual (ptr->mAscendingOrder).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_sortDescriptorListForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAttributeTypeIndex.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAttributeName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAscendingOrder.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 List '@sortDescriptorListForGeneration'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_sortDescriptorListForGeneration ("sortDescriptorListForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_sortDescriptorListForGeneration::
internalAppendValues (const GGS_unifiedTypeMapProxy & argument_0,
                    const GGS_string& argument_1,
                    const GGS_bool& argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_sortDescriptorListForGeneration::
internalPrependValues (const GGS_unifiedTypeMapProxy & argument_0,
                    const GGS_string& argument_1,
                    const GGS_bool& argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_sortDescriptorListForGeneration::
addAssign_operation (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_string& argument_1,
                                const GGS_bool& argument_2) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_sortDescriptorListForGeneration GGS_sortDescriptorListForGeneration::
operator_concat (const GGS_sortDescriptorListForGeneration & inOperand) const {
  GGS_sortDescriptorListForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_sortDescriptorListForGeneration::
dotAssign_operation (const GGS_sortDescriptorListForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_sortDescriptorListForGeneration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_unifiedTypeMapProxy  p_0 = p->mAttributeTypeIndex ;
          GGS_string p_1 = p->mAttributeName ;
          GGS_bool p_2 = p->mAscendingOrder ;
          internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_sortDescriptorListForGeneration::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_unifiedTypeMapProxy & argument_0,
                     const GGS_string& argument_1,
                     const GGS_bool& argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_sortDescriptorListForGeneration::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mAttributeTypeIndex,
                                ptr->mAttributeName,
                                ptr->mAscendingOrder
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_sortDescriptorListForGeneration  GGS_sortDescriptorListForGeneration::
constructor_emptyList (void) {
  GGS_sortDescriptorListForGeneration result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sortDescriptorListForGeneration  GGS_sortDescriptorListForGeneration::
constructor_listWithValue (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_string& argument_1,
                                const GGS_bool& argument_2) {
  GGS_sortDescriptorListForGeneration result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_sortDescriptorListForGeneration::
internalSubListWithRange (GGS_sortDescriptorListForGeneration & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mAttributeTypeIndex, ptr->mAttributeName, ptr->mAscendingOrder) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_sortDescriptorListForGeneration GGS_sortDescriptorListForGeneration::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_sortDescriptorListForGeneration result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sortDescriptorListForGeneration GGS_sortDescriptorListForGeneration::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_sortDescriptorListForGeneration result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_sortDescriptorListForGeneration::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@sortDescriptorListForGeneration", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_sortDescriptorListForGeneration::
method_first (C_Compiler & inLexique,
              GGS_unifiedTypeMapProxy & _out_0,
              GGS_string& _out_1,
              GGS_bool& _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAttributeTypeIndex ;
    _out_1 = ptr->mAttributeName ;
    _out_2 = ptr->mAscendingOrder ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_sortDescriptorListForGeneration::
method_last (C_Compiler & inLexique,
             GGS_unifiedTypeMapProxy & _out_0,
             GGS_string& _out_1,
             GGS_bool& _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAttributeTypeIndex ;
    _out_1 = ptr->mAttributeName ;
    _out_2 = ptr->mAscendingOrder ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_sortDescriptorListForGeneration::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_unifiedTypeMapProxy & _out_0,
                 GGS_string& _out_1,
                 GGS_bool& _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAttributeTypeIndex ;
    _out_1 = ptr->mAttributeName ;
    _out_2 = ptr->mAscendingOrder ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_sortDescriptorListForGeneration::
modifier_popLast (C_Compiler & inLexique,
                GGS_unifiedTypeMapProxy & _out_0,
                GGS_string& _out_1,
                GGS_bool& _out_2
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAttributeTypeIndex ;
    _out_1 = ptr->mAttributeName ;
    _out_2 = ptr->mAscendingOrder ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapProxy  GGS_sortDescriptorListForGeneration::
reader_mAttributeTypeIndexAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_unifiedTypeMapProxy  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mAttributeTypeIndex ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_sortDescriptorListForGeneration::
reader_mAttributeNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_string result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mAttributeName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_sortDescriptorListForGeneration::
reader_mAscendingOrderAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mAscendingOrder ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_sortDescriptorListForGeneration::
modifier_setMAttributeTypeIndexAtIndex (C_Compiler & inLexique,
                              const GGS_unifiedTypeMapProxy  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mAttributeTypeIndex = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_sortDescriptorListForGeneration::
modifier_setMAttributeNameAtIndex (C_Compiler & inLexique,
                              const GGS_string & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mAttributeName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_sortDescriptorListForGeneration::
modifier_setMAscendingOrderAtIndex (C_Compiler & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mAscendingOrder = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_unifiedTypeMapProxy  & GGS_sortDescriptorListForGeneration::cEnumerator::_mAttributeTypeIndex (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mAttributeTypeIndex ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_sortDescriptorListForGeneration::cEnumerator::_mAttributeName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mAttributeName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_sortDescriptorListForGeneration::cEnumerator::_mAscendingOrder (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mAscendingOrder ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_sortDescriptorListForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_sortDescriptorListForGeneration * p = NULL ;
    macroMyNew (p, GGS_sortDescriptorListForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sortDescriptorListForGeneration GGS_sortDescriptorListForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_sortDescriptorListForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_sortDescriptorListForGeneration * p = dynamic_cast <const GGS_sortDescriptorListForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_sortDescriptorListForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_sortDescriptorListForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_sortDescriptorListForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_sortedListTypeForGeneration'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_sortedListTypeForGeneration::
cPtr_sortedListTypeForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_typedAttributeList & argument_1,
                                const GGS_sortDescriptorListForGeneration & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticTypeForGeneration (argument_0 COMMA_THERE),
mTypedAttributeList (argument_1),
mSortDescriptorList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_sortedListTypeForGeneration * GGS_sortedListTypeForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_sortedListTypeForGeneration) ;
    return (cPtr_sortedListTypeForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_sortedListTypeForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_sortedListTypeForGeneration * ptr = dynamic_cast <const cPtr_sortedListTypeForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTypeIndex.operator_isEqual (ptr->mTypeIndex).boolValue ()
         && mTypedAttributeList.operator_isEqual (ptr->mTypedAttributeList).boolValue ()
         && mSortDescriptorList.operator_isEqual (ptr->mSortDescriptorList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_sortedListTypeForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@sortedListTypeForGeneration:"
           << mTypeIndex.reader_description (inIndentation + 1)
           << mTypedAttributeList.reader_description (inIndentation + 1)
           << mSortDescriptorList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_sortedListTypeForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_sortedListTypeForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_sortedListTypeForGeneration (& typeid (cPtr_sortedListTypeForGeneration), & typeid (cPtr_semanticTypeForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_sortedListTypeForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__sortedListTypeForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_sortedListTypeForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_sortedListTypeForGeneration (mTypeIndex, mTypedAttributeList, mSortDescriptorList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_sortedListTypeForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_sortedListTypeForGeneration ("sortedListTypeForGeneration", true, & kTypeDescriptor_GGS_semanticTypeForGeneration) ;

//---------------------------------------------------------------------------*

GGS_sortedListTypeForGeneration::
GGS_sortedListTypeForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_sortedListTypeForGeneration::
GGS_sortedListTypeForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_sortedListTypeForGeneration GGS_sortedListTypeForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_sortedListTypeForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_sortedListTypeForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_sortedListTypeForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_sortedListTypeForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_sortedListTypeForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sortedListTypeForGeneration GGS_sortedListTypeForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_typedAttributeList & argument_1,
                 const GGS_sortDescriptorListForGeneration & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_sortedListTypeForGeneration result ;
  macroMyNew (result.mPointer, cPtr_sortedListTypeForGeneration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typedAttributeList  GGS_sortedListTypeForGeneration::
reader_mTypedAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typedAttributeList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sortedListTypeForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sortedListTypeForGeneration *) mPointer)->mTypedAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sortDescriptorListForGeneration  GGS_sortedListTypeForGeneration::
reader_mSortDescriptorList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_sortDescriptorListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sortedListTypeForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sortedListTypeForGeneration *) mPointer)->mSortDescriptorList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_sortedListTypeForGeneration::actualTypeName (void) const {
  return "sortedListTypeForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__sortedListTypeForGeneration ("sortedListTypeForGeneration", gClassInfoFor__semanticTypeForGeneration, & kTypeDescriptor_GGS_sortedListTypeForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_sortedListTypeForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_sortedListTypeForGeneration * p = NULL ;
    macroMyNew (p, GGS_sortedListTypeForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sortedListTypeForGeneration GGS_sortedListTypeForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_sortedListTypeForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_sortedListTypeForGeneration * p = dynamic_cast <const GGS_sortedListTypeForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_sortedListTypeForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_sortedListTypeForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_sortedListTypeForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//     Element of list '@enumMessageAssociationSortedListForGeneration'      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_enumMessageAssociationSortedListForGeneration::
elementOf_GGS_enumMessageAssociationSortedListForGeneration (const GGS_uint & argument_0,
                                const GGS_string& argument_1,
                                const GGS_string& argument_2):
mConstantIndex (argument_0),
mConstantName (argument_1),
mMessage (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_enumMessageAssociationSortedListForGeneration::
isEqualToObject (const cSortedListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_enumMessageAssociationSortedListForGeneration * ptr = dynamic_cast <const elementOf_GGS_enumMessageAssociationSortedListForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mConstantIndex.operator_isEqual (ptr->mConstantIndex).boolValue ()
         && mConstantName.operator_isEqual (ptr->mConstantName).boolValue ()
         && mMessage.operator_isEqual (ptr->mMessage).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

PMSInt32 elementOf_GGS_enumMessageAssociationSortedListForGeneration::
compareForSorting (const cSortedListElement * inOperand) const {
  const elementOf_GGS_enumMessageAssociationSortedListForGeneration * operand = (const elementOf_GGS_enumMessageAssociationSortedListForGeneration *) inOperand ;
  PMSInt32 result = mConstantIndex.genericObjectCompare (operand->mConstantIndex) ;
  return result ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_enumMessageAssociationSortedListForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mConstantIndex.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mConstantName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMessage.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//       Sorted list '@enumMessageAssociationSortedListForGeneration'        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_enumMessageAssociationSortedListForGeneration ("enumMessageAssociationSortedListForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

GGS_enumMessageAssociationSortedListForGeneration::GGS_enumMessageAssociationSortedListForGeneration (void): AC_GGS_sortedlist () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_enumMessageAssociationSortedListForGeneration::
GGS_enumMessageAssociationSortedListForGeneration (const GGS_enumMessageAssociationSortedListForGeneration & inSource): AC_GGS_sortedlist (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_enumMessageAssociationSortedListForGeneration::
operator_isEqual (const GGS_enumMessageAssociationSortedListForGeneration & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_enumMessageAssociationSortedListForGeneration::
operator_isNotEqual (const GGS_enumMessageAssociationSortedListForGeneration & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationSortedListForGeneration::
internalAppendValues (const GGS_uint & argument_0,
                    const GGS_string& argument_1,
                    const GGS_string& argument_2) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationSortedListForGeneration::
addAssign_operation (const GGS_uint & argument_0,
                                const GGS_string& argument_1,
                                const GGS_string& argument_2) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

GGS_enumMessageAssociationSortedListForGeneration GGS_enumMessageAssociationSortedListForGeneration::
operator_concat (const GGS_enumMessageAssociationSortedListForGeneration & inOperand) const {
  GGS_enumMessageAssociationSortedListForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationSortedListForGeneration::
dotAssign_operation (const GGS_enumMessageAssociationSortedListForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      *this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_enumMessageAssociationSortedListForGeneration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_uint  p_0 = p->mConstantIndex ;
          GGS_string p_1 = p->mConstantName ;
          GGS_string p_2 = p->mMessage ;
          internalAppendValues (p_0, p_1, p_2) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationSortedListForGeneration::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mConstantIndex,
                                ptr->mConstantName,
                                ptr->mMessage) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_enumMessageAssociationSortedListForGeneration  GGS_enumMessageAssociationSortedListForGeneration::
constructor_emptySortedList (void) {
  GGS_enumMessageAssociationSortedListForGeneration result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMessageAssociationSortedListForGeneration  GGS_enumMessageAssociationSortedListForGeneration::
constructor_sortedListWithValue (const GGS_uint & argument_0,
                           const GGS_string& argument_1,
                           const GGS_string& argument_2) {
  GGS_enumMessageAssociationSortedListForGeneration result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_enumMessageAssociationSortedListForGeneration::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@enumMessageAssociationSortedListForGeneration", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationSortedListForGeneration::
method_smallest (C_Compiler & inLexique,
                 GGS_uint & _out_0,
                 GGS_string& _out_1,
                 GGS_string& _out_2
                 COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mConstantIndex ;
    _out_1 = ptr->mConstantName ;
    _out_2 = ptr->mMessage ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationSortedListForGeneration::
method_greatest (C_Compiler & inLexique,
             GGS_uint & _out_0,
             GGS_string& _out_1,
             GGS_string& _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'greatest' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mConstantIndex ;
    _out_1 = ptr->mConstantName ;
    _out_2 = ptr->mMessage ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationSortedListForGeneration::
modifier_popSmallest (C_Compiler & inLexique,
                 GGS_uint & _out_0,
                 GGS_string& _out_1,
                 GGS_string& _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popSmallest' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mConstantIndex ;
    _out_1 = ptr->mConstantName ;
    _out_2 = ptr->mMessage ;
    insulateList () ;
    _internalRemoveSmallest () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationSortedListForGeneration::
modifier_popGreatest (C_Compiler & inLexique,
                GGS_uint & _out_0,
                GGS_string& _out_1,
                GGS_string& _out_2
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popGreatest' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mConstantIndex ;
    _out_1 = ptr->mConstantName ;
    _out_2 = ptr->mMessage ;
    insulateList () ;
    _internalRemoveGreatest () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_enumMessageAssociationSortedListForGeneration::cEnumerator::_mConstantIndex (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mConstantIndex ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_enumMessageAssociationSortedListForGeneration::cEnumerator::_mConstantName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mConstantName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_enumMessageAssociationSortedListForGeneration::cEnumerator::_mMessage (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mMessage ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_enumMessageAssociationSortedListForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_enumMessageAssociationSortedListForGeneration * p = NULL ;
    macroMyNew (p, GGS_enumMessageAssociationSortedListForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMessageAssociationSortedListForGeneration GGS_enumMessageAssociationSortedListForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_enumMessageAssociationSortedListForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_enumMessageAssociationSortedListForGeneration * p = dynamic_cast <const GGS_enumMessageAssociationSortedListForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_enumMessageAssociationSortedListForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_enumMessageAssociationSortedListForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_enumMessageAssociationSortedListForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@enumMessageListForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_enumMessageListForGeneration::
elementOf_GGS_enumMessageListForGeneration (const GGS_string& argument_0,
                                const GGS_enumMessageAssociationSortedListForGeneration & argument_1
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mEnumMessageName (argument_0),
mMessageAssociationList (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_enumMessageListForGeneration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_enumMessageListForGeneration * ptr = dynamic_cast <const elementOf_GGS_enumMessageListForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mEnumMessageName.operator_isEqual (ptr->mEnumMessageName).boolValue ()
         && mMessageAssociationList.operator_isEqual (ptr->mMessageAssociationList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_enumMessageListForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEnumMessageName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMessageAssociationList.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@enumMessageListForGeneration'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_enumMessageListForGeneration ("enumMessageListForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_enumMessageListForGeneration::
internalAppendValues (const GGS_string& argument_0,
                    const GGS_enumMessageAssociationSortedListForGeneration & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageListForGeneration::
internalPrependValues (const GGS_string& argument_0,
                    const GGS_enumMessageAssociationSortedListForGeneration & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageListForGeneration::
addAssign_operation (const GGS_string& argument_0,
                                const GGS_enumMessageAssociationSortedListForGeneration & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_enumMessageListForGeneration GGS_enumMessageListForGeneration::
operator_concat (const GGS_enumMessageListForGeneration & inOperand) const {
  GGS_enumMessageListForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageListForGeneration::
dotAssign_operation (const GGS_enumMessageListForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_enumMessageListForGeneration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_string p_0 = p->mEnumMessageName ;
          GGS_enumMessageAssociationSortedListForGeneration  p_1 = p->mMessageAssociationList ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageListForGeneration::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_string& argument_0,
                     const GGS_enumMessageAssociationSortedListForGeneration & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageListForGeneration::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mEnumMessageName,
                                ptr->mMessageAssociationList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_enumMessageListForGeneration  GGS_enumMessageListForGeneration::
constructor_emptyList (void) {
  GGS_enumMessageListForGeneration result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMessageListForGeneration  GGS_enumMessageListForGeneration::
constructor_listWithValue (const GGS_string& argument_0,
                                const GGS_enumMessageAssociationSortedListForGeneration & argument_1) {
  GGS_enumMessageListForGeneration result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageListForGeneration::
internalSubListWithRange (GGS_enumMessageListForGeneration & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mEnumMessageName, ptr->mMessageAssociationList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_enumMessageListForGeneration GGS_enumMessageListForGeneration::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_enumMessageListForGeneration result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMessageListForGeneration GGS_enumMessageListForGeneration::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_enumMessageListForGeneration result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_enumMessageListForGeneration::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@enumMessageListForGeneration", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageListForGeneration::
method_first (C_Compiler & inLexique,
              GGS_string& _out_0,
              GGS_enumMessageAssociationSortedListForGeneration & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mEnumMessageName ;
    _out_1 = ptr->mMessageAssociationList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageListForGeneration::
method_last (C_Compiler & inLexique,
             GGS_string& _out_0,
             GGS_enumMessageAssociationSortedListForGeneration & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mEnumMessageName ;
    _out_1 = ptr->mMessageAssociationList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageListForGeneration::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_string& _out_0,
                 GGS_enumMessageAssociationSortedListForGeneration & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mEnumMessageName ;
    _out_1 = ptr->mMessageAssociationList ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageListForGeneration::
modifier_popLast (C_Compiler & inLexique,
                GGS_string& _out_0,
                GGS_enumMessageAssociationSortedListForGeneration & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mEnumMessageName ;
    _out_1 = ptr->mMessageAssociationList ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_string GGS_enumMessageListForGeneration::
reader_mEnumMessageNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_string result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mEnumMessageName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMessageAssociationSortedListForGeneration  GGS_enumMessageListForGeneration::
reader_mMessageAssociationListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_enumMessageAssociationSortedListForGeneration  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mMessageAssociationList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageListForGeneration::
modifier_setMEnumMessageNameAtIndex (C_Compiler & inLexique,
                              const GGS_string & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mEnumMessageName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageListForGeneration::
modifier_setMMessageAssociationListAtIndex (C_Compiler & inLexique,
                              const GGS_enumMessageAssociationSortedListForGeneration  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mMessageAssociationList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_enumMessageListForGeneration::cEnumerator::_mEnumMessageName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mEnumMessageName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_enumMessageAssociationSortedListForGeneration  & GGS_enumMessageListForGeneration::cEnumerator::_mMessageAssociationList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mMessageAssociationList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_enumMessageListForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_enumMessageListForGeneration * p = NULL ;
    macroMyNew (p, GGS_enumMessageListForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMessageListForGeneration GGS_enumMessageListForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_enumMessageListForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_enumMessageListForGeneration * p = dynamic_cast <const GGS_enumMessageListForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_enumMessageListForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_enumMessageListForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_enumMessageListForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_enumTypeForGeneration'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_enumTypeForGeneration::
cPtr_enumTypeForGeneration (const GGS_unifiedTypeMapProxy & argument_0,
                                const GGS_stringlist & argument_1,
                                const GGS_enumMessageListForGeneration & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticTypeForGeneration (argument_0 COMMA_THERE),
mConstantList (argument_1),
mEnumMessageList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_enumTypeForGeneration * GGS_enumTypeForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_enumTypeForGeneration) ;
    return (cPtr_enumTypeForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_enumTypeForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_enumTypeForGeneration * ptr = dynamic_cast <const cPtr_enumTypeForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTypeIndex.operator_isEqual (ptr->mTypeIndex).boolValue ()
         && mConstantList.operator_isEqual (ptr->mConstantList).boolValue ()
         && mEnumMessageList.operator_isEqual (ptr->mEnumMessageList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_enumTypeForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@enumTypeForGeneration:"
           << mTypeIndex.reader_description (inIndentation + 1)
           << mConstantList.reader_description (inIndentation + 1)
           << mEnumMessageList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_enumTypeForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_enumTypeForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_enumTypeForGeneration (& typeid (cPtr_enumTypeForGeneration), & typeid (cPtr_semanticTypeForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_enumTypeForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__enumTypeForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_enumTypeForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_enumTypeForGeneration (mTypeIndex, mConstantList, mEnumMessageList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_enumTypeForGeneration'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_enumTypeForGeneration ("enumTypeForGeneration", true, & kTypeDescriptor_GGS_semanticTypeForGeneration) ;

//---------------------------------------------------------------------------*

GGS_enumTypeForGeneration::
GGS_enumTypeForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_enumTypeForGeneration::
GGS_enumTypeForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_enumTypeForGeneration GGS_enumTypeForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_enumTypeForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_enumTypeForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_enumTypeForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_enumTypeForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_enumTypeForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumTypeForGeneration GGS_enumTypeForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_unifiedTypeMapProxy & argument_0,
                 const GGS_stringlist & argument_1,
                 const GGS_enumMessageListForGeneration & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_enumTypeForGeneration result ;
  macroMyNew (result.mPointer, cPtr_enumTypeForGeneration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringlist  GGS_enumTypeForGeneration::
reader_mConstantList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_stringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumTypeForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumTypeForGeneration *) mPointer)->mConstantList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMessageListForGeneration  GGS_enumTypeForGeneration::
reader_mEnumMessageList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_enumMessageListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumTypeForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumTypeForGeneration *) mPointer)->mEnumMessageList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_enumTypeForGeneration::actualTypeName (void) const {
  return "enumTypeForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__enumTypeForGeneration ("enumTypeForGeneration", gClassInfoFor__semanticTypeForGeneration, & kTypeDescriptor_GGS_enumTypeForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_enumTypeForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_enumTypeForGeneration * p = NULL ;
    macroMyNew (p, GGS_enumTypeForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumTypeForGeneration GGS_enumTypeForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_enumTypeForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_enumTypeForGeneration * p = dynamic_cast <const GGS_enumTypeForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_enumTypeForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_enumTypeForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_enumTypeForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_abstractCategoryMethodForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_abstractCategoryMethodForGeneration::
cPtr_abstractCategoryMethodForGeneration (const GGS_string& argument_0,
                                const GGS_string& argument_1,
                                const GGS_formalParameterListForGeneration & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticDeclarationForGeneration (THERE),
mTypeName (argument_0),
mAbstractCategoryMethodName (argument_1),
mAbstractCategoryMethodFormalParameterList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_abstractCategoryMethodForGeneration * GGS_abstractCategoryMethodForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_abstractCategoryMethodForGeneration) ;
    return (cPtr_abstractCategoryMethodForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_abstractCategoryMethodForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_abstractCategoryMethodForGeneration * ptr = dynamic_cast <const cPtr_abstractCategoryMethodForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTypeName.operator_isEqual (ptr->mTypeName).boolValue ()
         && mAbstractCategoryMethodName.operator_isEqual (ptr->mAbstractCategoryMethodName).boolValue ()
         && mAbstractCategoryMethodFormalParameterList.operator_isEqual (ptr->mAbstractCategoryMethodFormalParameterList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_abstractCategoryMethodForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@abstractCategoryMethodForGeneration:"
           << mTypeName.reader_description (inIndentation + 1)
           << mAbstractCategoryMethodName.reader_description (inIndentation + 1)
           << mAbstractCategoryMethodFormalParameterList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_abstractCategoryMethodForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_abstractCategoryMethodForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_abstractCategoryMethodForGeneration (& typeid (cPtr_abstractCategoryMethodForGeneration), & typeid (cPtr_semanticDeclarationForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_abstractCategoryMethodForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__abstractCategoryMethodForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_abstractCategoryMethodForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_abstractCategoryMethodForGeneration (mTypeName, mAbstractCategoryMethodName, mAbstractCategoryMethodFormalParameterList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_abstractCategoryMethodForGeneration'           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_abstractCategoryMethodForGeneration ("abstractCategoryMethodForGeneration", true, & kTypeDescriptor_GGS_semanticDeclarationForGeneration) ;

//---------------------------------------------------------------------------*

GGS_abstractCategoryMethodForGeneration::
GGS_abstractCategoryMethodForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_abstractCategoryMethodForGeneration::
GGS_abstractCategoryMethodForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_abstractCategoryMethodForGeneration GGS_abstractCategoryMethodForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_abstractCategoryMethodForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_abstractCategoryMethodForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_abstractCategoryMethodForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_abstractCategoryMethodForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_abstractCategoryMethodForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_abstractCategoryMethodForGeneration GGS_abstractCategoryMethodForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0,
                 const GGS_string& argument_1,
                 const GGS_formalParameterListForGeneration & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_abstractCategoryMethodForGeneration result ;
  macroMyNew (result.mPointer, cPtr_abstractCategoryMethodForGeneration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_abstractCategoryMethodForGeneration::
reader_mTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_abstractCategoryMethodForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_abstractCategoryMethodForGeneration *) mPointer)->mTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_abstractCategoryMethodForGeneration::
reader_mAbstractCategoryMethodName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_abstractCategoryMethodForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_abstractCategoryMethodForGeneration *) mPointer)->mAbstractCategoryMethodName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameterListForGeneration  GGS_abstractCategoryMethodForGeneration::
reader_mAbstractCategoryMethodFormalParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_formalParameterListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_abstractCategoryMethodForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_abstractCategoryMethodForGeneration *) mPointer)->mAbstractCategoryMethodFormalParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_abstractCategoryMethodForGeneration::actualTypeName (void) const {
  return "abstractCategoryMethodForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__abstractCategoryMethodForGeneration ("abstractCategoryMethodForGeneration", gClassInfoFor__semanticDeclarationForGeneration, & kTypeDescriptor_GGS_abstractCategoryMethodForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_abstractCategoryMethodForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_abstractCategoryMethodForGeneration * p = NULL ;
    macroMyNew (p, GGS_abstractCategoryMethodForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_abstractCategoryMethodForGeneration GGS_abstractCategoryMethodForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_abstractCategoryMethodForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_abstractCategoryMethodForGeneration * p = dynamic_cast <const GGS_abstractCategoryMethodForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_abstractCategoryMethodForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_abstractCategoryMethodForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_abstractCategoryMethodForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_categoryMethodForGeneration'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_categoryMethodForGeneration::
cPtr_categoryMethodForGeneration (const GGS_string& argument_0,
                                const GGS_string& argument_1,
                                const GGS_formalParameterListForGeneration & argument_2,
                                const GGS_typedAttributeList & argument_3,
                                const GGS_semanticInstructionListForGeneration & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_semanticDeclarationForGeneration (THERE),
mTypeName (argument_0),
mCategoryMethodName (argument_1),
mCategoryMethodFormalParameterList (argument_2),
mTypedAttributeList (argument_3),
mSemanticInstructionListForGeneration (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_categoryMethodForGeneration * GGS_categoryMethodForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_categoryMethodForGeneration) ;
    return (cPtr_categoryMethodForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_categoryMethodForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_categoryMethodForGeneration * ptr = dynamic_cast <const cPtr_categoryMethodForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTypeName.operator_isEqual (ptr->mTypeName).boolValue ()
         && mCategoryMethodName.operator_isEqual (ptr->mCategoryMethodName).boolValue ()
         && mCategoryMethodFormalParameterList.operator_isEqual (ptr->mCategoryMethodFormalParameterList).boolValue ()
         && mTypedAttributeList.operator_isEqual (ptr->mTypedAttributeList).boolValue ()
         && mSemanticInstructionListForGeneration.operator_isEqual (ptr->mSemanticInstructionListForGeneration).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_categoryMethodForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@categoryMethodForGeneration:"
           << mTypeName.reader_description (inIndentation + 1)
           << mCategoryMethodName.reader_description (inIndentation + 1)
           << mCategoryMethodFormalParameterList.reader_description (inIndentation + 1)
           << mTypedAttributeList.reader_description (inIndentation + 1)
           << mSemanticInstructionListForGeneration.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_categoryMethodForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_categoryMethodForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_categoryMethodForGeneration (& typeid (cPtr_categoryMethodForGeneration), & typeid (cPtr_semanticDeclarationForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_categoryMethodForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__categoryMethodForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_categoryMethodForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_categoryMethodForGeneration (mTypeName, mCategoryMethodName, mCategoryMethodFormalParameterList, mTypedAttributeList, mSemanticInstructionListForGeneration COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_categoryMethodForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_categoryMethodForGeneration ("categoryMethodForGeneration", true, & kTypeDescriptor_GGS_semanticDeclarationForGeneration) ;

//---------------------------------------------------------------------------*

GGS_categoryMethodForGeneration::
GGS_categoryMethodForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_categoryMethodForGeneration::
GGS_categoryMethodForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_categoryMethodForGeneration GGS_categoryMethodForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_categoryMethodForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_categoryMethodForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_categoryMethodForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_categoryMethodForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_categoryMethodForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_categoryMethodForGeneration GGS_categoryMethodForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0,
                 const GGS_string& argument_1,
                 const GGS_formalParameterListForGeneration & argument_2,
                 const GGS_typedAttributeList & argument_3,
                 const GGS_semanticInstructionListForGeneration & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_categoryMethodForGeneration result ;
  macroMyNew (result.mPointer, cPtr_categoryMethodForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_categoryMethodForGeneration::
reader_mTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_categoryMethodForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_categoryMethodForGeneration *) mPointer)->mTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_categoryMethodForGeneration::
reader_mCategoryMethodName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_categoryMethodForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_categoryMethodForGeneration *) mPointer)->mCategoryMethodName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameterListForGeneration  GGS_categoryMethodForGeneration::
reader_mCategoryMethodFormalParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_formalParameterListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_categoryMethodForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_categoryMethodForGeneration *) mPointer)->mCategoryMethodFormalParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typedAttributeList  GGS_categoryMethodForGeneration::
reader_mTypedAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typedAttributeList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_categoryMethodForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_categoryMethodForGeneration *) mPointer)->mTypedAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration  GGS_categoryMethodForGeneration::
reader_mSemanticInstructionListForGeneration (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_categoryMethodForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_categoryMethodForGeneration *) mPointer)->mSemanticInstructionListForGeneration ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_categoryMethodForGeneration::actualTypeName (void) const {
  return "categoryMethodForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__categoryMethodForGeneration ("categoryMethodForGeneration", gClassInfoFor__semanticDeclarationForGeneration, & kTypeDescriptor_GGS_categoryMethodForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_categoryMethodForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_categoryMethodForGeneration * p = NULL ;
    macroMyNew (p, GGS_categoryMethodForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_categoryMethodForGeneration GGS_categoryMethodForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_categoryMethodForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_categoryMethodForGeneration * p = dynamic_cast <const GGS_categoryMethodForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_categoryMethodForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_categoryMethodForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_categoryMethodForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            class 'cPtr_overridingCategoryMethodForGeneration'             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_overridingCategoryMethodForGeneration::
cPtr_overridingCategoryMethodForGeneration (const GGS_string& argument_0,
                                const GGS_string& argument_1,
                                const GGS_string& argument_2,
                                const GGS_formalParameterListForGeneration & argument_3,
                                const GGS_typedAttributeList & argument_4,
                                const GGS_semanticInstructionListForGeneration & argument_5
                                COMMA_LOCATION_ARGS)
:cPtr_semanticDeclarationForGeneration (THERE),
mTypeName (argument_0),
mBaseTypeName (argument_1),
mCategoryMethodName (argument_2),
mCategoryMethodFormalParameterList (argument_3),
mTypedAttributeList (argument_4),
mSemanticInstructionListForGeneration (argument_5) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_overridingCategoryMethodForGeneration * GGS_overridingCategoryMethodForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_overridingCategoryMethodForGeneration) ;
    return (cPtr_overridingCategoryMethodForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_overridingCategoryMethodForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_overridingCategoryMethodForGeneration * ptr = dynamic_cast <const cPtr_overridingCategoryMethodForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTypeName.operator_isEqual (ptr->mTypeName).boolValue ()
         && mBaseTypeName.operator_isEqual (ptr->mBaseTypeName).boolValue ()
         && mCategoryMethodName.operator_isEqual (ptr->mCategoryMethodName).boolValue ()
         && mCategoryMethodFormalParameterList.operator_isEqual (ptr->mCategoryMethodFormalParameterList).boolValue ()
         && mTypedAttributeList.operator_isEqual (ptr->mTypedAttributeList).boolValue ()
         && mSemanticInstructionListForGeneration.operator_isEqual (ptr->mSemanticInstructionListForGeneration).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_overridingCategoryMethodForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@overridingCategoryMethodForGeneration:"
           << mTypeName.reader_description (inIndentation + 1)
           << mBaseTypeName.reader_description (inIndentation + 1)
           << mCategoryMethodName.reader_description (inIndentation + 1)
           << mCategoryMethodFormalParameterList.reader_description (inIndentation + 1)
           << mTypedAttributeList.reader_description (inIndentation + 1)
           << mSemanticInstructionListForGeneration.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_overridingCategoryMethodForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_overridingCategoryMethodForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_overridingCategoryMethodForGeneration (& typeid (cPtr_overridingCategoryMethodForGeneration), & typeid (cPtr_semanticDeclarationForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_overridingCategoryMethodForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__overridingCategoryMethodForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_overridingCategoryMethodForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_overridingCategoryMethodForGeneration (mTypeName, mBaseTypeName, mCategoryMethodName, mCategoryMethodFormalParameterList, mTypedAttributeList, mSemanticInstructionListForGeneration COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         GALGAS class 'GGS_overridingCategoryMethodForGeneration'          *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_overridingCategoryMethodForGeneration ("overridingCategoryMethodForGeneration", true, & kTypeDescriptor_GGS_semanticDeclarationForGeneration) ;

//---------------------------------------------------------------------------*

GGS_overridingCategoryMethodForGeneration::
GGS_overridingCategoryMethodForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_overridingCategoryMethodForGeneration::
GGS_overridingCategoryMethodForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_overridingCategoryMethodForGeneration GGS_overridingCategoryMethodForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_overridingCategoryMethodForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_overridingCategoryMethodForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_overridingCategoryMethodForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_overridingCategoryMethodForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_overridingCategoryMethodForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_overridingCategoryMethodForGeneration GGS_overridingCategoryMethodForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0,
                 const GGS_string& argument_1,
                 const GGS_string& argument_2,
                 const GGS_formalParameterListForGeneration & argument_3,
                 const GGS_typedAttributeList & argument_4,
                 const GGS_semanticInstructionListForGeneration & argument_5
                                COMMA_LOCATION_ARGS) {
  GGS_overridingCategoryMethodForGeneration result ;
  macroMyNew (result.mPointer, cPtr_overridingCategoryMethodForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_overridingCategoryMethodForGeneration::
reader_mTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_overridingCategoryMethodForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_overridingCategoryMethodForGeneration *) mPointer)->mTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_overridingCategoryMethodForGeneration::
reader_mBaseTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_overridingCategoryMethodForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_overridingCategoryMethodForGeneration *) mPointer)->mBaseTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_overridingCategoryMethodForGeneration::
reader_mCategoryMethodName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_overridingCategoryMethodForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_overridingCategoryMethodForGeneration *) mPointer)->mCategoryMethodName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameterListForGeneration  GGS_overridingCategoryMethodForGeneration::
reader_mCategoryMethodFormalParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_formalParameterListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_overridingCategoryMethodForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_overridingCategoryMethodForGeneration *) mPointer)->mCategoryMethodFormalParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typedAttributeList  GGS_overridingCategoryMethodForGeneration::
reader_mTypedAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typedAttributeList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_overridingCategoryMethodForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_overridingCategoryMethodForGeneration *) mPointer)->mTypedAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration  GGS_overridingCategoryMethodForGeneration::
reader_mSemanticInstructionListForGeneration (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_overridingCategoryMethodForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_overridingCategoryMethodForGeneration *) mPointer)->mSemanticInstructionListForGeneration ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_overridingCategoryMethodForGeneration::actualTypeName (void) const {
  return "overridingCategoryMethodForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__overridingCategoryMethodForGeneration ("overridingCategoryMethodForGeneration", gClassInfoFor__semanticDeclarationForGeneration, & kTypeDescriptor_GGS_overridingCategoryMethodForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_overridingCategoryMethodForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_overridingCategoryMethodForGeneration * p = NULL ;
    macroMyNew (p, GGS_overridingCategoryMethodForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_overridingCategoryMethodForGeneration GGS_overridingCategoryMethodForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_overridingCategoryMethodForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_overridingCategoryMethodForGeneration * p = dynamic_cast <const GGS_overridingCategoryMethodForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_overridingCategoryMethodForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_overridingCategoryMethodForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_overridingCategoryMethodForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_abstractCategoryReaderForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_abstractCategoryReaderForGeneration::
cPtr_abstractCategoryReaderForGeneration (const GGS_string& argument_0,
                                const GGS_string& argument_1,
                                const GGS_unifiedTypeMapProxy & argument_2,
                                const GGS_formalInputParameterListForGeneration & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticDeclarationForGeneration (THERE),
mTypeName (argument_0),
mAbstractCategoryReaderName (argument_1),
mResultType (argument_2),
mAbstractCategoryReaderFormalParameterList (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_abstractCategoryReaderForGeneration * GGS_abstractCategoryReaderForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_abstractCategoryReaderForGeneration) ;
    return (cPtr_abstractCategoryReaderForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_abstractCategoryReaderForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_abstractCategoryReaderForGeneration * ptr = dynamic_cast <const cPtr_abstractCategoryReaderForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTypeName.operator_isEqual (ptr->mTypeName).boolValue ()
         && mAbstractCategoryReaderName.operator_isEqual (ptr->mAbstractCategoryReaderName).boolValue ()
         && mResultType.operator_isEqual (ptr->mResultType).boolValue ()
         && mAbstractCategoryReaderFormalParameterList.operator_isEqual (ptr->mAbstractCategoryReaderFormalParameterList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_abstractCategoryReaderForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@abstractCategoryReaderForGeneration:"
           << mTypeName.reader_description (inIndentation + 1)
           << mAbstractCategoryReaderName.reader_description (inIndentation + 1)
           << mResultType.reader_description (inIndentation + 1)
           << mAbstractCategoryReaderFormalParameterList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_abstractCategoryReaderForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_abstractCategoryReaderForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_abstractCategoryReaderForGeneration (& typeid (cPtr_abstractCategoryReaderForGeneration), & typeid (cPtr_semanticDeclarationForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_abstractCategoryReaderForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__abstractCategoryReaderForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_abstractCategoryReaderForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_abstractCategoryReaderForGeneration (mTypeName, mAbstractCategoryReaderName, mResultType, mAbstractCategoryReaderFormalParameterList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_abstractCategoryReaderForGeneration'           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_abstractCategoryReaderForGeneration ("abstractCategoryReaderForGeneration", true, & kTypeDescriptor_GGS_semanticDeclarationForGeneration) ;

//---------------------------------------------------------------------------*

GGS_abstractCategoryReaderForGeneration::
GGS_abstractCategoryReaderForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_abstractCategoryReaderForGeneration::
GGS_abstractCategoryReaderForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_abstractCategoryReaderForGeneration GGS_abstractCategoryReaderForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_abstractCategoryReaderForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_abstractCategoryReaderForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_abstractCategoryReaderForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_abstractCategoryReaderForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_abstractCategoryReaderForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_abstractCategoryReaderForGeneration GGS_abstractCategoryReaderForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0,
                 const GGS_string& argument_1,
                 const GGS_unifiedTypeMapProxy & argument_2,
                 const GGS_formalInputParameterListForGeneration & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_abstractCategoryReaderForGeneration result ;
  macroMyNew (result.mPointer, cPtr_abstractCategoryReaderForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_abstractCategoryReaderForGeneration::
reader_mTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_abstractCategoryReaderForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_abstractCategoryReaderForGeneration *) mPointer)->mTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_abstractCategoryReaderForGeneration::
reader_mAbstractCategoryReaderName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_abstractCategoryReaderForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_abstractCategoryReaderForGeneration *) mPointer)->mAbstractCategoryReaderName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapProxy  GGS_abstractCategoryReaderForGeneration::
reader_mResultType (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_unifiedTypeMapProxy   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_abstractCategoryReaderForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_abstractCategoryReaderForGeneration *) mPointer)->mResultType ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalInputParameterListForGeneration  GGS_abstractCategoryReaderForGeneration::
reader_mAbstractCategoryReaderFormalParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_formalInputParameterListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_abstractCategoryReaderForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_abstractCategoryReaderForGeneration *) mPointer)->mAbstractCategoryReaderFormalParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_abstractCategoryReaderForGeneration::actualTypeName (void) const {
  return "abstractCategoryReaderForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__abstractCategoryReaderForGeneration ("abstractCategoryReaderForGeneration", gClassInfoFor__semanticDeclarationForGeneration, & kTypeDescriptor_GGS_abstractCategoryReaderForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_abstractCategoryReaderForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_abstractCategoryReaderForGeneration * p = NULL ;
    macroMyNew (p, GGS_abstractCategoryReaderForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_abstractCategoryReaderForGeneration GGS_abstractCategoryReaderForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_abstractCategoryReaderForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_abstractCategoryReaderForGeneration * p = dynamic_cast <const GGS_abstractCategoryReaderForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_abstractCategoryReaderForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_abstractCategoryReaderForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_abstractCategoryReaderForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_categoryReaderForGeneration'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_categoryReaderForGeneration::
cPtr_categoryReaderForGeneration (const GGS_string& argument_0,
                                const GGS_string& argument_1,
                                const GGS_unifiedTypeMapProxy & argument_2,
                                const GGS_string& argument_3,
                                const GGS_formalInputParameterListForGeneration & argument_4,
                                const GGS_typedAttributeList & argument_5,
                                const GGS_semanticInstructionListForGeneration & argument_6
                                COMMA_LOCATION_ARGS)
:cPtr_semanticDeclarationForGeneration (THERE),
mTypeName (argument_0),
mCategoryReaderName (argument_1),
mResultType (argument_2),
mResultVarCppName (argument_3),
mCategoryReaderFormalParameterList (argument_4),
mTypedAttributeList (argument_5),
mSemanticInstructionListForGeneration (argument_6) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_categoryReaderForGeneration * GGS_categoryReaderForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_categoryReaderForGeneration) ;
    return (cPtr_categoryReaderForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_categoryReaderForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_categoryReaderForGeneration * ptr = dynamic_cast <const cPtr_categoryReaderForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTypeName.operator_isEqual (ptr->mTypeName).boolValue ()
         && mCategoryReaderName.operator_isEqual (ptr->mCategoryReaderName).boolValue ()
         && mResultType.operator_isEqual (ptr->mResultType).boolValue ()
         && mResultVarCppName.operator_isEqual (ptr->mResultVarCppName).boolValue ()
         && mCategoryReaderFormalParameterList.operator_isEqual (ptr->mCategoryReaderFormalParameterList).boolValue ()
         && mTypedAttributeList.operator_isEqual (ptr->mTypedAttributeList).boolValue ()
         && mSemanticInstructionListForGeneration.operator_isEqual (ptr->mSemanticInstructionListForGeneration).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_categoryReaderForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@categoryReaderForGeneration:"
           << mTypeName.reader_description (inIndentation + 1)
           << mCategoryReaderName.reader_description (inIndentation + 1)
           << mResultType.reader_description (inIndentation + 1)
           << mResultVarCppName.reader_description (inIndentation + 1)
           << mCategoryReaderFormalParameterList.reader_description (inIndentation + 1)
           << mTypedAttributeList.reader_description (inIndentation + 1)
           << mSemanticInstructionListForGeneration.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_categoryReaderForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_categoryReaderForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_categoryReaderForGeneration (& typeid (cPtr_categoryReaderForGeneration), & typeid (cPtr_semanticDeclarationForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_categoryReaderForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__categoryReaderForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_categoryReaderForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_categoryReaderForGeneration (mTypeName, mCategoryReaderName, mResultType, mResultVarCppName, mCategoryReaderFormalParameterList, mTypedAttributeList, mSemanticInstructionListForGeneration COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_categoryReaderForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_categoryReaderForGeneration ("categoryReaderForGeneration", true, & kTypeDescriptor_GGS_semanticDeclarationForGeneration) ;

//---------------------------------------------------------------------------*

GGS_categoryReaderForGeneration::
GGS_categoryReaderForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_categoryReaderForGeneration::
GGS_categoryReaderForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_categoryReaderForGeneration GGS_categoryReaderForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_categoryReaderForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_categoryReaderForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_categoryReaderForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_categoryReaderForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_categoryReaderForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_categoryReaderForGeneration GGS_categoryReaderForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0,
                 const GGS_string& argument_1,
                 const GGS_unifiedTypeMapProxy & argument_2,
                 const GGS_string& argument_3,
                 const GGS_formalInputParameterListForGeneration & argument_4,
                 const GGS_typedAttributeList & argument_5,
                 const GGS_semanticInstructionListForGeneration & argument_6
                                COMMA_LOCATION_ARGS) {
  GGS_categoryReaderForGeneration result ;
  macroMyNew (result.mPointer, cPtr_categoryReaderForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_categoryReaderForGeneration::
reader_mTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_categoryReaderForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_categoryReaderForGeneration *) mPointer)->mTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_categoryReaderForGeneration::
reader_mCategoryReaderName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_categoryReaderForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_categoryReaderForGeneration *) mPointer)->mCategoryReaderName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapProxy  GGS_categoryReaderForGeneration::
reader_mResultType (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_unifiedTypeMapProxy   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_categoryReaderForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_categoryReaderForGeneration *) mPointer)->mResultType ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_categoryReaderForGeneration::
reader_mResultVarCppName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_categoryReaderForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_categoryReaderForGeneration *) mPointer)->mResultVarCppName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalInputParameterListForGeneration  GGS_categoryReaderForGeneration::
reader_mCategoryReaderFormalParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_formalInputParameterListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_categoryReaderForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_categoryReaderForGeneration *) mPointer)->mCategoryReaderFormalParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typedAttributeList  GGS_categoryReaderForGeneration::
reader_mTypedAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typedAttributeList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_categoryReaderForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_categoryReaderForGeneration *) mPointer)->mTypedAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration  GGS_categoryReaderForGeneration::
reader_mSemanticInstructionListForGeneration (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_categoryReaderForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_categoryReaderForGeneration *) mPointer)->mSemanticInstructionListForGeneration ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_categoryReaderForGeneration::actualTypeName (void) const {
  return "categoryReaderForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__categoryReaderForGeneration ("categoryReaderForGeneration", gClassInfoFor__semanticDeclarationForGeneration, & kTypeDescriptor_GGS_categoryReaderForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_categoryReaderForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_categoryReaderForGeneration * p = NULL ;
    macroMyNew (p, GGS_categoryReaderForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_categoryReaderForGeneration GGS_categoryReaderForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_categoryReaderForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_categoryReaderForGeneration * p = dynamic_cast <const GGS_categoryReaderForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_categoryReaderForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_categoryReaderForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_categoryReaderForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_overrideCategoryReaderForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_overrideCategoryReaderForGeneration::
cPtr_overrideCategoryReaderForGeneration (const GGS_string& argument_0,
                                const GGS_string& argument_1,
                                const GGS_string& argument_2,
                                const GGS_unifiedTypeMapProxy & argument_3,
                                const GGS_string& argument_4,
                                const GGS_formalInputParameterListForGeneration & argument_5,
                                const GGS_typedAttributeList & argument_6,
                                const GGS_semanticInstructionListForGeneration & argument_7
                                COMMA_LOCATION_ARGS)
:cPtr_semanticDeclarationForGeneration (THERE),
mTypeName (argument_0),
mBaseTypeName (argument_1),
mOverridingCategoryReaderName (argument_2),
mResultType (argument_3),
mResultVarCppName (argument_4),
mOverridingCategoryReaderFormalParameterList (argument_5),
mTypedAttributeList (argument_6),
mSemanticInstructionListForGeneration (argument_7) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_overrideCategoryReaderForGeneration * GGS_overrideCategoryReaderForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_overrideCategoryReaderForGeneration) ;
    return (cPtr_overrideCategoryReaderForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_overrideCategoryReaderForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_overrideCategoryReaderForGeneration * ptr = dynamic_cast <const cPtr_overrideCategoryReaderForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTypeName.operator_isEqual (ptr->mTypeName).boolValue ()
         && mBaseTypeName.operator_isEqual (ptr->mBaseTypeName).boolValue ()
         && mOverridingCategoryReaderName.operator_isEqual (ptr->mOverridingCategoryReaderName).boolValue ()
         && mResultType.operator_isEqual (ptr->mResultType).boolValue ()
         && mResultVarCppName.operator_isEqual (ptr->mResultVarCppName).boolValue ()
         && mOverridingCategoryReaderFormalParameterList.operator_isEqual (ptr->mOverridingCategoryReaderFormalParameterList).boolValue ()
         && mTypedAttributeList.operator_isEqual (ptr->mTypedAttributeList).boolValue ()
         && mSemanticInstructionListForGeneration.operator_isEqual (ptr->mSemanticInstructionListForGeneration).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_overrideCategoryReaderForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@overrideCategoryReaderForGeneration:"
           << mTypeName.reader_description (inIndentation + 1)
           << mBaseTypeName.reader_description (inIndentation + 1)
           << mOverridingCategoryReaderName.reader_description (inIndentation + 1)
           << mResultType.reader_description (inIndentation + 1)
           << mResultVarCppName.reader_description (inIndentation + 1)
           << mOverridingCategoryReaderFormalParameterList.reader_description (inIndentation + 1)
           << mTypedAttributeList.reader_description (inIndentation + 1)
           << mSemanticInstructionListForGeneration.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_overrideCategoryReaderForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_overrideCategoryReaderForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_overrideCategoryReaderForGeneration (& typeid (cPtr_overrideCategoryReaderForGeneration), & typeid (cPtr_semanticDeclarationForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_overrideCategoryReaderForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__overrideCategoryReaderForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_overrideCategoryReaderForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_overrideCategoryReaderForGeneration (mTypeName, mBaseTypeName, mOverridingCategoryReaderName, mResultType, mResultVarCppName, mOverridingCategoryReaderFormalParameterList, mTypedAttributeList, mSemanticInstructionListForGeneration COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_overrideCategoryReaderForGeneration'           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_overrideCategoryReaderForGeneration ("overrideCategoryReaderForGeneration", true, & kTypeDescriptor_GGS_semanticDeclarationForGeneration) ;

//---------------------------------------------------------------------------*

GGS_overrideCategoryReaderForGeneration::
GGS_overrideCategoryReaderForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_overrideCategoryReaderForGeneration::
GGS_overrideCategoryReaderForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_overrideCategoryReaderForGeneration GGS_overrideCategoryReaderForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_overrideCategoryReaderForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_overrideCategoryReaderForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_overrideCategoryReaderForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_overrideCategoryReaderForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_overrideCategoryReaderForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_overrideCategoryReaderForGeneration GGS_overrideCategoryReaderForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0,
                 const GGS_string& argument_1,
                 const GGS_string& argument_2,
                 const GGS_unifiedTypeMapProxy & argument_3,
                 const GGS_string& argument_4,
                 const GGS_formalInputParameterListForGeneration & argument_5,
                 const GGS_typedAttributeList & argument_6,
                 const GGS_semanticInstructionListForGeneration & argument_7
                                COMMA_LOCATION_ARGS) {
  GGS_overrideCategoryReaderForGeneration result ;
  macroMyNew (result.mPointer, cPtr_overrideCategoryReaderForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_overrideCategoryReaderForGeneration::
reader_mTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_overrideCategoryReaderForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_overrideCategoryReaderForGeneration *) mPointer)->mTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_overrideCategoryReaderForGeneration::
reader_mBaseTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_overrideCategoryReaderForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_overrideCategoryReaderForGeneration *) mPointer)->mBaseTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_overrideCategoryReaderForGeneration::
reader_mOverridingCategoryReaderName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_overrideCategoryReaderForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_overrideCategoryReaderForGeneration *) mPointer)->mOverridingCategoryReaderName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapProxy  GGS_overrideCategoryReaderForGeneration::
reader_mResultType (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_unifiedTypeMapProxy   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_overrideCategoryReaderForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_overrideCategoryReaderForGeneration *) mPointer)->mResultType ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_overrideCategoryReaderForGeneration::
reader_mResultVarCppName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_overrideCategoryReaderForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_overrideCategoryReaderForGeneration *) mPointer)->mResultVarCppName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalInputParameterListForGeneration  GGS_overrideCategoryReaderForGeneration::
reader_mOverridingCategoryReaderFormalParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_formalInputParameterListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_overrideCategoryReaderForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_overrideCategoryReaderForGeneration *) mPointer)->mOverridingCategoryReaderFormalParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typedAttributeList  GGS_overrideCategoryReaderForGeneration::
reader_mTypedAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typedAttributeList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_overrideCategoryReaderForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_overrideCategoryReaderForGeneration *) mPointer)->mTypedAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListForGeneration  GGS_overrideCategoryReaderForGeneration::
reader_mSemanticInstructionListForGeneration (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_overrideCategoryReaderForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_overrideCategoryReaderForGeneration *) mPointer)->mSemanticInstructionListForGeneration ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_overrideCategoryReaderForGeneration::actualTypeName (void) const {
  return "overrideCategoryReaderForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__overrideCategoryReaderForGeneration ("overrideCategoryReaderForGeneration", gClassInfoFor__semanticDeclarationForGeneration, & kTypeDescriptor_GGS_overrideCategoryReaderForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_overrideCategoryReaderForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_overrideCategoryReaderForGeneration * p = NULL ;
    macroMyNew (p, GGS_overrideCategoryReaderForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_overrideCategoryReaderForGeneration GGS_overrideCategoryReaderForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_overrideCategoryReaderForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_overrideCategoryReaderForGeneration * p = dynamic_cast <const GGS_overrideCategoryReaderForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_overrideCategoryReaderForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_overrideCategoryReaderForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_overrideCategoryReaderForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         Element of list '@filewrapperTemplateListForGeneration'           *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_filewrapperTemplateListForGeneration::
elementOf_GGS_filewrapperTemplateListForGeneration (const GGS_string& argument_0,
                                const GGS_formalInputParameterListForGeneration & argument_1,
                                const GGS_templateInstructionListForGeneration & argument_2
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mFilewrapperTemplateName (argument_0),
mFilewrapperTemplateFormalInputParameters (argument_1),
mTemplateInstructionListForGeneration (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_filewrapperTemplateListForGeneration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_filewrapperTemplateListForGeneration * ptr = dynamic_cast <const elementOf_GGS_filewrapperTemplateListForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mFilewrapperTemplateName.operator_isEqual (ptr->mFilewrapperTemplateName).boolValue ()
         && mFilewrapperTemplateFormalInputParameters.operator_isEqual (ptr->mFilewrapperTemplateFormalInputParameters).boolValue ()
         && mTemplateInstructionListForGeneration.operator_isEqual (ptr->mTemplateInstructionListForGeneration).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_filewrapperTemplateListForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFilewrapperTemplateName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFilewrapperTemplateFormalInputParameters.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTemplateInstructionListForGeneration.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               List '@filewrapperTemplateListForGeneration'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_filewrapperTemplateListForGeneration ("filewrapperTemplateListForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateListForGeneration::
internalAppendValues (const GGS_string& argument_0,
                    const GGS_formalInputParameterListForGeneration & argument_1,
                    const GGS_templateInstructionListForGeneration & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateListForGeneration::
internalPrependValues (const GGS_string& argument_0,
                    const GGS_formalInputParameterListForGeneration & argument_1,
                    const GGS_templateInstructionListForGeneration & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateListForGeneration::
addAssign_operation (const GGS_string& argument_0,
                                const GGS_formalInputParameterListForGeneration & argument_1,
                                const GGS_templateInstructionListForGeneration & argument_2) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateListForGeneration GGS_filewrapperTemplateListForGeneration::
operator_concat (const GGS_filewrapperTemplateListForGeneration & inOperand) const {
  GGS_filewrapperTemplateListForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateListForGeneration::
dotAssign_operation (const GGS_filewrapperTemplateListForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_filewrapperTemplateListForGeneration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_string p_0 = p->mFilewrapperTemplateName ;
          GGS_formalInputParameterListForGeneration  p_1 = p->mFilewrapperTemplateFormalInputParameters ;
          GGS_templateInstructionListForGeneration  p_2 = p->mTemplateInstructionListForGeneration ;
          internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateListForGeneration::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_string& argument_0,
                     const GGS_formalInputParameterListForGeneration & argument_1,
                     const GGS_templateInstructionListForGeneration & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateListForGeneration::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mFilewrapperTemplateName,
                                ptr->mFilewrapperTemplateFormalInputParameters,
                                ptr->mTemplateInstructionListForGeneration
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateListForGeneration  GGS_filewrapperTemplateListForGeneration::
constructor_emptyList (void) {
  GGS_filewrapperTemplateListForGeneration result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateListForGeneration  GGS_filewrapperTemplateListForGeneration::
constructor_listWithValue (const GGS_string& argument_0,
                                const GGS_formalInputParameterListForGeneration & argument_1,
                                const GGS_templateInstructionListForGeneration & argument_2) {
  GGS_filewrapperTemplateListForGeneration result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateListForGeneration::
internalSubListWithRange (GGS_filewrapperTemplateListForGeneration & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mFilewrapperTemplateName, ptr->mFilewrapperTemplateFormalInputParameters, ptr->mTemplateInstructionListForGeneration) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateListForGeneration GGS_filewrapperTemplateListForGeneration::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_filewrapperTemplateListForGeneration result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateListForGeneration GGS_filewrapperTemplateListForGeneration::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_filewrapperTemplateListForGeneration result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_filewrapperTemplateListForGeneration::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@filewrapperTemplateListForGeneration", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateListForGeneration::
method_first (C_Compiler & inLexique,
              GGS_string& _out_0,
              GGS_formalInputParameterListForGeneration & _out_1,
              GGS_templateInstructionListForGeneration & _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mFilewrapperTemplateName ;
    _out_1 = ptr->mFilewrapperTemplateFormalInputParameters ;
    _out_2 = ptr->mTemplateInstructionListForGeneration ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateListForGeneration::
method_last (C_Compiler & inLexique,
             GGS_string& _out_0,
             GGS_formalInputParameterListForGeneration & _out_1,
             GGS_templateInstructionListForGeneration & _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mFilewrapperTemplateName ;
    _out_1 = ptr->mFilewrapperTemplateFormalInputParameters ;
    _out_2 = ptr->mTemplateInstructionListForGeneration ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateListForGeneration::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_string& _out_0,
                 GGS_formalInputParameterListForGeneration & _out_1,
                 GGS_templateInstructionListForGeneration & _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mFilewrapperTemplateName ;
    _out_1 = ptr->mFilewrapperTemplateFormalInputParameters ;
    _out_2 = ptr->mTemplateInstructionListForGeneration ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateListForGeneration::
modifier_popLast (C_Compiler & inLexique,
                GGS_string& _out_0,
                GGS_formalInputParameterListForGeneration & _out_1,
                GGS_templateInstructionListForGeneration & _out_2
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mFilewrapperTemplateName ;
    _out_1 = ptr->mFilewrapperTemplateFormalInputParameters ;
    _out_2 = ptr->mTemplateInstructionListForGeneration ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_string GGS_filewrapperTemplateListForGeneration::
reader_mFilewrapperTemplateNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_string result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mFilewrapperTemplateName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalInputParameterListForGeneration  GGS_filewrapperTemplateListForGeneration::
reader_mFilewrapperTemplateFormalInputParametersAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_formalInputParameterListForGeneration  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mFilewrapperTemplateFormalInputParameters ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionListForGeneration  GGS_filewrapperTemplateListForGeneration::
reader_mTemplateInstructionListForGenerationAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_templateInstructionListForGeneration  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mTemplateInstructionListForGeneration ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateListForGeneration::
modifier_setMFilewrapperTemplateNameAtIndex (C_Compiler & inLexique,
                              const GGS_string & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mFilewrapperTemplateName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateListForGeneration::
modifier_setMFilewrapperTemplateFormalInputParametersAtIndex (C_Compiler & inLexique,
                              const GGS_formalInputParameterListForGeneration  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mFilewrapperTemplateFormalInputParameters = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateListForGeneration::
modifier_setMTemplateInstructionListForGenerationAtIndex (C_Compiler & inLexique,
                              const GGS_templateInstructionListForGeneration  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mTemplateInstructionListForGeneration = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_filewrapperTemplateListForGeneration::cEnumerator::_mFilewrapperTemplateName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mFilewrapperTemplateName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_formalInputParameterListForGeneration  & GGS_filewrapperTemplateListForGeneration::cEnumerator::_mFilewrapperTemplateFormalInputParameters (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mFilewrapperTemplateFormalInputParameters ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_templateInstructionListForGeneration  & GGS_filewrapperTemplateListForGeneration::cEnumerator::_mTemplateInstructionListForGeneration (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mTemplateInstructionListForGeneration ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_filewrapperTemplateListForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_filewrapperTemplateListForGeneration * p = NULL ;
    macroMyNew (p, GGS_filewrapperTemplateListForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateListForGeneration GGS_filewrapperTemplateListForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_filewrapperTemplateListForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_filewrapperTemplateListForGeneration * p = dynamic_cast <const GGS_filewrapperTemplateListForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_filewrapperTemplateListForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_filewrapperTemplateListForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_filewrapperTemplateListForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_filewrapperDeclarationForGeneration'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_filewrapperDeclarationForGeneration::
cPtr_filewrapperDeclarationForGeneration (const GGS_string& argument_0,
                                const GGS_string& argument_1,
                                const GGS_wrapperFileMap & argument_2,
                                const GGS_wrapperDirectoryMap & argument_3,
                                const GGS_filewrapperTemplateListForGeneration & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_semanticDeclarationForGeneration (THERE),
mFilewrapperName (argument_0),
mFilewrapperAbsolutePath (argument_1),
mFilewrapperFileMap (argument_2),
mFilewrapperDirectoryMap (argument_3),
mFilewrapperTemplateListForGeneration (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_filewrapperDeclarationForGeneration * GGS_filewrapperDeclarationForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_filewrapperDeclarationForGeneration) ;
    return (cPtr_filewrapperDeclarationForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_filewrapperDeclarationForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_filewrapperDeclarationForGeneration * ptr = dynamic_cast <const cPtr_filewrapperDeclarationForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mFilewrapperName.operator_isEqual (ptr->mFilewrapperName).boolValue ()
         && mFilewrapperAbsolutePath.operator_isEqual (ptr->mFilewrapperAbsolutePath).boolValue ()
         && mFilewrapperFileMap.operator_isEqual (ptr->mFilewrapperFileMap).boolValue ()
         && mFilewrapperDirectoryMap.operator_isEqual (ptr->mFilewrapperDirectoryMap).boolValue ()
         && mFilewrapperTemplateListForGeneration.operator_isEqual (ptr->mFilewrapperTemplateListForGeneration).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_filewrapperDeclarationForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@filewrapperDeclarationForGeneration:"
           << mFilewrapperName.reader_description (inIndentation + 1)
           << mFilewrapperAbsolutePath.reader_description (inIndentation + 1)
           << mFilewrapperFileMap.reader_description (inIndentation + 1)
           << mFilewrapperDirectoryMap.reader_description (inIndentation + 1)
           << mFilewrapperTemplateListForGeneration.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_filewrapperDeclarationForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_filewrapperDeclarationForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_filewrapperDeclarationForGeneration (& typeid (cPtr_filewrapperDeclarationForGeneration), & typeid (cPtr_semanticDeclarationForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_filewrapperDeclarationForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__filewrapperDeclarationForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_filewrapperDeclarationForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_filewrapperDeclarationForGeneration (mFilewrapperName, mFilewrapperAbsolutePath, mFilewrapperFileMap, mFilewrapperDirectoryMap, mFilewrapperTemplateListForGeneration COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_filewrapperDeclarationForGeneration'           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_filewrapperDeclarationForGeneration ("filewrapperDeclarationForGeneration", true, & kTypeDescriptor_GGS_semanticDeclarationForGeneration) ;

//---------------------------------------------------------------------------*

GGS_filewrapperDeclarationForGeneration::
GGS_filewrapperDeclarationForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperDeclarationForGeneration::
GGS_filewrapperDeclarationForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_filewrapperDeclarationForGeneration GGS_filewrapperDeclarationForGeneration::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_filewrapperDeclarationForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_filewrapperDeclarationForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_filewrapperDeclarationForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_filewrapperDeclarationForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_filewrapperDeclarationForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperDeclarationForGeneration GGS_filewrapperDeclarationForGeneration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0,
                 const GGS_string& argument_1,
                 const GGS_wrapperFileMap & argument_2,
                 const GGS_wrapperDirectoryMap & argument_3,
                 const GGS_filewrapperTemplateListForGeneration & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_filewrapperDeclarationForGeneration result ;
  macroMyNew (result.mPointer, cPtr_filewrapperDeclarationForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_filewrapperDeclarationForGeneration::
reader_mFilewrapperName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_filewrapperDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_filewrapperDeclarationForGeneration *) mPointer)->mFilewrapperName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_filewrapperDeclarationForGeneration::
reader_mFilewrapperAbsolutePath (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_filewrapperDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_filewrapperDeclarationForGeneration *) mPointer)->mFilewrapperAbsolutePath ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_wrapperFileMap  GGS_filewrapperDeclarationForGeneration::
reader_mFilewrapperFileMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_wrapperFileMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_filewrapperDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_filewrapperDeclarationForGeneration *) mPointer)->mFilewrapperFileMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_wrapperDirectoryMap  GGS_filewrapperDeclarationForGeneration::
reader_mFilewrapperDirectoryMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_wrapperDirectoryMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_filewrapperDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_filewrapperDeclarationForGeneration *) mPointer)->mFilewrapperDirectoryMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateListForGeneration  GGS_filewrapperDeclarationForGeneration::
reader_mFilewrapperTemplateListForGeneration (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_filewrapperTemplateListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_filewrapperDeclarationForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_filewrapperDeclarationForGeneration *) mPointer)->mFilewrapperTemplateListForGeneration ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_filewrapperDeclarationForGeneration::actualTypeName (void) const {
  return "filewrapperDeclarationForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__filewrapperDeclarationForGeneration ("filewrapperDeclarationForGeneration", gClassInfoFor__semanticDeclarationForGeneration, & kTypeDescriptor_GGS_filewrapperDeclarationForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_filewrapperDeclarationForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_filewrapperDeclarationForGeneration * p = NULL ;
    macroMyNew (p, GGS_filewrapperDeclarationForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperDeclarationForGeneration GGS_filewrapperDeclarationForGeneration::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_filewrapperDeclarationForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_filewrapperDeclarationForGeneration * p = dynamic_cast <const GGS_filewrapperDeclarationForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_filewrapperDeclarationForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_filewrapperDeclarationForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_filewrapperDeclarationForGeneration ;
}

//---------------------------------------------------------------------------*

