//---------------------------------------------------------------------------*
//                                                                           *
//                        File 'lexiqueSemantics.h'                          *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                       june 1st, 2009, at 16h30'43"                        *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

#ifndef lexiqueSemantics_DEFINED
#define lexiqueSemantics_DEFINED

#include <string.h>

//---------------------------------------------------------------------------*

#include "galgas/C_GGS_Object.h"
#include "galgas/GGS_location.h"
#include "galgas/GGS_lbool.h"
#include "galgas/GGS_lchar.h"
#include "galgas/GGS_lstring.h"
#include "galgas/GGS_ldouble.h"
#include "galgas/GGS_luint.h"
#include "galgas/GGS_lsint.h"
#include "galgas/GGS_luint64.h"
#include "galgas/GGS_lsint64.h"
#include "galgas/GGS_stringset.h"
#include "galgas/GGS_binaryset.h"
#include "galgas/GGS_filewrapper.h"
#include "galgas/predefined_types.h"
#include "galgas/AC_galgas_class.h"
#include "galgas/AC_galgas_domain.h"
#include "galgas/AC_galgas_mapindex.h"
#include "galgas/AC_galgas_map.h"
#include "galgas/AC_galgas_listmap.h"
#include "galgas/AC_galgas_list.h"
#include "galgas/AC_galgas_sortedlist.h"

//---------------------------------------------------------------------------*

#include "galgas/C_Lexique.h"

//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                          Class Predeclarations                            *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalTypeEnum ;
class GGS_lexicalTypeList ;
class GGS_lexicalTypeMap ;
class GGS_lexicalAttributeMap ;
class GGS_terminalMap ;
class GGS_lexicalExplicitTokenListMap ;
class GGS_lexicalExplicitTokenListMapMap ;
class GGS_lexicalMessageMap ;
class GGS_lexicalArgumentMode ;
class GGS_lexicalRoutineFormalArgumentList ;
class GGS_lexicalRoutineMap ;
class GGS_lexicalFunctionMap ;
class GGS_lexiqueAnalysisContext ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 Class for 'lexicalTypeEnum' Enumeration                   *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalTypeEnum {
//--- Enumeration
  public : enum enumeration {kNotBuilt, enum_lexicalType_char, enum_lexicalType_double, enum_lexicalType_sint, enum_lexicalType_sint64, enum_lexicalType_string, enum_lexicalType_uint, enum_lexicalType_uint64} ;

//--- Private attribute
  private : enumeration mValue ;

//--- Get value
  public : inline enumeration enumValue (void) const { return mValue ; }

//--- Default constructor
  public : inline GGS_lexicalTypeEnum (void) : mValue (kNotBuilt) {}

//--- Internal constructor
  private : inline GGS_lexicalTypeEnum (const enumeration inValue) : mValue (inValue) {}

//--- Bit count for bdd
  public : static inline uint16 bitCount (void) { return 3 ; }

//--- Is built ?
  public : bool isBuilt (void) const ;

//--- Construction from GALGAS constructor
  public : static inline GGS_lexicalTypeEnum  constructor_lexicalType_char (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
    return GGS_lexicalTypeEnum (enum_lexicalType_char) ;
  }
  public : static inline GGS_lexicalTypeEnum  constructor_lexicalType_double (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
    return GGS_lexicalTypeEnum (enum_lexicalType_double) ;
  }
  public : static inline GGS_lexicalTypeEnum  constructor_lexicalType_sint (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
    return GGS_lexicalTypeEnum (enum_lexicalType_sint) ;
  }
  public : static inline GGS_lexicalTypeEnum  constructor_lexicalType_sint64 (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
    return GGS_lexicalTypeEnum (enum_lexicalType_sint64) ;
  }
  public : static inline GGS_lexicalTypeEnum  constructor_lexicalType_string (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
    return GGS_lexicalTypeEnum (enum_lexicalType_string) ;
  }
  public : static inline GGS_lexicalTypeEnum  constructor_lexicalType_uint (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
    return GGS_lexicalTypeEnum (enum_lexicalType_uint) ;
  }
  public : static inline GGS_lexicalTypeEnum  constructor_lexicalType_uint64 (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
    return GGS_lexicalTypeEnum (enum_lexicalType_uint64) ;
  }

//--- Readers
  public : GGS_string reader_lexicalTypeName (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;

//--- Modifiers

//--- Methods

//--- Operators

//--- 'description' reader
  public : GGS_string reader_description (C_Compiler & inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;

//--- Drop operation
  public : inline void drop (void) { mValue = kNotBuilt ; }

//--- Comparison operators
  public : GGS_bool _operator_isEqual (const GGS_lexicalTypeEnum inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalTypeEnum inOperand) const ;
  public : GGS_bool _operator_infOrEqual (const GGS_lexicalTypeEnum inOperand) const ;
  public : GGS_bool _operator_supOrEqual (const GGS_lexicalTypeEnum inOperand) const ;
  public : GGS_bool _operator_strictInf (const GGS_lexicalTypeEnum inOperand) const ;
  public : GGS_bool _operator_strictSup (const GGS_lexicalTypeEnum inOperand) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         list '@lexicalTypeList'                           *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_lexicalTypeList ;

class GGS_lexicalTypeList : public AC_galgas_list {
  public : typedef elementOf_GGS_lexicalTypeList cElement ;

//--- Constructor 'emptyList'
  public : static GGS_lexicalTypeList constructor_emptyList (void) ;
  public : static GGS_lexicalTypeList constructor_listWithValue (const GGS_lexicalTypeEnum& argument_0) ;
//--- Get sublist
  protected : void
  internalSubListWithRange (GGS_lexicalTypeList & ioList,
                            const sint32 inFirstIndex,
                            const sint32 inCount) const ;

  public : GGS_lexicalTypeList
  reader_subListWithRange (C_Compiler & inLexique,
                           const GGS_uint & inFirstIndex,
                           const GGS_uint & inCount
                           COMMA_LOCATION_ARGS) const ;

  public : GGS_lexicalTypeList
  reader_subListFromIndex (C_Compiler & inLexique,
                           const GGS_uint & inIndex
                           COMMA_LOCATION_ARGS) const ;

//--- Get first object
  public : inline cElement * firstObject (void) const {
    return (cElement *) internalFirstObject () ;
  }
//--- Get last object
  public : inline cElement * lastObject (void) const {
    return (cElement *) internalLastObject () ;
  }
//--- Operator () used for method call
  public : const GGS_lexicalTypeList * operator () (UNUSED_LOCATION_ARGS) const { return this ;} 
//--- Method 'first'
  public : void method_first (C_Compiler & inLexique,
                              GGS_lexicalTypeEnum& _out_0
                              COMMA_LOCATION_ARGS) const ;
//--- Method 'last'
  public : void method_last (C_Compiler & inLexique,
                             GGS_lexicalTypeEnum& _out_0
                             COMMA_LOCATION_ARGS) const ;
//--- Modifier 'popLast'
  public : void modifier_popLast (C_Compiler & inLexique,
                                GGS_lexicalTypeEnum& _out_0
                                COMMA_LOCATION_ARGS) ;
//--- Modifier 'popFirst'
  public : void modifier_popFirst (C_Compiler & inLexique,
                                 GGS_lexicalTypeEnum& _out_0
                                 COMMA_LOCATION_ARGS) ;
//--- Handle '.=' operator
  public : void _dotAssign_operation (const GGS_lexicalTypeList inOperand) ;

//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lexicalTypeEnum& argument_0) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalTypeList _operator_concat (const GGS_lexicalTypeList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & inLexique,
                                const GGS_lexicalTypeEnum& argument_0
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lexicalTypeEnum& argument_0
                                COMMA_LOCATION_ARGS) ;

  protected : void _internalPrependValues (const GGS_lexicalTypeEnum& argument_0
                                COMMA_LOCATION_ARGS) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--------------------------------- Direct Read Access
  public : GGS_lexicalTypeEnum
  reader_mLexicalTypeAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const ;

//--------------------------------- Direct Write Access
  public : void
  modifier_setMLexicalTypeAtIndex (C_Compiler & inLexique,
                              const GGS_lexicalTypeEnum & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const ;

//--------------------------------- List Enumerator
  public : class cEnumerator : public cAbstractListEnumerator {
  //--- Constructor
    public : inline cEnumerator (const GGS_lexicalTypeList & inList,
                                 const bool inAscending) :
    cAbstractListEnumerator (inList, inAscending) {
    }
  //--- Iterator method
    public : inline cElement * nextObject (void) {
      return (cElement *) internalNextObject () ;
    }
  public : /* const */ GGS_lexicalTypeEnum  & _mLexicalType (LOCATION_ARGS) const ;
  } ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                          Map '@lexicalTypeMap'                            *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_lexicalTypeMap ;

class GGS_lexicalTypeMap : public AC_galgas_map {
//--- Element Class
  public : typedef elementOf_GGS_lexicalTypeMap cElement ;

//--- Get pointers
  public : inline cElement * firstObject (void) const { return (cElement *) internalFirstObject () ; }
  public : inline cElement * lastObject (void) const { return (cElement *) internalLastObject () ; }

//--- Comparison methods
  public : GGS_bool _operator_isEqual (const GGS_lexicalTypeMap & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalTypeMap & inOperand) const ;

//--- Create a new element
  protected : virtual AC_galgas_map_element *
  new_element (const GGS_lstring & inKey, void * inInfo) ;

//--- Assign information to an existing element
  protected : virtual void
  assignInfo (AC_galgas_map_element * inPtr, void * inInfo) ;

//--- Enter an index
  public : void enterIndex (const GGS_lstring & inKey,
                            AC_galgas_index_core & outIndex) ;

//--- Get object pointer (for method call)
  public : inline GGS_lexicalTypeMap * operator () (UNUSED_LOCATION_ARGS) { return this ; }
  public : inline const GGS_lexicalTypeMap * operator () (UNUSED_LOCATION_ARGS) const { return this ; }

//--- 'emptyMap' constructor
  public : static GGS_lexicalTypeMap constructor_emptyMap (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;

//--- Method used for duplicate a map
  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;

//--- Modifiers "set'Value'ForKey"

  public : static const utf32 kInsertMessage_insertKey [] ;

//--- 'insertKey' Insert Modifier
  public : void modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lexicalTypeEnum&  inParameter0 COMMA_LOCATION_ARGS) ;

  public : static const utf32 kSearchMessage_searchKey [] ;

//--- 'searchKey' Search Method
  public : void method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lexicalTypeEnum  & outParameter0 COMMA_LOCATION_ARGS) const ;
//--- Internal method for inserting an element
  protected : void insertElement (C_Compiler & inLexique,
                                   const utf32 * inErrorMessage,
                                   const GGS_lstring & inKey,
                                   const GGS_lexicalTypeEnum& inParameter0,
                                   GGS_luint * outIndex
                                   COMMA_LOCATION_ARGS) ;
//--- Internal method for searching for an element
  protected : void searchElement (C_Compiler & inLexique,
                                   const utf32 * inErrorMessage,
                                   const GGS_lstring & inKey,
                                   GGS_lexicalTypeEnum& outParameter0,
                                   GGS_luint * outIndex
                                   COMMA_LOCATION_ARGS) const ;
  public : GGS_string reader_description (C_Compiler & inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;
  public : static GGS_lexicalTypeMap constructor_mapWithMapToOverride (C_Compiler & inLexique,
                                            const GGS_lexicalTypeMap & inMapToOverride
                                            COMMA_LOCATION_ARGS) ;
  public : GGS_lexicalTypeMap reader_overriddenMap (C_Compiler & inLexique
                                            COMMA_LOCATION_ARGS) const ;
//--------------------------------- Map Enumerator
  public : class cEnumerator : public cAbstractMapEnumerator {
  //--- Constructors
    public : inline cEnumerator (const GGS_lexicalTypeMap & inMap,
                                 const bool inAscending) :
    cAbstractMapEnumerator (inMap, inAscending) {
    }
    public : inline cEnumerator (const GGS_lexicalTypeMap & inMap) :
    cAbstractMapEnumerator (inMap) {
    }
  //--- Iterator method
    public : inline cElement * nextObject (void) {
      return (cElement *) internalNextObject () ;
    }
    public : /* const */ GGS_lexicalTypeEnum  & _mLexicalType (LOCATION_ARGS) const ;
  } ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        Map '@lexicalAttributeMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_lexicalAttributeMap ;

class GGS_lexicalAttributeMap : public AC_galgas_map {
//--- Element Class
  public : typedef elementOf_GGS_lexicalAttributeMap cElement ;

//--- Get pointers
  public : inline cElement * firstObject (void) const { return (cElement *) internalFirstObject () ; }
  public : inline cElement * lastObject (void) const { return (cElement *) internalLastObject () ; }

//--- Comparison methods
  public : GGS_bool _operator_isEqual (const GGS_lexicalAttributeMap & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalAttributeMap & inOperand) const ;

//--- Create a new element
  protected : virtual AC_galgas_map_element *
  new_element (const GGS_lstring & inKey, void * inInfo) ;

//--- Assign information to an existing element
  protected : virtual void
  assignInfo (AC_galgas_map_element * inPtr, void * inInfo) ;

//--- Enter an index
  public : void enterIndex (const GGS_lstring & inKey,
                            AC_galgas_index_core & outIndex) ;

//--- Get object pointer (for method call)
  public : inline GGS_lexicalAttributeMap * operator () (UNUSED_LOCATION_ARGS) { return this ; }
  public : inline const GGS_lexicalAttributeMap * operator () (UNUSED_LOCATION_ARGS) const { return this ; }

//--- 'emptyMap' constructor
  public : static GGS_lexicalAttributeMap constructor_emptyMap (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;

//--- Method used for duplicate a map
  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;

//--- Modifiers "set'Value'ForKey"

  public : static const utf32 kInsertMessage_insertKey [] ;

//--- 'insertKey' Insert Modifier
  public : void modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lexicalTypeEnum&  inParameter0 COMMA_LOCATION_ARGS) ;

  public : static const utf32 kSearchMessage_searchKey [] ;

//--- 'searchKey' Search Method
  public : void method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lexicalTypeEnum  & outParameter0 COMMA_LOCATION_ARGS) const ;
//--- Internal method for inserting an element
  protected : void insertElement (C_Compiler & inLexique,
                                   const utf32 * inErrorMessage,
                                   const GGS_lstring & inKey,
                                   const GGS_lexicalTypeEnum& inParameter0,
                                   GGS_luint * outIndex
                                   COMMA_LOCATION_ARGS) ;
//--- Internal method for searching for an element
  protected : void searchElement (C_Compiler & inLexique,
                                   const utf32 * inErrorMessage,
                                   const GGS_lstring & inKey,
                                   GGS_lexicalTypeEnum& outParameter0,
                                   GGS_luint * outIndex
                                   COMMA_LOCATION_ARGS) const ;
  public : GGS_string reader_description (C_Compiler & inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;
  public : static GGS_lexicalAttributeMap constructor_mapWithMapToOverride (C_Compiler & inLexique,
                                            const GGS_lexicalAttributeMap & inMapToOverride
                                            COMMA_LOCATION_ARGS) ;
  public : GGS_lexicalAttributeMap reader_overriddenMap (C_Compiler & inLexique
                                            COMMA_LOCATION_ARGS) const ;
//--------------------------------- Map Enumerator
  public : class cEnumerator : public cAbstractMapEnumerator {
  //--- Constructors
    public : inline cEnumerator (const GGS_lexicalAttributeMap & inMap,
                                 const bool inAscending) :
    cAbstractMapEnumerator (inMap, inAscending) {
    }
    public : inline cEnumerator (const GGS_lexicalAttributeMap & inMap) :
    cAbstractMapEnumerator (inMap) {
    }
  //--- Iterator method
    public : inline cElement * nextObject (void) {
      return (cElement *) internalNextObject () ;
    }
    public : /* const */ GGS_lexicalTypeEnum  & _mLexicalType (LOCATION_ARGS) const ;
  } ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                            Map '@terminalMap'                             *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_terminalMap ;

class GGS_terminalMap : public AC_galgas_map {
//--- Element Class
  public : typedef elementOf_GGS_terminalMap cElement ;

//--- Get pointers
  public : inline cElement * firstObject (void) const { return (cElement *) internalFirstObject () ; }
  public : inline cElement * lastObject (void) const { return (cElement *) internalLastObject () ; }

//--- Comparison methods
  public : GGS_bool _operator_isEqual (const GGS_terminalMap & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_terminalMap & inOperand) const ;

//--- Create a new element
  protected : virtual AC_galgas_map_element *
  new_element (const GGS_lstring & inKey, void * inInfo) ;

//--- Assign information to an existing element
  protected : virtual void
  assignInfo (AC_galgas_map_element * inPtr, void * inInfo) ;

//--- Enter an index
  public : void enterIndex (const GGS_lstring & inKey,
                            AC_galgas_index_core & outIndex) ;

//--- Get object pointer (for method call)
  public : inline GGS_terminalMap * operator () (UNUSED_LOCATION_ARGS) { return this ; }
  public : inline const GGS_terminalMap * operator () (UNUSED_LOCATION_ARGS) const { return this ; }

//--- 'emptyMap' constructor
  public : static GGS_terminalMap constructor_emptyMap (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;

//--- Method used for duplicate a map
  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;

//--- Modifiers "set'Value'ForKey"

  public : static const utf32 kInsertMessage_insertKey [] ;

//--- 'insertKey' Insert Modifier
  public : void modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lexicalTypeList &  inParameter0 COMMA_LOCATION_ARGS) ;

  public : static const utf32 kSearchMessage_searchKey [] ;

//--- 'searchKey' Search Method
  public : void method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lexicalTypeList   & outParameter0 COMMA_LOCATION_ARGS) const ;
//--- Internal method for inserting an element
  protected : void insertElement (C_Compiler & inLexique,
                                   const utf32 * inErrorMessage,
                                   const GGS_lstring & inKey,
                                   const GGS_lexicalTypeList & inParameter0,
                                   GGS_luint * outIndex
                                   COMMA_LOCATION_ARGS) ;
//--- Internal method for searching for an element
  protected : void searchElement (C_Compiler & inLexique,
                                   const utf32 * inErrorMessage,
                                   const GGS_lstring & inKey,
                                   GGS_lexicalTypeList & outParameter0,
                                   GGS_luint * outIndex
                                   COMMA_LOCATION_ARGS) const ;
  public : GGS_string reader_description (C_Compiler & inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;
  public : static GGS_terminalMap constructor_mapWithMapToOverride (C_Compiler & inLexique,
                                            const GGS_terminalMap & inMapToOverride
                                            COMMA_LOCATION_ARGS) ;
  public : GGS_terminalMap reader_overriddenMap (C_Compiler & inLexique
                                            COMMA_LOCATION_ARGS) const ;
//--------------------------------- Map Enumerator
  public : class cEnumerator : public cAbstractMapEnumerator {
  //--- Constructors
    public : inline cEnumerator (const GGS_terminalMap & inMap,
                                 const bool inAscending) :
    cAbstractMapEnumerator (inMap, inAscending) {
    }
    public : inline cEnumerator (const GGS_terminalMap & inMap) :
    cAbstractMapEnumerator (inMap) {
    }
  //--- Iterator method
    public : inline cElement * nextObject (void) {
      return (cElement *) internalNextObject () ;
    }
    public : /* const */ GGS_lexicalTypeList   & _mArgumentTypeList (LOCATION_ARGS) const ;
  } ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    Map '@lexicalExplicitTokenListMap'                     *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_lexicalExplicitTokenListMap ;

class GGS_lexicalExplicitTokenListMap : public AC_galgas_map {
//--- Element Class
  public : typedef elementOf_GGS_lexicalExplicitTokenListMap cElement ;

//--- Get pointers
  public : inline cElement * firstObject (void) const { return (cElement *) internalFirstObject () ; }
  public : inline cElement * lastObject (void) const { return (cElement *) internalLastObject () ; }

//--- Comparison methods
  public : GGS_bool _operator_isEqual (const GGS_lexicalExplicitTokenListMap & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalExplicitTokenListMap & inOperand) const ;

//--- Create a new element
  protected : virtual AC_galgas_map_element *
  new_element (const GGS_lstring & inKey, void * inInfo) ;

//--- Assign information to an existing element
  protected : virtual void
  assignInfo (AC_galgas_map_element * inPtr, void * inInfo) ;

//--- Enter an index
  public : void enterIndex (const GGS_lstring & inKey,
                            AC_galgas_index_core & outIndex) ;

//--- Get object pointer (for method call)
  public : inline GGS_lexicalExplicitTokenListMap * operator () (UNUSED_LOCATION_ARGS) { return this ; }
  public : inline const GGS_lexicalExplicitTokenListMap * operator () (UNUSED_LOCATION_ARGS) const { return this ; }

//--- 'emptyMap' constructor
  public : static GGS_lexicalExplicitTokenListMap constructor_emptyMap (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;

//--- Method used for duplicate a map
  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;

//--- Modifiers "set'Value'ForKey"

  public : static const utf32 kInsertMessage_insertKey [] ;

//--- 'insertKey' Insert Modifier
  public : void modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lstring &  inParameter0,
                                const GGS_lstringlist &  inParameter1 COMMA_LOCATION_ARGS) ;

  public : static const utf32 kSearchMessage_searchKey [] ;

//--- 'searchKey' Search Method
  public : void method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lstring   & outParameter0,
                                GGS_lstringlist   & outParameter1 COMMA_LOCATION_ARGS) const ;
//--- Internal method for inserting an element
  protected : void insertElement (C_Compiler & inLexique,
                                   const utf32 * inErrorMessage,
                                   const GGS_lstring & inKey,
                                   const GGS_lstring & inParameter0,
                                   const GGS_lstringlist & inParameter1,
                                   GGS_luint * outIndex
                                   COMMA_LOCATION_ARGS) ;
//--- Internal method for searching for an element
  protected : void searchElement (C_Compiler & inLexique,
                                   const utf32 * inErrorMessage,
                                   const GGS_lstring & inKey,
                                   GGS_lstring & outParameter0,
                                   GGS_lstringlist & outParameter1,
                                   GGS_luint * outIndex
                                   COMMA_LOCATION_ARGS) const ;
  public : GGS_string reader_description (C_Compiler & inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;
  public : static GGS_lexicalExplicitTokenListMap constructor_mapWithMapToOverride (C_Compiler & inLexique,
                                            const GGS_lexicalExplicitTokenListMap & inMapToOverride
                                            COMMA_LOCATION_ARGS) ;
  public : GGS_lexicalExplicitTokenListMap reader_overriddenMap (C_Compiler & inLexique
                                            COMMA_LOCATION_ARGS) const ;
//--------------------------------- Map Enumerator
  public : class cEnumerator : public cAbstractMapEnumerator {
  //--- Constructors
    public : inline cEnumerator (const GGS_lexicalExplicitTokenListMap & inMap,
                                 const bool inAscending) :
    cAbstractMapEnumerator (inMap, inAscending) {
    }
    public : inline cEnumerator (const GGS_lexicalExplicitTokenListMap & inMap) :
    cAbstractMapEnumerator (inMap) {
    }
  //--- Iterator method
    public : inline cElement * nextObject (void) {
      return (cElement *) internalNextObject () ;
    }
    public : /* const */ GGS_lstring   & _mTerminal (LOCATION_ARGS) const ;
    public : /* const */ GGS_lstringlist   & _mFeatureList (LOCATION_ARGS) const ;
  } ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  Map '@lexicalExplicitTokenListMapMap'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_lexicalExplicitTokenListMapMap ;

class GGS_lexicalExplicitTokenListMapMap : public AC_galgas_map {
//--- Element Class
  public : typedef elementOf_GGS_lexicalExplicitTokenListMapMap cElement ;

//--- Get pointers
  public : inline cElement * firstObject (void) const { return (cElement *) internalFirstObject () ; }
  public : inline cElement * lastObject (void) const { return (cElement *) internalLastObject () ; }

//--- Comparison methods
  public : GGS_bool _operator_isEqual (const GGS_lexicalExplicitTokenListMapMap & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalExplicitTokenListMapMap & inOperand) const ;

//--- Create a new element
  protected : virtual AC_galgas_map_element *
  new_element (const GGS_lstring & inKey, void * inInfo) ;

//--- Assign information to an existing element
  protected : virtual void
  assignInfo (AC_galgas_map_element * inPtr, void * inInfo) ;

//--- Enter an index
  public : void enterIndex (const GGS_lstring & inKey,
                            AC_galgas_index_core & outIndex) ;

//--- Get object pointer (for method call)
  public : inline GGS_lexicalExplicitTokenListMapMap * operator () (UNUSED_LOCATION_ARGS) { return this ; }
  public : inline const GGS_lexicalExplicitTokenListMapMap * operator () (UNUSED_LOCATION_ARGS) const { return this ; }

//--- 'emptyMap' constructor
  public : static GGS_lexicalExplicitTokenListMapMap constructor_emptyMap (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;

//--- Method used for duplicate a map
  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;

//--- Modifiers "set'Value'ForKey"

  public : static const utf32 kInsertMessage_insertKey [] ;

//--- 'insertKey' Insert Modifier
  public : void modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lexicalExplicitTokenListMap &  inParameter0 COMMA_LOCATION_ARGS) ;

  public : static const utf32 kSearchMessage_searchKey [] ;

//--- 'searchKey' Search Method
  public : void method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lexicalExplicitTokenListMap   & outParameter0 COMMA_LOCATION_ARGS) const ;
//--- Internal method for inserting an element
  protected : void insertElement (C_Compiler & inLexique,
                                   const utf32 * inErrorMessage,
                                   const GGS_lstring & inKey,
                                   const GGS_lexicalExplicitTokenListMap & inParameter0,
                                   GGS_luint * outIndex
                                   COMMA_LOCATION_ARGS) ;
//--- Internal method for searching for an element
  protected : void searchElement (C_Compiler & inLexique,
                                   const utf32 * inErrorMessage,
                                   const GGS_lstring & inKey,
                                   GGS_lexicalExplicitTokenListMap & outParameter0,
                                   GGS_luint * outIndex
                                   COMMA_LOCATION_ARGS) const ;
  public : GGS_string reader_description (C_Compiler & inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;
  public : static GGS_lexicalExplicitTokenListMapMap constructor_mapWithMapToOverride (C_Compiler & inLexique,
                                            const GGS_lexicalExplicitTokenListMapMap & inMapToOverride
                                            COMMA_LOCATION_ARGS) ;
  public : GGS_lexicalExplicitTokenListMapMap reader_overriddenMap (C_Compiler & inLexique
                                            COMMA_LOCATION_ARGS) const ;
//--------------------------------- Map Enumerator
  public : class cEnumerator : public cAbstractMapEnumerator {
  //--- Constructors
    public : inline cEnumerator (const GGS_lexicalExplicitTokenListMapMap & inMap,
                                 const bool inAscending) :
    cAbstractMapEnumerator (inMap, inAscending) {
    }
    public : inline cEnumerator (const GGS_lexicalExplicitTokenListMapMap & inMap) :
    cAbstractMapEnumerator (inMap) {
    }
  //--- Iterator method
    public : inline cElement * nextObject (void) {
      return (cElement *) internalNextObject () ;
    }
    public : /* const */ GGS_lexicalExplicitTokenListMap   & _mExplicitTokenListMap (LOCATION_ARGS) const ;
  } ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         Map '@lexicalMessageMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_lexicalMessageMap ;

class GGS_lexicalMessageMap : public AC_galgas_map {
//--- Element Class
  public : typedef elementOf_GGS_lexicalMessageMap cElement ;

//--- Get pointers
  public : inline cElement * firstObject (void) const { return (cElement *) internalFirstObject () ; }
  public : inline cElement * lastObject (void) const { return (cElement *) internalLastObject () ; }

//--- Comparison methods
  public : GGS_bool _operator_isEqual (const GGS_lexicalMessageMap & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalMessageMap & inOperand) const ;

//--- Create a new element
  protected : virtual AC_galgas_map_element *
  new_element (const GGS_lstring & inKey, void * inInfo) ;

//--- Assign information to an existing element
  protected : virtual void
  assignInfo (AC_galgas_map_element * inPtr, void * inInfo) ;

//--- Enter an index
  public : void enterIndex (const GGS_lstring & inKey,
                            AC_galgas_index_core & outIndex) ;

//--- Get object pointer (for method call)
  public : inline GGS_lexicalMessageMap * operator () (UNUSED_LOCATION_ARGS) { return this ; }
  public : inline const GGS_lexicalMessageMap * operator () (UNUSED_LOCATION_ARGS) const { return this ; }

//--- 'emptyMap' constructor
  public : static GGS_lexicalMessageMap constructor_emptyMap (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;

//--- Method used for duplicate a map
  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;

//--- Modifiers "set'Value'ForKey"

  public : static const utf32 kInsertMessage_insertKey [] ;

//--- 'insertKey' Insert Modifier
  public : void modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lstring &  inParameter0,
                                const GGS_bool&  inParameter1 COMMA_LOCATION_ARGS) ;

  public : static const utf32 kSearchMessage_searchKey [] ;

//--- 'searchKey' Search Method
  public : void method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lstring   & outParameter0,
                                GGS_bool  & outParameter1 COMMA_LOCATION_ARGS) const ;
//--- Internal method for inserting an element
  protected : void insertElement (C_Compiler & inLexique,
                                   const utf32 * inErrorMessage,
                                   const GGS_lstring & inKey,
                                   const GGS_lstring & inParameter0,
                                   const GGS_bool& inParameter1,
                                   GGS_luint * outIndex
                                   COMMA_LOCATION_ARGS) ;
//--- Internal method for searching for an element
  protected : void searchElement (C_Compiler & inLexique,
                                   const utf32 * inErrorMessage,
                                   const GGS_lstring & inKey,
                                   GGS_lstring & outParameter0,
                                   GGS_bool& outParameter1,
                                   GGS_luint * outIndex
                                   COMMA_LOCATION_ARGS) const ;
  public : GGS_string reader_description (C_Compiler & inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;
  public : static GGS_lexicalMessageMap constructor_mapWithMapToOverride (C_Compiler & inLexique,
                                            const GGS_lexicalMessageMap & inMapToOverride
                                            COMMA_LOCATION_ARGS) ;
  public : GGS_lexicalMessageMap reader_overriddenMap (C_Compiler & inLexique
                                            COMMA_LOCATION_ARGS) const ;
//--------------------------------- Map Enumerator
  public : class cEnumerator : public cAbstractMapEnumerator {
  //--- Constructors
    public : inline cEnumerator (const GGS_lexicalMessageMap & inMap,
                                 const bool inAscending) :
    cAbstractMapEnumerator (inMap, inAscending) {
    }
    public : inline cEnumerator (const GGS_lexicalMessageMap & inMap) :
    cAbstractMapEnumerator (inMap) {
    }
  //--- Iterator method
    public : inline cElement * nextObject (void) {
      return (cElement *) internalNextObject () ;
    }
    public : /* const */ GGS_lstring   & _mLexicalMessage (LOCATION_ARGS) const ;
    public : /* const */ GGS_bool  & _mMessageIsUsed (LOCATION_ARGS) const ;
  } ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//               Class for 'lexicalArgumentMode' Enumeration                 *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalArgumentMode {
//--- Enumeration
  public : enum enumeration {kNotBuilt, enum_lexicalInputMode, enum_lexicalInputOutputMode} ;

//--- Private attribute
  private : enumeration mValue ;

//--- Get value
  public : inline enumeration enumValue (void) const { return mValue ; }

//--- Default constructor
  public : inline GGS_lexicalArgumentMode (void) : mValue (kNotBuilt) {}

//--- Internal constructor
  private : inline GGS_lexicalArgumentMode (const enumeration inValue) : mValue (inValue) {}

//--- Bit count for bdd
  public : static inline uint16 bitCount (void) { return 2 ; }

//--- Is built ?
  public : bool isBuilt (void) const ;

//--- Construction from GALGAS constructor
  public : static inline GGS_lexicalArgumentMode  constructor_lexicalInputMode (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
    return GGS_lexicalArgumentMode (enum_lexicalInputMode) ;
  }
  public : static inline GGS_lexicalArgumentMode  constructor_lexicalInputOutputMode (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
    return GGS_lexicalArgumentMode (enum_lexicalInputOutputMode) ;
  }

//--- Readers

//--- Modifiers

//--- Methods

//--- Operators

//--- 'description' reader
  public : GGS_string reader_description (C_Compiler & inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;

//--- Drop operation
  public : inline void drop (void) { mValue = kNotBuilt ; }

//--- Comparison operators
  public : GGS_bool _operator_isEqual (const GGS_lexicalArgumentMode inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalArgumentMode inOperand) const ;
  public : GGS_bool _operator_infOrEqual (const GGS_lexicalArgumentMode inOperand) const ;
  public : GGS_bool _operator_supOrEqual (const GGS_lexicalArgumentMode inOperand) const ;
  public : GGS_bool _operator_strictInf (const GGS_lexicalArgumentMode inOperand) const ;
  public : GGS_bool _operator_strictSup (const GGS_lexicalArgumentMode inOperand) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 list '@lexicalRoutineFormalArgumentList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_lexicalRoutineFormalArgumentList ;

class GGS_lexicalRoutineFormalArgumentList : public AC_galgas_list {
  public : typedef elementOf_GGS_lexicalRoutineFormalArgumentList cElement ;

//--- Constructor 'emptyList'
  public : static GGS_lexicalRoutineFormalArgumentList constructor_emptyList (void) ;
  public : static GGS_lexicalRoutineFormalArgumentList constructor_listWithValue (const GGS_lexicalArgumentMode& argument_0,
                                const GGS_lexicalTypeEnum& argument_1) ;
//--- Get sublist
  protected : void
  internalSubListWithRange (GGS_lexicalRoutineFormalArgumentList & ioList,
                            const sint32 inFirstIndex,
                            const sint32 inCount) const ;

  public : GGS_lexicalRoutineFormalArgumentList
  reader_subListWithRange (C_Compiler & inLexique,
                           const GGS_uint & inFirstIndex,
                           const GGS_uint & inCount
                           COMMA_LOCATION_ARGS) const ;

  public : GGS_lexicalRoutineFormalArgumentList
  reader_subListFromIndex (C_Compiler & inLexique,
                           const GGS_uint & inIndex
                           COMMA_LOCATION_ARGS) const ;

//--- Get first object
  public : inline cElement * firstObject (void) const {
    return (cElement *) internalFirstObject () ;
  }
//--- Get last object
  public : inline cElement * lastObject (void) const {
    return (cElement *) internalLastObject () ;
  }
//--- Operator () used for method call
  public : const GGS_lexicalRoutineFormalArgumentList * operator () (UNUSED_LOCATION_ARGS) const { return this ;} 
//--- Method 'first'
  public : void method_first (C_Compiler & inLexique,
                              GGS_lexicalArgumentMode& _out_0,
                              GGS_lexicalTypeEnum& _out_1
                              COMMA_LOCATION_ARGS) const ;
//--- Method 'last'
  public : void method_last (C_Compiler & inLexique,
                             GGS_lexicalArgumentMode& _out_0,
                             GGS_lexicalTypeEnum& _out_1
                             COMMA_LOCATION_ARGS) const ;
//--- Modifier 'popLast'
  public : void modifier_popLast (C_Compiler & inLexique,
                                GGS_lexicalArgumentMode& _out_0,
                                GGS_lexicalTypeEnum& _out_1
                                COMMA_LOCATION_ARGS) ;
//--- Modifier 'popFirst'
  public : void modifier_popFirst (C_Compiler & inLexique,
                                 GGS_lexicalArgumentMode& _out_0,
                                 GGS_lexicalTypeEnum& _out_1
                                 COMMA_LOCATION_ARGS) ;
//--- Handle '.=' operator
  public : void _dotAssign_operation (const GGS_lexicalRoutineFormalArgumentList inOperand) ;

//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lexicalArgumentMode& argument_0,
                                const GGS_lexicalTypeEnum& argument_1) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalRoutineFormalArgumentList _operator_concat (const GGS_lexicalRoutineFormalArgumentList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & inLexique,
                                const GGS_lexicalArgumentMode& argument_0,
                                const GGS_lexicalTypeEnum& argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lexicalArgumentMode& argument_0,
                                const GGS_lexicalTypeEnum& argument_1
                                COMMA_LOCATION_ARGS) ;

  protected : void _internalPrependValues (const GGS_lexicalArgumentMode& argument_0,
                                const GGS_lexicalTypeEnum& argument_1
                                COMMA_LOCATION_ARGS) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--------------------------------- Direct Read Access
  public : GGS_lexicalArgumentMode
  reader_mLexicalArgumentModeAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const ;
  public : GGS_lexicalTypeEnum
  reader_mLexicalTypeAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const ;

//--------------------------------- Direct Write Access
  public : void
  modifier_setMLexicalArgumentModeAtIndex (C_Compiler & inLexique,
                              const GGS_lexicalArgumentMode & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const ;
  public : void
  modifier_setMLexicalTypeAtIndex (C_Compiler & inLexique,
                              const GGS_lexicalTypeEnum & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const ;

//--------------------------------- List Enumerator
  public : class cEnumerator : public cAbstractListEnumerator {
  //--- Constructor
    public : inline cEnumerator (const GGS_lexicalRoutineFormalArgumentList & inList,
                                 const bool inAscending) :
    cAbstractListEnumerator (inList, inAscending) {
    }
  //--- Iterator method
    public : inline cElement * nextObject (void) {
      return (cElement *) internalNextObject () ;
    }
  public : /* const */ GGS_lexicalArgumentMode  & _mLexicalArgumentMode (LOCATION_ARGS) const ;
  public : /* const */ GGS_lexicalTypeEnum  & _mLexicalType (LOCATION_ARGS) const ;
  } ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         Map '@lexicalRoutineMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_lexicalRoutineMap ;

class GGS_lexicalRoutineMap : public AC_galgas_map {
//--- Element Class
  public : typedef elementOf_GGS_lexicalRoutineMap cElement ;

//--- Get pointers
  public : inline cElement * firstObject (void) const { return (cElement *) internalFirstObject () ; }
  public : inline cElement * lastObject (void) const { return (cElement *) internalLastObject () ; }

//--- Comparison methods
  public : GGS_bool _operator_isEqual (const GGS_lexicalRoutineMap & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalRoutineMap & inOperand) const ;

//--- Create a new element
  protected : virtual AC_galgas_map_element *
  new_element (const GGS_lstring & inKey, void * inInfo) ;

//--- Assign information to an existing element
  protected : virtual void
  assignInfo (AC_galgas_map_element * inPtr, void * inInfo) ;

//--- Enter an index
  public : void enterIndex (const GGS_lstring & inKey,
                            AC_galgas_index_core & outIndex) ;

//--- Get object pointer (for method call)
  public : inline GGS_lexicalRoutineMap * operator () (UNUSED_LOCATION_ARGS) { return this ; }
  public : inline const GGS_lexicalRoutineMap * operator () (UNUSED_LOCATION_ARGS) const { return this ; }

//--- 'emptyMap' constructor
  public : static GGS_lexicalRoutineMap constructor_emptyMap (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;

//--- Method used for duplicate a map
  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;

//--- Modifiers "set'Value'ForKey"

  public : static const utf32 kInsertMessage_insertKey [] ;

//--- 'insertKey' Insert Modifier
  public : void modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lexicalRoutineFormalArgumentList &  inParameter0,
                                const GGS_stringlist &  inParameter1 COMMA_LOCATION_ARGS) ;

  public : static const utf32 kSearchMessage_searchKey [] ;

//--- 'searchKey' Search Method
  public : void method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lexicalRoutineFormalArgumentList   & outParameter0,
                                GGS_stringlist   & outParameter1 COMMA_LOCATION_ARGS) const ;
//--- Internal method for inserting an element
  protected : void insertElement (C_Compiler & inLexique,
                                   const utf32 * inErrorMessage,
                                   const GGS_lstring & inKey,
                                   const GGS_lexicalRoutineFormalArgumentList & inParameter0,
                                   const GGS_stringlist & inParameter1,
                                   GGS_luint * outIndex
                                   COMMA_LOCATION_ARGS) ;
//--- Internal method for searching for an element
  protected : void searchElement (C_Compiler & inLexique,
                                   const utf32 * inErrorMessage,
                                   const GGS_lstring & inKey,
                                   GGS_lexicalRoutineFormalArgumentList & outParameter0,
                                   GGS_stringlist & outParameter1,
                                   GGS_luint * outIndex
                                   COMMA_LOCATION_ARGS) const ;
  public : GGS_string reader_description (C_Compiler & inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;
  public : static GGS_lexicalRoutineMap constructor_mapWithMapToOverride (C_Compiler & inLexique,
                                            const GGS_lexicalRoutineMap & inMapToOverride
                                            COMMA_LOCATION_ARGS) ;
  public : GGS_lexicalRoutineMap reader_overriddenMap (C_Compiler & inLexique
                                            COMMA_LOCATION_ARGS) const ;
//--------------------------------- Map Enumerator
  public : class cEnumerator : public cAbstractMapEnumerator {
  //--- Constructors
    public : inline cEnumerator (const GGS_lexicalRoutineMap & inMap,
                                 const bool inAscending) :
    cAbstractMapEnumerator (inMap, inAscending) {
    }
    public : inline cEnumerator (const GGS_lexicalRoutineMap & inMap) :
    cAbstractMapEnumerator (inMap) {
    }
  //--- Iterator method
    public : inline cElement * nextObject (void) {
      return (cElement *) internalNextObject () ;
    }
    public : /* const */ GGS_lexicalRoutineFormalArgumentList   & _mLexicalRoutineFormalArgumentList (LOCATION_ARGS) const ;
    public : /* const */ GGS_stringlist   & _mErrorMessageList (LOCATION_ARGS) const ;
  } ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        Map '@lexicalFunctionMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_lexicalFunctionMap ;

class GGS_lexicalFunctionMap : public AC_galgas_map {
//--- Element Class
  public : typedef elementOf_GGS_lexicalFunctionMap cElement ;

//--- Get pointers
  public : inline cElement * firstObject (void) const { return (cElement *) internalFirstObject () ; }
  public : inline cElement * lastObject (void) const { return (cElement *) internalLastObject () ; }

//--- Comparison methods
  public : GGS_bool _operator_isEqual (const GGS_lexicalFunctionMap & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexicalFunctionMap & inOperand) const ;

//--- Create a new element
  protected : virtual AC_galgas_map_element *
  new_element (const GGS_lstring & inKey, void * inInfo) ;

//--- Assign information to an existing element
  protected : virtual void
  assignInfo (AC_galgas_map_element * inPtr, void * inInfo) ;

//--- Enter an index
  public : void enterIndex (const GGS_lstring & inKey,
                            AC_galgas_index_core & outIndex) ;

//--- Get object pointer (for method call)
  public : inline GGS_lexicalFunctionMap * operator () (UNUSED_LOCATION_ARGS) { return this ; }
  public : inline const GGS_lexicalFunctionMap * operator () (UNUSED_LOCATION_ARGS) const { return this ; }

//--- 'emptyMap' constructor
  public : static GGS_lexicalFunctionMap constructor_emptyMap (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;

//--- Method used for duplicate a map
  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;

//--- Modifiers "set'Value'ForKey"

  public : static const utf32 kInsertMessage_insertKey [] ;

//--- 'insertKey' Insert Modifier
  public : void modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lexicalTypeList &  inParameter0,
                                const GGS_lexicalTypeEnum&  inParameter1 COMMA_LOCATION_ARGS) ;

  public : static const utf32 kSearchMessage_searchKey [] ;

//--- 'searchKey' Search Method
  public : void method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lexicalTypeList   & outParameter0,
                                GGS_lexicalTypeEnum  & outParameter1 COMMA_LOCATION_ARGS) const ;
//--- Internal method for inserting an element
  protected : void insertElement (C_Compiler & inLexique,
                                   const utf32 * inErrorMessage,
                                   const GGS_lstring & inKey,
                                   const GGS_lexicalTypeList & inParameter0,
                                   const GGS_lexicalTypeEnum& inParameter1,
                                   GGS_luint * outIndex
                                   COMMA_LOCATION_ARGS) ;
//--- Internal method for searching for an element
  protected : void searchElement (C_Compiler & inLexique,
                                   const utf32 * inErrorMessage,
                                   const GGS_lstring & inKey,
                                   GGS_lexicalTypeList & outParameter0,
                                   GGS_lexicalTypeEnum& outParameter1,
                                   GGS_luint * outIndex
                                   COMMA_LOCATION_ARGS) const ;
  public : GGS_string reader_description (C_Compiler & inLexique
                                          COMMA_LOCATION_ARGS,
                                          const sint32 inIndentation = 0) const ;
  public : static GGS_lexicalFunctionMap constructor_mapWithMapToOverride (C_Compiler & inLexique,
                                            const GGS_lexicalFunctionMap & inMapToOverride
                                            COMMA_LOCATION_ARGS) ;
  public : GGS_lexicalFunctionMap reader_overriddenMap (C_Compiler & inLexique
                                            COMMA_LOCATION_ARGS) const ;
//--------------------------------- Map Enumerator
  public : class cEnumerator : public cAbstractMapEnumerator {
  //--- Constructors
    public : inline cEnumerator (const GGS_lexicalFunctionMap & inMap,
                                 const bool inAscending) :
    cAbstractMapEnumerator (inMap, inAscending) {
    }
    public : inline cEnumerator (const GGS_lexicalFunctionMap & inMap) :
    cAbstractMapEnumerator (inMap) {
    }
  //--- Iterator method
    public : inline cElement * nextObject (void) {
      return (cElement *) internalNextObject () ;
    }
    public : /* const */ GGS_lexicalTypeList   & _mLexicalTypeList (LOCATION_ARGS) const ;
    public : /* const */ GGS_lexicalTypeEnum  & _mReturnedLexicalType (LOCATION_ARGS) const ;
  } ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    Element of list '@lexicalTypeList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_lexicalTypeList : public AC_galgas_list::cListElement {
//--- Attributes
  public : GGS_lexicalTypeEnum mLexicalType ;
//--- Constructor
  public : elementOf_GGS_lexicalTypeList (const GGS_lexicalTypeEnum& 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline elementOf_GGS_lexicalTypeList * nextObject (void) const { return (elementOf_GGS_lexicalTypeList *) internalNextItem () ; }

//--- Access to previous
  public : inline elementOf_GGS_lexicalTypeList * previousObject (void) const { return (elementOf_GGS_lexicalTypeList *) internalPreviousItem () ; }

//--- Element comparison
  protected : virtual bool
  isEqualToObject (const cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Friend class declaration
  friend class GGS_lexicalTypeList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     Element of map '@lexicalTypeMap'                      *
//                                                                           *
//---------------------------------------------------------------------------*

class e_lexicalTypeMap {
  public : GGS_lexicalTypeEnum mLexicalType ;

  public : e_lexicalTypeMap (void) ;
} ;

//---------------------------------------------------------------------------*

class elementOf_GGS_lexicalTypeMap : public AC_galgas_map_element {
//--- Constructor
  public : elementOf_GGS_lexicalTypeMap (const GGS_lstring & inKey,
                                     const sint32 inIndex,
                                     const e_lexicalTypeMap & inInfo) ;
//--- Get pointers
  public : inline elementOf_GGS_lexicalTypeMap * nextObject (void) const { return (elementOf_GGS_lexicalTypeMap *) mNextItem ; }
  public : inline elementOf_GGS_lexicalTypeMap * infObject (void) const { return (elementOf_GGS_lexicalTypeMap *) mInfPtr ; }
  public : inline elementOf_GGS_lexicalTypeMap * supObject (void) const { return (elementOf_GGS_lexicalTypeMap *) mSupPtr ; }
//--- Comparison
  protected : virtual bool isEqualToMapElement (const AC_galgas_map_element * inOperand) const ;
//--- Data member
  public : e_lexicalTypeMap mInfo ;
//--- Method for 'description' reader
  public : void appendForMapDescription (C_Compiler & inLexique,
                                         const sint32 inElementIndex,
                                         C_String & ioString,
                                         const sint32 inIndentation
                                         COMMA_LOCATION_ARGS) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of map '@lexicalAttributeMap'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class e_lexicalAttributeMap {
  public : GGS_lexicalTypeEnum mLexicalType ;

  public : e_lexicalAttributeMap (void) ;
} ;

//---------------------------------------------------------------------------*

class elementOf_GGS_lexicalAttributeMap : public AC_galgas_map_element {
//--- Constructor
  public : elementOf_GGS_lexicalAttributeMap (const GGS_lstring & inKey,
                                     const sint32 inIndex,
                                     const e_lexicalAttributeMap & inInfo) ;
//--- Get pointers
  public : inline elementOf_GGS_lexicalAttributeMap * nextObject (void) const { return (elementOf_GGS_lexicalAttributeMap *) mNextItem ; }
  public : inline elementOf_GGS_lexicalAttributeMap * infObject (void) const { return (elementOf_GGS_lexicalAttributeMap *) mInfPtr ; }
  public : inline elementOf_GGS_lexicalAttributeMap * supObject (void) const { return (elementOf_GGS_lexicalAttributeMap *) mSupPtr ; }
//--- Comparison
  protected : virtual bool isEqualToMapElement (const AC_galgas_map_element * inOperand) const ;
//--- Data member
  public : e_lexicalAttributeMap mInfo ;
//--- Method for 'description' reader
  public : void appendForMapDescription (C_Compiler & inLexique,
                                         const sint32 inElementIndex,
                                         C_String & ioString,
                                         const sint32 inIndentation
                                         COMMA_LOCATION_ARGS) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      Element of map '@terminalMap'                        *
//                                                                           *
//---------------------------------------------------------------------------*

class e_terminalMap {
  public : GGS_lexicalTypeList  mArgumentTypeList ;

  public : e_terminalMap (void) ;
} ;

//---------------------------------------------------------------------------*

class elementOf_GGS_terminalMap : public AC_galgas_map_element {
//--- Constructor
  public : elementOf_GGS_terminalMap (const GGS_lstring & inKey,
                                     const sint32 inIndex,
                                     const e_terminalMap & inInfo) ;
//--- Get pointers
  public : inline elementOf_GGS_terminalMap * nextObject (void) const { return (elementOf_GGS_terminalMap *) mNextItem ; }
  public : inline elementOf_GGS_terminalMap * infObject (void) const { return (elementOf_GGS_terminalMap *) mInfPtr ; }
  public : inline elementOf_GGS_terminalMap * supObject (void) const { return (elementOf_GGS_terminalMap *) mSupPtr ; }
//--- Comparison
  protected : virtual bool isEqualToMapElement (const AC_galgas_map_element * inOperand) const ;
//--- Data member
  public : e_terminalMap mInfo ;
//--- Method for 'description' reader
  public : void appendForMapDescription (C_Compiler & inLexique,
                                         const sint32 inElementIndex,
                                         C_String & ioString,
                                         const sint32 inIndentation
                                         COMMA_LOCATION_ARGS) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of map '@lexicalExplicitTokenListMap'                *
//                                                                           *
//---------------------------------------------------------------------------*

class e_lexicalExplicitTokenListMap {
  public : GGS_lstring  mTerminal ;
  public : GGS_lstringlist  mFeatureList ;

  public : e_lexicalExplicitTokenListMap (void) ;
} ;

//---------------------------------------------------------------------------*

class elementOf_GGS_lexicalExplicitTokenListMap : public AC_galgas_map_element {
//--- Constructor
  public : elementOf_GGS_lexicalExplicitTokenListMap (const GGS_lstring & inKey,
                                     const sint32 inIndex,
                                     const e_lexicalExplicitTokenListMap & inInfo) ;
//--- Get pointers
  public : inline elementOf_GGS_lexicalExplicitTokenListMap * nextObject (void) const { return (elementOf_GGS_lexicalExplicitTokenListMap *) mNextItem ; }
  public : inline elementOf_GGS_lexicalExplicitTokenListMap * infObject (void) const { return (elementOf_GGS_lexicalExplicitTokenListMap *) mInfPtr ; }
  public : inline elementOf_GGS_lexicalExplicitTokenListMap * supObject (void) const { return (elementOf_GGS_lexicalExplicitTokenListMap *) mSupPtr ; }
//--- Comparison
  protected : virtual bool isEqualToMapElement (const AC_galgas_map_element * inOperand) const ;
//--- Data member
  public : e_lexicalExplicitTokenListMap mInfo ;
//--- Method for 'description' reader
  public : void appendForMapDescription (C_Compiler & inLexique,
                                         const sint32 inElementIndex,
                                         C_String & ioString,
                                         const sint32 inIndentation
                                         COMMA_LOCATION_ARGS) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of map '@lexicalExplicitTokenListMapMap'              *
//                                                                           *
//---------------------------------------------------------------------------*

class e_lexicalExplicitTokenListMapMap {
  public : GGS_lexicalExplicitTokenListMap  mExplicitTokenListMap ;

  public : e_lexicalExplicitTokenListMapMap (void) ;
} ;

//---------------------------------------------------------------------------*

class elementOf_GGS_lexicalExplicitTokenListMapMap : public AC_galgas_map_element {
//--- Constructor
  public : elementOf_GGS_lexicalExplicitTokenListMapMap (const GGS_lstring & inKey,
                                     const sint32 inIndex,
                                     const e_lexicalExplicitTokenListMapMap & inInfo) ;
//--- Get pointers
  public : inline elementOf_GGS_lexicalExplicitTokenListMapMap * nextObject (void) const { return (elementOf_GGS_lexicalExplicitTokenListMapMap *) mNextItem ; }
  public : inline elementOf_GGS_lexicalExplicitTokenListMapMap * infObject (void) const { return (elementOf_GGS_lexicalExplicitTokenListMapMap *) mInfPtr ; }
  public : inline elementOf_GGS_lexicalExplicitTokenListMapMap * supObject (void) const { return (elementOf_GGS_lexicalExplicitTokenListMapMap *) mSupPtr ; }
//--- Comparison
  protected : virtual bool isEqualToMapElement (const AC_galgas_map_element * inOperand) const ;
//--- Data member
  public : e_lexicalExplicitTokenListMapMap mInfo ;
//--- Method for 'description' reader
  public : void appendForMapDescription (C_Compiler & inLexique,
                                         const sint32 inElementIndex,
                                         C_String & ioString,
                                         const sint32 inIndentation
                                         COMMA_LOCATION_ARGS) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   Element of map '@lexicalMessageMap'                     *
//                                                                           *
//---------------------------------------------------------------------------*

class e_lexicalMessageMap {
  public : GGS_lstring  mLexicalMessage ;
  public : GGS_bool mMessageIsUsed ;

  public : e_lexicalMessageMap (void) ;
} ;

//---------------------------------------------------------------------------*

class elementOf_GGS_lexicalMessageMap : public AC_galgas_map_element {
//--- Constructor
  public : elementOf_GGS_lexicalMessageMap (const GGS_lstring & inKey,
                                     const sint32 inIndex,
                                     const e_lexicalMessageMap & inInfo) ;
//--- Get pointers
  public : inline elementOf_GGS_lexicalMessageMap * nextObject (void) const { return (elementOf_GGS_lexicalMessageMap *) mNextItem ; }
  public : inline elementOf_GGS_lexicalMessageMap * infObject (void) const { return (elementOf_GGS_lexicalMessageMap *) mInfPtr ; }
  public : inline elementOf_GGS_lexicalMessageMap * supObject (void) const { return (elementOf_GGS_lexicalMessageMap *) mSupPtr ; }
//--- Comparison
  protected : virtual bool isEqualToMapElement (const AC_galgas_map_element * inOperand) const ;
//--- Data member
  public : e_lexicalMessageMap mInfo ;
//--- Method for 'description' reader
  public : void appendForMapDescription (C_Compiler & inLexique,
                                         const sint32 inElementIndex,
                                         C_String & ioString,
                                         const sint32 inIndentation
                                         COMMA_LOCATION_ARGS) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//           Element of list '@lexicalRoutineFormalArgumentList'             *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_lexicalRoutineFormalArgumentList : public AC_galgas_list::cListElement {
//--- Attributes
  public : GGS_lexicalArgumentMode mLexicalArgumentMode ;
  public : GGS_lexicalTypeEnum mLexicalType ;
//--- Constructor
  public : elementOf_GGS_lexicalRoutineFormalArgumentList (const GGS_lexicalArgumentMode& ,
                                const GGS_lexicalTypeEnum& 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline elementOf_GGS_lexicalRoutineFormalArgumentList * nextObject (void) const { return (elementOf_GGS_lexicalRoutineFormalArgumentList *) internalNextItem () ; }

//--- Access to previous
  public : inline elementOf_GGS_lexicalRoutineFormalArgumentList * previousObject (void) const { return (elementOf_GGS_lexicalRoutineFormalArgumentList *) internalPreviousItem () ; }

//--- Element comparison
  protected : virtual bool
  isEqualToObject (const cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Friend class declaration
  friend class GGS_lexicalRoutineFormalArgumentList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   Element of map '@lexicalRoutineMap'                     *
//                                                                           *
//---------------------------------------------------------------------------*

class e_lexicalRoutineMap {
  public : GGS_lexicalRoutineFormalArgumentList  mLexicalRoutineFormalArgumentList ;
  public : GGS_stringlist  mErrorMessageList ;

  public : e_lexicalRoutineMap (void) ;
} ;

//---------------------------------------------------------------------------*

class elementOf_GGS_lexicalRoutineMap : public AC_galgas_map_element {
//--- Constructor
  public : elementOf_GGS_lexicalRoutineMap (const GGS_lstring & inKey,
                                     const sint32 inIndex,
                                     const e_lexicalRoutineMap & inInfo) ;
//--- Get pointers
  public : inline elementOf_GGS_lexicalRoutineMap * nextObject (void) const { return (elementOf_GGS_lexicalRoutineMap *) mNextItem ; }
  public : inline elementOf_GGS_lexicalRoutineMap * infObject (void) const { return (elementOf_GGS_lexicalRoutineMap *) mInfPtr ; }
  public : inline elementOf_GGS_lexicalRoutineMap * supObject (void) const { return (elementOf_GGS_lexicalRoutineMap *) mSupPtr ; }
//--- Comparison
  protected : virtual bool isEqualToMapElement (const AC_galgas_map_element * inOperand) const ;
//--- Data member
  public : e_lexicalRoutineMap mInfo ;
//--- Method for 'description' reader
  public : void appendForMapDescription (C_Compiler & inLexique,
                                         const sint32 inElementIndex,
                                         C_String & ioString,
                                         const sint32 inIndentation
                                         COMMA_LOCATION_ARGS) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   Element of map '@lexicalFunctionMap'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class e_lexicalFunctionMap {
  public : GGS_lexicalTypeList  mLexicalTypeList ;
  public : GGS_lexicalTypeEnum mReturnedLexicalType ;

  public : e_lexicalFunctionMap (void) ;
} ;

//---------------------------------------------------------------------------*

class elementOf_GGS_lexicalFunctionMap : public AC_galgas_map_element {
//--- Constructor
  public : elementOf_GGS_lexicalFunctionMap (const GGS_lstring & inKey,
                                     const sint32 inIndex,
                                     const e_lexicalFunctionMap & inInfo) ;
//--- Get pointers
  public : inline elementOf_GGS_lexicalFunctionMap * nextObject (void) const { return (elementOf_GGS_lexicalFunctionMap *) mNextItem ; }
  public : inline elementOf_GGS_lexicalFunctionMap * infObject (void) const { return (elementOf_GGS_lexicalFunctionMap *) mInfPtr ; }
  public : inline elementOf_GGS_lexicalFunctionMap * supObject (void) const { return (elementOf_GGS_lexicalFunctionMap *) mSupPtr ; }
//--- Comparison
  protected : virtual bool isEqualToMapElement (const AC_galgas_map_element * inOperand) const ;
//--- Data member
  public : e_lexicalFunctionMap mInfo ;
//--- Method for 'description' reader
  public : void appendForMapDescription (C_Compiler & inLexique,
                                         const sint32 inElementIndex,
                                         C_String & ioString,
                                         const sint32 inIndentation
                                         COMMA_LOCATION_ARGS) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//             Declarations for 'lexiqueAnalysisContext' struct              *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexiqueAnalysisContext {
//--- Default constructor
  public : GGS_lexiqueAnalysisContext (void) ;

//--- Virtual destructor
  public : virtual ~GGS_lexiqueAnalysisContext (void) ;

//--- Handle 'drop' instruction
  public : void drop (void) ;

//--- Method 'isBuilt'
  public : bool isBuilt (void) const ;

//--- Support for method call handling in GALGAS
  public : inline const GGS_lexiqueAnalysisContext * operator () (UNUSED_LOCATION_ARGS) const { return this ; }
  public : inline GGS_lexiqueAnalysisContext * operator () (UNUSED_LOCATION_ARGS) { return this ; }

//--- Comparison
  public : GGS_bool _operator_isEqual (const GGS_lexiqueAnalysisContext & inOperand) const ;
  public : GGS_bool _operator_isNotEqual (const GGS_lexiqueAnalysisContext & inOperand) const ;

//--- Reader 'description'
  public : GGS_string
  reader_description (C_Compiler & inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;
//--- Galgas 'new' destructor
  public : static GGS_lexiqueAnalysisContext constructor_new (const GGS_lexicalRoutineMap & argument_0,
                 const GGS_lexicalFunctionMap & argument_1,
                 const GGS_lexicalMessageMap & argument_2,
                 const GGS_terminalMap & argument_3,
                 const GGS_lexicalAttributeMap & argument_4,
                 const GGS_lexicalExplicitTokenListMapMap & argument_5) ;

//--- Readers
  public : inline GGS_lexicalRoutineMap 
  reader_mLexicalRoutineMessageMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
    return mLexicalRoutineMessageMap ;
  }

  public : inline GGS_lexicalFunctionMap 
  reader_mLexicalFunctionMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
    return mLexicalFunctionMap ;
  }

  public : inline GGS_lexicalMessageMap 
  reader_mLexicalMessageMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
    return mLexicalMessageMap ;
  }

  public : inline GGS_terminalMap 
  reader_mTerminalMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
    return mTerminalMap ;
  }

  public : inline GGS_lexicalAttributeMap 
  reader_mLexicalAttributeMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
    return mLexicalAttributeMap ;
  }

  public : inline GGS_lexicalExplicitTokenListMapMap 
  reader_mLexicalTokenListMapMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
    return mLexicalTokenListMapMap ;
  }

//--- Attributes
  public : GGS_lexicalRoutineMap  mLexicalRoutineMessageMap ;
  public : GGS_lexicalFunctionMap  mLexicalFunctionMap ;
  public : GGS_lexicalMessageMap  mLexicalMessageMap ;
  public : GGS_terminalMap  mTerminalMap ;
  public : GGS_lexicalAttributeMap  mLexicalAttributeMap ;
  public : GGS_lexicalExplicitTokenListMapMap  mLexicalTokenListMapMap ;
} ;

//---------------------------------------------------------------------------*

#endif
