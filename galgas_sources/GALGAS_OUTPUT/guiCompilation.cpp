//---------------------------------------------------------------------------*
//                                                                           *
//                        File 'guiCompilation.cpp'                          *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                       july 6th, 2009, at 16h31'52"                        *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "galgas/C_galgas_CLI_Options.h"
#include "guiCompilation.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "guiCompilation.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//             Include directives generated by grammar includes              *
//                                                                           *
//---------------------------------------------------------------------------*

#include "guiGrammar.h"

//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@guiCommandLineOptionList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_guiCommandLineOptionList::
elementOf_GGS_guiCommandLineOptionList (const GGS_string& argument_0,
                                const GGS_string& argument_1,
                                const GGS_char& argument_2,
                                const GGS_string& argument_3,
                                const GGS_string& argument_4
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mOptionComponent (argument_0),
mOptionIdentifier (argument_1),
mOptionChar (argument_2),
mOptionString (argument_3),
mComment (argument_4) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_guiCommandLineOptionList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_guiCommandLineOptionList * ptr = dynamic_cast <const elementOf_GGS_guiCommandLineOptionList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOptionComponent.operator_isEqual (ptr->mOptionComponent).boolValue ()
         && mOptionIdentifier.operator_isEqual (ptr->mOptionIdentifier).boolValue ()
         && mOptionChar.operator_isEqual (ptr->mOptionChar).boolValue ()
         && mOptionString.operator_isEqual (ptr->mOptionString).boolValue ()
         && mComment.operator_isEqual (ptr->mComment).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_guiCommandLineOptionList::
appendForDescription (C_Compiler & inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOptionComponent.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOptionIdentifier.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOptionChar.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOptionString.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mComment.reader_description  (inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@guiCommandLineOptionList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_guiCommandLineOptionList::
_internalAppendValues (const GGS_string& argument_0,
                    const GGS_string& argument_1,
                    const GGS_char& argument_2,
                    const GGS_string& argument_3,
                    const GGS_string& argument_4
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_guiCommandLineOptionList::
_internalPrependValues (const GGS_string& argument_0,
                    const GGS_string& argument_1,
                    const GGS_char& argument_2,
                    const GGS_string& argument_3,
                    const GGS_string& argument_4
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_guiCommandLineOptionList::
_addAssign_operation (const GGS_string& argument_0,
                                const GGS_string& argument_1,
                                const GGS_char& argument_2,
                                const GGS_string& argument_3,
                                const GGS_string& argument_4) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()&& argument_3.isBuilt ()&& argument_4.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_guiCommandLineOptionList GGS_guiCommandLineOptionList::
operator_concat (const GGS_guiCommandLineOptionList & inOperand) const {
  GGS_guiCommandLineOptionList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_guiCommandLineOptionList::
dotAssign_operation (const GGS_guiCommandLineOptionList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_guiCommandLineOptionList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_string p_0 = p->mOptionComponent ;
          GGS_string p_1 = p->mOptionIdentifier ;
          GGS_char p_2 = p->mOptionChar ;
          GGS_string p_3 = p->mOptionString ;
          GGS_string p_4 = p->mComment ;
          _internalAppendValues (p_0, p_1, p_2, p_3, p_4 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_guiCommandLineOptionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_string& argument_0,
                     const GGS_string& argument_1,
                     const GGS_char& argument_2,
                     const GGS_string& argument_3,
                     const GGS_string& argument_4
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_guiCommandLineOptionList::
_insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      _internalAppendValues (ptr->mOptionComponent,
                                ptr->mOptionIdentifier,
                                ptr->mOptionChar,
                                ptr->mOptionString,
                                ptr->mComment
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_guiCommandLineOptionList  GGS_guiCommandLineOptionList::
constructor_emptyList (void) {
  GGS_guiCommandLineOptionList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_guiCommandLineOptionList  GGS_guiCommandLineOptionList::
constructor_listWithValue (const GGS_string& argument_0,
                                const GGS_string& argument_1,
                                const GGS_char& argument_2,
                                const GGS_string& argument_3,
                                const GGS_string& argument_4) {
  GGS_guiCommandLineOptionList result ;
  result.alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2, argument_3, argument_4) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_guiCommandLineOptionList::
internalSubListWithRange (GGS_guiCommandLineOptionList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList._addAssign_operation (ptr->mOptionComponent, ptr->mOptionIdentifier, ptr->mOptionChar, ptr->mOptionString, ptr->mComment) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_guiCommandLineOptionList GGS_guiCommandLineOptionList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_guiCommandLineOptionList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_guiCommandLineOptionList GGS_guiCommandLineOptionList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_guiCommandLineOptionList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_guiCommandLineOptionList::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (inLexique, "@guiCommandLineOptionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_guiCommandLineOptionList::
method_first (C_Compiler & inLexique,
              GGS_string& _out_0,
              GGS_string& _out_1,
              GGS_char& _out_2,
              GGS_string& _out_3,
              GGS_string& _out_4
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mOptionComponent ;
    _out_1 = ptr->mOptionIdentifier ;
    _out_2 = ptr->mOptionChar ;
    _out_3 = ptr->mOptionString ;
    _out_4 = ptr->mComment ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_guiCommandLineOptionList::
method_last (C_Compiler & inLexique,
             GGS_string& _out_0,
             GGS_string& _out_1,
             GGS_char& _out_2,
             GGS_string& _out_3,
             GGS_string& _out_4
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mOptionComponent ;
    _out_1 = ptr->mOptionIdentifier ;
    _out_2 = ptr->mOptionChar ;
    _out_3 = ptr->mOptionString ;
    _out_4 = ptr->mComment ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_guiCommandLineOptionList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_string& _out_0,
                 GGS_string& _out_1,
                 GGS_char& _out_2,
                 GGS_string& _out_3,
                 GGS_string& _out_4
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mOptionComponent ;
    _out_1 = ptr->mOptionIdentifier ;
    _out_2 = ptr->mOptionChar ;
    _out_3 = ptr->mOptionString ;
    _out_4 = ptr->mComment ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_guiCommandLineOptionList::
modifier_popLast (C_Compiler & inLexique,
                GGS_string& _out_0,
                GGS_string& _out_1,
                GGS_char& _out_2,
                GGS_string& _out_3,
                GGS_string& _out_4
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mOptionComponent ;
    _out_1 = ptr->mOptionIdentifier ;
    _out_2 = ptr->mOptionChar ;
    _out_3 = ptr->mOptionString ;
    _out_4 = ptr->mComment ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_string GGS_guiCommandLineOptionList::
reader_mOptionComponentAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_string result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mOptionComponent ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_guiCommandLineOptionList::
reader_mOptionIdentifierAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_string result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mOptionIdentifier ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_char GGS_guiCommandLineOptionList::
reader_mOptionCharAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_char result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mOptionChar ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_guiCommandLineOptionList::
reader_mOptionStringAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_string result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mOptionString ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_guiCommandLineOptionList::
reader_mCommentAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_string result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mComment ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_guiCommandLineOptionList::
modifier_setMOptionComponentAtIndex (C_Compiler & inLexique,
                              const GGS_string & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mOptionComponent = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_guiCommandLineOptionList::
modifier_setMOptionIdentifierAtIndex (C_Compiler & inLexique,
                              const GGS_string & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mOptionIdentifier = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_guiCommandLineOptionList::
modifier_setMOptionCharAtIndex (C_Compiler & inLexique,
                              const GGS_char & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mOptionChar = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_guiCommandLineOptionList::
modifier_setMOptionStringAtIndex (C_Compiler & inLexique,
                              const GGS_string & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mOptionString = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_guiCommandLineOptionList::
modifier_setMCommentAtIndex (C_Compiler & inLexique,
                              const GGS_string & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mComment = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_guiCommandLineOptionList::cEnumerator::_mOptionComponent (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mOptionComponent ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_guiCommandLineOptionList::cEnumerator::_mOptionIdentifier (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mOptionIdentifier ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_char & GGS_guiCommandLineOptionList::cEnumerator::_mOptionChar (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mOptionChar ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_guiCommandLineOptionList::cEnumerator::_mOptionString (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mOptionString ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_guiCommandLineOptionList::cEnumerator::_mComment (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mComment ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'e_extensionMap'                           *
//                                                                           *
//---------------------------------------------------------------------------*

e_extensionMap::e_extensionMap (void) :
mLexiqueName () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class map '@extensionMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_extensionMap::
elementOf_GGS_extensionMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_extensionMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_extensionMap::
appendForMapDescription (C_Compiler & inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mLexiqueName.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_extensionMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_extensionMap * ptr = dynamic_cast <const elementOf_GGS_extensionMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mLexiqueName.operator_isEqual (ptr->mInfo.mLexiqueName)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_extensionMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_extensionMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_extensionMap * info = (e_extensionMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_extensionMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_extensionMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_extensionMap * info = (e_extensionMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_extensionMap GGS_extensionMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_extensionMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_extensionMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_extensionMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_extensionMap::
operator_isEqual (const GGS_extensionMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_extensionMap::
operator_isNotEqual (const GGS_extensionMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_extensionMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_extensionMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_string& inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_extensionMap info  ;
    info.mLexiqueName = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_extensionMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_string  & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mLexiqueName ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_extensionMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('e'),
  TO_UNICODE ('x'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE ('s'),
  TO_UNICODE ('i'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_extensionMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_string& inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_extensionMap GGS_extensionMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_extensionMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_extensionMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_extensionMap GGS_extensionMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_extensionMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_extensionMap::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @extensionMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_extensionMap::cEnumerator::_mLexiqueName (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mLexiqueName ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    Element of list '@nibAndClassList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_nibAndClassList::
elementOf_GGS_nibAndClassList (const GGS_string& argument_0,
                                const GGS_string& argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mNibName (argument_0),
mClassName (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_nibAndClassList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_nibAndClassList * ptr = dynamic_cast <const elementOf_GGS_nibAndClassList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mNibName.operator_isEqual (ptr->mNibName).boolValue ()
         && mClassName.operator_isEqual (ptr->mClassName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_nibAndClassList::
appendForDescription (C_Compiler & inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mNibName.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mClassName.reader_description  (inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         List '@nibAndClassList'                           *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_nibAndClassList::
_internalAppendValues (const GGS_string& argument_0,
                    const GGS_string& argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_nibAndClassList::
_internalPrependValues (const GGS_string& argument_0,
                    const GGS_string& argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_nibAndClassList::
_addAssign_operation (const GGS_string& argument_0,
                                const GGS_string& argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_nibAndClassList GGS_nibAndClassList::
operator_concat (const GGS_nibAndClassList & inOperand) const {
  GGS_nibAndClassList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_nibAndClassList::
dotAssign_operation (const GGS_nibAndClassList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_nibAndClassList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_string p_0 = p->mNibName ;
          GGS_string p_1 = p->mClassName ;
          _internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_nibAndClassList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_string& argument_0,
                     const GGS_string& argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_nibAndClassList::
_insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      _internalAppendValues (ptr->mNibName,
                                ptr->mClassName
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_nibAndClassList  GGS_nibAndClassList::
constructor_emptyList (void) {
  GGS_nibAndClassList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_nibAndClassList  GGS_nibAndClassList::
constructor_listWithValue (const GGS_string& argument_0,
                                const GGS_string& argument_1) {
  GGS_nibAndClassList result ;
  result.alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_nibAndClassList::
internalSubListWithRange (GGS_nibAndClassList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList._addAssign_operation (ptr->mNibName, ptr->mClassName) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_nibAndClassList GGS_nibAndClassList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_nibAndClassList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_nibAndClassList GGS_nibAndClassList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_nibAndClassList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_nibAndClassList::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (inLexique, "@nibAndClassList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_nibAndClassList::
method_first (C_Compiler & inLexique,
              GGS_string& _out_0,
              GGS_string& _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mNibName ;
    _out_1 = ptr->mClassName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_nibAndClassList::
method_last (C_Compiler & inLexique,
             GGS_string& _out_0,
             GGS_string& _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mNibName ;
    _out_1 = ptr->mClassName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_nibAndClassList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_string& _out_0,
                 GGS_string& _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mNibName ;
    _out_1 = ptr->mClassName ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_nibAndClassList::
modifier_popLast (C_Compiler & inLexique,
                GGS_string& _out_0,
                GGS_string& _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mNibName ;
    _out_1 = ptr->mClassName ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_string GGS_nibAndClassList::
reader_mNibNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_string result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mNibName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_nibAndClassList::
reader_mClassNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_string result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mClassName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_nibAndClassList::
modifier_setMNibNameAtIndex (C_Compiler & inLexique,
                              const GGS_string & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mNibName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_nibAndClassList::
modifier_setMClassNameAtIndex (C_Compiler & inLexique,
                              const GGS_string & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mClassName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_nibAndClassList::cEnumerator::_mNibName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mNibName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_nibAndClassList::cEnumerator::_mClassName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mClassName ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     Element of list '@textMacroList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_textMacroList::
elementOf_GGS_textMacroList (const GGS_string& argument_0,
                                const GGS_string& argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mKey (argument_0),
mContents (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_textMacroList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_textMacroList * ptr = dynamic_cast <const elementOf_GGS_textMacroList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mKey.operator_isEqual (ptr->mKey).boolValue ()
         && mContents.operator_isEqual (ptr->mContents).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_textMacroList::
appendForDescription (C_Compiler & inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mKey.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mContents.reader_description  (inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          List '@textMacroList'                            *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_textMacroList::
_internalAppendValues (const GGS_string& argument_0,
                    const GGS_string& argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_textMacroList::
_internalPrependValues (const GGS_string& argument_0,
                    const GGS_string& argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_textMacroList::
_addAssign_operation (const GGS_string& argument_0,
                                const GGS_string& argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_textMacroList GGS_textMacroList::
operator_concat (const GGS_textMacroList & inOperand) const {
  GGS_textMacroList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_textMacroList::
dotAssign_operation (const GGS_textMacroList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_textMacroList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_string p_0 = p->mKey ;
          GGS_string p_1 = p->mContents ;
          _internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_textMacroList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_string& argument_0,
                     const GGS_string& argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_textMacroList::
_insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      _internalAppendValues (ptr->mKey,
                                ptr->mContents
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_textMacroList  GGS_textMacroList::
constructor_emptyList (void) {
  GGS_textMacroList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_textMacroList  GGS_textMacroList::
constructor_listWithValue (const GGS_string& argument_0,
                                const GGS_string& argument_1) {
  GGS_textMacroList result ;
  result.alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_textMacroList::
internalSubListWithRange (GGS_textMacroList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList._addAssign_operation (ptr->mKey, ptr->mContents) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_textMacroList GGS_textMacroList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_textMacroList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_textMacroList GGS_textMacroList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_textMacroList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_textMacroList::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (inLexique, "@textMacroList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_textMacroList::
method_first (C_Compiler & inLexique,
              GGS_string& _out_0,
              GGS_string& _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mKey ;
    _out_1 = ptr->mContents ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_textMacroList::
method_last (C_Compiler & inLexique,
             GGS_string& _out_0,
             GGS_string& _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mKey ;
    _out_1 = ptr->mContents ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_textMacroList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_string& _out_0,
                 GGS_string& _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mKey ;
    _out_1 = ptr->mContents ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_textMacroList::
modifier_popLast (C_Compiler & inLexique,
                GGS_string& _out_0,
                GGS_string& _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mKey ;
    _out_1 = ptr->mContents ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_string GGS_textMacroList::
reader_mKeyAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_string result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mKey ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_textMacroList::
reader_mContentsAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_string result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mContents ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_textMacroList::
modifier_setMKeyAtIndex (C_Compiler & inLexique,
                              const GGS_string & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mKey = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_textMacroList::
modifier_setMContentsAtIndex (C_Compiler & inLexique,
                              const GGS_string & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mContents = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_textMacroList::cEnumerator::_mKey (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mKey ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_textMacroList::cEnumerator::_mContents (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mContents ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@importedLexiqueList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_importedLexiqueList::
elementOf_GGS_importedLexiqueList (const GGS_string& argument_0,
                                const GGS_string& argument_1,
                                const GGS_string& argument_2,
                                const GGS_textMacroList & argument_3
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mLexiqueClassName (argument_0),
mBlockComment (argument_1),
mTitle (argument_2),
mTextMacroList (argument_3) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_importedLexiqueList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_importedLexiqueList * ptr = dynamic_cast <const elementOf_GGS_importedLexiqueList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLexiqueClassName.operator_isEqual (ptr->mLexiqueClassName).boolValue ()
         && mBlockComment.operator_isEqual (ptr->mBlockComment).boolValue ()
         && mTitle.operator_isEqual (ptr->mTitle).boolValue ()
         && mTextMacroList.operator_isEqual (ptr->mTextMacroList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_importedLexiqueList::
appendForDescription (C_Compiler & inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLexiqueClassName.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mBlockComment.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTitle.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTextMacroList.reader_description  (inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@importedLexiqueList'                         *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_importedLexiqueList::
_internalAppendValues (const GGS_string& argument_0,
                    const GGS_string& argument_1,
                    const GGS_string& argument_2,
                    const GGS_textMacroList & argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_importedLexiqueList::
_internalPrependValues (const GGS_string& argument_0,
                    const GGS_string& argument_1,
                    const GGS_string& argument_2,
                    const GGS_textMacroList & argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_importedLexiqueList::
_addAssign_operation (const GGS_string& argument_0,
                                const GGS_string& argument_1,
                                const GGS_string& argument_2,
                                const GGS_textMacroList & argument_3) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()&& argument_3.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_importedLexiqueList GGS_importedLexiqueList::
operator_concat (const GGS_importedLexiqueList & inOperand) const {
  GGS_importedLexiqueList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_importedLexiqueList::
dotAssign_operation (const GGS_importedLexiqueList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_importedLexiqueList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_string p_0 = p->mLexiqueClassName ;
          GGS_string p_1 = p->mBlockComment ;
          GGS_string p_2 = p->mTitle ;
          GGS_textMacroList  p_3 = p->mTextMacroList ;
          _internalAppendValues (p_0, p_1, p_2, p_3 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_importedLexiqueList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_string& argument_0,
                     const GGS_string& argument_1,
                     const GGS_string& argument_2,
                     const GGS_textMacroList & argument_3
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_importedLexiqueList::
_insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      _internalAppendValues (ptr->mLexiqueClassName,
                                ptr->mBlockComment,
                                ptr->mTitle,
                                ptr->mTextMacroList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_importedLexiqueList  GGS_importedLexiqueList::
constructor_emptyList (void) {
  GGS_importedLexiqueList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_importedLexiqueList  GGS_importedLexiqueList::
constructor_listWithValue (const GGS_string& argument_0,
                                const GGS_string& argument_1,
                                const GGS_string& argument_2,
                                const GGS_textMacroList & argument_3) {
  GGS_importedLexiqueList result ;
  result.alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2, argument_3) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_importedLexiqueList::
internalSubListWithRange (GGS_importedLexiqueList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList._addAssign_operation (ptr->mLexiqueClassName, ptr->mBlockComment, ptr->mTitle, ptr->mTextMacroList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_importedLexiqueList GGS_importedLexiqueList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_importedLexiqueList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_importedLexiqueList GGS_importedLexiqueList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_importedLexiqueList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_importedLexiqueList::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (inLexique, "@importedLexiqueList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_importedLexiqueList::
method_first (C_Compiler & inLexique,
              GGS_string& _out_0,
              GGS_string& _out_1,
              GGS_string& _out_2,
              GGS_textMacroList & _out_3
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mLexiqueClassName ;
    _out_1 = ptr->mBlockComment ;
    _out_2 = ptr->mTitle ;
    _out_3 = ptr->mTextMacroList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_importedLexiqueList::
method_last (C_Compiler & inLexique,
             GGS_string& _out_0,
             GGS_string& _out_1,
             GGS_string& _out_2,
             GGS_textMacroList & _out_3
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mLexiqueClassName ;
    _out_1 = ptr->mBlockComment ;
    _out_2 = ptr->mTitle ;
    _out_3 = ptr->mTextMacroList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_importedLexiqueList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_string& _out_0,
                 GGS_string& _out_1,
                 GGS_string& _out_2,
                 GGS_textMacroList & _out_3
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mLexiqueClassName ;
    _out_1 = ptr->mBlockComment ;
    _out_2 = ptr->mTitle ;
    _out_3 = ptr->mTextMacroList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_importedLexiqueList::
modifier_popLast (C_Compiler & inLexique,
                GGS_string& _out_0,
                GGS_string& _out_1,
                GGS_string& _out_2,
                GGS_textMacroList & _out_3
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mLexiqueClassName ;
    _out_1 = ptr->mBlockComment ;
    _out_2 = ptr->mTitle ;
    _out_3 = ptr->mTextMacroList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_string GGS_importedLexiqueList::
reader_mLexiqueClassNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_string result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mLexiqueClassName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_importedLexiqueList::
reader_mBlockCommentAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_string result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mBlockComment ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_importedLexiqueList::
reader_mTitleAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_string result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mTitle ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_textMacroList  GGS_importedLexiqueList::
reader_mTextMacroListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_textMacroList  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mTextMacroList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_importedLexiqueList::
modifier_setMLexiqueClassNameAtIndex (C_Compiler & inLexique,
                              const GGS_string & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mLexiqueClassName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_importedLexiqueList::
modifier_setMBlockCommentAtIndex (C_Compiler & inLexique,
                              const GGS_string & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mBlockComment = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_importedLexiqueList::
modifier_setMTitleAtIndex (C_Compiler & inLexique,
                              const GGS_string & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mTitle = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_importedLexiqueList::
modifier_setMTextMacroListAtIndex (C_Compiler & inLexique,
                              const GGS_textMacroList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mTextMacroList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_importedLexiqueList::cEnumerator::_mLexiqueClassName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mLexiqueClassName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_importedLexiqueList::cEnumerator::_mBlockComment (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mBlockComment ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_importedLexiqueList::cEnumerator::_mTitle (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mTitle ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_textMacroList  & GGS_importedLexiqueList::cEnumerator::_mTextMacroList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((cElement *) mCurrentEnumeratedObject)->mTextMacroList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Implementation of 'guiAnalysisContext' struct                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_guiAnalysisContext::GGS_guiAnalysisContext (void) :
mImportedOptionComponentList (),
mBoolOptionList (),
mUIntOptionList (),
mStringOptionList (),
mNibAndClassList (),
mExtensionMap (),
mWithLexiqueList () {
}

//---------------------------------------------------------------------------*

GGS_guiAnalysisContext::~GGS_guiAnalysisContext (void) {
}

//---------------------------------------------------------------------------*

void GGS_guiAnalysisContext::drop (void) {
  mImportedOptionComponentList.drop () ;
  mBoolOptionList.drop () ;
  mUIntOptionList.drop () ;
  mStringOptionList.drop () ;
  mNibAndClassList.drop () ;
  mExtensionMap.drop () ;
  mWithLexiqueList.drop () ;
}

//---------------------------------------------------------------------------*

bool GGS_guiAnalysisContext::isBuilt (void) const {
  return mImportedOptionComponentList.isBuilt ()
    && mBoolOptionList.isBuilt ()
    && mUIntOptionList.isBuilt ()
    && mStringOptionList.isBuilt ()
    && mNibAndClassList.isBuilt ()
    && mExtensionMap.isBuilt ()
    && mWithLexiqueList.isBuilt () ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_guiAnalysisContext::
operator_isEqual (const GGS_guiAnalysisContext & inOperand) const {
  return mImportedOptionComponentList.operator_isEqual (inOperand.mImportedOptionComponentList)
    .operator_and (mBoolOptionList.operator_isEqual (inOperand.mBoolOptionList))
    .operator_and (mUIntOptionList.operator_isEqual (inOperand.mUIntOptionList))
    .operator_and (mStringOptionList.operator_isEqual (inOperand.mStringOptionList))
    .operator_and (mNibAndClassList.operator_isEqual (inOperand.mNibAndClassList))
    .operator_and (mExtensionMap.operator_isEqual (inOperand.mExtensionMap))
    .operator_and (mWithLexiqueList.operator_isEqual (inOperand.mWithLexiqueList)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_guiAnalysisContext::
operator_isNotEqual (const GGS_guiAnalysisContext & inOperand) const {
  return mImportedOptionComponentList.operator_isNotEqual (inOperand.mImportedOptionComponentList)
    .operator_or (mBoolOptionList.operator_isNotEqual (inOperand.mBoolOptionList))
    .operator_or (mUIntOptionList.operator_isNotEqual (inOperand.mUIntOptionList))
    .operator_or (mStringOptionList.operator_isNotEqual (inOperand.mStringOptionList))
    .operator_or (mNibAndClassList.operator_isNotEqual (inOperand.mNibAndClassList))
    .operator_or (mExtensionMap.operator_isNotEqual (inOperand.mExtensionMap))
    .operator_or (mWithLexiqueList.operator_isNotEqual (inOperand.mWithLexiqueList)) ;
}

//---------------------------------------------------------------------------*

GGS_guiAnalysisContext GGS_guiAnalysisContext::
constructor_new (const GGS_stringlist & argument_0,
                 const GGS_guiCommandLineOptionList & argument_1,
                 const GGS_guiCommandLineOptionList & argument_2,
                 const GGS_guiCommandLineOptionList & argument_3,
                 const GGS_nibAndClassList & argument_4,
                 const GGS_extensionMap & argument_5,
                 const GGS_importedLexiqueList & argument_6) {
  GGS_guiAnalysisContext result ;
  result.mImportedOptionComponentList = argument_0 ;
  result.mBoolOptionList = argument_1 ;
  result.mUIntOptionList = argument_2 ;
  result.mStringOptionList = argument_3 ;
  result.mNibAndClassList = argument_4 ;
  result.mExtensionMap = argument_5 ;
  result.mWithLexiqueList = argument_6 ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_guiAnalysisContext::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String _s ;
  _s << "<struct @guiAnalysisContext" ;
  if (isBuilt ()) {
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mImportedOptionComponentList " ;
    _s << mImportedOptionComponentList.reader_description (inLexique COMMA_THERE, inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mBoolOptionList " ;
    _s << mBoolOptionList.reader_description (inLexique COMMA_THERE, inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mUIntOptionList " ;
    _s << mUIntOptionList.reader_description (inLexique COMMA_THERE, inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mStringOptionList " ;
    _s << mStringOptionList.reader_description (inLexique COMMA_THERE, inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mNibAndClassList " ;
    _s << mNibAndClassList.reader_description (inLexique COMMA_THERE, inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mExtensionMap " ;
    _s << mExtensionMap.reader_description (inLexique COMMA_THERE, inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mWithLexiqueList " ;
    _s << mWithLexiqueList.reader_description (inLexique COMMA_THERE, inIndentation + 1) ;
  }else{
    _s << "not built" ;
  }
  _s << "\n" ;
  _s.writeStringMultiple ("| ", inIndentation) ;
  _s << ">" ;
  return GGS_string (true, _s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Implementation of wrapper 'guiGenerationTemplates'             *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

//--- All files of '' directory

static const cRegularFileWrapper * gWrapperAllFiles_guiGenerationTemplates_0 [1] = {
  NULL
} ;

//---------------------------------------------------------------------------*

//--- All sub-directories of '' directory

static const cDirectoryWrapper * gWrapperAllDirectories_guiGenerationTemplates_0 [1] = {
  NULL
} ;

//---------------------------------------------------------------------------*

//--- Directory ''

const cDirectoryWrapper gWrapperDirectory_0_guiGenerationTemplates = {
  "",
  0,
  gWrapperAllFiles_guiGenerationTemplates_0,
  0,
  gWrapperAllDirectories_guiGenerationTemplates_0
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//  'gui_implementation' template of 'guiGenerationTemplates' filewrapper    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_string
template_filewrapper_guiGenerationTemplates_gui_implementation (C_Compiler & inLexique,
                                const GGS_guiAnalysisContext& var_cas_GUI_CONTEXT) {
  C_String result ;
  const bool isBuilt = var_cas_GUI_CONTEXT.isBuilt () ;
  if (isBuilt) {
    result << "\n"
      "#include \"version_libpm.h\"\n"
      "#if LIBPM_VERSION != THE_LIBPM_VERSION\n"
      "  #error \"This file has been compiled with a version of GALGAS different than the version of libpm\"\n"
      "#endif\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "\n"
      "#import \"OC_Token.h\"\n"
      "#import \"F_CocoaWrapperForGalgas.h\"\n" ;
    GGS_importedLexiqueList::cEnumerator enumerator_353 (var_cas_GUI_CONTEXT.reader_mWithLexiqueList (inLexique COMMA_SOURCE_FILE_AT_LINE (11)), true) ;
    const GGS_importedLexiqueList::cElement * operand_353 = NULL ;
    while (((operand_353 = enumerator_353.nextObject ()))) {
      macroValidPointer (operand_353) ;
      result << "#import \"" ;
      result << operand_353->mLexiqueClassName ;
      result << "-cocoa.m\"\n" ;
    }
    GGS_nibAndClassList::cEnumerator enumerator_451 (var_cas_GUI_CONTEXT.reader_mNibAndClassList (inLexique COMMA_SOURCE_FILE_AT_LINE (14)), true) ;
    const GGS_nibAndClassList::cElement * operand_451 = NULL ;
    while (((operand_451 = enumerator_451.nextObject ()))) {
      macroValidPointer (operand_451) ;
      result << "#import \"" ;
      result << operand_451->mClassName ;
      result << ".h\"\n" ;
    }
    result << "\n"
      "#ifdef USER_DEFAULT_COLORS_DEFINED\n"
      "  #import \"user_default_colors.h\"\n"
      "#endif\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "\n"
      "#pragma mark Nibs\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "//                                                                           *\n"
      "//          N I B S   A N D   T H E I R   M A I N   C L A S S E S            *\n"
      "//                                                                           *\n"
      "//---------------------------------------------------------------------------*\n"
      "\n"
      "NSArray * nibsAndClasses (void) {\n"
      "  return [NSArray arrayWithObjects:\n" ;
    GGS_nibAndClassList::cEnumerator enumerator_1180 (var_cas_GUI_CONTEXT.reader_mNibAndClassList (inLexique COMMA_SOURCE_FILE_AT_LINE (33)), true) ;
    const GGS_nibAndClassList::cElement * operand_1180 = NULL ;
    while (((operand_1180 = enumerator_1180.nextObject ()))) {
      macroValidPointer (operand_1180) ;
      result << "    [NSArray arrayWithObjects:@\"" ;
      result << operand_1180->mNibName ;
      result << "\", [" ;
      result << operand_1180->mClassName ;
      result << " class], nil],\n" ;
    }
    result << "    nil\n"
      "  ] ;\n"
      "}\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "\n"
      "#pragma mark Command Line Options\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "//                                                                           *\n"
      "//                       Command Line Options                                *\n"
      "//                                                                           *\n"
      "//---------------------------------------------------------------------------*\n"
      "\n" ;
    GGS_stringlist::cEnumerator enumerator_1855 (var_cas_GUI_CONTEXT.reader_mImportedOptionComponentList (inLexique COMMA_SOURCE_FILE_AT_LINE (50)), true) ;
    const GGS_stringlist::cElement * operand_1855 = NULL ;
    while (((operand_1855 = enumerator_1855.nextObject ()))) {
      macroValidPointer (operand_1855) ;
      result << "#import \"" ;
      result << operand_1855->mValue ;
      result << "-cocoa.m\"\n" ;
    }
    result << "\n"
      "//---------------------------------------------------------------------------*\n"
      "\n"
      "void enterOptions (NSMutableArray * ioBoolOptionArray,\n"
      "                   NSMutableArray * ioUIntOptionArray,\n"
      "                   NSMutableArray * ioStringOptionArray) {\n" ;
    GGS_stringlist::cEnumerator enumerator_2207 (var_cas_GUI_CONTEXT.reader_mImportedOptionComponentList (inLexique COMMA_SOURCE_FILE_AT_LINE (60)), true) ;
    const GGS_stringlist::cElement * operand_2207 = NULL ;
    while (((operand_2207 = enumerator_2207.nextObject ()))) {
      macroValidPointer (operand_2207) ;
      result << "  enterOptionsFor_" ;
      result << operand_2207->mValue.reader_identifierRepresentation (inLexique COMMA_SOURCE_FILE_AT_LINE (61)) ;
      result << " (ioBoolOptionArray, ioUIntOptionArray, ioStringOptionArray) ;\n" ;
    }
    result << "}\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "\n"
      "#pragma mark Popup List Data\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "//                                                                           *\n"
      "//                     P O P U P    L I S T    D A T A                       *\n"
      "//                                                                           *\n"
      "//---------------------------------------------------------------------------*\n"
      "\n"
      "static uint16 kPopUpListData_7 [] = {99, 0} ;\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "\n"
      "static uint16 kPopUpListData_20 [] = {99, 0} ;\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "\n"
      "static uint16 kPopUpListData_41 [] = {99, 0} ;\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "\n"
      "static uint16 kPopUpListData_45 [] = {99, 0} ;\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "\n"
      "static uint16 kPopUpListData_49 [] = {99, 0} ;\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "\n"
      "static uint16 kPopUpListData_52 [] = {141, 0} ;\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "\n"
      "static uint16 kPopUpListData_62 [] = {99, 0} ;\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "\n"
      "static uint16 kPopUpListData_68 [] = {1, 0} ;\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "\n"
      "static uint16 kPopUpListData_69 [] = {141, 0} ;\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "\n"
      "static uint16 kPopUpListData_75 [] = {99, 0} ;\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "\n"
      "static const uint16 * kPopUpListData [144] = {\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  kPopUpListData_7,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  kPopUpListData_20,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  kPopUpListData_41,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  kPopUpListData_45,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  kPopUpListData_49,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  kPopUpListData_52,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  kPopUpListData_62,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  kPopUpListData_68,\n"
      "  kPopUpListData_69,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  kPopUpListData_75,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL,\n"
      "  NULL} ;\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "\n"
      "#pragma mark Lexique interface\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "//                                                                           *\n"
      "//                            Lexique interface                              *\n"
      "//                                                                           *\n"
      "//---------------------------------------------------------------------------*\n"
      "\n"
      "@interface OC_Tokenizer_galgas_scanner : OC_Lexique_galgas_scanner {\n"
      "}\n"
      "\n"
      "@end\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "\n"
      "@implementation OC_Tokenizer_galgas_scanner\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "\n"
      "- (NSString *) blockComment {\n"
      "  return @\"#\" ;\n"
      "}\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "\n"
      "- (UInt32) textMacroCount {\n"
      "  return 7 ;\n"
      "}\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "\n"
      "- (NSString *) textMacroTitleAtIndex: (const UInt32) inIndex {\n"
      "  static NSString * kTextMacroTitle [8] = {\n"
      "    @\"Types/Class\",\n"
      "    @\"Types/Enum\",\n"
      "    @\"Types/List\",\n"
      "    @\"Types/List Map\",\n"
      "    @\"Types/Map\",\n"
      "    @\"Types/Sorted List\",\n"
      "    @\"Types/Struct\",\n"
      "    NULL\n"
      "  } ;\n"
      "  return kTextMacroTitle [inIndex] ;\n"
      "}\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "\n"
      "- (NSString *) textMacroContentAtIndex: (const UInt32) inIndex {\n"
      "  static NSString * kTextMacroContent [8] = {\n"
      "    @\"class @aClassName : extends @superClassNane {\n"
      "\"\n"
      "    \"  @aType mAnAttribute ;\n"
      "\"\n"
      "    \"  override method myMethod !@string outResult :\n"
      "\"\n"
      "    \"    outResult := \\\"a string\\\" ;\n"
      "\"\n"
      "    \"  end method ;\n"
      "\"\n"
      "    \"}\n"
      "\",\n"
      "    @\"enum @aType {\n"
      "\"\n"
      "    \"  constructor constant1 ;\n"
      "\"\n"
      "    \"  constructor constant2 ;\n"
      "\"\n"
      "    \"}{\n"
      "\"\n"
      "    \"  reader actualArgumentMessage :\n"
      "\"\n"
      "    \"    constant1 -> \\\"message for constant1\\\" ;\n"
      "\"\n"
      "    \"    constant2 -> \\\"message for constant2\\\" ;\n"
      "\"\n"
      "    \"  end reader ;\n"
      "\"\n"
      "    \"}\n"
      "\",\n"
      "    @\"list @type {\n"
      "\"\n"
      "    \"  @aType mAnAttribute ;\n"
      "\"\n"
      "    \"}\n"
      "\",\n"
      "    @\"list @type {\n"
      "\"\n"
      "    \"  @aType mAnAttribute ;\n"
      "\"\n"
      "    \"}\n"
      "\"\n"
      "    \"listmap @myListMap (@aList) ;\n"
      "\",\n"
      "    @\"map @type {\n"
      "\"\n"
      "    \"  @aType mAnAttribute ;\n"
      "\"\n"
      "    \"}\n"
      "\",\n"
      "    @\"sortedlist @type {\n"
      "\"\n"
      "    \"  @string mFirstAttribute ;\n"
      "\"\n"
      "    \"  @bool mSecondAttribute ;\n"
      "\"\n"
      "    \"}{\n"
      "\"\n"
      "    \"mFirstAttribute >, mSecondAttribute <\n"
      "\"\n"
      "    \"}\n"
      "\",\n"
      "    @\"struct @type {\n"
      "\"\n"
      "    \"  @aType mAnAttribute ;\n"
      "\"\n"
      "    \"}\n"
      "\",\n"
      "    NULL\n"
      "  } ;\n"
      "  return kTextMacroContent [inIndex] ;\n"
      "}\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "\n"
      "- (const UInt16 **) popupListData {\n"
      "  return kPopUpListData ;\n"
      "}\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "\n"
      "@end\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "\n"
      "NSObject <OCP_TokenizerProtocol> * tokenizerForExtension (const NSString * inExtension) {\n"
      "  NSObject <OCP_TokenizerProtocol> * result = nil ;\n" ;
    GGS_extensionMap::cEnumerator enumerator_8531 (var_cas_GUI_CONTEXT.reader_mExtensionMap (inLexique COMMA_SOURCE_FILE_AT_LINE (365)), true) ;
    const GGS_extensionMap::cElement * operand_8531 = NULL ;
    if (enumerator_8531.hasCurrentObject ()) {
      result << "  if" ;
      while (((operand_8531 = enumerator_8531.nextObject ()))) {
        macroValidPointer (operand_8531) ;
        result << " ([inExtension isEqualToString:@" ;
        result << operand_8531->mKey.ggs_string ().reader_utf8Representation (inLexique COMMA_SOURCE_FILE_AT_LINE (367)) ;
        result << "]) {\n"
          "    result = [[OC_Tokenizer_" ;
        result << operand_8531->mInfo.mLexiqueName ;
        result << " alloc] init] ;\n" ;
        if (enumerator_8531.hasNextObject ()) {
          result << "  }else if" ;
        }
      }
      result << "  }\n" ;
    }
    result << "  return result ;\n"
      "}\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "\n"
      "NSArray * tokenizers (void) {\n"
      "  return [NSArray arrayWithObjects:\n" ;
    GGS_importedLexiqueList::cEnumerator enumerator_8941 (var_cas_GUI_CONTEXT.reader_mWithLexiqueList (inLexique COMMA_SOURCE_FILE_AT_LINE (379)), true) ;
    const GGS_importedLexiqueList::cElement * operand_8941 = NULL ;
    while (((operand_8941 = enumerator_8941.nextObject ()))) {
      macroValidPointer (operand_8941) ;
      result << "    [[[OC_Tokenizer_" ;
      result << operand_8941->mLexiqueClassName ;
      result << " alloc] init] autorelease],\n" ;
    }
    result << "    nil\n"
      "  ] ;\n"
      "}\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "\n" ;
  }
  return GGS_string (isBuilt, result) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Implementation of routine "compileGuiComponent"               *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_compileGuiComponent (C_Compiler & inLexique,
                                const GGS_lstring   var_cas_inSourceFile,
                                const GGS_string  var_cas_inOutputDirectory,
                                GGS_parsedComponentStruct & var_cas_ioParsedComponentStruct COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_compileGuiComponent at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_guiComponentRoot  var_cas_guiComponentRoot ;
  const GGS_string _depExtension = GGS_string ("") ;
  const GGS_string _depPath = GGS_string ("") ;
  if (_depExtension.isBuilt () && _depPath.isBuilt ()) {
    guiGrammar::_performSourceFileParsing_ (inLexique,
                                  _depExtension.string (),
                                  _depPath.string (),
                                  NULL,
                                  var_cas_inSourceFile,
                                  var_cas_guiComponentRoot
                                  COMMA_SOURCE_FILE_AT_LINE (103)) ;
  }
  GGS_lstring  var_cas_componentName ;
  var_cas_componentName = var_cas_guiComponentRoot.reader_mGUIName (inLexique COMMA_SOURCE_FILE_AT_LINE (105)) ;
  GGS_string var_cas_basename ;
  var_cas_basename = var_cas_inSourceFile.ggs_string ().reader_lastPathComponent (inLexique COMMA_SOURCE_FILE_AT_LINE (106)).reader_stringByDeletingPathExtension (inLexique COMMA_SOURCE_FILE_AT_LINE (106)) ;
  if (((var_cas_componentName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (107))).operator_isNotEqual (var_cas_basename)).isBuiltAndTrue ()) {
    var_cas_componentName.reader_location (inLexique COMMA_HERE).signalGGSSemanticWarning (inLexique, ((((GGS_string ("GALGAS checks "
      "the component name ('")).operator_concat (var_cas_componentName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (109)))).operator_concat (GGS_string ("') against the source file base name ('"))).operator_concat (var_cas_basename)).operator_concat (GGS_string ("'): they should be identical")) COMMA_SOURCE_FILE_AT_LINE (111)) ;
  }
  GGS_guiAnalysisContext var_cas_context ;
  var_cas_context = GGS_guiAnalysisContext::constructor_new (GGS_stringlist ::constructor_emptyList (), GGS_guiCommandLineOptionList ::constructor_emptyList (), GGS_guiCommandLineOptionList ::constructor_emptyList (), GGS_guiCommandLineOptionList ::constructor_emptyList (), GGS_nibAndClassList ::constructor_emptyList (), GGS_extensionMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_importedLexiqueList ::constructor_emptyList ()) ;
  {
    GGS_lstringlist::cEnumerator enumerator_5006 (var_cas_guiComponentRoot.reader_mImportedOptionList (inLexique COMMA_SOURCE_FILE_AT_LINE (124)), true) ;
    const GGS_lstringlist::cElement * operand_5006 = NULL ;
    while (((operand_5006 = enumerator_5006.nextObject ()))) {
      macroValidPointer (operand_5006) ;
      if (((operand_5006->mValue.ggs_string ().reader_pathExtension (inLexique COMMA_SOURCE_FILE_AT_LINE (125))).operator_isNotEqual (GGS_string ("gOption"))).isBuiltAndTrue ()) {
        operand_5006->mValue.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("only an option component (path extension '.gOption') can be imported here") COMMA_SOURCE_FILE_AT_LINE (127)) ;
      }else{
        GGS_optionComponentRoot  automatic_var_0 ;
        ::routine_parseOptionComponent (inLexique,  GGS_lstring ::constructor_new (inLexique, operand_5006->mValue.ggs_string ().reader_absolutePathFromPath (inLexique, var_cas_inSourceFile.ggs_string ().reader_stringByDeletingLastPathComponent (inLexique COMMA_SOURCE_FILE_AT_LINE (130)) COMMA_SOURCE_FILE_AT_LINE (130)), operand_5006->mValue.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (131)) COMMA_HERE),  var_cas_ioParsedComponentStruct,  automatic_var_0 COMMA_SOURCE_FILE_AT_LINE (128)) ;
        var_cas_context.mImportedOptionComponentList._addAssign_operation (operand_5006->mValue.ggs_string ().reader_lastPathComponent (inLexique COMMA_SOURCE_FILE_AT_LINE (136)).reader_stringByDeletingPathExtension (inLexique COMMA_SOURCE_FILE_AT_LINE (136))) ;
      }
    }
  }
  {
    GGS_guiSimpleAttributeList::cEnumerator enumerator_5610 (var_cas_guiComponentRoot.reader_mGlobalSimpleAttributeList (inLexique COMMA_SOURCE_FILE_AT_LINE (140)), true) ;
    const GGS_guiSimpleAttributeList::cElement * operand_5610 = NULL ;
    while (((operand_5610 = enumerator_5610.nextObject ()))) {
      macroValidPointer (operand_5610) ;
      if (((operand_5610->mKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (141))).operator_isNotEqual (GGS_string ("nibAndMainClass"))).isBuiltAndTrue ()) {
        operand_5610->mKey.reader_location (inLexique COMMA_HERE).signalGGSSemanticWarning (inLexique, ((GGS_string ("the '")).operator_concat (operand_5610->mKey)).operator_concat (GGS_string ("' key is invalid and has no effect")) COMMA_SOURCE_FILE_AT_LINE (142)) ;
      }else{
        GGS_stringlist  var_cas_x ;
        var_cas_x = operand_5610->mValue.ggs_string ().reader_componentsSeparatedByString (inLexique, GGS_string (".") COMMA_SOURCE_FILE_AT_LINE (145)) ;
        if (((var_cas_x.reader_length (inLexique COMMA_SOURCE_FILE_AT_LINE (146))).operator_isNotEqual (GGS_uint (2U))).isBuiltAndTrue ()) {
          operand_5610->mValue.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("the string string should conform to \"nib_name.nib_main_class\"") COMMA_SOURCE_FILE_AT_LINE (148)) ;
        }else{
          var_cas_context.mNibAndClassList._addAssign_operation (var_cas_x.reader_mValueAtIndex (inLexique, GGS_uint (0U) COMMA_SOURCE_FILE_AT_LINE (150)), var_cas_x.reader_mValueAtIndex (inLexique, GGS_uint (1U) COMMA_SOURCE_FILE_AT_LINE (151))) ;
        }
      }
    }
  }
  {
    GGS_withLexiqueList::cEnumerator enumerator_6286 (var_cas_guiComponentRoot.reader_mWithLexiqueList (inLexique COMMA_SOURCE_FILE_AT_LINE (157)), true) ;
    const GGS_withLexiqueList::cElement * operand_6286 = NULL ;
    while (((operand_6286 = enumerator_6286.nextObject ()))) {
      macroValidPointer (operand_6286) ;
      GGS_lexiqueComponentRoot  var_cas_lexiqueComponentRoot ;
      if (((operand_6286->mLexiqueFileName.ggs_string ().reader_pathExtension (inLexique COMMA_SOURCE_FILE_AT_LINE (160))).operator_isNotEqual (GGS_string ("gLexique"))).isBuiltAndTrue ()) {
        operand_6286->mLexiqueFileName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("the file extension for a lexique component should be 'gLexique'") COMMA_SOURCE_FILE_AT_LINE (162)) ;
        var_cas_lexiqueComponentRoot.drop () ;
      }else{
        GGS_lstring  var_cas_lexiqueFullPathName ;
        var_cas_lexiqueFullPathName = GGS_lstring ::constructor_new (inLexique, operand_6286->mLexiqueFileName.ggs_string ().reader_absolutePathFromPath (inLexique, var_cas_inSourceFile.ggs_string ().reader_stringByDeletingLastPathComponent (inLexique COMMA_SOURCE_FILE_AT_LINE (164)) COMMA_SOURCE_FILE_AT_LINE (164)), operand_6286->mLexiqueFileName.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (165)) COMMA_HERE) ;
        ::routine_parseLexiqueComponent (inLexique,  var_cas_lexiqueFullPathName,  var_cas_ioParsedComponentStruct,  var_cas_lexiqueComponentRoot COMMA_SOURCE_FILE_AT_LINE (167)) ;
      }
      GGS_textMacroList  var_cas_textMacroList ;
      var_cas_textMacroList = GGS_textMacroList ::constructor_emptyList () ;
      {
        GGS_guiCompoundAttributeList::cEnumerator enumerator_7016 (operand_6286->mCompoundAttributes, true) ;
        const GGS_guiCompoundAttributeList::cElement * operand_7016 = NULL ;
        while (((operand_7016 = enumerator_7016.nextObject ()))) {
          macroValidPointer (operand_7016) ;
          if (((operand_7016->mKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (176))).operator_isNotEqual (GGS_string ("textMacro"))).isBuiltAndTrue ()) {
            operand_7016->mKey.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("for a compound attribute, only the 'textMacro' key is valid") COMMA_SOURCE_FILE_AT_LINE (178)) ;
          }else{
            var_cas_textMacroList._addAssign_operation (operand_7016->mAttributeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (179)), operand_7016->mValue.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (179))) ;
          }
        }
      }
      GGS_bool var_cas_hasAssociatedExtension ;
      var_cas_hasAssociatedExtension = GGS_bool (false) ;
      GGS_bool var_cas_hasTabViewTitle ;
      var_cas_hasTabViewTitle = GGS_bool (false) ;
      GGS_bool var_cas_hasBlockComment ;
      var_cas_hasBlockComment = GGS_bool (false) ;
      GGS_string var_cas_tabViewTitle ;
      var_cas_tabViewTitle = GGS_string ("") ;
      GGS_string var_cas_blockComment ;
      var_cas_blockComment = GGS_string ("") ;
      {
        GGS_guiSimpleAttributeList::cEnumerator enumerator_7498 (operand_6286->mSimpleAttributes, true) ;
        const GGS_guiSimpleAttributeList::cElement * operand_7498 = NULL ;
        while (((operand_7498 = enumerator_7498.nextObject ()))) {
          macroValidPointer (operand_7498) ;
          if (((operand_7498->mKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (189))).operator_isEqual (GGS_string ("fileExtension"))).isBuiltAndTrue ()) {
            var_cas_context.mExtensionMap.modifier_insertKey (inLexique, operand_7498->mValue, operand_6286->mLexiqueFileName.ggs_string ().reader_lastPathComponent (inLexique COMMA_SOURCE_FILE_AT_LINE (190)).reader_stringByDeletingPathExtension (inLexique COMMA_SOURCE_FILE_AT_LINE (190)) COMMA_SOURCE_FILE_AT_LINE (190)) ;
            var_cas_hasAssociatedExtension = GGS_bool (true) ;
          }else if (((operand_7498->mKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (192))).operator_isEqual (GGS_string ("title"))).isBuiltAndTrue ()) {
            if ((var_cas_hasTabViewTitle).isBuiltAndTrue ()) {
              operand_7498->mKey.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("the '")).operator_concat (operand_7498->mKey)).operator_concat (GGS_string ("' key should be defined once")) COMMA_SOURCE_FILE_AT_LINE (195)) ;
            }
            var_cas_hasTabViewTitle = GGS_bool (true) ;
            var_cas_tabViewTitle = operand_7498->mValue.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (197)) ;
          }else if (((operand_7498->mKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (198))).operator_isEqual (GGS_string ("blockComment"))).isBuiltAndTrue ()) {
            if ((var_cas_hasBlockComment).isBuiltAndTrue ()) {
              operand_7498->mKey.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("the '")).operator_concat (operand_7498->mKey)).operator_concat (GGS_string ("' key should be defined once")) COMMA_SOURCE_FILE_AT_LINE (201)) ;
            }
            var_cas_hasBlockComment = GGS_bool (true) ;
            var_cas_blockComment = operand_7498->mValue.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (203)) ;
          }else{
            operand_7498->mKey.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("the '")).operator_concat (operand_7498->mKey)).operator_concat (GGS_string ("' key is not valid (valid keys: 'blockComment,', 'fileExtension', 'title')")) COMMA_SOURCE_FILE_AT_LINE (206)) ;
          }
        }
      }
      if (((var_cas_hasAssociatedExtension).operator_not ()).isBuiltAndTrue ()) {
        operand_6286->mLexiqueFileName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("one or more file extensions should be associated with a lexique (fileExtension : \"...\")") COMMA_SOURCE_FILE_AT_LINE (211)) ;
      }
      if (((var_cas_hasTabViewTitle).operator_not ()).isBuiltAndTrue ()) {
        operand_6286->mLexiqueFileName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("the 'title' key should be defined once (it is not defined)") COMMA_SOURCE_FILE_AT_LINE (215)) ;
      }
      var_cas_context.mWithLexiqueList._addAssign_operation (operand_6286->mLexiqueFileName.ggs_string ().reader_lastPathComponent (inLexique COMMA_SOURCE_FILE_AT_LINE (218)).reader_stringByDeletingPathExtension (inLexique COMMA_SOURCE_FILE_AT_LINE (218)), var_cas_blockComment, var_cas_tabViewTitle, var_cas_textMacroList) ;
    }
  }
  if (((GGS_uint ::constructor_errorCount (inLexique COMMA_HERE)).operator_isEqual (GGS_uint (0U))).isBuiltAndTrue ()) {
    GGS_string::class_method_generateFile (inLexique, var_cas_inOutputDirectory, (var_cas_componentName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (228))).operator_concat (GGS_string ("-2.mm")), GGS_string ("//"), GGS_string ("\n"
      "\n"), template_filewrapper_guiGenerationTemplates_gui_implementation (inLexique, var_cas_context), GGS_string ("\n"
      "\n"), GGS_string ("\n"
      "\n") COMMA_SOURCE_FILE_AT_LINE (226)) ;
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_compileGuiComponent\n") ;
  #endif
}

//---------------------------------------------------------------------------*

