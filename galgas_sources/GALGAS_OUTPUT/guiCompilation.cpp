//---------------------------------------------------------------------------*
//                                                                           *
//                        File 'guiCompilation.cpp'                          *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                     february 7th, 2010, at 19h41'18"                      *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "galgas/C_galgas_CLI_Options.h"
#include "guiCompilation.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "guiCompilation.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//             Include directives generated by grammar includes              *
//                                                                           *
//---------------------------------------------------------------------------*

#include "guiGrammar.h"

//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@guiCommandLineOptionList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_guiCommandLineOptionList::
elementOf_GGS_guiCommandLineOptionList (const GGS_string& argument_0,
                                const GGS_string& argument_1,
                                const GGS_char& argument_2,
                                const GGS_string& argument_3,
                                const GGS_string& argument_4
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mOptionComponent (argument_0),
mOptionIdentifier (argument_1),
mOptionChar (argument_2),
mOptionString (argument_3),
mComment (argument_4) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_guiCommandLineOptionList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_guiCommandLineOptionList * ptr = dynamic_cast <const elementOf_GGS_guiCommandLineOptionList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOptionComponent.operator_isEqual (ptr->mOptionComponent).boolValue ()
         && mOptionIdentifier.operator_isEqual (ptr->mOptionIdentifier).boolValue ()
         && mOptionChar.operator_isEqual (ptr->mOptionChar).boolValue ()
         && mOptionString.operator_isEqual (ptr->mOptionString).boolValue ()
         && mComment.operator_isEqual (ptr->mComment).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_guiCommandLineOptionList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOptionComponent.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOptionIdentifier.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOptionChar.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOptionString.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mComment.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@guiCommandLineOptionList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_guiCommandLineOptionList ("guiCommandLineOptionList", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_guiCommandLineOptionList::
internalAppendValues (const GGS_string& argument_0,
                    const GGS_string& argument_1,
                    const GGS_char& argument_2,
                    const GGS_string& argument_3,
                    const GGS_string& argument_4
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_guiCommandLineOptionList::
internalPrependValues (const GGS_string& argument_0,
                    const GGS_string& argument_1,
                    const GGS_char& argument_2,
                    const GGS_string& argument_3,
                    const GGS_string& argument_4
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_guiCommandLineOptionList::
addAssign_operation (const GGS_string& argument_0,
                                const GGS_string& argument_1,
                                const GGS_char& argument_2,
                                const GGS_string& argument_3,
                                const GGS_string& argument_4) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()&& argument_3.isBuilt ()&& argument_4.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_guiCommandLineOptionList GGS_guiCommandLineOptionList::
operator_concat (const GGS_guiCommandLineOptionList & inOperand) const {
  GGS_guiCommandLineOptionList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_guiCommandLineOptionList::
dotAssign_operation (const GGS_guiCommandLineOptionList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_guiCommandLineOptionList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_string p_0 = p->mOptionComponent ;
          GGS_string p_1 = p->mOptionIdentifier ;
          GGS_char p_2 = p->mOptionChar ;
          GGS_string p_3 = p->mOptionString ;
          GGS_string p_4 = p->mComment ;
          internalAppendValues (p_0, p_1, p_2, p_3, p_4 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_guiCommandLineOptionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_string& argument_0,
                     const GGS_string& argument_1,
                     const GGS_char& argument_2,
                     const GGS_string& argument_3,
                     const GGS_string& argument_4
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_guiCommandLineOptionList::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mOptionComponent,
                                ptr->mOptionIdentifier,
                                ptr->mOptionChar,
                                ptr->mOptionString,
                                ptr->mComment
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_guiCommandLineOptionList  GGS_guiCommandLineOptionList::
constructor_emptyList (void) {
  GGS_guiCommandLineOptionList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_guiCommandLineOptionList  GGS_guiCommandLineOptionList::
constructor_listWithValue (const GGS_string& argument_0,
                                const GGS_string& argument_1,
                                const GGS_char& argument_2,
                                const GGS_string& argument_3,
                                const GGS_string& argument_4) {
  GGS_guiCommandLineOptionList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2, argument_3, argument_4) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_guiCommandLineOptionList::
internalSubListWithRange (GGS_guiCommandLineOptionList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mOptionComponent, ptr->mOptionIdentifier, ptr->mOptionChar, ptr->mOptionString, ptr->mComment) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_guiCommandLineOptionList GGS_guiCommandLineOptionList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_guiCommandLineOptionList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_guiCommandLineOptionList GGS_guiCommandLineOptionList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_guiCommandLineOptionList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_guiCommandLineOptionList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@guiCommandLineOptionList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_guiCommandLineOptionList::
method_first (C_Compiler & inLexique,
              GGS_string& _out_0,
              GGS_string& _out_1,
              GGS_char& _out_2,
              GGS_string& _out_3,
              GGS_string& _out_4
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mOptionComponent ;
    _out_1 = ptr->mOptionIdentifier ;
    _out_2 = ptr->mOptionChar ;
    _out_3 = ptr->mOptionString ;
    _out_4 = ptr->mComment ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_guiCommandLineOptionList::
method_last (C_Compiler & inLexique,
             GGS_string& _out_0,
             GGS_string& _out_1,
             GGS_char& _out_2,
             GGS_string& _out_3,
             GGS_string& _out_4
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mOptionComponent ;
    _out_1 = ptr->mOptionIdentifier ;
    _out_2 = ptr->mOptionChar ;
    _out_3 = ptr->mOptionString ;
    _out_4 = ptr->mComment ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_guiCommandLineOptionList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_string& _out_0,
                 GGS_string& _out_1,
                 GGS_char& _out_2,
                 GGS_string& _out_3,
                 GGS_string& _out_4
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mOptionComponent ;
    _out_1 = ptr->mOptionIdentifier ;
    _out_2 = ptr->mOptionChar ;
    _out_3 = ptr->mOptionString ;
    _out_4 = ptr->mComment ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_guiCommandLineOptionList::
modifier_popLast (C_Compiler & inLexique,
                GGS_string& _out_0,
                GGS_string& _out_1,
                GGS_char& _out_2,
                GGS_string& _out_3,
                GGS_string& _out_4
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mOptionComponent ;
    _out_1 = ptr->mOptionIdentifier ;
    _out_2 = ptr->mOptionChar ;
    _out_3 = ptr->mOptionString ;
    _out_4 = ptr->mComment ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_string GGS_guiCommandLineOptionList::
reader_mOptionComponentAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_string result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mOptionComponent ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_guiCommandLineOptionList::
reader_mOptionIdentifierAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_string result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mOptionIdentifier ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_char GGS_guiCommandLineOptionList::
reader_mOptionCharAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_char result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mOptionChar ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_guiCommandLineOptionList::
reader_mOptionStringAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_string result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mOptionString ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_guiCommandLineOptionList::
reader_mCommentAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_string result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mComment ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_guiCommandLineOptionList::
modifier_setMOptionComponentAtIndex (C_Compiler & inLexique,
                              const GGS_string & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mOptionComponent = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_guiCommandLineOptionList::
modifier_setMOptionIdentifierAtIndex (C_Compiler & inLexique,
                              const GGS_string & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mOptionIdentifier = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_guiCommandLineOptionList::
modifier_setMOptionCharAtIndex (C_Compiler & inLexique,
                              const GGS_char & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mOptionChar = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_guiCommandLineOptionList::
modifier_setMOptionStringAtIndex (C_Compiler & inLexique,
                              const GGS_string & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mOptionString = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_guiCommandLineOptionList::
modifier_setMCommentAtIndex (C_Compiler & inLexique,
                              const GGS_string & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mComment = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_guiCommandLineOptionList::cEnumerator::_mOptionComponent (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mOptionComponent ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_guiCommandLineOptionList::cEnumerator::_mOptionIdentifier (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mOptionIdentifier ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_char & GGS_guiCommandLineOptionList::cEnumerator::_mOptionChar (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mOptionChar ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_guiCommandLineOptionList::cEnumerator::_mOptionString (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mOptionString ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_guiCommandLineOptionList::cEnumerator::_mComment (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mComment ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_guiCommandLineOptionList::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_guiCommandLineOptionList * p = NULL ;
    macroMyNew (p, GGS_guiCommandLineOptionList (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_guiCommandLineOptionList GGS_guiCommandLineOptionList::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_guiCommandLineOptionList result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_guiCommandLineOptionList * p = dynamic_cast <const GGS_guiCommandLineOptionList *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_guiCommandLineOptionList, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_guiCommandLineOptionList::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_guiCommandLineOptionList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'e_extensionMap'                           *
//                                                                           *
//---------------------------------------------------------------------------*

e_extensionMap::e_extensionMap (void) :
mLexiqueName () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class map '@extensionMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_extensionMap ("extensionMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_extensionMap::
elementOf_GGS_extensionMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_extensionMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_extensionMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mLexiqueName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_extensionMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_extensionMap * ptr = dynamic_cast <const elementOf_GGS_extensionMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mLexiqueName.operator_isEqual (ptr->mInfo.mLexiqueName)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_extensionMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_extensionMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_extensionMap * info = (e_extensionMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_extensionMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_extensionMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_extensionMap * info = (e_extensionMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_extensionMap GGS_extensionMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_extensionMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_extensionMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_extensionMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_extensionMap::
operator_isEqual (const GGS_extensionMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_extensionMap::
operator_isNotEqual (const GGS_extensionMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_extensionMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_extensionMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_string& inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_extensionMap info  ;
    info.mLexiqueName = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_extensionMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_string  & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mLexiqueName ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_extensionMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('e'),
  TO_UNICODE ('x'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE ('s'),
  TO_UNICODE ('i'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_extensionMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_string& inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_extensionMap GGS_extensionMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_extensionMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_extensionMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_extensionMap GGS_extensionMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_extensionMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_extensionMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @extensionMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_extensionMap::cEnumerator::_mLexiqueName (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mLexiqueName ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_extensionMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_extensionMap * p = NULL ;
    macroMyNew (p, GGS_extensionMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_extensionMap GGS_extensionMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_extensionMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_extensionMap * p = dynamic_cast <const GGS_extensionMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_extensionMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_extensionMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_extensionMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    Element of list '@nibAndClassList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_nibAndClassList::
elementOf_GGS_nibAndClassList (const GGS_string& argument_0,
                                const GGS_string& argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mNibName (argument_0),
mClassName (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_nibAndClassList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_nibAndClassList * ptr = dynamic_cast <const elementOf_GGS_nibAndClassList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mNibName.operator_isEqual (ptr->mNibName).boolValue ()
         && mClassName.operator_isEqual (ptr->mClassName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_nibAndClassList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mNibName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mClassName.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         List '@nibAndClassList'                           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_nibAndClassList ("nibAndClassList", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_nibAndClassList::
internalAppendValues (const GGS_string& argument_0,
                    const GGS_string& argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_nibAndClassList::
internalPrependValues (const GGS_string& argument_0,
                    const GGS_string& argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_nibAndClassList::
addAssign_operation (const GGS_string& argument_0,
                                const GGS_string& argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_nibAndClassList GGS_nibAndClassList::
operator_concat (const GGS_nibAndClassList & inOperand) const {
  GGS_nibAndClassList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_nibAndClassList::
dotAssign_operation (const GGS_nibAndClassList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_nibAndClassList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_string p_0 = p->mNibName ;
          GGS_string p_1 = p->mClassName ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_nibAndClassList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_string& argument_0,
                     const GGS_string& argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_nibAndClassList::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mNibName,
                                ptr->mClassName
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_nibAndClassList  GGS_nibAndClassList::
constructor_emptyList (void) {
  GGS_nibAndClassList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_nibAndClassList  GGS_nibAndClassList::
constructor_listWithValue (const GGS_string& argument_0,
                                const GGS_string& argument_1) {
  GGS_nibAndClassList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_nibAndClassList::
internalSubListWithRange (GGS_nibAndClassList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mNibName, ptr->mClassName) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_nibAndClassList GGS_nibAndClassList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_nibAndClassList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_nibAndClassList GGS_nibAndClassList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_nibAndClassList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_nibAndClassList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@nibAndClassList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_nibAndClassList::
method_first (C_Compiler & inLexique,
              GGS_string& _out_0,
              GGS_string& _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mNibName ;
    _out_1 = ptr->mClassName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_nibAndClassList::
method_last (C_Compiler & inLexique,
             GGS_string& _out_0,
             GGS_string& _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mNibName ;
    _out_1 = ptr->mClassName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_nibAndClassList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_string& _out_0,
                 GGS_string& _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mNibName ;
    _out_1 = ptr->mClassName ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_nibAndClassList::
modifier_popLast (C_Compiler & inLexique,
                GGS_string& _out_0,
                GGS_string& _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mNibName ;
    _out_1 = ptr->mClassName ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_string GGS_nibAndClassList::
reader_mNibNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_string result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mNibName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_nibAndClassList::
reader_mClassNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_string result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mClassName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_nibAndClassList::
modifier_setMNibNameAtIndex (C_Compiler & inLexique,
                              const GGS_string & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mNibName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_nibAndClassList::
modifier_setMClassNameAtIndex (C_Compiler & inLexique,
                              const GGS_string & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mClassName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_nibAndClassList::cEnumerator::_mNibName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mNibName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_nibAndClassList::cEnumerator::_mClassName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mClassName ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_nibAndClassList::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_nibAndClassList * p = NULL ;
    macroMyNew (p, GGS_nibAndClassList (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_nibAndClassList GGS_nibAndClassList::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_nibAndClassList result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_nibAndClassList * p = dynamic_cast <const GGS_nibAndClassList *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_nibAndClassList, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_nibAndClassList::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_nibAndClassList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     Element of list '@textMacroList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_textMacroList::
elementOf_GGS_textMacroList (const GGS_string& argument_0,
                                const GGS_string& argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mKey (argument_0),
mContents (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_textMacroList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_textMacroList * ptr = dynamic_cast <const elementOf_GGS_textMacroList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mKey.operator_isEqual (ptr->mKey).boolValue ()
         && mContents.operator_isEqual (ptr->mContents).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_textMacroList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mKey.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mContents.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          List '@textMacroList'                            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_textMacroList ("textMacroList", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_textMacroList::
internalAppendValues (const GGS_string& argument_0,
                    const GGS_string& argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_textMacroList::
internalPrependValues (const GGS_string& argument_0,
                    const GGS_string& argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_textMacroList::
addAssign_operation (const GGS_string& argument_0,
                                const GGS_string& argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_textMacroList GGS_textMacroList::
operator_concat (const GGS_textMacroList & inOperand) const {
  GGS_textMacroList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_textMacroList::
dotAssign_operation (const GGS_textMacroList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_textMacroList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_string p_0 = p->mKey ;
          GGS_string p_1 = p->mContents ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_textMacroList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_string& argument_0,
                     const GGS_string& argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_textMacroList::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mKey,
                                ptr->mContents
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_textMacroList  GGS_textMacroList::
constructor_emptyList (void) {
  GGS_textMacroList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_textMacroList  GGS_textMacroList::
constructor_listWithValue (const GGS_string& argument_0,
                                const GGS_string& argument_1) {
  GGS_textMacroList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_textMacroList::
internalSubListWithRange (GGS_textMacroList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mKey, ptr->mContents) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_textMacroList GGS_textMacroList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_textMacroList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_textMacroList GGS_textMacroList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_textMacroList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_textMacroList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@textMacroList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_textMacroList::
method_first (C_Compiler & inLexique,
              GGS_string& _out_0,
              GGS_string& _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mKey ;
    _out_1 = ptr->mContents ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_textMacroList::
method_last (C_Compiler & inLexique,
             GGS_string& _out_0,
             GGS_string& _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mKey ;
    _out_1 = ptr->mContents ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_textMacroList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_string& _out_0,
                 GGS_string& _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mKey ;
    _out_1 = ptr->mContents ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_textMacroList::
modifier_popLast (C_Compiler & inLexique,
                GGS_string& _out_0,
                GGS_string& _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mKey ;
    _out_1 = ptr->mContents ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_string GGS_textMacroList::
reader_mKeyAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_string result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mKey ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_textMacroList::
reader_mContentsAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_string result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mContents ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_textMacroList::
modifier_setMKeyAtIndex (C_Compiler & inLexique,
                              const GGS_string & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mKey = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_textMacroList::
modifier_setMContentsAtIndex (C_Compiler & inLexique,
                              const GGS_string & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mContents = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_textMacroList::cEnumerator::_mKey (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mKey ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_textMacroList::cEnumerator::_mContents (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mContents ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_textMacroList::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_textMacroList * p = NULL ;
    macroMyNew (p, GGS_textMacroList (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_textMacroList GGS_textMacroList::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_textMacroList result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_textMacroList * p = dynamic_cast <const GGS_textMacroList *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_textMacroList, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_textMacroList::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_textMacroList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@importedLexiqueList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_importedLexiqueList::
elementOf_GGS_importedLexiqueList (const GGS_string& argument_0,
                                const GGS_string& argument_1,
                                const GGS_string& argument_2,
                                const GGS_textMacroList & argument_3,
                                const GGS_guiLabelList & argument_4
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mLexiqueClassName (argument_0),
mBlockComment (argument_1),
mTitle (argument_2),
mTextMacroList (argument_3),
mLabels (argument_4) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_importedLexiqueList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_importedLexiqueList * ptr = dynamic_cast <const elementOf_GGS_importedLexiqueList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLexiqueClassName.operator_isEqual (ptr->mLexiqueClassName).boolValue ()
         && mBlockComment.operator_isEqual (ptr->mBlockComment).boolValue ()
         && mTitle.operator_isEqual (ptr->mTitle).boolValue ()
         && mTextMacroList.operator_isEqual (ptr->mTextMacroList).boolValue ()
         && mLabels.operator_isEqual (ptr->mLabels).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_importedLexiqueList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLexiqueClassName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mBlockComment.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTitle.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTextMacroList.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLabels.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@importedLexiqueList'                         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_importedLexiqueList ("importedLexiqueList", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_importedLexiqueList::
internalAppendValues (const GGS_string& argument_0,
                    const GGS_string& argument_1,
                    const GGS_string& argument_2,
                    const GGS_textMacroList & argument_3,
                    const GGS_guiLabelList & argument_4
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_importedLexiqueList::
internalPrependValues (const GGS_string& argument_0,
                    const GGS_string& argument_1,
                    const GGS_string& argument_2,
                    const GGS_textMacroList & argument_3,
                    const GGS_guiLabelList & argument_4
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_importedLexiqueList::
addAssign_operation (const GGS_string& argument_0,
                                const GGS_string& argument_1,
                                const GGS_string& argument_2,
                                const GGS_textMacroList & argument_3,
                                const GGS_guiLabelList & argument_4) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()&& argument_3.isBuilt ()&& argument_4.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_importedLexiqueList GGS_importedLexiqueList::
operator_concat (const GGS_importedLexiqueList & inOperand) const {
  GGS_importedLexiqueList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_importedLexiqueList::
dotAssign_operation (const GGS_importedLexiqueList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_importedLexiqueList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_string p_0 = p->mLexiqueClassName ;
          GGS_string p_1 = p->mBlockComment ;
          GGS_string p_2 = p->mTitle ;
          GGS_textMacroList  p_3 = p->mTextMacroList ;
          GGS_guiLabelList  p_4 = p->mLabels ;
          internalAppendValues (p_0, p_1, p_2, p_3, p_4 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_importedLexiqueList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_string& argument_0,
                     const GGS_string& argument_1,
                     const GGS_string& argument_2,
                     const GGS_textMacroList & argument_3,
                     const GGS_guiLabelList & argument_4
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_importedLexiqueList::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mLexiqueClassName,
                                ptr->mBlockComment,
                                ptr->mTitle,
                                ptr->mTextMacroList,
                                ptr->mLabels
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_importedLexiqueList  GGS_importedLexiqueList::
constructor_emptyList (void) {
  GGS_importedLexiqueList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_importedLexiqueList  GGS_importedLexiqueList::
constructor_listWithValue (const GGS_string& argument_0,
                                const GGS_string& argument_1,
                                const GGS_string& argument_2,
                                const GGS_textMacroList & argument_3,
                                const GGS_guiLabelList & argument_4) {
  GGS_importedLexiqueList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2, argument_3, argument_4) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_importedLexiqueList::
internalSubListWithRange (GGS_importedLexiqueList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mLexiqueClassName, ptr->mBlockComment, ptr->mTitle, ptr->mTextMacroList, ptr->mLabels) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_importedLexiqueList GGS_importedLexiqueList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_importedLexiqueList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_importedLexiqueList GGS_importedLexiqueList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_importedLexiqueList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_importedLexiqueList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@importedLexiqueList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_importedLexiqueList::
method_first (C_Compiler & inLexique,
              GGS_string& _out_0,
              GGS_string& _out_1,
              GGS_string& _out_2,
              GGS_textMacroList & _out_3,
              GGS_guiLabelList & _out_4
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mLexiqueClassName ;
    _out_1 = ptr->mBlockComment ;
    _out_2 = ptr->mTitle ;
    _out_3 = ptr->mTextMacroList ;
    _out_4 = ptr->mLabels ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_importedLexiqueList::
method_last (C_Compiler & inLexique,
             GGS_string& _out_0,
             GGS_string& _out_1,
             GGS_string& _out_2,
             GGS_textMacroList & _out_3,
             GGS_guiLabelList & _out_4
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mLexiqueClassName ;
    _out_1 = ptr->mBlockComment ;
    _out_2 = ptr->mTitle ;
    _out_3 = ptr->mTextMacroList ;
    _out_4 = ptr->mLabels ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_importedLexiqueList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_string& _out_0,
                 GGS_string& _out_1,
                 GGS_string& _out_2,
                 GGS_textMacroList & _out_3,
                 GGS_guiLabelList & _out_4
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mLexiqueClassName ;
    _out_1 = ptr->mBlockComment ;
    _out_2 = ptr->mTitle ;
    _out_3 = ptr->mTextMacroList ;
    _out_4 = ptr->mLabels ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_importedLexiqueList::
modifier_popLast (C_Compiler & inLexique,
                GGS_string& _out_0,
                GGS_string& _out_1,
                GGS_string& _out_2,
                GGS_textMacroList & _out_3,
                GGS_guiLabelList & _out_4
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mLexiqueClassName ;
    _out_1 = ptr->mBlockComment ;
    _out_2 = ptr->mTitle ;
    _out_3 = ptr->mTextMacroList ;
    _out_4 = ptr->mLabels ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_string GGS_importedLexiqueList::
reader_mLexiqueClassNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_string result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mLexiqueClassName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_importedLexiqueList::
reader_mBlockCommentAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_string result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mBlockComment ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_importedLexiqueList::
reader_mTitleAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_string result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mTitle ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_textMacroList  GGS_importedLexiqueList::
reader_mTextMacroListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_textMacroList  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mTextMacroList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_guiLabelList  GGS_importedLexiqueList::
reader_mLabelsAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_guiLabelList  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mLabels ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_importedLexiqueList::
modifier_setMLexiqueClassNameAtIndex (C_Compiler & inLexique,
                              const GGS_string & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mLexiqueClassName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_importedLexiqueList::
modifier_setMBlockCommentAtIndex (C_Compiler & inLexique,
                              const GGS_string & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mBlockComment = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_importedLexiqueList::
modifier_setMTitleAtIndex (C_Compiler & inLexique,
                              const GGS_string & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mTitle = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_importedLexiqueList::
modifier_setMTextMacroListAtIndex (C_Compiler & inLexique,
                              const GGS_textMacroList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mTextMacroList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_importedLexiqueList::
modifier_setMLabelsAtIndex (C_Compiler & inLexique,
                              const GGS_guiLabelList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mLabels = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_importedLexiqueList::cEnumerator::_mLexiqueClassName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mLexiqueClassName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_importedLexiqueList::cEnumerator::_mBlockComment (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mBlockComment ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_importedLexiqueList::cEnumerator::_mTitle (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mTitle ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_textMacroList  & GGS_importedLexiqueList::cEnumerator::_mTextMacroList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mTextMacroList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_guiLabelList  & GGS_importedLexiqueList::cEnumerator::_mLabels (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mLabels ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_importedLexiqueList::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_importedLexiqueList * p = NULL ;
    macroMyNew (p, GGS_importedLexiqueList (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_importedLexiqueList GGS_importedLexiqueList::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_importedLexiqueList result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_importedLexiqueList * p = dynamic_cast <const GGS_importedLexiqueList *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_importedLexiqueList, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_importedLexiqueList::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_importedLexiqueList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Implementation of 'guiAnalysisContext' struct                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_guiAnalysisContext ("guiAnalysisContext", false, NULL) ;

//---------------------------------------------------------------------------*

GGS_guiAnalysisContext::GGS_guiAnalysisContext (void) :
mImportedOptionComponentList (),
mBoolOptionList (),
mUIntOptionList (),
mStringOptionList (),
mNibAndClassList (),
mExtensionMap (),
mWithLexiqueList () {
}

//---------------------------------------------------------------------------*

GGS_guiAnalysisContext::~GGS_guiAnalysisContext (void) {
}

//---------------------------------------------------------------------------*

void GGS_guiAnalysisContext::drop (void) {
  mImportedOptionComponentList.drop () ;
  mBoolOptionList.drop () ;
  mUIntOptionList.drop () ;
  mStringOptionList.drop () ;
  mNibAndClassList.drop () ;
  mExtensionMap.drop () ;
  mWithLexiqueList.drop () ;
}

//---------------------------------------------------------------------------*

bool GGS_guiAnalysisContext::isBuilt (void) const {
  return mImportedOptionComponentList.isBuilt ()
    && mBoolOptionList.isBuilt ()
    && mUIntOptionList.isBuilt ()
    && mStringOptionList.isBuilt ()
    && mNibAndClassList.isBuilt ()
    && mExtensionMap.isBuilt ()
    && mWithLexiqueList.isBuilt () ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_guiAnalysisContext::
operator_isEqual (const GGS_guiAnalysisContext & inOperand) const {
  return mImportedOptionComponentList.operator_isEqual (inOperand.mImportedOptionComponentList)
    .operator_and (mBoolOptionList.operator_isEqual (inOperand.mBoolOptionList))
    .operator_and (mUIntOptionList.operator_isEqual (inOperand.mUIntOptionList))
    .operator_and (mStringOptionList.operator_isEqual (inOperand.mStringOptionList))
    .operator_and (mNibAndClassList.operator_isEqual (inOperand.mNibAndClassList))
    .operator_and (mExtensionMap.operator_isEqual (inOperand.mExtensionMap))
    .operator_and (mWithLexiqueList.operator_isEqual (inOperand.mWithLexiqueList)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_guiAnalysisContext::
operator_isNotEqual (const GGS_guiAnalysisContext & inOperand) const {
  return mImportedOptionComponentList.operator_isNotEqual (inOperand.mImportedOptionComponentList)
    .operator_or (mBoolOptionList.operator_isNotEqual (inOperand.mBoolOptionList))
    .operator_or (mUIntOptionList.operator_isNotEqual (inOperand.mUIntOptionList))
    .operator_or (mStringOptionList.operator_isNotEqual (inOperand.mStringOptionList))
    .operator_or (mNibAndClassList.operator_isNotEqual (inOperand.mNibAndClassList))
    .operator_or (mExtensionMap.operator_isNotEqual (inOperand.mExtensionMap))
    .operator_or (mWithLexiqueList.operator_isNotEqual (inOperand.mWithLexiqueList)) ;
}

//---------------------------------------------------------------------------*

GGS_guiAnalysisContext GGS_guiAnalysisContext::
constructor_new (const GGS_stringlist & argument_0,
                 const GGS_guiCommandLineOptionList & argument_1,
                 const GGS_guiCommandLineOptionList & argument_2,
                 const GGS_guiCommandLineOptionList & argument_3,
                 const GGS_nibAndClassList & argument_4,
                 const GGS_extensionMap & argument_5,
                 const GGS_importedLexiqueList & argument_6) {
  GGS_guiAnalysisContext result ;
  result.mImportedOptionComponentList = argument_0 ;
  result.mBoolOptionList = argument_1 ;
  result.mUIntOptionList = argument_2 ;
  result.mStringOptionList = argument_3 ;
  result.mNibAndClassList = argument_4 ;
  result.mExtensionMap = argument_5 ;
  result.mWithLexiqueList = argument_6 ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_guiAnalysisContext::
reader_description (const PMSInt32 inIndentation) const {
  C_String _s ;
  _s << "<struct @guiAnalysisContext" ;
  if (isBuilt ()) {
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mImportedOptionComponentList " ;
    _s << mImportedOptionComponentList.reader_description (inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mBoolOptionList " ;
    _s << mBoolOptionList.reader_description (inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mUIntOptionList " ;
    _s << mUIntOptionList.reader_description (inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mStringOptionList " ;
    _s << mStringOptionList.reader_description (inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mNibAndClassList " ;
    _s << mNibAndClassList.reader_description (inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mExtensionMap " ;
    _s << mExtensionMap.reader_description (inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mWithLexiqueList " ;
    _s << mWithLexiqueList.reader_description (inIndentation + 1) ;
  }else{
    _s << "not built" ;
  }
  _s << "\n" ;
  _s.writeStringMultiple ("| ", inIndentation) ;
  _s << ">" ;
  return GGS_string (true, _s) ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_guiAnalysisContext::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_guiAnalysisContext * p = NULL ;
    macroMyNew (p, GGS_guiAnalysisContext (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_guiAnalysisContext GGS_guiAnalysisContext::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_guiAnalysisContext result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_guiAnalysisContext * p = dynamic_cast <const GGS_guiAnalysisContext *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_guiAnalysisContext, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_guiAnalysisContext::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_guiAnalysisContext ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Implementation of wrapper 'guiGenerationTemplates'             *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

//--- All files of '' directory

static const cRegularFileWrapper * gWrapperAllFiles_guiGenerationTemplates_0 [1] = {
  NULL
} ;

//---------------------------------------------------------------------------*

//--- All sub-directories of '' directory

static const cDirectoryWrapper * gWrapperAllDirectories_guiGenerationTemplates_0 [1] = {
  NULL
} ;

//---------------------------------------------------------------------------*

//--- Directory ''

const cDirectoryWrapper gWrapperDirectory_0_guiGenerationTemplates (
  "",
  0,
  gWrapperAllFiles_guiGenerationTemplates_0,
  0,
  gWrapperAllDirectories_guiGenerationTemplates_0
) ;

//---------------------------------------------------------------------------*
//                                                                           *
//  'gui_implementation' template of 'guiGenerationTemplates' filewrapper    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_string
template_filewrapper_guiGenerationTemplates_gui_implementation (C_Compiler & inLexique,
                                const GGS_guiAnalysisContext& var_cas_GUI_CONTEXT) {
  C_String result ;
  const bool isBuilt = var_cas_GUI_CONTEXT.isBuilt () ;
  if (isBuilt) {
    result << "\n"
      "#include \"version_libpm.h\"\n"
      "#if LIBPM_VERSION != THE_LIBPM_VERSION\n"
      "  #error \"This file has been compiled with a version of GALGAS different than the version of libpm\"\n"
      "#endif\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "\n"
      "#import \"OC_Token.h\"\n"
      "#import \"F_CocoaWrapperForGalgas.h\"\n" ;
    GGS_importedLexiqueList::cEnumerator enumerator_353 (var_cas_GUI_CONTEXT.reader_mWithLexiqueList (inLexique COMMA_SOURCE_FILE_AT_LINE (11)), true) ;
    const GGS_importedLexiqueList::cElement * operand_353 = NULL ;
    while (((operand_353 = enumerator_353.nextObject ()))) {
      macroValidPointer (operand_353) ;
      result << "#import \"" ;
      result << operand_353->mLexiqueClassName ;
      result << "-cocoa.m\"\n" ;
    }
    GGS_nibAndClassList::cEnumerator enumerator_452 (var_cas_GUI_CONTEXT.reader_mNibAndClassList (inLexique COMMA_SOURCE_FILE_AT_LINE (14)), true) ;
    const GGS_nibAndClassList::cElement * operand_452 = NULL ;
    while (((operand_452 = enumerator_452.nextObject ()))) {
      macroValidPointer (operand_452) ;
      result << "#import \"" ;
      result << operand_452->mClassName ;
      result << ".h\"\n" ;
    }
    result << "\n"
      "#ifdef USER_DEFAULT_COLORS_DEFINED\n"
      "  #import \"user_default_colors.h\"\n"
      "#endif\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "\n"
      "#pragma mark Nibs\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "//                                                                           *\n"
      "//          N I B S   A N D   T H E I R   M A I N   C L A S S E S            *\n"
      "//                                                                           *\n"
      "//---------------------------------------------------------------------------*\n"
      "\n"
      "NSArray * nibsAndClasses (void) {\n"
      "  return [NSArray arrayWithObjects:\n" ;
    GGS_nibAndClassList::cEnumerator enumerator_1182 (var_cas_GUI_CONTEXT.reader_mNibAndClassList (inLexique COMMA_SOURCE_FILE_AT_LINE (33)), true) ;
    const GGS_nibAndClassList::cElement * operand_1182 = NULL ;
    while (((operand_1182 = enumerator_1182.nextObject ()))) {
      macroValidPointer (operand_1182) ;
      result << "    [NSArray arrayWithObjects:@\"" ;
      result << operand_1182->mNibName ;
      result << "\", [" ;
      result << operand_1182->mClassName ;
      result << " class], nil],\n" ;
    }
    result << "    nil\n"
      "  ] ;\n"
      "}\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "\n"
      "#pragma mark Command Line Options\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "//                                                                           *\n"
      "//                       Command Line Options                                *\n"
      "//                                                                           *\n"
      "//---------------------------------------------------------------------------*\n"
      "\n" ;
    GGS_stringlist::cEnumerator enumerator_1859 (var_cas_GUI_CONTEXT.reader_mImportedOptionComponentList (inLexique COMMA_SOURCE_FILE_AT_LINE (50)), true) ;
    const GGS_stringlist::cElement * operand_1859 = NULL ;
    while (((operand_1859 = enumerator_1859.nextObject ()))) {
      macroValidPointer (operand_1859) ;
      result << "#import \"" ;
      result << operand_1859->mValue ;
      result << "-cocoa.m\"\n" ;
    }
    result << "\n"
      "//---------------------------------------------------------------------------*\n"
      "\n"
      "void enterOptions (NSMutableArray * ioBoolOptionArray,\n"
      "                   NSMutableArray * ioUIntOptionArray,\n"
      "                   NSMutableArray * ioStringOptionArray) {\n" ;
    GGS_stringlist::cEnumerator enumerator_2212 (var_cas_GUI_CONTEXT.reader_mImportedOptionComponentList (inLexique COMMA_SOURCE_FILE_AT_LINE (60)), true) ;
    const GGS_stringlist::cElement * operand_2212 = NULL ;
    while (((operand_2212 = enumerator_2212.nextObject ()))) {
      macroValidPointer (operand_2212) ;
      result << "  enterOptionsFor_" ;
      result << operand_2212->mValue.reader_identifierRepresentation () ;
      result << " (ioBoolOptionArray, ioUIntOptionArray, ioStringOptionArray) ;\n" ;
    }
    result << "}\n"
      "\n" ;
    GGS_importedLexiqueList::cEnumerator enumerator_2394 (var_cas_GUI_CONTEXT.reader_mWithLexiqueList (inLexique COMMA_SOURCE_FILE_AT_LINE (65)), true) ;
    const GGS_importedLexiqueList::cElement * operand_2394 = NULL ;
    while (((operand_2394 = enumerator_2394.nextObject ()))) {
      macroValidPointer (operand_2394) ;
      result << "//---------------------------------------------------------------------------*\n"
        "\n"
        "#pragma mark Lexique " ;
      result << operand_2394->mLexiqueClassName ;
      result << "\n"
        "\n"
        "//---------------------------------------------------------------------------*\n"
        "//                                                                           *\n"
        "//                     P O P    U P    L I S T    D A T A                    *\n"
        "//                                                                           *\n"
        "//---------------------------------------------------------------------------*\n"
        "\n" ;
      GGS_guiLabelList::cEnumerator enumerator_2979 (operand_2394->mLabels, true) ;
      const GGS_guiLabelList::cElement * operand_2979 = NULL ;
      while (((operand_2979 = enumerator_2979.nextObject ()))) {
        macroValidPointer (operand_2979) ;
        result << "static const UInt16 gPopUpData_" ;
        result << operand_2394->mLexiqueClassName.reader_identifierRepresentation () ;
        result << "_" ;
        result << operand_2979->mLocation.reader_locationIndex (inLexique COMMA_SOURCE_FILE_AT_LINE (74)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (74)) ;
        result << " [" ;
        result << operand_2979->mTerminalList.reader_length ().add_operation (inLexique, GGS_uint (1U) COMMA_SOURCE_FILE_AT_LINE (74)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (74)) ;
        result << "] = {\n" ;
        GGS_lstringlist::cEnumerator enumerator_3180 (operand_2979->mTerminalList, true) ;
        const GGS_lstringlist::cElement * operand_3180 = NULL ;
        while (((operand_3180 = enumerator_3180.nextObject ()))) {
          macroValidPointer (operand_3180) ;
          result << "  " ;
          result << operand_2394->mLexiqueClassName ;
          result << "_1_" ;
          result << operand_3180->mValue.ggs_string ().reader_identifierRepresentation () ;
          result << ",\n" ;
        }
        result << "  0\n"
          "} ;\n"
          "\n" ;
      }
      result << "static const UInt16 * gPopUpData_" ;
      result << operand_2394->mLexiqueClassName.reader_identifierRepresentation () ;
      result << " [" ;
      result << operand_2394->mLabels.reader_length ().add_operation (inLexique, GGS_uint (1U) COMMA_SOURCE_FILE_AT_LINE (81)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (81)) ;
      result << "] = {\n" ;
      GGS_guiLabelList::cEnumerator enumerator_3464 (operand_2394->mLabels, true) ;
      const GGS_guiLabelList::cElement * operand_3464 = NULL ;
      while (((operand_3464 = enumerator_3464.nextObject ()))) {
        macroValidPointer (operand_3464) ;
        result << "  gPopUpData_" ;
        result << operand_2394->mLexiqueClassName.reader_identifierRepresentation () ;
        result << "_" ;
        result << operand_3464->mLocation.reader_locationIndex (inLexique COMMA_SOURCE_FILE_AT_LINE (83)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (83)) ;
        result << ",\n" ;
      }
      result << "  NULL\n"
        "} ;\n"
        "\n"
        "//---------------------------------------------------------------------------*\n"
        "//                                                                           *\n"
        "//                            Lexique interface                              *\n"
        "//                                                                           *\n"
        "//---------------------------------------------------------------------------*\n"
        "\n"
        "@interface OC_Tokenizer_" ;
      result << operand_2394->mLexiqueClassName ;
      result << " : OC_Lexique_" ;
      result << operand_2394->mLexiqueClassName ;
      result << " {\n"
        "\n"
        "}\n"
        "\n"
        "- (NSString *) blockComment ;\n"
        "\n"
        "- (const UInt16 * *) popupListData ;\n"
        "\n"
        "- (UInt32) textMacroCount ;\n"
        "\n"
        "- (NSString *) textMacroTitleAtIndex: (const UInt32) inIndex ;\n"
        "\n"
        "- (NSString *) textMacroContentAtIndex: (const UInt32) inIndex ;\n"
        "\n"
        "- (NSString *) tabItemTitle ;\n"
        "\n"
        "@end\n"
        "\n"
        "//---------------------------------------------------------------------------*\n"
        "\n"
        "@implementation OC_Tokenizer_" ;
      result << operand_2394->mLexiqueClassName ;
      result << "\n"
        "\n"
        "//---------------------------------------------------------------------------*\n"
        "\n"
        "- (NSString *) blockComment {\n"
        "  return @" ;
      result << operand_2394->mBlockComment.reader_utf8Representation () ;
      result << " ;\n"
        "}\n"
        "\n"
        "//---------------------------------------------------------------------------*\n"
        "\n"
        "- (const UInt16 * *) popupListData {\n"
        "  return gPopUpData_" ;
      result << operand_2394->mLexiqueClassName.reader_identifierRepresentation () ;
      result << " ;\n"
        "}\n"
        "\n"
        "//---------------------------------------------------------------------------*\n"
        "\n"
        "- (UInt32) textMacroCount {\n"
        "  return " ;
      result << operand_2394->mTextMacroList.reader_length ().reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (113)) ;
      result << " ;\n"
        "}\n"
        "\n"
        "//---------------------------------------------------------------------------*\n"
        "\n"
        "- (NSString *) tabItemTitle {\n"
        "  return @" ;
      result << operand_2394->mTitle.reader_utf8Representation () ;
      result << " ;\n"
        "}\n"
        "\n"
        "//---------------------------------------------------------------------------*\n"
        "\n"
        "- (NSString *) textMacroTitleAtIndex: (const UInt32) inIndex {\n"
        "  static NSString * kTextMacroTitle [" ;
      result << operand_2394->mTextMacroList.reader_length ().add_operation (inLexique, GGS_uint (1U) COMMA_SOURCE_FILE_AT_LINE (121)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (121)) ;
      result << "] = {\n" ;
      GGS_textMacroList::cEnumerator enumerator_5643 (operand_2394->mTextMacroList, true) ;
      const GGS_textMacroList::cElement * operand_5643 = NULL ;
      while (((operand_5643 = enumerator_5643.nextObject ()))) {
        macroValidPointer (operand_5643) ;
        result << "    @" ;
        result << operand_5643->mKey.reader_utf8Representation () ;
        result << ",\n" ;
      }
      result << "    NULL\n"
        "  } ;\n"
        "  return kTextMacroTitle [inIndex] ;\n"
        "}\n"
        "\n"
        "//---------------------------------------------------------------------------*\n"
        "\n"
        "- (NSString *) textMacroContentAtIndex: (const UInt32) inIndex {\n"
        "  static NSString * kTextMacroContent [" ;
      result << operand_2394->mTextMacroList.reader_length ().add_operation (inLexique, GGS_uint (1U) COMMA_SOURCE_FILE_AT_LINE (131)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (131)) ;
      result << "] = {\n" ;
      GGS_textMacroList::cEnumerator enumerator_6056 (operand_2394->mTextMacroList, true) ;
      const GGS_textMacroList::cElement * operand_6056 = NULL ;
      while (((operand_6056 = enumerator_6056.nextObject ()))) {
        macroValidPointer (operand_6056) ;
        result << "    @" ;
        result << operand_6056->mContents.reader_utf8Representation () ;
        result << ",\n" ;
      }
      result << "    NULL\n"
        "  } ;\n"
        "  return kTextMacroContent [inIndex] ;\n"
        "}\n"
        "\n"
        "//---------------------------------------------------------------------------*\n"
        "\n"
        "@end\n"
        "\n" ;
    }
    result << "\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "\n"
      "OC_Lexique * tokenizerForExtension (const NSString * inExtension) {\n"
      "  OC_Lexique * result = nil ;\n" ;
    GGS_extensionMap::cEnumerator enumerator_6541 (var_cas_GUI_CONTEXT.reader_mExtensionMap (inLexique COMMA_SOURCE_FILE_AT_LINE (148)), true) ;
    const GGS_extensionMap::cElement * operand_6541 = NULL ;
    if (enumerator_6541.hasCurrentObject ()) {
      result << "  if" ;
      while (((operand_6541 = enumerator_6541.nextObject ()))) {
        macroValidPointer (operand_6541) ;
        result << " ([inExtension isEqualToString:@" ;
        result << operand_6541->mKey.ggs_string ().reader_utf8Representation () ;
        result << "]) {\n"
          "    result = [[[OC_Tokenizer_" ;
        result << operand_6541->mInfo.mLexiqueName ;
        result << " alloc] init] autorelease] ;\n" ;
        if (enumerator_6541.hasNextObject ()) {
          result << "  }else if" ;
        }
      }
      result << "  }\n" ;
    }
    result << "  return result ;\n"
      "}\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "\n"
      "NSArray * tokenizers (void) {\n"
      "  return [NSArray arrayWithObjects:\n" ;
    GGS_importedLexiqueList::cEnumerator enumerator_6965 (var_cas_GUI_CONTEXT.reader_mWithLexiqueList (inLexique COMMA_SOURCE_FILE_AT_LINE (162)), true) ;
    const GGS_importedLexiqueList::cElement * operand_6965 = NULL ;
    while (((operand_6965 = enumerator_6965.nextObject ()))) {
      macroValidPointer (operand_6965) ;
      result << "    [[[OC_Tokenizer_" ;
      result << operand_6965->mLexiqueClassName ;
      result << " alloc] init] autorelease],\n" ;
    }
    result << "    nil\n"
      "  ] ;\n"
      "}\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "\n" ;
  }
  return GGS_string (isBuilt, result) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Implementation of routine "compileGuiComponent"               *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_compileGuiComponent (C_Compiler & inLexique,
                                const GGS_lstring   var_cas_inSourceFile,
                                const GGS_string  var_cas_inOutputDirectory,
                                GGS_parsedComponentStruct & var_cas_ioParsedComponentStruct COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_compileGuiComponent at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_guiComponentRoot  var_cas_guiComponentRoot ;
  const GGS_string _depExtension = GGS_string ("") ;
  const GGS_string _depPath = GGS_string ("") ;
  if (_depExtension.isBuilt () && _depPath.isBuilt ()) {
    C_Grammar_guiGrammar::_performSourceFileParsing_ (inLexique,
                                  _depExtension.string (),
                                  _depPath.string (),
                                  NULL,
                                  var_cas_inSourceFile,
                                  var_cas_guiComponentRoot
                                  COMMA_SOURCE_FILE_AT_LINE (106)) ;
  }
  GGS_lstring  var_cas_componentName = var_cas_guiComponentRoot.reader_mGUIName (inLexique COMMA_SOURCE_FILE_AT_LINE (108)) ;
  GGS_string var_cas_basename = var_cas_inSourceFile.ggs_string ().reader_lastPathComponent ().reader_stringByDeletingPathExtension () ;
  const GGS_bool cond_4698 = (var_cas_componentName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (110))).operator_isNotEqual (var_cas_basename) ;
  if (cond_4698.isBuiltAndTrue ()) {
    var_cas_componentName.reader_location (inLexique COMMA_HERE).signalGGSSemanticWarning (inLexique, ((((GGS_string ("GALGAS checks "
      "the component name ('")).operator_concat (var_cas_componentName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (112)))).operator_concat (GGS_string ("') against the source file base name ('"))).operator_concat (var_cas_basename)).operator_concat (GGS_string ("'): they should be identical")) COMMA_SOURCE_FILE_AT_LINE (114)) ;
  }
  GGS_guiAnalysisContext var_cas_context = GGS_guiAnalysisContext::constructor_new (GGS_stringlist ::constructor_emptyList (), GGS_guiCommandLineOptionList ::constructor_emptyList (), GGS_guiCommandLineOptionList ::constructor_emptyList (), GGS_guiCommandLineOptionList ::constructor_emptyList (), GGS_nibAndClassList ::constructor_emptyList (), GGS_extensionMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_importedLexiqueList ::constructor_emptyList ()) ;
  {
    GGS_lstringlist::cEnumerator enumerator_5108 (var_cas_guiComponentRoot.reader_mImportedOptionList (inLexique COMMA_SOURCE_FILE_AT_LINE (127)), true) ;
    const GGS_lstringlist::cElement * operand_5108 = NULL ;
    while (((operand_5108 = enumerator_5108.nextObject ()))) {
      macroValidPointer (operand_5108) ;
      const GGS_bool cond_5304 = (operand_5108->mValue.ggs_string ().reader_pathExtension ()).operator_isNotEqual (GGS_string ("gOption")) ;
      if (cond_5304.isBuiltAndTrue ()) {
        operand_5108->mValue.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("only an option component (path extension '.gOption') can be imported here") COMMA_SOURCE_FILE_AT_LINE (130)) ;
      }else if (cond_5304.isBuiltAndFalse ()) {
        GGS_optionComponentRoot  automatic_var_5537_0 ;
        ::routine_parseOptionComponent (inLexique,  GGS_lstring ::constructor_new (inLexique, operand_5108->mValue.ggs_string ().reader_absolutePathFromPath (var_cas_inSourceFile.ggs_string ().reader_stringByDeletingLastPathComponent ()), operand_5108->mValue.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (134)) COMMA_HERE),  var_cas_ioParsedComponentStruct,  automatic_var_5537_0 COMMA_SOURCE_FILE_AT_LINE (131)) ;
        var_cas_context.mImportedOptionComponentList.addAssign_operation (operand_5108->mValue.ggs_string ().reader_lastPathComponent ().reader_stringByDeletingPathExtension ()) ;
      }
    }
  }
  {
    GGS_guiSimpleAttributeList::cEnumerator enumerator_5712 (var_cas_guiComponentRoot.reader_mGlobalSimpleAttributeList (inLexique COMMA_SOURCE_FILE_AT_LINE (143)), true) ;
    const GGS_guiSimpleAttributeList::cElement * operand_5712 = NULL ;
    while (((operand_5712 = enumerator_5712.nextObject ()))) {
      macroValidPointer (operand_5712) ;
      const GGS_bool cond_5986 = (operand_5712->mKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (144))).operator_isNotEqual (GGS_string ("nibAndMainClass")) ;
      if (cond_5986.isBuiltAndTrue ()) {
        operand_5712->mKey.reader_location (inLexique COMMA_HERE).signalGGSSemanticWarning (inLexique, ((GGS_string ("the '")).operator_concat (operand_5712->mKey)).operator_concat (GGS_string ("' key is invalid and has no effect")) COMMA_SOURCE_FILE_AT_LINE (145)) ;
      }else if (cond_5986.isBuiltAndFalse ()) {
        GGS_stringlist  var_cas_x = operand_5712->mValue.ggs_string ().reader_componentsSeparatedByString (GGS_string (".")) ;
        const GGS_bool cond_6183 = (var_cas_x.reader_length ()).operator_isNotEqual (GGS_uint (2U)) ;
        if (cond_6183.isBuiltAndTrue ()) {
          operand_5712->mValue.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("the string string should conform to \"nib_name.nib_main_class\"") COMMA_SOURCE_FILE_AT_LINE (151)) ;
        }else if (cond_6183.isBuiltAndFalse ()) {
          var_cas_context.mNibAndClassList.addAssign_operation (var_cas_x.reader_mValueAtIndex (inLexique, GGS_uint (0U) COMMA_SOURCE_FILE_AT_LINE (153)), var_cas_x.reader_mValueAtIndex (inLexique, GGS_uint (1U) COMMA_SOURCE_FILE_AT_LINE (154))) ;
        }
      }
    }
  }
  {
    GGS_withLexiqueList::cEnumerator enumerator_6388 (var_cas_guiComponentRoot.reader_mWithLexiqueList (inLexique COMMA_SOURCE_FILE_AT_LINE (160)), true) ;
    const GGS_withLexiqueList::cElement * operand_6388 = NULL ;
    while (((operand_6388 = enumerator_6388.nextObject ()))) {
      macroValidPointer (operand_6388) ;
      GGS_lexiqueComponentRoot  var_cas_lexiqueComponentRoot ;
      const GGS_bool cond_6684 = (operand_6388->mLexiqueFileName.ggs_string ().reader_pathExtension ()).operator_isNotEqual (GGS_string ("gLexique")) ;
      if (cond_6684.isBuiltAndTrue ()) {
        operand_6388->mLexiqueFileName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("the file extension for a lexique component should be 'gLexique'") COMMA_SOURCE_FILE_AT_LINE (165)) ;
        var_cas_lexiqueComponentRoot.drop () ;
      }else if (cond_6684.isBuiltAndFalse ()) {
        GGS_lstring  var_cas_lexiqueFullPathName = GGS_lstring ::constructor_new (inLexique, operand_6388->mLexiqueFileName.ggs_string ().reader_absolutePathFromPath (var_cas_inSourceFile.ggs_string ().reader_stringByDeletingLastPathComponent ()), operand_6388->mLexiqueFileName.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (168)) COMMA_HERE) ;
        ::routine_parseLexiqueComponent (inLexique,  var_cas_lexiqueFullPathName,  var_cas_ioParsedComponentStruct,  var_cas_lexiqueComponentRoot COMMA_SOURCE_FILE_AT_LINE (170)) ;
      }
      GGS_stringset  var_cas_terminalSymbolSet = GGS_stringset ::constructor_emptySet () ;
      {
        GGS_terminalDeclarationList::cEnumerator enumerator_7105 (var_cas_lexiqueComponentRoot.reader_mTerminalDeclarationList (inLexique COMMA_SOURCE_FILE_AT_LINE (178)), true) ;
        const GGS_terminalDeclarationList::cElement * operand_7105 = NULL ;
        while (((operand_7105 = enumerator_7105.nextObject ()))) {
          macroValidPointer (operand_7105) ;
          var_cas_terminalSymbolSet.addAssign_operation (operand_7105->mName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (179))) ;
        }
      }
      {
        GGS_lexicalListDeclarationList::cEnumerator enumerator_7231 (var_cas_lexiqueComponentRoot.reader_mLexicalListDeclarationList (inLexique COMMA_SOURCE_FILE_AT_LINE (181)), true) ;
        const GGS_lexicalListDeclarationList::cElement * operand_7231 = NULL ;
        while (((operand_7231 = enumerator_7231.nextObject ()))) {
          macroValidPointer (operand_7231) ;
          {
            GGS_lexicalListEntryList::cEnumerator enumerator_7308 (operand_7231->mEntryList, true) ;
            const GGS_lexicalListEntryList::cElement * operand_7308 = NULL ;
            while (((operand_7308 = enumerator_7308.nextObject ()))) {
              macroValidPointer (operand_7308) ;
              var_cas_terminalSymbolSet.addAssign_operation (operand_7308->mTerminalSpelling.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (183))) ;
            }
          }
        }
      }
      {
        GGS_guiLabelList::cEnumerator enumerator_7448 (operand_6388->mLabels, true) ;
        const GGS_guiLabelList::cElement * operand_7448 = NULL ;
        while (((operand_7448 = enumerator_7448.nextObject ()))) {
          macroValidPointer (operand_7448) ;
          {
            GGS_lstringlist::cEnumerator enumerator_7479 (operand_7448->mTerminalList, true) ;
            const GGS_lstringlist::cElement * operand_7479 = NULL ;
            while (((operand_7479 = enumerator_7479.nextObject ()))) {
              macroValidPointer (operand_7479) ;
              const GGS_bool cond_7741 = (var_cas_terminalSymbolSet.reader_hasKey (operand_7479->mValue.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (189)))).operator_not () ;
              if (cond_7741.isBuiltAndTrue ()) {
                operand_7479->mValue.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((GGS_string ("the '$")).operator_concat (operand_7479->mValue)).operator_concat (GGS_string ("$' terminal symbol is not declared by the '"))).operator_concat (operand_6388->mLexiqueFileName)).operator_concat (GGS_string ("' lexique")) COMMA_SOURCE_FILE_AT_LINE (196)) ;
              }
            }
          }
        }
      }
      GGS_textMacroList  var_cas_textMacroList = GGS_textMacroList ::constructor_emptyList () ;
      {
        GGS_guiCompoundAttributeList::cEnumerator enumerator_7890 (operand_6388->mCompoundAttributes, true) ;
        const GGS_guiCompoundAttributeList::cElement * operand_7890 = NULL ;
        while (((operand_7890 = enumerator_7890.nextObject ()))) {
          macroValidPointer (operand_7890) ;
          const GGS_bool cond_8031 = (operand_7890->mKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (202))).operator_isNotEqual (GGS_string ("textMacro")) ;
          if (cond_8031.isBuiltAndTrue ()) {
            operand_7890->mKey.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("for a compound attribute, only the 'textMacro' key is valid") COMMA_SOURCE_FILE_AT_LINE (204)) ;
          }else if (cond_8031.isBuiltAndFalse ()) {
            var_cas_textMacroList.addAssign_operation (operand_7890->mAttributeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (205)), operand_7890->mValue.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (205))) ;
          }
        }
      }
      GGS_bool var_cas_hasAssociatedExtension = GGS_bool (false) ;
      GGS_bool var_cas_hasTabViewTitle = GGS_bool (false) ;
      GGS_bool var_cas_hasBlockComment = GGS_bool (false) ;
      GGS_string var_cas_tabViewTitle = GGS_string ("") ;
      GGS_string var_cas_blockComment = GGS_string ("") ;
      {
        GGS_guiSimpleAttributeList::cEnumerator enumerator_8372 (operand_6388->mSimpleAttributes, true) ;
        const GGS_guiSimpleAttributeList::cElement * operand_8372 = NULL ;
        while (((operand_8372 = enumerator_8372.nextObject ()))) {
          macroValidPointer (operand_8372) ;
          const GGS_bool cond_8599 = (operand_8372->mKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (215))).operator_isEqual (GGS_string ("fileExtension")) ;
          if (cond_8599.isBuiltAndTrue ()) {
            var_cas_context.mExtensionMap.modifier_insertKey (inLexique, operand_8372->mValue, operand_6388->mLexiqueFileName.ggs_string ().reader_lastPathComponent ().reader_stringByDeletingPathExtension () COMMA_SOURCE_FILE_AT_LINE (216)) ;
            var_cas_hasAssociatedExtension = GGS_bool (true) ;
          }else if (cond_8599.isBuiltAndFalse ()) {
            const GGS_bool cond_8838 = (operand_8372->mKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (218))).operator_isEqual (GGS_string ("title")) ;
            if (cond_8838.isBuiltAndTrue ()) {
              const GGS_bool cond_8745 = var_cas_hasTabViewTitle ;
              if (cond_8745.isBuiltAndTrue ()) {
                operand_8372->mKey.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("the '")).operator_concat (operand_8372->mKey)).operator_concat (GGS_string ("' key should be defined once")) COMMA_SOURCE_FILE_AT_LINE (221)) ;
              }
              var_cas_hasTabViewTitle = GGS_bool (true) ;
              var_cas_tabViewTitle = operand_8372->mValue.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (223)) ;
            }else if (cond_8838.isBuiltAndFalse ()) {
              const GGS_bool cond_9083 = (operand_8372->mKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (224))).operator_isEqual (GGS_string ("blockComment")) ;
              if (cond_9083.isBuiltAndTrue ()) {
                const GGS_bool cond_8991 = var_cas_hasBlockComment ;
                if (cond_8991.isBuiltAndTrue ()) {
                  operand_8372->mKey.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("the '")).operator_concat (operand_8372->mKey)).operator_concat (GGS_string ("' key should be defined once")) COMMA_SOURCE_FILE_AT_LINE (227)) ;
                }
                var_cas_hasBlockComment = GGS_bool (true) ;
                var_cas_blockComment = operand_8372->mValue.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (229)) ;
              }else if (cond_9083.isBuiltAndFalse ()) {
                operand_8372->mKey.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("the '")).operator_concat (operand_8372->mKey)).operator_concat (GGS_string ("' key is not valid (valid keys: 'blockComment,', 'fileExtension', 'title')")) COMMA_SOURCE_FILE_AT_LINE (232)) ;
              }
            }
          }
        }
      }
      const GGS_bool cond_9428 = (var_cas_hasAssociatedExtension).operator_not () ;
      if (cond_9428.isBuiltAndTrue ()) {
        operand_6388->mLexiqueFileName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("one or more file extensions should be associated with a lexique (fileExtension : \"...\")") COMMA_SOURCE_FILE_AT_LINE (237)) ;
      }
      const GGS_bool cond_9584 = (var_cas_hasTabViewTitle).operator_not () ;
      if (cond_9584.isBuiltAndTrue ()) {
        operand_6388->mLexiqueFileName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("the 'title' key should be defined once (it is not defined)") COMMA_SOURCE_FILE_AT_LINE (241)) ;
      }
      var_cas_context.mWithLexiqueList.addAssign_operation (operand_6388->mLexiqueFileName.ggs_string ().reader_lastPathComponent ().reader_stringByDeletingPathExtension (), var_cas_blockComment, var_cas_tabViewTitle, var_cas_textMacroList, operand_6388->mLabels) ;
    }
  }
  const GGS_bool cond_10129 = (GGS_uint ::constructor_errorCount (inLexique COMMA_HERE)).operator_isEqual (GGS_uint (0U)) ;
  if (cond_10129.isBuiltAndTrue ()) {
    GGS_string::class_method_generateFile (inLexique, var_cas_inOutputDirectory, (var_cas_componentName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (255))).operator_concat (GGS_string (".m")), GGS_string ("//"), GGS_string ("\n"
      "\n"), template_filewrapper_guiGenerationTemplates_gui_implementation (inLexique, var_cas_context), GGS_string ("\n"
      "\n"), GGS_string ("\n"
      "\n") COMMA_SOURCE_FILE_AT_LINE (253)) ;
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_compileGuiComponent\n") ;
  #endif
}

//---------------------------------------------------------------------------*

