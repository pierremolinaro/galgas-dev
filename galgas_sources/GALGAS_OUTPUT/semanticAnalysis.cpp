//---------------------------------------------------------------------------*
//                                                                           *
//                       File 'semanticAnalysis.cpp'                         *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                       may 1st, 2010, at 11h56'24"                         *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if CURRENT_LIBPM_VERSION != VERSION_OF_LIBPM_USED_BY_GALGAS_COMPILER
  #error "This file has been compiled with a version of GALGAS that uses libpm version VERSION_OF_LIBPM_USED_BY_GALGAS_COMPILER, different than the current version (CURRENT_LIBPM_VERSION) of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "galgas/C_galgas_CLI_Options.h"
#include "semanticAnalysis.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "semanticAnalysis.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//            Implementation of routine "checkMethodSignatures"              *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_checkMethodSignatures (C_Compiler & inLexique,
                                const GGS_formalParameterListForGeneration   var_cas_inTestedSignature,
                                const GGS_location   var_cas_inErrorLocation,
                                const GGS_formalParameterSignature   var_cas_inReferenceSignature,
                                const GGS_location   var_cas_inReferenceLocation COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_checkMethodSignatures at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  const GGS_bool cond_2501 = (var_cas_inTestedSignature.reader_length ()).operator_isNotEqual (var_cas_inReferenceSignature.reader_length ()) ;
  if (cond_2501.isBuiltAndTrue ()) {
    var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, (((GGS_string ("this method declares ")).operator_concat (var_cas_inTestedSignature.reader_length ().reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (37)))).operator_concat (GGS_string (" formal parameter(s), but overriden method declares "))).operator_concat (var_cas_inReferenceSignature.reader_length ().reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (38))) COMMA_SOURCE_FILE_AT_LINE (40)) ;
    var_cas_inReferenceLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("overriden method is declared here") COMMA_SOURCE_FILE_AT_LINE (41)) ;
  }else if (cond_2501.isBuiltAndFalse ()) {
    {
      GGS_formalParameterSignature::cEnumerator enumerator_2534 (var_cas_inReferenceSignature, true) ;
      const GGS_formalParameterSignature::cElement * operand_2534 = NULL ;
      GGS_formalParameterListForGeneration::cEnumerator enumerator_2569 (var_cas_inTestedSignature, true) ;
      const GGS_formalParameterListForGeneration::cElement * operand_2569 = NULL ;
      while (((operand_2534 = enumerator_2534.nextObject ()))
          && ((operand_2569 = enumerator_2569.nextObject ()))) {
        macroValidPointer (operand_2534) ;
        macroValidPointer (operand_2569) ;
        const GGS_bool cond_3012 = (operand_2534->mFormalParameterPassingMode).operator_isNotEqual (operand_2569->mFormalParameterPassingMode) ;
        if (cond_3012.isBuiltAndTrue ()) {
          operand_2569->mFormalParameterName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, (((((GGS_string ("the '")).operator_concat (operand_2569->mFormalParameterName)).operator_concat (GGS_string ("' formal parameter is declared as "))).operator_concat (operand_2569->mFormalParameterPassingMode.reader_formalArgumentMessage (inLexique COMMA_SOURCE_FILE_AT_LINE (45)))).operator_concat (GGS_string (", but overriden method declares it as "))).operator_concat (operand_2534->mFormalParameterPassingMode.reader_formalArgumentMessage (inLexique COMMA_SOURCE_FILE_AT_LINE (46))) COMMA_SOURCE_FILE_AT_LINE (47)) ;
          var_cas_inReferenceLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("overriden method is declared here") COMMA_SOURCE_FILE_AT_LINE (48)) ;
        }
        const GGS_bool cond_3431 = (operand_2569->mFormalParameterType.reader_key (inLexique COMMA_SOURCE_FILE_AT_LINE (49)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (49))).operator_isNotEqual (operand_2534->mParameterType.reader_keyString (inLexique COMMA_SOURCE_FILE_AT_LINE (49))) ;
        if (cond_3431.isBuiltAndTrue ()) {
          operand_2569->mFormalParameterName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((((GGS_string ("the '")).operator_concat (operand_2569->mFormalParameterName)).operator_concat (GGS_string ("' formal parameter has the '@"))).operator_concat (operand_2569->mFormalParameterType.reader_key (inLexique COMMA_SOURCE_FILE_AT_LINE (51)))).operator_concat (GGS_string ("' type, but overriden method declares with the '@"))).operator_concat (operand_2534->mParameterType.reader_keyString (inLexique COMMA_SOURCE_FILE_AT_LINE (52)))).operator_concat (GGS_string ("' type")) COMMA_SOURCE_FILE_AT_LINE (53)) ;
          var_cas_inReferenceLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("overriden method is declared here") COMMA_SOURCE_FILE_AT_LINE (54)) ;
        }
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_checkMethodSignatures\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//    Category method '@semanticDeclarationAST.performSemanticAnalysis'      *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__semanticDeclarationAST__performSemanticAnalysis (C_Compiler &,
                                const cPtr_semanticDeclarationAST * operand_3926,
                                const GGS_semanticContext  /* var_cas_inSemanticContext */,
                                GGS_semanticDeclarationListForGeneration  & /* var_cas_ioSemanticDeclarationListForGeneration */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_3926 != NULL) {
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//Virtual Table for category method '@semanticDeclarationAST.performSemanticAnalysis'*
//                                                                           *
//---------------------------------------------------------------------------*

static TC_UniqueArray <typeCategoryMethod__semanticDeclarationAST__performSemanticAnalysis> gDispatchTableForMethod__semanticDeclarationAST__performSemanticAnalysis ;

//---------------------------------------------------------------------------*

void
enterCategoryMethod__semanticDeclarationAST__performSemanticAnalysis (typeCategoryMethod__semanticDeclarationAST__performSemanticAnalysis inRoutine,
                     const PMSInt32 inClassID) {
  gDispatchTableForMethod__semanticDeclarationAST__performSemanticAnalysis.forceObjectAtIndex (inClassID, inRoutine, NULL COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

typeCategoryMethod__semanticDeclarationAST__performSemanticAnalysis
findCategoryMethod__semanticDeclarationAST__performSemanticAnalysis (AC_galgasClassRunTimeInformationEX * inClassPtr) {
  typeCategoryMethod__semanticDeclarationAST__performSemanticAnalysis result = NULL ;
  if (inClassPtr->slotID () < gDispatchTableForMethod__semanticDeclarationAST__performSemanticAnalysis.count ()) {
    result = gDispatchTableForMethod__semanticDeclarationAST__performSemanticAnalysis (inClassPtr->slotID () COMMA_HERE) ;
  }
  if (NULL == result) {
    AC_galgasClassRunTimeInformationEX * superClassPtr = inClassPtr->superClassPtr () ;
    if (superClassPtr != NULL) {
      result = findCategoryMethod__semanticDeclarationAST__performSemanticAnalysis (superClassPtr) ;
      gDispatchTableForMethod__semanticDeclarationAST__performSemanticAnalysis.forceObjectAtIndex (inClassPtr->slotID (), result, NULL COMMA_HERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//       Category method '@predefinedTypeAST.performSemanticAnalysis'        *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__predefinedTypeAST__performSemanticAnalysis (C_Compiler & inLexique,
                                const cPtr_predefinedTypeAST * operand_4214,
                                const GGS_semanticContext  var_cas_inSemanticContext,
                                GGS_semanticDeclarationListForGeneration  & var_cas_ioSemanticDeclarationListForGeneration
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_4214 != NULL) {
    var_cas_ioSemanticDeclarationListForGeneration.addAssign_operation (GGS_primitiveTypeForGeneration ::constructor_new (inLexique, GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, GGS_lstring ::constructor_new (inLexique, operand_4214->mPredefinedTypeName, GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (78)) COMMA_SOURCE_FILE_AT_LINE (78)) COMMA_SOURCE_FILE_AT_LINE (77))) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'e_attributeIndexMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

e_attributeIndexMap::e_attributeIndexMap (void) :
mIndex () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class map '@attributeIndexMap'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_attributeIndexMap ("attributeIndexMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_attributeIndexMap::
elementOf_GGS_attributeIndexMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_attributeIndexMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_attributeIndexMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mIndex.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_attributeIndexMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_attributeIndexMap * ptr = dynamic_cast <const elementOf_GGS_attributeIndexMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mIndex.operator_isEqual (ptr->mInfo.mIndex)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_attributeIndexMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_attributeIndexMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_attributeIndexMap * info = (e_attributeIndexMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_attributeIndexMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_attributeIndexMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_attributeIndexMap * info = (e_attributeIndexMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_attributeIndexMap GGS_attributeIndexMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_attributeIndexMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_attributeIndexMap::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_attributeIndexMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_attributeIndexMap::
operator_isEqual (const GGS_attributeIndexMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_attributeIndexMap::
operator_isNotEqual (const GGS_attributeIndexMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_attributeIndexMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined) ;
}

//---------------------------------------------------------------------------*

void GGS_attributeIndexMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_uint & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_attributeIndexMap info  ;
    info.mIndex = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_attributeIndexMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_uint   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mIndex ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_attributeIndexMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('t'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('b'),
  TO_UNICODE ('u'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_attributeIndexMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_uint   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_attributeIndexMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('t'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('b'),
  TO_UNICODE ('u'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_attributeIndexMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_uint & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_attributeIndexMap GGS_attributeIndexMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_attributeIndexMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_attributeIndexMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_attributeIndexMap GGS_attributeIndexMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_attributeIndexMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_attributeIndexMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @attributeIndexMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_attributeIndexMap::cEnumerator::_mIndex (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mIndex ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_attributeIndexMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_attributeIndexMap * p = NULL ;
    macroMyNew (p, GGS_attributeIndexMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_attributeIndexMap GGS_attributeIndexMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_attributeIndexMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_attributeIndexMap * p = dynamic_cast <const GGS_attributeIndexMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_attributeIndexMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_attributeIndexMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_attributeIndexMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Category method '@listDeclarationAST.performSemanticAnalysis'        *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__listDeclarationAST__performSemanticAnalysis (C_Compiler & inLexique,
                                const cPtr_listDeclarationAST * operand_4956,
                                const GGS_semanticContext  var_cas_inSemanticContext,
                                GGS_semanticDeclarationListForGeneration  & var_cas_ioSemanticDeclarationListForGeneration
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_4956 != NULL) {
    GGS_typedAttributeList  var_cas_typedAttributeList = GGS_typedAttributeList ::constructor_emptyList () ;
    GGS_attributeIndexMap  var_cas_attributeIndexMap = GGS_attributeIndexMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (98)) ;
    {
      GGS_attributeInCollectionListAST::cEnumerator enumerator_5210 (operand_4956->mAttributeList, true) ;
      const GGS_attributeInCollectionListAST::cElement * operand_5210 = NULL ;
      while (((operand_5210 = enumerator_5210.nextObject ()))) {
        macroValidPointer (operand_5210) ;
        var_cas_typedAttributeList.addAssign_operation (GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_5210->mAttributeTypeName COMMA_SOURCE_FILE_AT_LINE (101)), operand_5210->mAttributeName) ;
        var_cas_attributeIndexMap.modifier_insertKey (inLexique, operand_5210->mAttributeName, var_cas_attributeIndexMap.reader_count () COMMA_SOURCE_FILE_AT_LINE (104)) ;
      }
    }
    var_cas_ioSemanticDeclarationListForGeneration.addAssign_operation (GGS_listTypeForGeneration ::constructor_new (inLexique, GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_4956->mListTypeName COMMA_SOURCE_FILE_AT_LINE (107)), var_cas_typedAttributeList COMMA_SOURCE_FILE_AT_LINE (106))) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//   Category method '@sortedListDeclarationAST.performSemanticAnalysis'     *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__sortedListDeclarationAST__performSemanticAnalysis (C_Compiler & inLexique,
                                const cPtr_sortedListDeclarationAST * operand_5798,
                                const GGS_semanticContext  var_cas_inSemanticContext,
                                GGS_semanticDeclarationListForGeneration  & var_cas_ioSemanticDeclarationListForGeneration
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_5798 != NULL) {
    GGS_typedAttributeList  var_cas_typedAttributeList = GGS_typedAttributeList ::constructor_emptyList () ;
    GGS_attributeIndexMap  var_cas_attributeIndexMap = GGS_attributeIndexMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (121)) ;
    {
      GGS_attributeInCollectionListAST::cEnumerator enumerator_6067 (operand_5798->mAttributeList, true) ;
      const GGS_attributeInCollectionListAST::cElement * operand_6067 = NULL ;
      while (((operand_6067 = enumerator_6067.nextObject ()))) {
        macroValidPointer (operand_6067) ;
        var_cas_typedAttributeList.addAssign_operation (GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_6067->mAttributeTypeName COMMA_SOURCE_FILE_AT_LINE (124)), operand_6067->mAttributeName) ;
        var_cas_attributeIndexMap.modifier_insertKey (inLexique, operand_6067->mAttributeName, var_cas_attributeIndexMap.reader_count () COMMA_SOURCE_FILE_AT_LINE (127)) ;
      }
    }
    GGS_stringset  var_cas_attributesUsedForSorting = GGS_stringset ::constructor_emptySet () ;
    GGS_sortDescriptorListForGeneration  var_cas_sortDescriptorList = GGS_sortDescriptorListForGeneration ::constructor_emptyList () ;
    {
      GGS_sortedListSortDescriptorListAST::cEnumerator enumerator_6480 (operand_5798->mSortDescriptorList, true) ;
      const GGS_sortedListSortDescriptorListAST::cElement * operand_6480 = NULL ;
      while (((operand_6480 = enumerator_6480.nextObject ()))) {
        macroValidPointer (operand_6480) ;
        GGS_uint  var_cas_attributeIndex ;
        const GGS_attributeIndexMap  temp_6543 = var_cas_attributeIndexMap ;
        if (temp_6543.isBuilt ()) {
          temp_6543 (HERE)->method_searchKey (inLexique, operand_6480->mSortedAttributeName, var_cas_attributeIndex COMMA_SOURCE_FILE_AT_LINE (134)) ;
        }
        var_cas_sortDescriptorList.addAssign_operation (var_cas_attributeIndex, operand_6480->mAscending) ;
        const GGS_bool cond_6827 = var_cas_attributesUsedForSorting.reader_hasKey (operand_6480->mSortedAttributeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (136))) ;
        if (cond_6827.isBuiltAndTrue ()) {
          operand_6480->mSortedAttributeName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("the '")).operator_concat (operand_6480->mSortedAttributeName)).operator_concat (GGS_string ("' is already used for sorting")) COMMA_SOURCE_FILE_AT_LINE (138)) ;
        }
        var_cas_attributesUsedForSorting.addAssign_operation (operand_6480->mSortedAttributeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (139))) ;
      }
    }
    var_cas_ioSemanticDeclarationListForGeneration.addAssign_operation (GGS_sortedListTypeForGeneration ::constructor_new (inLexique, GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_5798->mSortedListTypeName COMMA_SOURCE_FILE_AT_LINE (143)), var_cas_typedAttributeList, var_cas_sortDescriptorList COMMA_SOURCE_FILE_AT_LINE (142))) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//     Category method '@structDeclarationAST.performSemanticAnalysis'       *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__structDeclarationAST__performSemanticAnalysis (C_Compiler & inLexique,
                                const cPtr_structDeclarationAST * operand_7309,
                                const GGS_semanticContext  var_cas_inSemanticContext,
                                GGS_semanticDeclarationListForGeneration  & var_cas_ioSemanticDeclarationListForGeneration
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_7309 != NULL) {
    GGS_typedAttributeList  var_cas_typedAttributeList = GGS_typedAttributeList ::constructor_emptyList () ;
    GGS_attributeIndexMap  var_cas_attributeIndexMap = GGS_attributeIndexMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (157)) ;
    {
      GGS_attributeInCollectionListAST::cEnumerator enumerator_7563 (operand_7309->mAttributeList, true) ;
      const GGS_attributeInCollectionListAST::cElement * operand_7563 = NULL ;
      while (((operand_7563 = enumerator_7563.nextObject ()))) {
        macroValidPointer (operand_7563) ;
        var_cas_typedAttributeList.addAssign_operation (GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_7563->mAttributeTypeName COMMA_SOURCE_FILE_AT_LINE (160)), operand_7563->mAttributeName) ;
        var_cas_attributeIndexMap.modifier_insertKey (inLexique, operand_7563->mAttributeName, var_cas_attributeIndexMap.reader_count () COMMA_SOURCE_FILE_AT_LINE (163)) ;
      }
    }
    var_cas_ioSemanticDeclarationListForGeneration.addAssign_operation (GGS_structTypeForGeneration ::constructor_new (inLexique, GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_7309->mStructTypeName COMMA_SOURCE_FILE_AT_LINE (166)), var_cas_typedAttributeList COMMA_SOURCE_FILE_AT_LINE (165))) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'e_constantIndexMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

e_constantIndexMap::e_constantIndexMap (void) :
mIndex () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class map '@constantIndexMap'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_constantIndexMap ("constantIndexMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_constantIndexMap::
elementOf_GGS_constantIndexMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_constantIndexMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_constantIndexMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mIndex.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_constantIndexMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_constantIndexMap * ptr = dynamic_cast <const elementOf_GGS_constantIndexMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mIndex.operator_isEqual (ptr->mInfo.mIndex)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_constantIndexMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_constantIndexMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_constantIndexMap * info = (e_constantIndexMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_constantIndexMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_constantIndexMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_constantIndexMap * info = (e_constantIndexMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_constantIndexMap GGS_constantIndexMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_constantIndexMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_constantIndexMap::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_constantIndexMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_constantIndexMap::
operator_isEqual (const GGS_constantIndexMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_constantIndexMap::
operator_isNotEqual (const GGS_constantIndexMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_constantIndexMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined) ;
}

//---------------------------------------------------------------------------*

void GGS_constantIndexMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_uint & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_constantIndexMap info  ;
    info.mIndex = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_constantIndexMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_uint   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mIndex ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_constantIndexMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE ('s'),
  TO_UNICODE ('t'),
  TO_UNICODE ('a'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_constantIndexMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_uint   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_constantIndexMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE ('s'),
  TO_UNICODE ('t'),
  TO_UNICODE ('a'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_constantIndexMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_uint & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_constantIndexMap GGS_constantIndexMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_constantIndexMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_constantIndexMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_constantIndexMap GGS_constantIndexMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_constantIndexMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_constantIndexMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @constantIndexMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_constantIndexMap::cEnumerator::_mIndex (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mIndex ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_constantIndexMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_constantIndexMap * p = NULL ;
    macroMyNew (p, GGS_constantIndexMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_constantIndexMap GGS_constantIndexMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_constantIndexMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_constantIndexMap * p = dynamic_cast <const GGS_constantIndexMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_constantIndexMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_constantIndexMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_constantIndexMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Category method '@enumDeclarationAST.performSemanticAnalysis'        *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__enumDeclarationAST__performSemanticAnalysis (C_Compiler & inLexique,
                                const cPtr_enumDeclarationAST * operand_8417,
                                const GGS_semanticContext  var_cas_inSemanticContext,
                                GGS_semanticDeclarationListForGeneration  & var_cas_ioSemanticDeclarationListForGeneration
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_8417 != NULL) {
    GGS_stringlist  var_cas_constantList = GGS_stringlist ::constructor_emptyList () ;
    GGS_constantIndexMap  var_cas_constantMap = GGS_constantIndexMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (187)) ;
    {
      GGS_lstringlist::cEnumerator enumerator_8668 (operand_8417->mConstantList, true) ;
      const GGS_lstringlist::cElement * operand_8668 = NULL ;
      while (((operand_8668 = enumerator_8668.nextObject ()))) {
        macroValidPointer (operand_8668) ;
        var_cas_constantList.addAssign_operation (operand_8668->mValue.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (189))) ;
        var_cas_constantMap.modifier_insertKey (inLexique, operand_8668->mValue, var_cas_constantMap.reader_count () COMMA_SOURCE_FILE_AT_LINE (190)) ;
      }
    }
    const GGS_stringset  var_cas_constantSet = var_cas_constantMap.reader_allKeys (inLexique COMMA_SOURCE_FILE_AT_LINE (192)) ;
    GGS_enumMessageListForGeneration  var_cas_enumMessageList = GGS_enumMessageListForGeneration ::constructor_emptyList () ;
    GGS_stringset  var_cas_messageNameSet = GGS_stringset ::constructor_emptySet () ;
    {
      GGS_enumMessageListAST::cEnumerator enumerator_8989 (operand_8417->mEnumMessageList, true) ;
      const GGS_enumMessageListAST::cElement * operand_8989 = NULL ;
      while (((operand_8989 = enumerator_8989.nextObject ()))) {
        macroValidPointer (operand_8989) ;
        const GGS_bool cond_9150 = var_cas_messageNameSet.reader_hasKey (operand_8989->mEnumMessageName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (197))) ;
        if (cond_9150.isBuiltAndTrue ()) {
          operand_8989->mEnumMessageName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("this message is already declared for this enum type") COMMA_SOURCE_FILE_AT_LINE (199)) ;
        }
        var_cas_messageNameSet.addAssign_operation (operand_8989->mEnumMessageName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (200))) ;
        GGS_enumMessageAssociationSortedListForGeneration  var_cas_enumMessageAssociationSortedListForGeneration = GGS_enumMessageAssociationSortedListForGeneration ::constructor_emptySortedList () ;
        GGS_stringset  var_cas_usedConstantSet = GGS_stringset ::constructor_emptySet () ;
        {
          GGS_enumMessageAssociationListAST::cEnumerator enumerator_9440 (operand_8989->mMessageAssociationList, true) ;
          const GGS_enumMessageAssociationListAST::cElement * operand_9440 = NULL ;
          while (((operand_9440 = enumerator_9440.nextObject ()))) {
            macroValidPointer (operand_9440) ;
            GGS_uint  var_cas_constantIndex ;
            const GGS_constantIndexMap  temp_9500 = var_cas_constantMap ;
            if (temp_9500.isBuilt ()) {
              temp_9500 (HERE)->method_searchKey (inLexique, operand_9440->mConstantName, var_cas_constantIndex COMMA_SOURCE_FILE_AT_LINE (205)) ;
            }
            var_cas_usedConstantSet.addAssign_operation (operand_9440->mConstantName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (206))) ;
            var_cas_enumMessageAssociationSortedListForGeneration.addAssign_operation (var_cas_constantIndex, operand_9440->mConstantName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (209)), operand_9440->mMessage.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (210))) ;
          }
        }
        const GGS_stringset  var_cas_missedConstantSet = var_cas_constantSet.substract_operation (inLexique, var_cas_usedConstantSet COMMA_SOURCE_FILE_AT_LINE (213)) ;
        {
          GGS_stringset::cEnumerator enumerator_9851 (var_cas_missedConstantSet, true) ;
          while (enumerator_9851.hasCurrentObject ()) {
            operand_8989->mEnumMessageName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((GGS_string ("the '")).operator_concat (operand_8989->mEnumMessageName)).operator_concat (GGS_string ("' message definition does not name the '"))).operator_concat (enumerator_9851._key (HERE))).operator_concat (GGS_string ("' constant")) COMMA_SOURCE_FILE_AT_LINE (217)) ;
            enumerator_9851.next () ;
          }
        }
        var_cas_enumMessageList.addAssign_operation (operand_8989->mEnumMessageName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (218)), var_cas_enumMessageAssociationSortedListForGeneration) ;
      }
    }
    var_cas_ioSemanticDeclarationListForGeneration.addAssign_operation (GGS_enumTypeForGeneration ::constructor_new (inLexique, GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_8417->mEnumTypeName COMMA_SOURCE_FILE_AT_LINE (222)), var_cas_constantList, var_cas_enumMessageList COMMA_SOURCE_FILE_AT_LINE (221))) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//     Category method '@listmapDeclarationAST.performSemanticAnalysis'      *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__listmapDeclarationAST__performSemanticAnalysis (C_Compiler & inLexique,
                                const cPtr_listmapDeclarationAST * operand_10482,
                                const GGS_semanticContext  var_cas_inSemanticContext,
                                GGS_semanticDeclarationListForGeneration  & var_cas_ioSemanticDeclarationListForGeneration
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_10482 != NULL) {
    GGS_typeKindEnum var_cas_typeKindEnum ;
    GGS_typedAttributeList  var_cas_listTypeAttributeList ;
    GGS_bool automatic_var_10840_0 ;
    GGS_unifiedTypeMapProxy  automatic_var_10840_1 ;
    GGS_typedAttributeList  automatic_var_10840_2 ;
    GGS_constructorMap  automatic_var_10840_3 ;
    GGS_readerMap  automatic_var_10840_4 ;
    GGS_modifierMap  automatic_var_10840_5 ;
    GGS_instanceMethodMap  automatic_var_10840_6 ;
    GGS_classMethodMap  automatic_var_10840_7 ;
    GGS_enumerationDescriptorList  automatic_var_10840_8 ;
    GGS_uint  automatic_var_10840_9 ;
    GGS_unifiedTypeMapProxyList  automatic_var_10840_10 ;
    GGS_unifiedTypeMapProxyList  automatic_var_10840_11 ;
    GGS_nativeAttributeList  automatic_var_10840_12 ;
    GGS_lstringlist  automatic_var_10840_13 ;
    GGS_typedAttributeList  automatic_var_10840_14 ;
    GGS_mapMethodListAST  automatic_var_10840_15 ;
    GGS_mapMethodListAST  automatic_var_10840_16 ;
    const GGS_unifiedTypeMap  temp_10768 = var_cas_inSemanticContext.mTypeMap ;
    if (temp_10768.isBuilt ()) {
      temp_10768 (HERE)->method_searchKey (inLexique, operand_10482->mAssociatedListTypeName, automatic_var_10840_0, automatic_var_10840_1, var_cas_typeKindEnum, var_cas_listTypeAttributeList, automatic_var_10840_2, automatic_var_10840_3, automatic_var_10840_4, automatic_var_10840_5, automatic_var_10840_6, automatic_var_10840_7, automatic_var_10840_8, automatic_var_10840_9, automatic_var_10840_10, automatic_var_10840_11, automatic_var_10840_12, automatic_var_10840_13, automatic_var_10840_14, automatic_var_10840_15, automatic_var_10840_16 COMMA_SOURCE_FILE_AT_LINE (237)) ;
    }
    var_cas_ioSemanticDeclarationListForGeneration.addAssign_operation (GGS_listmapTypeForGeneration ::constructor_new (inLexique, GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_10482->mListmapTypeName COMMA_SOURCE_FILE_AT_LINE (240)), GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_10482->mAssociatedListTypeName COMMA_SOURCE_FILE_AT_LINE (241)), var_cas_listTypeAttributeList COMMA_SOURCE_FILE_AT_LINE (239))) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Category method '@genericTypeTypeAST.performSemanticAnalysis'        *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__genericTypeTypeAST__performSemanticAnalysis (C_Compiler & inLexique,
                                const cPtr_genericTypeTypeAST * operand_11286,
                                const GGS_semanticContext  var_cas_inSemanticContext,
                                GGS_semanticDeclarationListForGeneration  & var_cas_ioSemanticDeclarationListForGeneration
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_11286 != NULL) {
    var_cas_ioSemanticDeclarationListForGeneration.addAssign_operation (GGS_genericTypeForGeneration ::constructor_new (inLexique, GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, GGS_lstring ::constructor_new (inLexique, operand_11286->mTypeName, GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (253)) COMMA_SOURCE_FILE_AT_LINE (253)) COMMA_SOURCE_FILE_AT_LINE (252))) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map '@insertMethodMap'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_insertMethodMap ("insertMethodMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_insertMethodMap::
elementOf_GGS_insertMethodMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_insertMethodMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_insertMethodMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_insertMethodMap::
isEqualToMapElement (const AC_galgas_map_element * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_insertMethodMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_insertMethodMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_insertMethodMap * info = (e_insertMethodMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_insertMethodMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_insertMethodMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_insertMethodMap * info = (e_insertMethodMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_insertMethodMap GGS_insertMethodMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_insertMethodMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_insertMethodMap::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_insertMethodMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_insertMethodMap::
operator_isEqual (const GGS_insertMethodMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_insertMethodMap::
operator_isNotEqual (const GGS_insertMethodMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_insertMethodMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined) ;
}

//---------------------------------------------------------------------------*

void GGS_insertMethodMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_insertMethodMap info  ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_insertMethodMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_insertMethodMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('s'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('o'),
  TO_UNICODE ('d'),
  TO_UNICODE ('i'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_insertMethodMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_insertMethodMap GGS_insertMethodMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_insertMethodMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_insertMethodMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_insertMethodMap GGS_insertMethodMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_insertMethodMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_insertMethodMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @insertMethodMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_insertMethodMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_insertMethodMap * p = NULL ;
    macroMyNew (p, GGS_insertMethodMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_insertMethodMap GGS_insertMethodMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_insertMethodMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_insertMethodMap * p = dynamic_cast <const GGS_insertMethodMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_insertMethodMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_insertMethodMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_insertMethodMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map '@searchMethodMap'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_searchMethodMap ("searchMethodMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_searchMethodMap::
elementOf_GGS_searchMethodMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_searchMethodMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_searchMethodMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_searchMethodMap::
isEqualToMapElement (const AC_galgas_map_element * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_searchMethodMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_searchMethodMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_searchMethodMap * info = (e_searchMethodMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_searchMethodMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_searchMethodMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_searchMethodMap * info = (e_searchMethodMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_searchMethodMap GGS_searchMethodMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_searchMethodMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_searchMethodMap::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_searchMethodMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_searchMethodMap::
operator_isEqual (const GGS_searchMethodMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_searchMethodMap::
operator_isNotEqual (const GGS_searchMethodMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_searchMethodMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined) ;
}

//---------------------------------------------------------------------------*

void GGS_searchMethodMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_searchMethodMap info  ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_searchMethodMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_searchMethodMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('s'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('c'),
  TO_UNICODE ('h'),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('o'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_searchMethodMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_searchMethodMap GGS_searchMethodMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_searchMethodMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_searchMethodMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_searchMethodMap GGS_searchMethodMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_searchMethodMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_searchMethodMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @searchMethodMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_searchMethodMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_searchMethodMap * p = NULL ;
    macroMyNew (p, GGS_searchMethodMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_searchMethodMap GGS_searchMethodMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_searchMethodMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_searchMethodMap * p = dynamic_cast <const GGS_searchMethodMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_searchMethodMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_searchMethodMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_searchMethodMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//       Category method '@mapDeclarationAST.performSemanticAnalysis'        *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__mapDeclarationAST__performSemanticAnalysis (C_Compiler & inLexique,
                                const cPtr_mapDeclarationAST * operand_12114,
                                const GGS_semanticContext  var_cas_inSemanticContext,
                                GGS_semanticDeclarationListForGeneration  & var_cas_ioSemanticDeclarationListForGeneration
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_12114 != NULL) {
    GGS_typedAttributeList  var_cas_typedAttributeList = GGS_typedAttributeList ::constructor_emptyList () ;
    GGS_attributeIndexMap  var_cas_attributeIndexMap = GGS_attributeIndexMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (277)) ;
    {
      GGS_attributeInCollectionListAST::cEnumerator enumerator_12393 (operand_12114->mAttributeList, true) ;
      const GGS_attributeInCollectionListAST::cElement * operand_12393 = NULL ;
      while (((operand_12393 = enumerator_12393.nextObject ()))) {
        macroValidPointer (operand_12393) ;
        var_cas_typedAttributeList.addAssign_operation (GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_12393->mAttributeTypeName COMMA_SOURCE_FILE_AT_LINE (280)), operand_12393->mAttributeName) ;
        var_cas_attributeIndexMap.modifier_insertKey (inLexique, operand_12393->mAttributeName, var_cas_attributeIndexMap.reader_count () COMMA_SOURCE_FILE_AT_LINE (283)) ;
      }
    }
    GGS_insertMethodMap  var_cas_insertMethodMap = GGS_insertMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (286)) ;
    {
      GGS_insertMethodListAST::cEnumerator enumerator_12740 (operand_12114->mInsertMethodList, true) ;
      const GGS_insertMethodListAST::cElement * operand_12740 = NULL ;
      while (((operand_12740 = enumerator_12740.nextObject ()))) {
        macroValidPointer (operand_12740) ;
        var_cas_insertMethodMap.modifier_insertKey (inLexique, operand_12740->mMethodName COMMA_SOURCE_FILE_AT_LINE (288)) ;
        {
          GGS_stringlist::cEnumerator enumerator_12870 (operand_12740->mErrorMessage.ggs_string ().reader_componentsSeparatedByString (GGS_string ("%%")), true) ;
          const GGS_stringlist::cElement * operand_12870 = NULL ;
          while (((operand_12870 = enumerator_12870.nextObject ()))) {
            macroValidPointer (operand_12870) ;
            GGS_stringlist  var_cas_explodedArray = operand_12870->mValue.reader_componentsSeparatedByString (GGS_string ("%")) ;
            GGS_string automatic_var_13036_0 ;
            var_cas_explodedArray.modifier_popFirst (inLexique, automatic_var_13036_0 COMMA_SOURCE_FILE_AT_LINE (292)) ;
            {
              GGS_stringlist::cEnumerator enumerator_13066 (var_cas_explodedArray, true) ;
              const GGS_stringlist::cElement * operand_13066 = NULL ;
              while (((operand_13066 = enumerator_13066.nextObject ()))) {
                macroValidPointer (operand_13066) ;
                const GGS_bool cond_13354 = (operand_13066->mValue.reader_length ()).operator_strictSup (GGS_uint (0U)) ;
                if (cond_13354.isBuiltAndTrue ()) {
                  const GGS_char var_cas_c = operand_13066->mValue.reader_characterAtIndex (inLexique, GGS_uint (0U) COMMA_SOURCE_FILE_AT_LINE (295)) ;
                  const GGS_bool cond_13337 = ((var_cas_c).operator_isNotEqual (GGS_char (TO_UNICODE ('K')))).operator_and ((var_cas_c).operator_isNotEqual (GGS_char (TO_UNICODE ('L')))) ;
                  if (cond_13337.isBuiltAndTrue ()) {
                    operand_12740->mErrorMessage.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("only '%K', '%L' and '%%' escape sequences are allowed in an insert error message") COMMA_SOURCE_FILE_AT_LINE (298)) ;
                  }
                }
              }
            }
          }
        }
        {
          GGS_stringlist::cEnumerator enumerator_13482 (operand_12740->mShadowErrorMessage.ggs_string ().reader_componentsSeparatedByString (GGS_string ("%%")), true) ;
          const GGS_stringlist::cElement * operand_13482 = NULL ;
          while (((operand_13482 = enumerator_13482.nextObject ()))) {
            macroValidPointer (operand_13482) ;
            GGS_stringlist  var_cas_explodedArray = operand_13482->mValue.reader_componentsSeparatedByString (GGS_string ("%")) ;
            GGS_string automatic_var_13654_0 ;
            var_cas_explodedArray.modifier_popFirst (inLexique, automatic_var_13654_0 COMMA_SOURCE_FILE_AT_LINE (305)) ;
            {
              GGS_stringlist::cEnumerator enumerator_13684 (var_cas_explodedArray, true) ;
              const GGS_stringlist::cElement * operand_13684 = NULL ;
              while (((operand_13684 = enumerator_13684.nextObject ()))) {
                macroValidPointer (operand_13684) ;
                const GGS_bool cond_13971 = (operand_13684->mValue.reader_length ()).operator_strictSup (GGS_uint (0U)) ;
                if (cond_13971.isBuiltAndTrue ()) {
                  const GGS_char var_cas_c = operand_13684->mValue.reader_characterAtIndex (inLexique, GGS_uint (0U) COMMA_SOURCE_FILE_AT_LINE (308)) ;
                  const GGS_bool cond_13954 = ((var_cas_c).operator_isNotEqual (GGS_char (TO_UNICODE ('K')))).operator_and ((var_cas_c).operator_isNotEqual (GGS_char (TO_UNICODE ('L')))) ;
                  if (cond_13954.isBuiltAndTrue ()) {
                    operand_12740->mErrorMessage.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("only '%K', '%L' and '%%' escape sequences are allowed in a shadow error message") COMMA_SOURCE_FILE_AT_LINE (311)) ;
                  }
                }
              }
            }
          }
        }
      }
    }
    GGS_searchMethodMap  var_cas_searchMethodMap = GGS_searchMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (317)) ;
    {
      GGS_mapMethodListAST::cEnumerator enumerator_14132 (operand_12114->mSearchMethodList, true) ;
      const GGS_mapMethodListAST::cElement * operand_14132 = NULL ;
      while (((operand_14132 = enumerator_14132.nextObject ()))) {
        macroValidPointer (operand_14132) ;
        var_cas_searchMethodMap.modifier_insertKey (inLexique, operand_14132->mMethodName COMMA_SOURCE_FILE_AT_LINE (319)) ;
        {
          GGS_stringlist::cEnumerator enumerator_14258 (operand_14132->mErrorMessage.ggs_string ().reader_componentsSeparatedByString (GGS_string ("%%")), true) ;
          const GGS_stringlist::cElement * operand_14258 = NULL ;
          while (((operand_14258 = enumerator_14258.nextObject ()))) {
            macroValidPointer (operand_14258) ;
            GGS_stringlist  var_cas_explodedArray = operand_14258->mValue.reader_componentsSeparatedByString (GGS_string ("%")) ;
            GGS_string automatic_var_14424_0 ;
            var_cas_explodedArray.modifier_popFirst (inLexique, automatic_var_14424_0 COMMA_SOURCE_FILE_AT_LINE (323)) ;
            {
              GGS_stringlist::cEnumerator enumerator_14454 (var_cas_explodedArray, true) ;
              const GGS_stringlist::cElement * operand_14454 = NULL ;
              while (((operand_14454 = enumerator_14454.nextObject ()))) {
                macroValidPointer (operand_14454) ;
                const GGS_bool cond_14720 = (operand_14454->mValue.reader_length ()).operator_strictSup (GGS_uint (0U)) ;
                if (cond_14720.isBuiltAndTrue ()) {
                  const GGS_char var_cas_c = operand_14454->mValue.reader_characterAtIndex (inLexique, GGS_uint (0U) COMMA_SOURCE_FILE_AT_LINE (326)) ;
                  const GGS_bool cond_14703 = (var_cas_c).operator_isNotEqual (GGS_char (TO_UNICODE ('K'))) ;
                  if (cond_14703.isBuiltAndTrue ()) {
                    operand_14132->mErrorMessage.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("only '%K' and '%%' escape sequences are allowed in a search error message") COMMA_SOURCE_FILE_AT_LINE (329)) ;
                  }
                }
              }
            }
          }
        }
      }
    }
    {
      GGS_mapMethodListAST::cEnumerator enumerator_14833 (operand_12114->mRemoveMethodList, true) ;
      const GGS_mapMethodListAST::cElement * operand_14833 = NULL ;
      while (((operand_14833 = enumerator_14833.nextObject ()))) {
        macroValidPointer (operand_14833) ;
        var_cas_insertMethodMap.modifier_insertKey (inLexique, operand_14833->mMethodName COMMA_SOURCE_FILE_AT_LINE (336)) ;
        {
          GGS_stringlist::cEnumerator enumerator_14959 (operand_14833->mErrorMessage.ggs_string ().reader_componentsSeparatedByString (GGS_string ("%%")), true) ;
          const GGS_stringlist::cElement * operand_14959 = NULL ;
          while (((operand_14959 = enumerator_14959.nextObject ()))) {
            macroValidPointer (operand_14959) ;
            GGS_stringlist  var_cas_explodedArray = operand_14959->mValue.reader_componentsSeparatedByString (GGS_string ("%")) ;
            GGS_string automatic_var_15125_0 ;
            var_cas_explodedArray.modifier_popFirst (inLexique, automatic_var_15125_0 COMMA_SOURCE_FILE_AT_LINE (340)) ;
            {
              GGS_stringlist::cEnumerator enumerator_15155 (var_cas_explodedArray, true) ;
              const GGS_stringlist::cElement * operand_15155 = NULL ;
              while (((operand_15155 = enumerator_15155.nextObject ()))) {
                macroValidPointer (operand_15155) ;
                const GGS_bool cond_15421 = (operand_15155->mValue.reader_length ()).operator_strictSup (GGS_uint (0U)) ;
                if (cond_15421.isBuiltAndTrue ()) {
                  const GGS_char var_cas_c = operand_15155->mValue.reader_characterAtIndex (inLexique, GGS_uint (0U) COMMA_SOURCE_FILE_AT_LINE (343)) ;
                  const GGS_bool cond_15404 = (var_cas_c).operator_isNotEqual (GGS_char (TO_UNICODE ('K'))) ;
                  if (cond_15404.isBuiltAndTrue ()) {
                    operand_14833->mErrorMessage.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("only '%K' and '%%' escape sequences are allowed in a remove error message") COMMA_SOURCE_FILE_AT_LINE (346)) ;
                  }
                }
              }
            }
          }
        }
      }
    }
    {
        GGS_uint var_cas_IDX (true, 0) ;
      GGS_insertOrReplaceDeclarationListAST::cEnumerator enumerator_15593 (operand_12114->mInsertOrReplaceDeclarationListAST, true) ;
      const GGS_insertOrReplaceDeclarationListAST::cElement * operand_15593 = NULL ;
      while (((operand_15593 = enumerator_15593.nextObject ()))) {
        macroValidPointer (operand_15593) ;
        const GGS_bool cond_15740 = (var_cas_IDX).operator_strictSup (GGS_uint (0U)) ;
        if (cond_15740.isBuiltAndTrue ()) {
          operand_15593->mInsertOrReplaceDeclarationLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticWarning (inLexique, GGS_string ("the 'insertOrReplace' modifier is already declared") COMMA_SOURCE_FILE_AT_LINE (354)) ;
        }
        var_cas_IDX.mValue ++ ;
      }
    }
    const GGS_bool var_cas_hasInsertOrReplaceModifier = (operand_12114->mInsertOrReplaceDeclarationListAST.reader_length ()).operator_strictSup (GGS_uint (0U)) ;
    const GGS_bool cond_16255 = (var_cas_hasInsertOrReplaceModifier).operator_and (var_cas_insertMethodMap.reader_hasKey (GGS_string ("insertOrReplace"))) ;
    if (cond_16255.isBuiltAndTrue ()) {
      GGS_location  var_cas_insertOrReplaceDeclarationLocation ;
      const GGS_insertOrReplaceDeclarationListAST  temp_16035 = operand_12114->mInsertOrReplaceDeclarationListAST ;
      if (temp_16035.isBuilt ()) {
        temp_16035 (HERE)->method_first (inLexique, var_cas_insertOrReplaceDeclarationLocation COMMA_SOURCE_FILE_AT_LINE (360)) ;
      }
      var_cas_insertOrReplaceDeclarationLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("the insertOrReplace' modifier cannot be declared : an insert modifier or a remove modifier has been declared with this name") COMMA_SOURCE_FILE_AT_LINE (362)) ;
    }
    var_cas_ioSemanticDeclarationListForGeneration.addAssign_operation (GGS_mapTypeForGeneration ::constructor_new (inLexique, GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_12114->mMapTypeName COMMA_SOURCE_FILE_AT_LINE (365)), operand_12114->mMapTypeName, var_cas_typedAttributeList, operand_12114->mInsertMethodList, operand_12114->mSearchMethodList, operand_12114->mRemoveMethodList, var_cas_hasInsertOrReplaceModifier COMMA_SOURCE_FILE_AT_LINE (364))) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//    Category method '@mapProxyDeclarationAST.performSemanticAnalysis'      *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__mapProxyDeclarationAST__performSemanticAnalysis (C_Compiler & inLexique,
                                const cPtr_mapProxyDeclarationAST * operand_16746,
                                const GGS_semanticContext  var_cas_inSemanticContext,
                                GGS_semanticDeclarationListForGeneration  & var_cas_ioSemanticDeclarationListForGeneration
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_16746 != NULL) {
    GGS_typedAttributeList  var_cas_listTypeAttributeList ;
    GGS_mapMethodListAST  var_cas_searchMethodList ;
    GGS_bool automatic_var_17114_0 ;
    GGS_unifiedTypeMapProxy  automatic_var_17114_1 ;
    GGS_typeKindEnum automatic_var_17114_2 ;
    GGS_typedAttributeList  automatic_var_17114_3 ;
    GGS_constructorMap  automatic_var_17114_4 ;
    GGS_readerMap  automatic_var_17114_5 ;
    GGS_modifierMap  automatic_var_17114_6 ;
    GGS_instanceMethodMap  automatic_var_17114_7 ;
    GGS_classMethodMap  automatic_var_17114_8 ;
    GGS_enumerationDescriptorList  automatic_var_17114_9 ;
    GGS_uint  automatic_var_17114_10 ;
    GGS_unifiedTypeMapProxyList  automatic_var_17114_11 ;
    GGS_unifiedTypeMapProxyList  automatic_var_17114_12 ;
    GGS_nativeAttributeList  automatic_var_17114_13 ;
    GGS_lstringlist  automatic_var_17114_14 ;
    GGS_typedAttributeList  automatic_var_17114_15 ;
    GGS_mapMethodListAST  automatic_var_17114_16 ;
    const GGS_unifiedTypeMap  temp_17036 = var_cas_inSemanticContext.mTypeMap ;
    if (temp_17036.isBuilt ()) {
      temp_17036 (HERE)->method_searchKey (inLexique, operand_16746->mAssociatedMapTypeName, automatic_var_17114_0, automatic_var_17114_1, automatic_var_17114_2, automatic_var_17114_3, var_cas_listTypeAttributeList, automatic_var_17114_4, automatic_var_17114_5, automatic_var_17114_6, automatic_var_17114_7, automatic_var_17114_8, automatic_var_17114_9, automatic_var_17114_10, automatic_var_17114_11, automatic_var_17114_12, automatic_var_17114_13, automatic_var_17114_14, automatic_var_17114_15, var_cas_searchMethodList, automatic_var_17114_16 COMMA_SOURCE_FILE_AT_LINE (384)) ;
    }
    var_cas_ioSemanticDeclarationListForGeneration.addAssign_operation (GGS_mapProxyTypeForGeneration ::constructor_new (inLexique, GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_16746->mMapProxyTypeName COMMA_SOURCE_FILE_AT_LINE (387)), GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_16746->mAssociatedMapTypeName COMMA_SOURCE_FILE_AT_LINE (388)), var_cas_listTypeAttributeList, var_cas_searchMethodList COMMA_SOURCE_FILE_AT_LINE (386))) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Category method '@classDeclarationAST.performSemanticAnalysis'       *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__classDeclarationAST__performSemanticAnalysis (C_Compiler & inLexique,
                                const cPtr_classDeclarationAST * operand_17584,
                                const GGS_semanticContext  var_cas_inSemanticContext,
                                GGS_semanticDeclarationListForGeneration  & var_cas_ioSemanticDeclarationListForGeneration
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_17584 != NULL) {
    GGS_typedAttributeList  var_cas_typedAttributeList = GGS_typedAttributeList ::constructor_emptyList () ;
    GGS_attributeIndexMap  var_cas_attributeIndexMap = GGS_attributeIndexMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (402)) ;
    {
      GGS_attributeInCollectionListAST::cEnumerator enumerator_17863 (operand_17584->mAttributeList, true) ;
      const GGS_attributeInCollectionListAST::cElement * operand_17863 = NULL ;
      while (((operand_17863 = enumerator_17863.nextObject ()))) {
        macroValidPointer (operand_17863) ;
        var_cas_typedAttributeList.addAssign_operation (GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_17863->mAttributeTypeName COMMA_SOURCE_FILE_AT_LINE (405)), operand_17863->mAttributeName) ;
        var_cas_attributeIndexMap.modifier_insertKey (inLexique, operand_17863->mAttributeName, var_cas_attributeIndexMap.reader_count () COMMA_SOURCE_FILE_AT_LINE (408)) ;
      }
    }
    GGS_instanceMethodMap  var_cas_inheritedInstanceMethodMap ;
    const GGS_bool cond_18305 = (operand_17584->mSuperClassName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (412))).operator_isEqual (GGS_string ("")) ;
    if (cond_18305.isBuiltAndTrue ()) {
      var_cas_inheritedInstanceMethodMap = GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (413)) ;
    }else if (cond_18305.isBuiltAndFalse ()) {
      GGS_bool automatic_var_18403_0 ;
      GGS_unifiedTypeMapProxy  automatic_var_18403_1 ;
      GGS_typeKindEnum automatic_var_18403_2 ;
      GGS_typedAttributeList  automatic_var_18403_3 ;
      GGS_typedAttributeList  automatic_var_18403_4 ;
      GGS_constructorMap  automatic_var_18403_5 ;
      GGS_readerMap  automatic_var_18403_6 ;
      GGS_modifierMap  automatic_var_18403_7 ;
      GGS_classMethodMap  automatic_var_18403_8 ;
      GGS_enumerationDescriptorList  automatic_var_18403_9 ;
      GGS_uint  automatic_var_18403_10 ;
      GGS_unifiedTypeMapProxyList  automatic_var_18403_11 ;
      GGS_unifiedTypeMapProxyList  automatic_var_18403_12 ;
      GGS_nativeAttributeList  automatic_var_18403_13 ;
      GGS_lstringlist  automatic_var_18403_14 ;
      GGS_typedAttributeList  automatic_var_18403_15 ;
      GGS_mapMethodListAST  automatic_var_18403_16 ;
      GGS_mapMethodListAST  automatic_var_18403_17 ;
      const GGS_unifiedTypeMap  temp_18348 = var_cas_inSemanticContext.mTypeMap ;
      if (temp_18348.isBuilt ()) {
        temp_18348 (HERE)->method_searchKey (inLexique, operand_17584->mSuperClassName, automatic_var_18403_0, automatic_var_18403_1, automatic_var_18403_2, automatic_var_18403_3, automatic_var_18403_4, automatic_var_18403_5, automatic_var_18403_6, automatic_var_18403_7, var_cas_inheritedInstanceMethodMap, automatic_var_18403_8, automatic_var_18403_9, automatic_var_18403_10, automatic_var_18403_11, automatic_var_18403_12, automatic_var_18403_13, automatic_var_18403_14, automatic_var_18403_15, automatic_var_18403_16, automatic_var_18403_17 COMMA_SOURCE_FILE_AT_LINE (415)) ;
      }
    }
    GGS_unifiedTypeMapProxy  var_cas_superClassIndex ;
    const GGS_bool cond_18642 = (operand_17584->mSuperClassName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (419))).operator_isEqual (GGS_string ("")) ;
    if (cond_18642.isBuiltAndTrue ()) {
      var_cas_superClassIndex = GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, GGS_lstring ::constructor_new (inLexique, GGS_string ("class"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (420)) COMMA_SOURCE_FILE_AT_LINE (420)) ;
    }else if (cond_18642.isBuiltAndFalse ()) {
      var_cas_superClassIndex = GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_17584->mSuperClassName COMMA_SOURCE_FILE_AT_LINE (422)) ;
    }
    GGS_abstractMethodDefinitionListForGeneration  var_cas_abstractMethodList = GGS_abstractMethodDefinitionListForGeneration ::constructor_emptyList () ;
    {
      GGS_abstractMethodDefinitionListAST::cEnumerator enumerator_18890 (operand_17584->mAbstractMethodList, true) ;
      const GGS_abstractMethodDefinitionListAST::cElement * operand_18890 = NULL ;
      while (((operand_18890 = enumerator_18890.nextObject ()))) {
        macroValidPointer (operand_18890) ;
        const GGS_bool cond_19076 = (operand_17584->mIsAbstract).operator_not () ;
        if (cond_19076.isBuiltAndTrue ()) {
          operand_18890->mMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("a concrete class cannot declare an abstract method") COMMA_SOURCE_FILE_AT_LINE (430)) ;
        }
        GGS_formalParameterListForGeneration  var_cas_formalParameterListForGeneration = GGS_formalParameterListForGeneration ::constructor_emptyList () ;
        {
          GGS_formalParameterListAST::cEnumerator enumerator_19221 (operand_18890->mSignature, true) ;
          const GGS_formalParameterListAST::cElement * operand_19221 = NULL ;
          while (((operand_19221 = enumerator_19221.nextObject ()))) {
            macroValidPointer (operand_19221) ;
            var_cas_formalParameterListForGeneration.addAssign_operation (operand_19221->mFormalParameterPassingMode, GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_19221->mFormalParameterTypeName COMMA_SOURCE_FILE_AT_LINE (436)), operand_19221->mFormalParameterName, operand_19221->mIsUnused) ;
          }
        }
        const GGS_bool cond_19940 = operand_18890->mIsOverriding ;
        if (cond_19940.isBuiltAndTrue ()) {
          GGS_formalParameterSignature  var_cas_inheritedSignature ;
          GGS_location  var_cas_inheritedDeclarationLocation ;
          GGS_bool automatic_var_19752_0 ;
          const GGS_instanceMethodMap  temp_19685 = var_cas_inheritedInstanceMethodMap ;
          if (temp_19685.isBuilt ()) {
            temp_19685 (HERE)->method_searchInheritedKey (inLexique, operand_18890->mMethodName, var_cas_inheritedSignature, var_cas_inheritedDeclarationLocation, automatic_var_19752_0 COMMA_SOURCE_FILE_AT_LINE (445)) ;
          }
          ::routine_checkMethodSignatures (inLexique,  var_cas_formalParameterListForGeneration,  operand_18890->mMethodName.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (448)),  var_cas_inheritedSignature,  var_cas_inheritedDeclarationLocation COMMA_SOURCE_FILE_AT_LINE (446)) ;
        }else if (cond_19940.isBuiltAndFalse ()) {
          const GGS_bool cond_20123 = var_cas_inheritedInstanceMethodMap.reader_hasKey (operand_18890->mMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (452))) ;
          if (cond_20123.isBuiltAndTrue ()) {
            operand_18890->mMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("this method cannot be declared as abstract, it is already declared in super class") COMMA_SOURCE_FILE_AT_LINE (454)) ;
          }
        }
        var_cas_abstractMethodList.addAssign_operation (operand_18890->mIsOverriding, operand_18890->mMethodName, var_cas_formalParameterListForGeneration) ;
      }
    }
    GGS_methodDefinitionListForGeneration  var_cas_methodList = GGS_methodDefinitionListForGeneration ::constructor_emptyList () ;
    {
      GGS_methodDefinitionListAST::cEnumerator enumerator_20339 (operand_17584->mMethodList, true) ;
      const GGS_methodDefinitionListAST::cElement * operand_20339 = NULL ;
      while (((operand_20339 = enumerator_20339.nextObject ()))) {
        macroValidPointer (operand_20339) ;
        GGS_formalParameterListForGeneration  var_cas_formalParameterListForGeneration = GGS_formalParameterListForGeneration ::constructor_emptyList () ;
        {
          GGS_formalParameterListAST::cEnumerator enumerator_20482 (operand_20339->mSignature, true) ;
          const GGS_formalParameterListAST::cElement * operand_20482 = NULL ;
          while (((operand_20482 = enumerator_20482.nextObject ()))) {
            macroValidPointer (operand_20482) ;
            var_cas_formalParameterListForGeneration.addAssign_operation (operand_20482->mFormalParameterPassingMode, GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_20482->mFormalParameterTypeName COMMA_SOURCE_FILE_AT_LINE (465)), operand_20482->mFormalParameterName, operand_20482->mIsUnused) ;
          }
        }
        const GGS_bool cond_21201 = operand_20339->mIsOverriding ;
        if (cond_21201.isBuiltAndTrue ()) {
          GGS_formalParameterSignature  var_cas_inheritedSignature ;
          GGS_location  var_cas_inheritedDeclarationLocation ;
          GGS_bool automatic_var_21013_0 ;
          const GGS_instanceMethodMap  temp_20946 = var_cas_inheritedInstanceMethodMap ;
          if (temp_20946.isBuilt ()) {
            temp_20946 (HERE)->method_searchInheritedKey (inLexique, operand_20339->mMethodName, var_cas_inheritedSignature, var_cas_inheritedDeclarationLocation, automatic_var_21013_0 COMMA_SOURCE_FILE_AT_LINE (474)) ;
          }
          ::routine_checkMethodSignatures (inLexique,  var_cas_formalParameterListForGeneration,  operand_20339->mMethodName.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (477)),  var_cas_inheritedSignature,  var_cas_inheritedDeclarationLocation COMMA_SOURCE_FILE_AT_LINE (475)) ;
        }else if (cond_21201.isBuiltAndFalse ()) {
          const GGS_bool cond_21384 = var_cas_inheritedInstanceMethodMap.reader_hasKey (operand_20339->mMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (481))) ;
          if (cond_21384.isBuiltAndTrue ()) {
            operand_20339->mMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("this method cannot be declared as abstract, it is already declared in super class") COMMA_SOURCE_FILE_AT_LINE (483)) ;
          }
        }
        var_cas_methodList.addAssign_operation (operand_20339->mIsOverriding, operand_20339->mMethodName, var_cas_formalParameterListForGeneration, GGS_semanticInstructionListForGeneration ::constructor_emptyList ()) ;
      }
    }
    var_cas_ioSemanticDeclarationListForGeneration.addAssign_operation (GGS_classTypeForGeneration ::constructor_new (inLexique, GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_17584->mClassTypeName COMMA_SOURCE_FILE_AT_LINE (493)), operand_17584->mIsAbstract, operand_17584->mClassTypeName, var_cas_superClassIndex, var_cas_typedAttributeList, var_cas_abstractMethodList, var_cas_methodList COMMA_SOURCE_FILE_AT_LINE (492))) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Implementation of routine "performSemanticAnalysis"             *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_performSemanticAnalysis (C_Compiler & inLexique,
                                const GGS_semanticDeclarationListAST   var_cas_inDeclarationList,
                                const GGS_semanticContext  var_cas_inSemanticContext,
                                GGS_semanticDeclarationListForGeneration  & var_cas_outDecoratedDeclarationListForGeneration COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_performSemanticAnalysis at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  var_cas_outDecoratedDeclarationListForGeneration = GGS_semanticDeclarationListForGeneration ::constructor_emptyList () ;
  {
    GGS_semanticDeclarationListAST::cEnumerator enumerator_22598 (var_cas_inDeclarationList, true) ;
    const GGS_semanticDeclarationListAST::cElement * operand_22598 = NULL ;
    while (((operand_22598 = enumerator_22598.nextObject ()))) {
      macroValidPointer (operand_22598) ;
      const GGS_semanticDeclarationAST  temp_22651 = operand_22598->mSemanticDeclaration ;
      if (temp_22651.isBuilt ()) {
        typeCategoryMethod__semanticDeclarationAST__performSemanticAnalysis method = findCategoryMethod__semanticDeclarationAST__performSemanticAnalysis (temp_22651.galgasObjectRunTimeInfo ()) ;
        if (method != NULL) {
          method (inLexique, temp_22651 (HERE), var_cas_inSemanticContext, var_cas_outDecoratedDeclarationListForGeneration COMMA_SOURCE_FILE_AT_LINE (517)) ;
        }
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_performSemanticAnalysis\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      Prologue and epilogue actions                        *
//                                                                           *
//---------------------------------------------------------------------------*

static void prologueRoutineFor_semanticAnalysis (void) {
  enterCategoryMethod__semanticDeclarationAST__performSemanticAnalysis (category_method__semanticDeclarationAST__performSemanticAnalysis, gClassInfoFor__semanticDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__performSemanticAnalysis ((typeCategoryMethod__semanticDeclarationAST__performSemanticAnalysis) category_method__predefinedTypeAST__performSemanticAnalysis, gClassInfoFor__predefinedTypeAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__performSemanticAnalysis ((typeCategoryMethod__semanticDeclarationAST__performSemanticAnalysis) category_method__listDeclarationAST__performSemanticAnalysis, gClassInfoFor__listDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__performSemanticAnalysis ((typeCategoryMethod__semanticDeclarationAST__performSemanticAnalysis) category_method__sortedListDeclarationAST__performSemanticAnalysis, gClassInfoFor__sortedListDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__performSemanticAnalysis ((typeCategoryMethod__semanticDeclarationAST__performSemanticAnalysis) category_method__structDeclarationAST__performSemanticAnalysis, gClassInfoFor__structDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__performSemanticAnalysis ((typeCategoryMethod__semanticDeclarationAST__performSemanticAnalysis) category_method__enumDeclarationAST__performSemanticAnalysis, gClassInfoFor__enumDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__performSemanticAnalysis ((typeCategoryMethod__semanticDeclarationAST__performSemanticAnalysis) category_method__listmapDeclarationAST__performSemanticAnalysis, gClassInfoFor__listmapDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__performSemanticAnalysis ((typeCategoryMethod__semanticDeclarationAST__performSemanticAnalysis) category_method__genericTypeTypeAST__performSemanticAnalysis, gClassInfoFor__genericTypeTypeAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__performSemanticAnalysis ((typeCategoryMethod__semanticDeclarationAST__performSemanticAnalysis) category_method__mapDeclarationAST__performSemanticAnalysis, gClassInfoFor__mapDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__performSemanticAnalysis ((typeCategoryMethod__semanticDeclarationAST__performSemanticAnalysis) category_method__mapProxyDeclarationAST__performSemanticAnalysis, gClassInfoFor__mapProxyDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__performSemanticAnalysis ((typeCategoryMethod__semanticDeclarationAST__performSemanticAnalysis) category_method__classDeclarationAST__performSemanticAnalysis, gClassInfoFor__classDeclarationAST.slotID ()) ;
}

//---------------------------------------------------------------------------*

static void epilogueRoutineFor_semanticAnalysis (void) {
  gDispatchTableForMethod__semanticDeclarationAST__performSemanticAnalysis.free () ;
}

//---------------------------------------------------------------------------*

C_PrologueEpilogue prologueEpilogueObjectFor_semanticAnalysis (prologueRoutineFor_semanticAnalysis, epilogueRoutineFor_semanticAnalysis) ;

//---------------------------------------------------------------------------*

