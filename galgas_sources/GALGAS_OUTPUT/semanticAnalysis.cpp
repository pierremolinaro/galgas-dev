//---------------------------------------------------------------------------*
//                                                                           *
//                       File 'semanticAnalysis.cpp'                         *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                     october 24th, 2010, at 21h21'4"                       *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if CURRENT_LIBPM_VERSION != VERSION_OF_LIBPM_USED_BY_GALGAS_COMPILER
  #error "This file has been compiled with a version of GALGAS that uses libpm version VERSION_OF_LIBPM_USED_BY_GALGAS_COMPILER, different than the current version (CURRENT_LIBPM_VERSION) of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "galgas/C_galgas_CLI_Options.h"
#include "semanticAnalysis.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "semanticAnalysis.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//             Include directives generated by grammar includes              *
//                                                                           *
//---------------------------------------------------------------------------*

#include "templateGrammar.h"

//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//            Implementation of routine "checkMethodSignatures"              *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_checkMethodSignatures (C_Compiler & inLexique,
                                const GGS_formalParameterListForGeneration   var_cas_inTestedSignature,
                                const GGS_location   var_cas_inErrorLocation,
                                const GGS_formalParameterSignature   var_cas_inReferenceSignature,
                                const GGS_location   var_cas_inReferenceLocation
                        COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_checkMethodSignatures at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  const GGS_bool cond_2697 = (var_cas_inTestedSignature.reader_length ()).operator_isNotEqual (var_cas_inReferenceSignature.reader_length ()) ;
  if (cond_2697.isBuiltAndTrue ()) {
    var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, (((GGS_string ("this method declares ")).operator_concat (var_cas_inTestedSignature.reader_length ().reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (41)))).operator_concat (GGS_string (" formal parameter(s), but overriden method declares "))).operator_concat (var_cas_inReferenceSignature.reader_length ().reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (42))) COMMA_SOURCE_FILE_AT_LINE (44)) ;
    var_cas_inReferenceLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("overriden method is declared here") COMMA_SOURCE_FILE_AT_LINE (45)) ;
  }else if (cond_2697.isBuiltAndFalse ()) {
    {
      GGS_formalParameterSignature::cEnumerator enumerator_2730 (var_cas_inReferenceSignature, true) ;
      const GGS_formalParameterSignature::cElement * operand_2730 = NULL ;
      GGS_formalParameterListForGeneration::cEnumerator enumerator_2765 (var_cas_inTestedSignature, true) ;
      const GGS_formalParameterListForGeneration::cElement * operand_2765 = NULL ;
      while (((operand_2730 = enumerator_2730.nextObject ()))
          && ((operand_2765 = enumerator_2765.nextObject ()))) {
        macroValidPointer (operand_2730) ;
        macroValidPointer (operand_2765) ;
        const GGS_bool cond_3202 = (operand_2730->mFormalArgumentPassingMode).operator_isNotEqual (operand_2765->mFormalArgumentPassingMode) ;
        if (cond_3202.isBuiltAndTrue ()) {
          operand_2765->mFormalArgumentName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, (((((GGS_string ("the '")).operator_concat (operand_2765->mFormalArgumentName)).operator_concat (GGS_string ("' formal parameter is declared as "))).operator_concat (operand_2765->mFormalArgumentPassingMode.reader_formalArgumentMessage (inLexique COMMA_SOURCE_FILE_AT_LINE (49)))).operator_concat (GGS_string (", but overriden method declares it as "))).operator_concat (operand_2730->mFormalArgumentPassingMode.reader_formalArgumentMessage (inLexique COMMA_SOURCE_FILE_AT_LINE (50))) COMMA_SOURCE_FILE_AT_LINE (51)) ;
          var_cas_inReferenceLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("overriden method is declared here") COMMA_SOURCE_FILE_AT_LINE (52)) ;
        }
        const GGS_bool cond_3606 = (operand_2765->mFormalArgumentType.reader_key (inLexique COMMA_SOURCE_FILE_AT_LINE (53))).operator_isNotEqual (operand_2730->mFormalArgumentType.reader_key (inLexique COMMA_SOURCE_FILE_AT_LINE (53))) ;
        if (cond_3606.isBuiltAndTrue ()) {
          operand_2765->mFormalArgumentName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((((GGS_string ("the '")).operator_concat (operand_2765->mFormalArgumentName)).operator_concat (GGS_string ("' formal parameter has the '@"))).operator_concat (operand_2765->mFormalArgumentType.reader_key (inLexique COMMA_SOURCE_FILE_AT_LINE (55)))).operator_concat (GGS_string ("' type, but overriden method declares with the '@"))).operator_concat (operand_2730->mFormalArgumentType.reader_key (inLexique COMMA_SOURCE_FILE_AT_LINE (56)))).operator_concat (GGS_string ("' type")) COMMA_SOURCE_FILE_AT_LINE (57)) ;
          var_cas_inReferenceLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("overriden method is declared here") COMMA_SOURCE_FILE_AT_LINE (58)) ;
        }
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_checkMethodSignatures\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//    Category method '@semanticDeclarationAST.performSemanticAnalysis'      *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__semanticDeclarationAST__performSemanticAnalysis (C_Compiler &,
                                const cPtr_semanticDeclarationAST * operand_4101,
                                const GGS_semanticContext  /* var_cas_inSemanticContext */,
                                const GGS_predefinedTypes  /* var_cas_inPredefinedTypes */,
                                GGS_semanticDeclarationSortedListForGeneration  & /* var_cas_ioSemanticDeclarationListForGeneration */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_4101 != NULL) {
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//Virtual Table for category method '@semanticDeclarationAST.performSemanticAnalysis'*
//                                                                           *
//---------------------------------------------------------------------------*

static TC_UniqueArray <typeCategoryMethod__semanticDeclarationAST__performSemanticAnalysis> gDispatchTableForMethod__semanticDeclarationAST__performSemanticAnalysis ;

//---------------------------------------------------------------------------*

void
enterCategoryMethod__semanticDeclarationAST__performSemanticAnalysis (typeCategoryMethod__semanticDeclarationAST__performSemanticAnalysis inRoutine,
                     const PMSInt32 inClassID) {
  gDispatchTableForMethod__semanticDeclarationAST__performSemanticAnalysis.forceObjectAtIndex (inClassID, inRoutine, NULL COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

typeCategoryMethod__semanticDeclarationAST__performSemanticAnalysis
findCategoryMethod__semanticDeclarationAST__performSemanticAnalysis (AC_galgasClassRunTimeInformationEX * inClassPtr) {
  typeCategoryMethod__semanticDeclarationAST__performSemanticAnalysis result = NULL ;
  if (inClassPtr->slotID () < gDispatchTableForMethod__semanticDeclarationAST__performSemanticAnalysis.count ()) {
    result = gDispatchTableForMethod__semanticDeclarationAST__performSemanticAnalysis (inClassPtr->slotID () COMMA_HERE) ;
  }
  if (NULL == result) {
    AC_galgasClassRunTimeInformationEX * superClassPtr = inClassPtr->superClassPtr () ;
    if (superClassPtr != NULL) {
      result = findCategoryMethod__semanticDeclarationAST__performSemanticAnalysis (superClassPtr) ;
      gDispatchTableForMethod__semanticDeclarationAST__performSemanticAnalysis.forceObjectAtIndex (inClassPtr->slotID (), result, NULL COMMA_HERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//       Category method '@predefinedTypeAST.performSemanticAnalysis'        *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__predefinedTypeAST__performSemanticAnalysis (C_Compiler & inLexique,
                                const cPtr_predefinedTypeAST * operand_4441,
                                const GGS_semanticContext  var_cas_inSemanticContext,
                                const GGS_predefinedTypes  /* var_cas_inPredefinedTypes */,
                                GGS_semanticDeclarationSortedListForGeneration  & var_cas_ioSemanticDeclarationListForGeneration
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_4441 != NULL) {
    var_cas_ioSemanticDeclarationListForGeneration.addAssign_operation (GGS_primitiveTypeForGeneration ::constructor_new (inLexique, GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, GGS_lstring ::constructor_new (inLexique, operand_4441->mPredefinedTypeName, GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (84)) COMMA_SOURCE_FILE_AT_LINE (84)), operand_4441->mPredefinedTypeName, operand_4441->mKind COMMA_SOURCE_FILE_AT_LINE (83)), GGS_string ("")) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'e_attributeIndexMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

e_attributeIndexMap::e_attributeIndexMap (void) :
mAttributeTypeIndex () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class map '@attributeIndexMap'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_attributeIndexMap ("attributeIndexMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_attributeIndexMap::
elementOf_GGS_attributeIndexMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_attributeIndexMap & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_attributeIndexMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mAttributeTypeIndex.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_attributeIndexMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_attributeIndexMap * ptr = dynamic_cast <const elementOf_GGS_attributeIndexMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mAttributeTypeIndex.operator_isEqual (ptr->mInfo.mAttributeTypeIndex)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_attributeIndexMap::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_attributeIndexMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_attributeIndexMap * info = (e_attributeIndexMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_attributeIndexMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_attributeIndexMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_attributeIndexMap * info = (e_attributeIndexMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_attributeIndexMap GGS_attributeIndexMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_attributeIndexMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_attributeIndexMap::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_attributeIndexMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_attributeIndexMap::
operator_isEqual (const GGS_attributeIndexMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_attributeIndexMap::
operator_isNotEqual (const GGS_attributeIndexMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_attributeIndexMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_attributeIndexMap::
insertElement (C_Compiler & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_unifiedTypeMapProxy & inParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap (THERE) ;
    e_attributeIndexMap info  ;
    info.mAttributeTypeIndex = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_attributeIndexMap::
searchElement (C_Compiler & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_unifiedTypeMapProxy   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    outParameter0 = node->mInfo.mAttributeTypeIndex ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_attributeIndexMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('t'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('b'),
  TO_UNICODE ('u'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_attributeIndexMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_unifiedTypeMapProxy   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 0,
                 kSearchMessage_searchKey,
                 inKey,
                 outParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_attributeIndexMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('t'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('b'),
  TO_UNICODE ('u'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_attributeIndexMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_unifiedTypeMapProxy & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                NULL
                COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_attributeIndexMap GGS_attributeIndexMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_attributeIndexMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_attributeIndexMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_attributeIndexMap GGS_attributeIndexMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_attributeIndexMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_attributeIndexMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @attributeIndexMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_unifiedTypeMapProxy  & GGS_attributeIndexMap::cEnumerator::_mAttributeTypeIndex (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mAttributeTypeIndex ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_attributeIndexMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_attributeIndexMap * p = NULL ;
    macroMyNew (p, GGS_attributeIndexMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_attributeIndexMap GGS_attributeIndexMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_attributeIndexMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_attributeIndexMap * p = dynamic_cast <const GGS_attributeIndexMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_attributeIndexMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_attributeIndexMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_attributeIndexMap ;
}

//---------------------------------------------------------------------------*

GGS_attributeIndexMap GGS_attributeIndexMap::constructor_mapWithKeyAndValue (C_Compiler & inLexique,
                                             const GGS_lstring & inKey,
                                             const GGS_unifiedTypeMapProxy & inValue0
                                             COMMA_LOCATION_ARGS) {
  GGS_attributeIndexMap result = constructor_emptyMap (inLexique COMMA_THERE) ;
  result.insertElement (inLexique,
                        0,
                        NULL,
                        inKey,
                        inValue0,
                        NULL
                        COMMA_THERE) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Category method '@listDeclarationAST.performSemanticAnalysis'        *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__listDeclarationAST__performSemanticAnalysis (C_Compiler & inLexique,
                                const cPtr_listDeclarationAST * operand_5307,
                                const GGS_semanticContext  var_cas_inSemanticContext,
                                const GGS_predefinedTypes  /* var_cas_inPredefinedTypes */,
                                GGS_semanticDeclarationSortedListForGeneration  & var_cas_ioSemanticDeclarationListForGeneration
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_5307 != NULL) {
    GGS_typedAttributeList  var_cas_typedAttributeList = GGS_typedAttributeList ::constructor_emptyList () ;
    GGS_attributeIndexMap  var_cas_attributeMap = GGS_attributeIndexMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (109)) ;
    {
      GGS_attributeInCollectionListAST::cEnumerator enumerator_5608 (operand_5307->mAttributeList, true) ;
      const GGS_attributeInCollectionListAST::cElement * operand_5608 = NULL ;
      while (((operand_5608 = enumerator_5608.nextObject ()))) {
        macroValidPointer (operand_5608) ;
        GGS_unifiedTypeMapProxy  var_cas_t = GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_5608->mAttributeTypeName COMMA_SOURCE_FILE_AT_LINE (111)) ;
        var_cas_typedAttributeList.addAssign_operation (var_cas_t, operand_5608->mAttributeName) ;
        var_cas_attributeMap.modifier_insertKey (inLexique, operand_5608->mAttributeName, var_cas_t COMMA_SOURCE_FILE_AT_LINE (116)) ;
      }
    }
    var_cas_ioSemanticDeclarationListForGeneration.addAssign_operation (GGS_listTypeForGeneration ::constructor_new (inLexique, GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_5307->mListTypeName COMMA_SOURCE_FILE_AT_LINE (119)), var_cas_typedAttributeList COMMA_SOURCE_FILE_AT_LINE (118)), GGS_string ("")) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//   Category method '@sortedListDeclarationAST.performSemanticAnalysis'     *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__sortedListDeclarationAST__performSemanticAnalysis (C_Compiler & inLexique,
                                const cPtr_sortedListDeclarationAST * operand_6185,
                                const GGS_semanticContext  var_cas_inSemanticContext,
                                const GGS_predefinedTypes  /* var_cas_inPredefinedTypes */,
                                GGS_semanticDeclarationSortedListForGeneration  & var_cas_ioSemanticDeclarationListForGeneration
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_6185 != NULL) {
    GGS_typedAttributeList  var_cas_typedAttributeList = GGS_typedAttributeList ::constructor_emptyList () ;
    GGS_attributeIndexMap  var_cas_attributeMap = GGS_attributeIndexMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (136)) ;
    {
      GGS_attributeInCollectionListAST::cEnumerator enumerator_6501 (operand_6185->mAttributeList, true) ;
      const GGS_attributeInCollectionListAST::cElement * operand_6501 = NULL ;
      while (((operand_6501 = enumerator_6501.nextObject ()))) {
        macroValidPointer (operand_6501) ;
        GGS_unifiedTypeMapProxy  var_cas_t = GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_6501->mAttributeTypeName COMMA_SOURCE_FILE_AT_LINE (138)) ;
        var_cas_typedAttributeList.addAssign_operation (var_cas_t, operand_6501->mAttributeName) ;
        var_cas_attributeMap.modifier_insertKey (inLexique, operand_6501->mAttributeName, var_cas_t COMMA_SOURCE_FILE_AT_LINE (143)) ;
      }
    }
    GGS_stringset  var_cas_attributesUsedForSorting = GGS_stringset ::constructor_emptySet () ;
    GGS_sortDescriptorListForGeneration  var_cas_sortDescriptorList = GGS_sortDescriptorListForGeneration ::constructor_emptyList () ;
    {
      GGS_sortedListSortDescriptorListAST::cEnumerator enumerator_6895 (operand_6185->mSortDescriptorList, true) ;
      const GGS_sortedListSortDescriptorListAST::cElement * operand_6895 = NULL ;
      while (((operand_6895 = enumerator_6895.nextObject ()))) {
        macroValidPointer (operand_6895) ;
        GGS_unifiedTypeMapProxy  var_cas_type ;
        if (var_cas_attributeMap.isBuilt ()) {
          var_cas_attributeMap (HERE)->method_searchKey (inLexique, operand_6895->mSortedAttributeName, var_cas_type COMMA_SOURCE_FILE_AT_LINE (150)) ;
        }
        var_cas_sortDescriptorList.addAssign_operation (var_cas_type, operand_6895->mSortedAttributeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (151)), operand_6895->mAscending) ;
        const GGS_bool cond_7253 = var_cas_attributesUsedForSorting.reader_hasKey (operand_6895->mSortedAttributeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (152))) ;
        if (cond_7253.isBuiltAndTrue ()) {
          operand_6895->mSortedAttributeName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("the '")).operator_concat (operand_6895->mSortedAttributeName)).operator_concat (GGS_string ("' is already used for sorting")) COMMA_SOURCE_FILE_AT_LINE (154)) ;
        }
        var_cas_attributesUsedForSorting.addAssign_operation (operand_6895->mSortedAttributeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (155))) ;
      }
    }
    var_cas_ioSemanticDeclarationListForGeneration.addAssign_operation (GGS_sortedListTypeForGeneration ::constructor_new (inLexique, GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_6185->mSortedListTypeName COMMA_SOURCE_FILE_AT_LINE (159)), var_cas_typedAttributeList, var_cas_sortDescriptorList COMMA_SOURCE_FILE_AT_LINE (158)), GGS_string ("")) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//     Category method '@structDeclarationAST.performSemanticAnalysis'       *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__structDeclarationAST__performSemanticAnalysis (C_Compiler & inLexique,
                                const cPtr_structDeclarationAST * operand_7743,
                                const GGS_semanticContext  var_cas_inSemanticContext,
                                const GGS_predefinedTypes  /* var_cas_inPredefinedTypes */,
                                GGS_semanticDeclarationSortedListForGeneration  & var_cas_ioSemanticDeclarationListForGeneration
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_7743 != NULL) {
    GGS_typedAttributeList  var_cas_typedAttributeList = GGS_typedAttributeList ::constructor_emptyList () ;
    GGS_attributeIndexMap  var_cas_attributeMap = GGS_attributeIndexMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (176)) ;
    {
      GGS_attributeInCollectionListAST::cEnumerator enumerator_8044 (operand_7743->mAttributeList, true) ;
      const GGS_attributeInCollectionListAST::cElement * operand_8044 = NULL ;
      while (((operand_8044 = enumerator_8044.nextObject ()))) {
        macroValidPointer (operand_8044) ;
        GGS_unifiedTypeMapProxy  var_cas_t = GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_8044->mAttributeTypeName COMMA_SOURCE_FILE_AT_LINE (178)) ;
        var_cas_typedAttributeList.addAssign_operation (var_cas_t, operand_8044->mAttributeName) ;
        var_cas_attributeMap.modifier_insertKey (inLexique, operand_8044->mAttributeName, var_cas_t COMMA_SOURCE_FILE_AT_LINE (183)) ;
      }
    }
    var_cas_ioSemanticDeclarationListForGeneration.addAssign_operation (GGS_structTypeForGeneration ::constructor_new (inLexique, GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_7743->mStructTypeName COMMA_SOURCE_FILE_AT_LINE (186)), var_cas_typedAttributeList COMMA_SOURCE_FILE_AT_LINE (185)), GGS_string ("")) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'e_constantIndexMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

e_constantIndexMap::e_constantIndexMap (void) :
mIndex () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class map '@constantIndexMap'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_constantIndexMap ("constantIndexMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_constantIndexMap::
elementOf_GGS_constantIndexMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_constantIndexMap & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_constantIndexMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mIndex.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_constantIndexMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_constantIndexMap * ptr = dynamic_cast <const elementOf_GGS_constantIndexMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mIndex.operator_isEqual (ptr->mInfo.mIndex)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_constantIndexMap::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_constantIndexMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_constantIndexMap * info = (e_constantIndexMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_constantIndexMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_constantIndexMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_constantIndexMap * info = (e_constantIndexMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_constantIndexMap GGS_constantIndexMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_constantIndexMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_constantIndexMap::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_constantIndexMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_constantIndexMap::
operator_isEqual (const GGS_constantIndexMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_constantIndexMap::
operator_isNotEqual (const GGS_constantIndexMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_constantIndexMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_constantIndexMap::
insertElement (C_Compiler & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_uint & inParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap (THERE) ;
    e_constantIndexMap info  ;
    info.mIndex = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_constantIndexMap::
searchElement (C_Compiler & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_uint   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    outParameter0 = node->mInfo.mIndex ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_constantIndexMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE ('s'),
  TO_UNICODE ('t'),
  TO_UNICODE ('a'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_constantIndexMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_uint   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 0,
                 kSearchMessage_searchKey,
                 inKey,
                 outParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_constantIndexMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE ('s'),
  TO_UNICODE ('t'),
  TO_UNICODE ('a'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_constantIndexMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_uint & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                NULL
                COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_constantIndexMap GGS_constantIndexMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_constantIndexMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_constantIndexMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_constantIndexMap GGS_constantIndexMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_constantIndexMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_constantIndexMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @constantIndexMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_constantIndexMap::cEnumerator::_mIndex (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mIndex ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_constantIndexMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_constantIndexMap * p = NULL ;
    macroMyNew (p, GGS_constantIndexMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_constantIndexMap GGS_constantIndexMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_constantIndexMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_constantIndexMap * p = dynamic_cast <const GGS_constantIndexMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_constantIndexMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_constantIndexMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_constantIndexMap ;
}

//---------------------------------------------------------------------------*

GGS_constantIndexMap GGS_constantIndexMap::constructor_mapWithKeyAndValue (C_Compiler & inLexique,
                                             const GGS_lstring & inKey,
                                             const GGS_uint & inValue0
                                             COMMA_LOCATION_ARGS) {
  GGS_constantIndexMap result = constructor_emptyMap (inLexique COMMA_THERE) ;
  result.insertElement (inLexique,
                        0,
                        NULL,
                        inKey,
                        inValue0,
                        NULL
                        COMMA_THERE) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Category method '@enumDeclarationAST.performSemanticAnalysis'        *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__enumDeclarationAST__performSemanticAnalysis (C_Compiler & inLexique,
                                const cPtr_enumDeclarationAST * operand_8887,
                                const GGS_semanticContext  var_cas_inSemanticContext,
                                const GGS_predefinedTypes  /* var_cas_inPredefinedTypes */,
                                GGS_semanticDeclarationSortedListForGeneration  & var_cas_ioSemanticDeclarationListForGeneration
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_8887 != NULL) {
    GGS_stringlist  var_cas_constantList = GGS_stringlist ::constructor_emptyList () ;
    GGS_constantIndexMap  var_cas_constantMap = GGS_constantIndexMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (210)) ;
    {
      GGS_lstringlist::cEnumerator enumerator_9190 (operand_8887->mConstantList, true) ;
      const GGS_lstringlist::cElement * operand_9190 = NULL ;
      while (((operand_9190 = enumerator_9190.nextObject ()))) {
        macroValidPointer (operand_9190) ;
        var_cas_constantList.addAssign_operation (operand_9190->mValue.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (212))) ;
        var_cas_constantMap.modifier_insertKey (inLexique, operand_9190->mValue, var_cas_constantMap.reader_count () COMMA_SOURCE_FILE_AT_LINE (213)) ;
      }
    }
    const GGS_stringset  var_cas_constantSet = var_cas_constantMap.reader_allKeys (inLexique COMMA_SOURCE_FILE_AT_LINE (215)) ;
    GGS_enumMessageListForGeneration  var_cas_enumMessageList = GGS_enumMessageListForGeneration ::constructor_emptyList () ;
    GGS_stringset  var_cas_messageNameSet = GGS_stringset ::constructor_emptySet () ;
    {
      GGS_enumMessageListAST::cEnumerator enumerator_9511 (operand_8887->mEnumMessageList, true) ;
      const GGS_enumMessageListAST::cElement * operand_9511 = NULL ;
      while (((operand_9511 = enumerator_9511.nextObject ()))) {
        macroValidPointer (operand_9511) ;
        const GGS_bool cond_9672 = var_cas_messageNameSet.reader_hasKey (operand_9511->mEnumMessageName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (220))) ;
        if (cond_9672.isBuiltAndTrue ()) {
          operand_9511->mEnumMessageName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("this message is already declared for this enum type") COMMA_SOURCE_FILE_AT_LINE (222)) ;
        }
        var_cas_messageNameSet.addAssign_operation (operand_9511->mEnumMessageName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (223))) ;
        GGS_enumMessageAssociationSortedListForGeneration  var_cas_enumMessageAssociationSortedListForGeneration = GGS_enumMessageAssociationSortedListForGeneration ::constructor_emptySortedList () ;
        GGS_stringset  var_cas_usedConstantSet = GGS_stringset ::constructor_emptySet () ;
        {
          GGS_enumMessageAssociationListAST::cEnumerator enumerator_9962 (operand_9511->mMessageAssociationList, true) ;
          const GGS_enumMessageAssociationListAST::cElement * operand_9962 = NULL ;
          while (((operand_9962 = enumerator_9962.nextObject ()))) {
            macroValidPointer (operand_9962) ;
            GGS_uint  var_cas_constantIndex ;
            if (var_cas_constantMap.isBuilt ()) {
              var_cas_constantMap (HERE)->method_searchKey (inLexique, operand_9962->mConstantName, var_cas_constantIndex COMMA_SOURCE_FILE_AT_LINE (228)) ;
            }
            var_cas_usedConstantSet.addAssign_operation (operand_9962->mConstantName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (229))) ;
            var_cas_enumMessageAssociationSortedListForGeneration.addAssign_operation (var_cas_constantIndex, operand_9962->mConstantName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (232)), operand_9962->mMessage.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (233))) ;
          }
        }
        const GGS_stringset  var_cas_missedConstantSet = var_cas_constantSet.substract_operation (inLexique, var_cas_usedConstantSet COMMA_SOURCE_FILE_AT_LINE (236)) ;
        {
          GGS_stringset::cEnumerator enumerator_10373 (var_cas_missedConstantSet, true) ;
          while (enumerator_10373.hasCurrentObject ()) {
            operand_9511->mEnumMessageName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((GGS_string ("the '")).operator_concat (operand_9511->mEnumMessageName)).operator_concat (GGS_string ("' message definition does not name the '"))).operator_concat (enumerator_10373._key (HERE))).operator_concat (GGS_string ("' constant")) COMMA_SOURCE_FILE_AT_LINE (240)) ;
            enumerator_10373.next () ;
          }
        }
        var_cas_enumMessageList.addAssign_operation (operand_9511->mEnumMessageName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (241)), var_cas_enumMessageAssociationSortedListForGeneration) ;
      }
    }
    var_cas_ioSemanticDeclarationListForGeneration.addAssign_operation (GGS_enumTypeForGeneration ::constructor_new (inLexique, GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_8887->mEnumTypeName COMMA_SOURCE_FILE_AT_LINE (245)), var_cas_constantList, var_cas_enumMessageList COMMA_SOURCE_FILE_AT_LINE (244)), GGS_string ("")) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//     Category method '@listmapDeclarationAST.performSemanticAnalysis'      *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__listmapDeclarationAST__performSemanticAnalysis (C_Compiler & inLexique,
                                const cPtr_listmapDeclarationAST * operand_11012,
                                const GGS_semanticContext  var_cas_inSemanticContext,
                                const GGS_predefinedTypes  /* var_cas_inPredefinedTypes */,
                                GGS_semanticDeclarationSortedListForGeneration  & var_cas_ioSemanticDeclarationListForGeneration
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_11012 != NULL) {
    GGS_typeKindEnum var_cas_typeKindEnum ;
    GGS_typedAttributeList  var_cas_listTypeAttributeList ;
    GGS_bool automatic_var_11422_0 ;
    GGS_unifiedTypeMapProxy  automatic_var_11422_1 ;
    GGS_attributeMap  automatic_var_11422_2 ;
    GGS_typedAttributeList  automatic_var_11422_3 ;
    GGS_constructorMap  automatic_var_11422_4 ;
    GGS_readerMap  automatic_var_11422_5 ;
    GGS_modifierMap  automatic_var_11422_6 ;
    GGS_instanceMethodMap  automatic_var_11422_7 ;
    GGS_classMethodMap  automatic_var_11422_8 ;
    GGS_enumerationDescriptorList  automatic_var_11422_9 ;
    GGS_uint  automatic_var_11422_10 ;
    GGS_unifiedTypeMapProxyList  automatic_var_11422_11 ;
    GGS_nativeAttributeList  automatic_var_11422_12 ;
    GGS_stringset  automatic_var_11422_13 ;
    GGS_lstringlist  automatic_var_11422_14 ;
    GGS_typedAttributeList  automatic_var_11422_15 ;
    GGS_mapSearchMethodListAST  automatic_var_11422_16 ;
    GGS_mapSearchMethodListAST  automatic_var_11422_17 ;
    GGS_withAccessorMap  automatic_var_11422_18 ;
    if (var_cas_inSemanticContext.mTypeMap.isBuilt ()) {
      var_cas_inSemanticContext.mTypeMap (HERE)->method_searchKey (inLexique, operand_11012->mAssociatedListTypeName, automatic_var_11422_0, automatic_var_11422_1, var_cas_typeKindEnum, var_cas_listTypeAttributeList, automatic_var_11422_2, automatic_var_11422_3, automatic_var_11422_4, automatic_var_11422_5, automatic_var_11422_6, automatic_var_11422_7, automatic_var_11422_8, automatic_var_11422_9, automatic_var_11422_10, automatic_var_11422_11, automatic_var_11422_12, automatic_var_11422_13, automatic_var_11422_14, automatic_var_11422_15, automatic_var_11422_16, automatic_var_11422_17, automatic_var_11422_18 COMMA_SOURCE_FILE_AT_LINE (263)) ;
    }
    var_cas_ioSemanticDeclarationListForGeneration.addAssign_operation (GGS_listmapTypeForGeneration ::constructor_new (inLexique, GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_11012->mListmapTypeName COMMA_SOURCE_FILE_AT_LINE (266)), GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_11012->mAssociatedListTypeName COMMA_SOURCE_FILE_AT_LINE (267)), var_cas_listTypeAttributeList COMMA_SOURCE_FILE_AT_LINE (265)), GGS_string ("")) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map '@insertMethodMap'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_insertMethodMap ("insertMethodMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_insertMethodMap::
elementOf_GGS_insertMethodMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_insertMethodMap & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_insertMethodMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_insertMethodMap::
isEqualToMapElement (const AC_galgas_map_element * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_insertMethodMap::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_insertMethodMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_insertMethodMap * info = (e_insertMethodMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_insertMethodMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_insertMethodMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_insertMethodMap * info = (e_insertMethodMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_insertMethodMap GGS_insertMethodMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_insertMethodMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_insertMethodMap::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_insertMethodMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_insertMethodMap::
operator_isEqual (const GGS_insertMethodMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_insertMethodMap::
operator_isNotEqual (const GGS_insertMethodMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_insertMethodMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_insertMethodMap::
insertElement (C_Compiler & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap (THERE) ;
    e_insertMethodMap info  ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_insertMethodMap::
searchElement (C_Compiler & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_insertMethodMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('s'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('o'),
  TO_UNICODE ('d'),
  TO_UNICODE ('i'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_insertMethodMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_insertKey,
                 inKey,
                NULL
                COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_insertMethodMap GGS_insertMethodMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_insertMethodMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_insertMethodMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_insertMethodMap GGS_insertMethodMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_insertMethodMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_insertMethodMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @insertMethodMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_insertMethodMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_insertMethodMap * p = NULL ;
    macroMyNew (p, GGS_insertMethodMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_insertMethodMap GGS_insertMethodMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_insertMethodMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_insertMethodMap * p = dynamic_cast <const GGS_insertMethodMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_insertMethodMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_insertMethodMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_insertMethodMap ;
}

//---------------------------------------------------------------------------*

GGS_insertMethodMap GGS_insertMethodMap::constructor_mapWithKeyAndValue (C_Compiler & inLexique,
                                             const GGS_lstring & inKey
                                             COMMA_LOCATION_ARGS) {
  GGS_insertMethodMap result = constructor_emptyMap (inLexique COMMA_THERE) ;
  result.insertElement (inLexique,
                        0,
                        NULL,
                        inKey,
                        NULL
                        COMMA_THERE) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map '@searchMethodMap'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_searchMethodMap ("searchMethodMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_searchMethodMap::
elementOf_GGS_searchMethodMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_searchMethodMap & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_searchMethodMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_searchMethodMap::
isEqualToMapElement (const AC_galgas_map_element * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_searchMethodMap::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_searchMethodMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_searchMethodMap * info = (e_searchMethodMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_searchMethodMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_searchMethodMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_searchMethodMap * info = (e_searchMethodMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_searchMethodMap GGS_searchMethodMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_searchMethodMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_searchMethodMap::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_searchMethodMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_searchMethodMap::
operator_isEqual (const GGS_searchMethodMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_searchMethodMap::
operator_isNotEqual (const GGS_searchMethodMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_searchMethodMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_searchMethodMap::
insertElement (C_Compiler & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap (THERE) ;
    e_searchMethodMap info  ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_searchMethodMap::
searchElement (C_Compiler & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_searchMethodMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('s'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('c'),
  TO_UNICODE ('h'),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('o'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_searchMethodMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_insertKey,
                 inKey,
                NULL
                COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_searchMethodMap GGS_searchMethodMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_searchMethodMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_searchMethodMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_searchMethodMap GGS_searchMethodMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_searchMethodMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_searchMethodMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @searchMethodMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_searchMethodMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_searchMethodMap * p = NULL ;
    macroMyNew (p, GGS_searchMethodMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_searchMethodMap GGS_searchMethodMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_searchMethodMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_searchMethodMap * p = dynamic_cast <const GGS_searchMethodMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_searchMethodMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_searchMethodMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_searchMethodMap ;
}

//---------------------------------------------------------------------------*

GGS_searchMethodMap GGS_searchMethodMap::constructor_mapWithKeyAndValue (C_Compiler & inLexique,
                                             const GGS_lstring & inKey
                                             COMMA_LOCATION_ARGS) {
  GGS_searchMethodMap result = constructor_emptyMap (inLexique COMMA_THERE) ;
  result.insertElement (inLexique,
                        0,
                        NULL,
                        inKey,
                        NULL
                        COMMA_THERE) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//       Category method '@mapDeclarationAST.performSemanticAnalysis'        *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__mapDeclarationAST__performSemanticAnalysis (C_Compiler & inLexique,
                                const cPtr_mapDeclarationAST * operand_12247,
                                const GGS_semanticContext  var_cas_inSemanticContext,
                                const GGS_predefinedTypes  var_cas_inPredefinedTypes,
                                GGS_semanticDeclarationSortedListForGeneration  & var_cas_ioSemanticDeclarationListForGeneration
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_12247 != NULL) {
    GGS_typedAttributeList  var_cas_typedAttributeList = GGS_typedAttributeList ::constructor_emptyList () ;
    GGS_attributeIndexMap  var_cas_attributeMap = GGS_attributeIndexMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (295)) ;
    {
      GGS_attributeInCollectionListAST::cEnumerator enumerator_12566 (operand_12247->mAttributeList, true) ;
      const GGS_attributeInCollectionListAST::cElement * operand_12566 = NULL ;
      while (((operand_12566 = enumerator_12566.nextObject ()))) {
        macroValidPointer (operand_12566) ;
        GGS_unifiedTypeMapProxy  var_cas_t = GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_12566->mAttributeTypeName COMMA_SOURCE_FILE_AT_LINE (297)) ;
        var_cas_typedAttributeList.addAssign_operation (var_cas_t, operand_12566->mAttributeName) ;
        var_cas_attributeMap.modifier_insertKey (inLexique, operand_12566->mAttributeName, var_cas_t COMMA_SOURCE_FILE_AT_LINE (302)) ;
      }
    }
    GGS_insertMethodMap  var_cas_insertMethodMap = GGS_insertMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (305)) ;
    {
      GGS_insertMethodListAST::cEnumerator enumerator_12894 (operand_12247->mInsertMethodList, true) ;
      const GGS_insertMethodListAST::cElement * operand_12894 = NULL ;
      while (((operand_12894 = enumerator_12894.nextObject ()))) {
        macroValidPointer (operand_12894) ;
        var_cas_insertMethodMap.modifier_insertKey (inLexique, operand_12894->mMethodName COMMA_SOURCE_FILE_AT_LINE (307)) ;
        {
          GGS_stringlist::cEnumerator enumerator_13024 (operand_12894->mErrorMessage.ggs_string ().reader_componentsSeparatedByString (GGS_string ("%%")), true) ;
          const GGS_stringlist::cElement * operand_13024 = NULL ;
          while (((operand_13024 = enumerator_13024.nextObject ()))) {
            macroValidPointer (operand_13024) ;
            GGS_stringlist  var_cas_explodedArray = operand_13024->mValue.reader_componentsSeparatedByString (GGS_string ("%")) ;
            GGS_string automatic_var_13190_0 ;
            var_cas_explodedArray.modifier_popFirst (inLexique, automatic_var_13190_0 COMMA_SOURCE_FILE_AT_LINE (311)) ;
            {
              GGS_stringlist::cEnumerator enumerator_13220 (var_cas_explodedArray, true) ;
              const GGS_stringlist::cElement * operand_13220 = NULL ;
              while (((operand_13220 = enumerator_13220.nextObject ()))) {
                macroValidPointer (operand_13220) ;
                const GGS_bool cond_13508 = (operand_13220->mValue.reader_length ()).operator_strictSup (GGS_uint (0U)) ;
                if (cond_13508.isBuiltAndTrue ()) {
                  const GGS_char var_cas_c = operand_13220->mValue.reader_characterAtIndex (inLexique, GGS_uint (0U) COMMA_SOURCE_FILE_AT_LINE (314)) ;
                  const GGS_bool cond_13491 = ((var_cas_c).operator_isNotEqual (GGS_char (TO_UNICODE ('K')))).operator_and ((var_cas_c).operator_isNotEqual (GGS_char (TO_UNICODE ('L')))) ;
                  if (cond_13491.isBuiltAndTrue ()) {
                    operand_12894->mErrorMessage.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("only '%K', '%L' and '%%' escape sequences are allowed in an insert error message") COMMA_SOURCE_FILE_AT_LINE (317)) ;
                  }
                }
              }
            }
          }
        }
        {
          GGS_stringlist::cEnumerator enumerator_13636 (operand_12894->mShadowErrorMessage.ggs_string ().reader_componentsSeparatedByString (GGS_string ("%%")), true) ;
          const GGS_stringlist::cElement * operand_13636 = NULL ;
          while (((operand_13636 = enumerator_13636.nextObject ()))) {
            macroValidPointer (operand_13636) ;
            GGS_stringlist  var_cas_explodedArray = operand_13636->mValue.reader_componentsSeparatedByString (GGS_string ("%")) ;
            GGS_string automatic_var_13808_0 ;
            var_cas_explodedArray.modifier_popFirst (inLexique, automatic_var_13808_0 COMMA_SOURCE_FILE_AT_LINE (324)) ;
            {
              GGS_stringlist::cEnumerator enumerator_13838 (var_cas_explodedArray, true) ;
              const GGS_stringlist::cElement * operand_13838 = NULL ;
              while (((operand_13838 = enumerator_13838.nextObject ()))) {
                macroValidPointer (operand_13838) ;
                const GGS_bool cond_14125 = (operand_13838->mValue.reader_length ()).operator_strictSup (GGS_uint (0U)) ;
                if (cond_14125.isBuiltAndTrue ()) {
                  const GGS_char var_cas_c = operand_13838->mValue.reader_characterAtIndex (inLexique, GGS_uint (0U) COMMA_SOURCE_FILE_AT_LINE (327)) ;
                  const GGS_bool cond_14108 = ((var_cas_c).operator_isNotEqual (GGS_char (TO_UNICODE ('K')))).operator_and ((var_cas_c).operator_isNotEqual (GGS_char (TO_UNICODE ('L')))) ;
                  if (cond_14108.isBuiltAndTrue ()) {
                    operand_12894->mErrorMessage.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("only '%K', '%L' and '%%' escape sequences are allowed in a shadow error message") COMMA_SOURCE_FILE_AT_LINE (330)) ;
                  }
                }
              }
            }
          }
        }
      }
    }
    GGS_searchMethodMap  var_cas_searchMethodMap = GGS_searchMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (336)) ;
    {
      GGS_mapSearchMethodListAST::cEnumerator enumerator_14286 (operand_12247->mSearchMethodList, true) ;
      const GGS_mapSearchMethodListAST::cElement * operand_14286 = NULL ;
      while (((operand_14286 = enumerator_14286.nextObject ()))) {
        macroValidPointer (operand_14286) ;
        var_cas_searchMethodMap.modifier_insertKey (inLexique, operand_14286->mMethodName COMMA_SOURCE_FILE_AT_LINE (338)) ;
        {
          GGS_stringlist::cEnumerator enumerator_14412 (operand_14286->mErrorMessage.ggs_string ().reader_componentsSeparatedByString (GGS_string ("%%")), true) ;
          const GGS_stringlist::cElement * operand_14412 = NULL ;
          while (((operand_14412 = enumerator_14412.nextObject ()))) {
            macroValidPointer (operand_14412) ;
            GGS_stringlist  var_cas_explodedArray = operand_14412->mValue.reader_componentsSeparatedByString (GGS_string ("%")) ;
            GGS_string automatic_var_14578_0 ;
            var_cas_explodedArray.modifier_popFirst (inLexique, automatic_var_14578_0 COMMA_SOURCE_FILE_AT_LINE (342)) ;
            {
              GGS_stringlist::cEnumerator enumerator_14608 (var_cas_explodedArray, true) ;
              const GGS_stringlist::cElement * operand_14608 = NULL ;
              while (((operand_14608 = enumerator_14608.nextObject ()))) {
                macroValidPointer (operand_14608) ;
                const GGS_bool cond_14874 = (operand_14608->mValue.reader_length ()).operator_strictSup (GGS_uint (0U)) ;
                if (cond_14874.isBuiltAndTrue ()) {
                  const GGS_char var_cas_c = operand_14608->mValue.reader_characterAtIndex (inLexique, GGS_uint (0U) COMMA_SOURCE_FILE_AT_LINE (345)) ;
                  const GGS_bool cond_14857 = (var_cas_c).operator_isNotEqual (GGS_char (TO_UNICODE ('K'))) ;
                  if (cond_14857.isBuiltAndTrue ()) {
                    operand_14286->mErrorMessage.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("only '%K' and '%%' escape sequences are allowed in a search error message") COMMA_SOURCE_FILE_AT_LINE (348)) ;
                  }
                }
              }
            }
          }
        }
      }
    }
    {
      GGS_mapRemoveMethodListAST::cEnumerator enumerator_14987 (operand_12247->mRemoveMethodList, true) ;
      const GGS_mapRemoveMethodListAST::cElement * operand_14987 = NULL ;
      while (((operand_14987 = enumerator_14987.nextObject ()))) {
        macroValidPointer (operand_14987) ;
        var_cas_insertMethodMap.modifier_insertKey (inLexique, operand_14987->mMethodName COMMA_SOURCE_FILE_AT_LINE (355)) ;
        {
          GGS_stringlist::cEnumerator enumerator_15113 (operand_14987->mErrorMessage.ggs_string ().reader_componentsSeparatedByString (GGS_string ("%%")), true) ;
          const GGS_stringlist::cElement * operand_15113 = NULL ;
          while (((operand_15113 = enumerator_15113.nextObject ()))) {
            macroValidPointer (operand_15113) ;
            GGS_stringlist  var_cas_explodedArray = operand_15113->mValue.reader_componentsSeparatedByString (GGS_string ("%")) ;
            GGS_string automatic_var_15279_0 ;
            var_cas_explodedArray.modifier_popFirst (inLexique, automatic_var_15279_0 COMMA_SOURCE_FILE_AT_LINE (359)) ;
            {
              GGS_stringlist::cEnumerator enumerator_15309 (var_cas_explodedArray, true) ;
              const GGS_stringlist::cElement * operand_15309 = NULL ;
              while (((operand_15309 = enumerator_15309.nextObject ()))) {
                macroValidPointer (operand_15309) ;
                const GGS_bool cond_15575 = (operand_15309->mValue.reader_length ()).operator_strictSup (GGS_uint (0U)) ;
                if (cond_15575.isBuiltAndTrue ()) {
                  const GGS_char var_cas_c = operand_15309->mValue.reader_characterAtIndex (inLexique, GGS_uint (0U) COMMA_SOURCE_FILE_AT_LINE (362)) ;
                  const GGS_bool cond_15558 = (var_cas_c).operator_isNotEqual (GGS_char (TO_UNICODE ('K'))) ;
                  if (cond_15558.isBuiltAndTrue ()) {
                    operand_14987->mErrorMessage.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("only '%K' and '%%' escape sequences are allowed in a remove error message") COMMA_SOURCE_FILE_AT_LINE (365)) ;
                  }
                }
              }
            }
          }
        }
      }
    }
    {
        GGS_uint var_cas_IDX (true, 0) ;
      GGS_insertOrReplaceDeclarationListAST::cEnumerator enumerator_15747 (operand_12247->mInsertOrReplaceDeclarationListAST, true) ;
      const GGS_insertOrReplaceDeclarationListAST::cElement * operand_15747 = NULL ;
      while (((operand_15747 = enumerator_15747.nextObject ()))) {
        macroValidPointer (operand_15747) ;
        const GGS_bool cond_15894 = (var_cas_IDX).operator_strictSup (GGS_uint (0U)) ;
        if (cond_15894.isBuiltAndTrue ()) {
          operand_15747->mInsertOrReplaceDeclarationLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticWarning (inLexique, GGS_string ("the 'insertOrReplace' modifier is already declared") COMMA_SOURCE_FILE_AT_LINE (373)) ;
        }
        var_cas_IDX.mValue ++ ;
      }
    }
    const GGS_bool var_cas_hasInsertOrReplaceModifier = (operand_12247->mInsertOrReplaceDeclarationListAST.reader_length ()).operator_strictSup (GGS_uint (0U)) ;
    const GGS_bool cond_16409 = (var_cas_hasInsertOrReplaceModifier).operator_and (var_cas_insertMethodMap.reader_hasKey (GGS_string ("insertOrReplace"))) ;
    if (cond_16409.isBuiltAndTrue ()) {
      GGS_location  var_cas_insertOrReplaceDeclarationLocation ;
      if (operand_12247->mInsertOrReplaceDeclarationListAST.isBuilt ()) {
        operand_12247->mInsertOrReplaceDeclarationListAST (HERE)->method_first (inLexique, var_cas_insertOrReplaceDeclarationLocation COMMA_SOURCE_FILE_AT_LINE (379)) ;
      }
      var_cas_insertOrReplaceDeclarationLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("the insertOrReplace' modifier cannot be declared : an insert modifier or a remove modifier has been declared with this name") COMMA_SOURCE_FILE_AT_LINE (381)) ;
    }
    GGS_withAccessorMap  var_cas_withAccessorMap = GGS_withAccessorMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (383)) ;
    var_cas_withAccessorMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("hasKey"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (384)), var_cas_inPredefinedTypes.mStringType COMMA_SOURCE_FILE_AT_LINE (384)) ;
    {
      GGS_mapSearchMethodListAST::cEnumerator enumerator_16616 (operand_12247->mSearchMethodList, true) ;
      const GGS_mapSearchMethodListAST::cElement * operand_16616 = NULL ;
      while (((operand_16616 = enumerator_16616.nextObject ()))) {
        macroValidPointer (operand_16616) ;
        var_cas_withAccessorMap.modifier_insertKey (inLexique, operand_16616->mMethodName, var_cas_inPredefinedTypes.mLStringType COMMA_SOURCE_FILE_AT_LINE (386)) ;
      }
    }
    var_cas_ioSemanticDeclarationListForGeneration.addAssign_operation (GGS_mapTypeForGeneration ::constructor_new (inLexique, GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_12247->mMapTypeName COMMA_SOURCE_FILE_AT_LINE (393)), operand_12247->mMapTypeName, var_cas_typedAttributeList, operand_12247->mInsertMethodList, operand_12247->mSearchMethodList, operand_12247->mRemoveMethodList, var_cas_hasInsertOrReplaceModifier, var_cas_withAccessorMap COMMA_SOURCE_FILE_AT_LINE (392)), GGS_string ("")) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//    Category method '@mapProxyDeclarationAST.performSemanticAnalysis'      *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__mapProxyDeclarationAST__performSemanticAnalysis (C_Compiler & inLexique,
                                const cPtr_mapProxyDeclarationAST * operand_17249,
                                const GGS_semanticContext  var_cas_inSemanticContext,
                                const GGS_predefinedTypes  /* var_cas_inPredefinedTypes */,
                                GGS_semanticDeclarationSortedListForGeneration  & var_cas_ioSemanticDeclarationListForGeneration
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_17249 != NULL) {
    GGS_typedAttributeList  var_cas_listTypeAttributeList ;
    GGS_mapSearchMethodListAST  var_cas_searchMethodList ;
    GGS_bool automatic_var_17676_0 ;
    GGS_unifiedTypeMapProxy  automatic_var_17676_1 ;
    GGS_typeKindEnum automatic_var_17676_2 ;
    GGS_typedAttributeList  automatic_var_17676_3 ;
    GGS_attributeMap  automatic_var_17676_4 ;
    GGS_constructorMap  automatic_var_17676_5 ;
    GGS_readerMap  automatic_var_17676_6 ;
    GGS_modifierMap  automatic_var_17676_7 ;
    GGS_instanceMethodMap  automatic_var_17676_8 ;
    GGS_classMethodMap  automatic_var_17676_9 ;
    GGS_enumerationDescriptorList  automatic_var_17676_10 ;
    GGS_uint  automatic_var_17676_11 ;
    GGS_unifiedTypeMapProxyList  automatic_var_17676_12 ;
    GGS_nativeAttributeList  automatic_var_17676_13 ;
    GGS_stringset  automatic_var_17676_14 ;
    GGS_lstringlist  automatic_var_17676_15 ;
    GGS_typedAttributeList  automatic_var_17676_16 ;
    GGS_mapSearchMethodListAST  automatic_var_17676_17 ;
    GGS_withAccessorMap  automatic_var_17676_18 ;
    if (var_cas_inSemanticContext.mTypeMap.isBuilt ()) {
      var_cas_inSemanticContext.mTypeMap (HERE)->method_searchKey (inLexique, operand_17249->mAssociatedMapTypeName, automatic_var_17676_0, automatic_var_17676_1, automatic_var_17676_2, automatic_var_17676_3, automatic_var_17676_4, var_cas_listTypeAttributeList, automatic_var_17676_5, automatic_var_17676_6, automatic_var_17676_7, automatic_var_17676_8, automatic_var_17676_9, automatic_var_17676_10, automatic_var_17676_11, automatic_var_17676_12, automatic_var_17676_13, automatic_var_17676_14, automatic_var_17676_15, automatic_var_17676_16, var_cas_searchMethodList, automatic_var_17676_17, automatic_var_17676_18 COMMA_SOURCE_FILE_AT_LINE (416)) ;
    }
    var_cas_ioSemanticDeclarationListForGeneration.addAssign_operation (GGS_mapProxyTypeForGeneration ::constructor_new (inLexique, GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_17249->mMapProxyTypeName COMMA_SOURCE_FILE_AT_LINE (419)), GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_17249->mAssociatedMapTypeName COMMA_SOURCE_FILE_AT_LINE (420)), var_cas_listTypeAttributeList, var_cas_searchMethodList COMMA_SOURCE_FILE_AT_LINE (418)), GGS_string ("")) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class map '@declaredMethodMap'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_declaredMethodMap ("declaredMethodMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_declaredMethodMap::
elementOf_GGS_declaredMethodMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_declaredMethodMap & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_declaredMethodMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_declaredMethodMap::
isEqualToMapElement (const AC_galgas_map_element * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_declaredMethodMap::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_declaredMethodMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_declaredMethodMap * info = (e_declaredMethodMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_declaredMethodMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_declaredMethodMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_declaredMethodMap * info = (e_declaredMethodMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_declaredMethodMap GGS_declaredMethodMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_declaredMethodMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_declaredMethodMap::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_declaredMethodMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_declaredMethodMap::
operator_isEqual (const GGS_declaredMethodMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_declaredMethodMap::
operator_isNotEqual (const GGS_declaredMethodMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_declaredMethodMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_declaredMethodMap::
insertElement (C_Compiler & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap (THERE) ;
    e_declaredMethodMap info  ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_declaredMethodMap::
searchElement (C_Compiler & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_declaredMethodMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('o'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (' '),
  TO_UNICODE ('f'),
  TO_UNICODE ('o'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE ('s'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_declaredMethodMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_insertKey,
                 inKey,
                NULL
                COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_declaredMethodMap GGS_declaredMethodMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_declaredMethodMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_declaredMethodMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_declaredMethodMap GGS_declaredMethodMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_declaredMethodMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_declaredMethodMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @declaredMethodMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_declaredMethodMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_declaredMethodMap * p = NULL ;
    macroMyNew (p, GGS_declaredMethodMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_declaredMethodMap GGS_declaredMethodMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_declaredMethodMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_declaredMethodMap * p = dynamic_cast <const GGS_declaredMethodMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_declaredMethodMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_declaredMethodMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_declaredMethodMap ;
}

//---------------------------------------------------------------------------*

GGS_declaredMethodMap GGS_declaredMethodMap::constructor_mapWithKeyAndValue (C_Compiler & inLexique,
                                             const GGS_lstring & inKey
                                             COMMA_LOCATION_ARGS) {
  GGS_declaredMethodMap result = constructor_emptyMap (inLexique COMMA_THERE) ;
  result.insertElement (inLexique,
                        0,
                        NULL,
                        inKey,
                        NULL
                        COMMA_THERE) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Implementation of routine "buildLocalVariableMapAndSignature"        *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_buildLocalVariableMapAndSignature (C_Compiler & inLexique,
                                const GGS_semanticContext  var_cas_inSemanticContext,
                                const GGS_formalParameterListAST   var_cas_inRoutineSignatureAST,
                                GGS_variableMap  & var_cas_ioVariableMap,
                                GGS_formalParameterListForGeneration  & var_cas_outRoutineSignature
                        COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_buildLocalVariableMapAndSignature at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  var_cas_outRoutineSignature = GGS_formalParameterListForGeneration ::constructor_emptyList () ;
  {
    GGS_formalParameterListAST::cEnumerator enumerator_18693 (var_cas_inRoutineSignatureAST, true) ;
    const GGS_formalParameterListAST::cElement * operand_18693 = NULL ;
    while (((operand_18693 = enumerator_18693.nextObject ()))) {
      macroValidPointer (operand_18693) ;
      const GGS_unifiedTypeMapProxy  var_cas_type = GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_18693->mFormalArgumentTypeName COMMA_SOURCE_FILE_AT_LINE (444)) ;
      GGS_string var_cas_formalArgumentCppName ;
      switch (operand_18693->mFormalArgumentPassingMode.enumValue ()) {
      case GGS_formalArgumentPassingModeAST::enum_argumentIn:
        {
        var_cas_formalArgumentCppName = (GGS_string ("inArgument_")).operator_concat (operand_18693->mFormalArgumentName.ggs_string ().reader_identifierRepresentation ()) ;
        const GGS_bool cond_19170 = operand_18693->mIsUnused ;
        if (cond_19170.isBuiltAndTrue ()) {
          var_cas_ioVariableMap.modifier_insertInputFormalArgumentDeclaredAsUnused (inLexique, operand_18693->mFormalArgumentName, var_cas_type, var_cas_formalArgumentCppName, var_cas_formalArgumentCppName COMMA_SOURCE_FILE_AT_LINE (450)) ;
        }else if (cond_19170.isBuiltAndFalse ()) {
          var_cas_ioVariableMap.modifier_insertInputFormalArgument (inLexique, operand_18693->mFormalArgumentName, var_cas_type, var_cas_formalArgumentCppName, var_cas_formalArgumentCppName COMMA_SOURCE_FILE_AT_LINE (452)) ;
        }
        }
        break ;
      case GGS_formalArgumentPassingModeAST::enum_argumentOut:
        {
        var_cas_formalArgumentCppName = (GGS_string ("outArgument_")).operator_concat (operand_18693->mFormalArgumentName.ggs_string ().reader_identifierRepresentation ()) ;
        var_cas_ioVariableMap.modifier_insertOutputFormalArgument (inLexique, operand_18693->mFormalArgumentName, var_cas_type, var_cas_formalArgumentCppName, var_cas_formalArgumentCppName COMMA_SOURCE_FILE_AT_LINE (456)) ;
        }
        break ;
      case GGS_formalArgumentPassingModeAST::enum_argumentInOut:
        {
        var_cas_formalArgumentCppName = (GGS_string ("ioArgument_")).operator_concat (operand_18693->mFormalArgumentName.ggs_string ().reader_identifierRepresentation ()) ;
        const GGS_bool cond_19863 = operand_18693->mIsUnused ;
        if (cond_19863.isBuiltAndTrue ()) {
          var_cas_ioVariableMap.modifier_insertInputOutputFormalArgumentDeclaredAsUnused (inLexique, operand_18693->mFormalArgumentName, var_cas_type, var_cas_formalArgumentCppName, var_cas_formalArgumentCppName COMMA_SOURCE_FILE_AT_LINE (460)) ;
        }else if (cond_19863.isBuiltAndFalse ()) {
          var_cas_ioVariableMap.modifier_insertInputOutputFormalArgument (inLexique, operand_18693->mFormalArgumentName, var_cas_type, var_cas_formalArgumentCppName, var_cas_formalArgumentCppName COMMA_SOURCE_FILE_AT_LINE (462)) ;
        }
        }
        break ;
      case GGS_formalArgumentPassingModeAST::enum_argumentConstantIn:
        {
        var_cas_formalArgumentCppName = (GGS_string ("constinArgument_")).operator_concat (operand_18693->mFormalArgumentName.ggs_string ().reader_identifierRepresentation ()) ;
        const GGS_bool cond_20328 = operand_18693->mIsUnused ;
        if (cond_20328.isBuiltAndTrue ()) {
          var_cas_ioVariableMap.modifier_insertConstantInputFormalArgumentDeclaredAsUnused (inLexique, operand_18693->mFormalArgumentName, var_cas_type, var_cas_formalArgumentCppName, var_cas_formalArgumentCppName COMMA_SOURCE_FILE_AT_LINE (467)) ;
        }else if (cond_20328.isBuiltAndFalse ()) {
          var_cas_ioVariableMap.modifier_insertConstantInputFormalArgument (inLexique, operand_18693->mFormalArgumentName, var_cas_type, var_cas_formalArgumentCppName, var_cas_formalArgumentCppName COMMA_SOURCE_FILE_AT_LINE (469)) ;
        }
        }
        break ;
      case GGS_formalArgumentPassingModeAST::kNotBuilt:
        break ;
      }
      var_cas_outRoutineSignature.addAssign_operation (operand_18693->mFormalArgumentPassingMode, var_cas_type, operand_18693->mFormalArgumentName, var_cas_formalArgumentCppName) ;
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_buildLocalVariableMapAndSignature\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Implementation of routine "analyzeRoutineBody"               *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_analyzeRoutineBody (C_Compiler & inLexique,
                                const GGS_analysisContext  var_cas_inAnalysisContext,
                                const GGS_formalParameterListAST   var_cas_inRoutineSignatureAST,
                                const GGS_localConstantList   var_cas_inLocalConstantList,
                                const GGS_typedAttributeList   var_cas_inTypedAttributeList,
                                const GGS_string  var_cas_inAttributeVariableNamePrefix,
                                const GGS_semanticInstructionListAST   var_cas_inInstructionList,
                                const GGS_location   var_cas_inEndOfMethodLocation,
                                GGS_semanticInstructionListForGeneration  & var_cas_outSemanticInstructionListForGeneration,
                                GGS_formalParameterListForGeneration  & var_cas_outRoutineSignature
                        COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_analyzeRoutineBody at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_variableMap  var_cas_variableMap = GGS_variableMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (489)) ;
  {
    GGS_localConstantList::cEnumerator enumerator_21283 (var_cas_inLocalConstantList, true) ;
    const GGS_localConstantList::cElement * operand_21283 = NULL ;
    while (((operand_21283 = enumerator_21283.nextObject ()))) {
      macroValidPointer (operand_21283) ;
      const GGS_bool cond_21415 = operand_21283->mNoWarningIfUnused ;
      if (cond_21415.isBuiltAndTrue ()) {
        var_cas_variableMap.modifier_insertUsedLocalConstant (inLexique, operand_21283->mName, operand_21283->mType, operand_21283->mCppName, function_selfMarkName (inLexique COMMA_SOURCE_FILE_AT_LINE (493)) COMMA_SOURCE_FILE_AT_LINE (493)) ;
      }else if (cond_21415.isBuiltAndFalse ()) {
        var_cas_variableMap.modifier_insertLocalConstant (inLexique, operand_21283->mName, operand_21283->mType, operand_21283->mCppName, function_selfMarkName (inLexique COMMA_SOURCE_FILE_AT_LINE (495)) COMMA_SOURCE_FILE_AT_LINE (495)) ;
      }
    }
  }
  {
    GGS_typedAttributeList::cEnumerator enumerator_21591 (var_cas_inTypedAttributeList, true) ;
    const GGS_typedAttributeList::cElement * operand_21591 = NULL ;
    while (((operand_21591 = enumerator_21591.nextObject ()))) {
      macroValidPointer (operand_21591) ;
      var_cas_variableMap.modifier_insertNonMutableAttribute (inLexique, operand_21591->mAttributeName, operand_21591->mAttributeTypeIndex, ((var_cas_inAttributeVariableNamePrefix).operator_concat (GGS_string ("mAttribute_"))).operator_concat (operand_21591->mAttributeName.ggs_string ().reader_identifierRepresentation ()), function_selfMarkName (inLexique COMMA_SOURCE_FILE_AT_LINE (504)) COMMA_SOURCE_FILE_AT_LINE (500)) ;
    }
  }
  ::routine_buildLocalVariableMapAndSignature (inLexique,  var_cas_inAnalysisContext.mSemanticContext,  var_cas_inRoutineSignatureAST,  var_cas_variableMap,  var_cas_outRoutineSignature COMMA_SOURCE_FILE_AT_LINE (508)) ;
  var_cas_outSemanticInstructionListForGeneration = GGS_semanticInstructionListForGeneration ::constructor_emptyList () ;
  {
    GGS_semanticInstructionListAST::cEnumerator enumerator_22166 (var_cas_inInstructionList, true) ;
    const GGS_semanticInstructionListAST::cElement * operand_22166 = NULL ;
    while (((operand_22166 = enumerator_22166.nextObject ()))) {
      macroValidPointer (operand_22166) ;
      { typeCategoryMethod__semanticInstructionAST__analyzeSemanticInstruction method = findCategoryMethod__semanticInstructionAST__analyzeSemanticInstruction (operand_22166->mInstruction.galgasObjectRunTimeInfo ()) ;
        if (method != NULL) {
          method (inLexique, operand_22166->mInstruction (HERE), var_cas_inAnalysisContext, var_cas_outSemanticInstructionListForGeneration, var_cas_variableMap COMMA_SOURCE_FILE_AT_LINE (517)) ;
        }
      }
    }
  }
  if (var_cas_variableMap.isBuilt ()) {
    var_cas_variableMap (HERE)->method_checkAutomatonStates (inLexique, var_cas_inEndOfMethodLocation COMMA_SOURCE_FILE_AT_LINE (524)) ;
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_analyzeRoutineBody\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
// Category method '@externFunctionDeclarationAST.performSemanticAnalysis'   *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__externFunctionDeclarationAST__performSemanticAnalysis (C_Compiler & inLexique,
                                const cPtr_externFunctionDeclarationAST * operand_22563,
                                const GGS_semanticContext  var_cas_inSemanticContext,
                                const GGS_predefinedTypes  /* var_cas_inPredefinedTypes */,
                                GGS_semanticDeclarationSortedListForGeneration  & var_cas_ioSemanticDeclarationListForGeneration
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_22563 != NULL) {
    GGS_formalInputParameterListForGeneration  var_cas_formalArgumentList = GGS_formalInputParameterListForGeneration ::constructor_emptyList () ;
    {
      GGS_formalInputParameterListAST::cEnumerator enumerator_22841 (operand_22563->mFormalArgumentList, true) ;
      const GGS_formalInputParameterListAST::cElement * operand_22841 = NULL ;
      while (((operand_22841 = enumerator_22841.nextObject ()))) {
        macroValidPointer (operand_22841) ;
        var_cas_formalArgumentList.addAssign_operation (GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_22841->mFormalArgumentTypeName COMMA_SOURCE_FILE_AT_LINE (537)), operand_22841->mFormalArgumentName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (538)), operand_22841->mIsUnused) ;
      }
    }
    var_cas_ioSemanticDeclarationListForGeneration.addAssign_operation (GGS_functionPrototypeDeclarationForGeneration ::constructor_new (inLexique, operand_22563->mFunctionName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (543)), var_cas_formalArgumentList, GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_22563->mResultTypeName COMMA_SOURCE_FILE_AT_LINE (545)) COMMA_SOURCE_FILE_AT_LINE (542)), GGS_string ("")) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//  Category method '@externRoutineDeclarationAST.performSemanticAnalysis'   *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__externRoutineDeclarationAST__performSemanticAnalysis (C_Compiler & inLexique,
                                const cPtr_externRoutineDeclarationAST * operand_23444,
                                const GGS_semanticContext  var_cas_inSemanticContext,
                                const GGS_predefinedTypes  /* var_cas_inPredefinedTypes */,
                                GGS_semanticDeclarationSortedListForGeneration  & var_cas_ioSemanticDeclarationListForGeneration
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_23444 != NULL) {
    GGS_formalParameterListForGeneration  var_cas_formalArgumentList = GGS_formalParameterListForGeneration ::constructor_emptyList () ;
    {
      GGS_formalParameterListAST::cEnumerator enumerator_23717 (operand_23444->mFormalArgumentList, true) ;
      const GGS_formalParameterListAST::cElement * operand_23717 = NULL ;
      while (((operand_23717 = enumerator_23717.nextObject ()))) {
        macroValidPointer (operand_23717) ;
        var_cas_formalArgumentList.addAssign_operation (operand_23717->mFormalArgumentPassingMode, GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_23717->mFormalArgumentTypeName COMMA_SOURCE_FILE_AT_LINE (562)), operand_23717->mFormalArgumentName, operand_23717->mFormalArgumentName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (564))) ;
      }
    }
    var_cas_ioSemanticDeclarationListForGeneration.addAssign_operation (GGS_routinePrototypeDeclarationForGeneration ::constructor_new (inLexique, operand_23444->mRoutineName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (568)), var_cas_formalArgumentList COMMA_SOURCE_FILE_AT_LINE (567)), GGS_string ("")) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//     Category method '@routineDeclarationAST.performSemanticAnalysis'      *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__routineDeclarationAST__performSemanticAnalysis (C_Compiler & inLexique,
                                const cPtr_routineDeclarationAST * operand_24272,
                                const GGS_semanticContext  var_cas_inSemanticContext,
                                const GGS_predefinedTypes  var_cas_inPredefinedTypes,
                                GGS_semanticDeclarationSortedListForGeneration  & var_cas_ioSemanticDeclarationListForGeneration
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_24272 != NULL) {
    GGS_formalParameterListForGeneration  var_cas_formalArgumentList = GGS_formalParameterListForGeneration ::constructor_emptyList () ;
    GGS_semanticInstructionListForGeneration  var_cas_instructionList ;
    const GGS_analysisContext var_cas_analysisContext = GGS_analysisContext::constructor_new (var_cas_inSemanticContext, var_cas_inPredefinedTypes, GGS_unifiedTypeMapProxy ::constructor_null (inLexique COMMA_SOURCE_FILE_AT_LINE (588)), GGS_string ("")) ;
    ::routine_analyzeRoutineBody (inLexique,  var_cas_analysisContext,  operand_24272->mFormalArgumentList,  GGS_localConstantList ::constructor_emptyList (),  GGS_typedAttributeList ::constructor_emptyList (),  GGS_string (""),  operand_24272->mRoutineInstructionList,  operand_24272->mEndOfRoutineInstructionList,  var_cas_instructionList,  var_cas_formalArgumentList COMMA_SOURCE_FILE_AT_LINE (591)) ;
    var_cas_ioSemanticDeclarationListForGeneration.addAssign_operation (GGS_routineImplementationForGeneration ::constructor_new (inLexique, operand_24272->mRoutineName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (604)), var_cas_formalArgumentList, var_cas_instructionList COMMA_SOURCE_FILE_AT_LINE (603)), GGS_string ("")) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Category method '@classDeclarationAST.performSemanticAnalysis'       *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__classDeclarationAST__performSemanticAnalysis (C_Compiler & inLexique,
                                const cPtr_classDeclarationAST * operand_25318,
                                const GGS_semanticContext  var_cas_inSemanticContext,
                                const GGS_predefinedTypes  var_cas_inPredefinedTypes,
                                GGS_semanticDeclarationSortedListForGeneration  & var_cas_ioSemanticDeclarationListForGeneration
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_25318 != NULL) {
    const GGS_unifiedTypeMapProxy  var_cas_selfType = GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_25318->mClassTypeName COMMA_SOURCE_FILE_AT_LINE (620)) ;
    GGS_unifiedTypeMapProxy  var_cas_superClassProxy ;
    GGS_typedAttributeList  var_cas_allAttributeList ;
    GGS_instanceMethodMap  var_cas_inheritedInstanceMethodMap ;
    const GGS_bool cond_26000 = (operand_25318->mSuperClassName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (625))).operator_isEqual (GGS_string ("")) ;
    if (cond_26000.isBuiltAndTrue ()) {
      var_cas_superClassProxy = GGS_unifiedTypeMapProxy ::constructor_null (inLexique COMMA_SOURCE_FILE_AT_LINE (626)) ;
      var_cas_allAttributeList = GGS_typedAttributeList ::constructor_emptyList () ;
      var_cas_inheritedInstanceMethodMap = GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (628)) ;
    }else if (cond_26000.isBuiltAndFalse ()) {
      var_cas_superClassProxy = GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_25318->mSuperClassName COMMA_SOURCE_FILE_AT_LINE (630)) ;
      var_cas_allAttributeList = var_cas_superClassProxy.reader_mAllTypedAttributeList (inLexique COMMA_SOURCE_FILE_AT_LINE (631)) ;
      var_cas_inheritedInstanceMethodMap = var_cas_superClassProxy.reader_mInstanceMethodMap (inLexique COMMA_SOURCE_FILE_AT_LINE (632)) ;
    }
    GGS_typedAttributeList  var_cas_typedAttributeList = GGS_typedAttributeList ::constructor_emptyList () ;
    GGS_attributeIndexMap  var_cas_attributeMap = GGS_attributeIndexMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (636)) ;
    {
      GGS_attributeInCollectionListAST::cEnumerator enumerator_26407 (operand_25318->mAttributeList, true) ;
      const GGS_attributeInCollectionListAST::cElement * operand_26407 = NULL ;
      while (((operand_26407 = enumerator_26407.nextObject ()))) {
        macroValidPointer (operand_26407) ;
        GGS_unifiedTypeMapProxy  var_cas_t = GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_26407->mAttributeTypeName COMMA_SOURCE_FILE_AT_LINE (638)) ;
        var_cas_typedAttributeList.addAssign_operation (var_cas_t, operand_26407->mAttributeName) ;
        var_cas_allAttributeList.addAssign_operation (var_cas_t, operand_26407->mAttributeName) ;
        var_cas_attributeMap.modifier_insertKey (inLexique, operand_26407->mAttributeName, var_cas_t COMMA_SOURCE_FILE_AT_LINE (647)) ;
      }
    }
    GGS_declaredMethodMap  var_cas_classMethodMap = GGS_declaredMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (650)) ;
    {
      GGS_abstractMethodDefinitionListAST::cEnumerator enumerator_26823 (operand_25318->mAbstractMethodList, true) ;
      const GGS_abstractMethodDefinitionListAST::cElement * operand_26823 = NULL ;
      while (((operand_26823 = enumerator_26823.nextObject ()))) {
        macroValidPointer (operand_26823) ;
        var_cas_classMethodMap.modifier_insertKey (inLexique, operand_26823->mMethodName COMMA_SOURCE_FILE_AT_LINE (652)) ;
      }
    }
    {
      GGS_methodDefinitionListAST::cEnumerator enumerator_26911 (operand_25318->mMethodList, true) ;
      const GGS_methodDefinitionListAST::cElement * operand_26911 = NULL ;
      while (((operand_26911 = enumerator_26911.nextObject ()))) {
        macroValidPointer (operand_26911) ;
        var_cas_classMethodMap.modifier_insertKey (inLexique, operand_26911->mMethodName COMMA_SOURCE_FILE_AT_LINE (655)) ;
      }
    }
    GGS_abstractMethodDefinitionListForGeneration  var_cas_abstractMethodList = GGS_abstractMethodDefinitionListForGeneration ::constructor_emptyList () ;
    {
      GGS_abstractMethodDefinitionListAST::cEnumerator enumerator_27110 (operand_25318->mAbstractMethodList, true) ;
      const GGS_abstractMethodDefinitionListAST::cElement * operand_27110 = NULL ;
      while (((operand_27110 = enumerator_27110.nextObject ()))) {
        macroValidPointer (operand_27110) ;
        const GGS_bool cond_27296 = (operand_25318->mIsAbstract).operator_not () ;
        if (cond_27296.isBuiltAndTrue ()) {
          operand_27110->mMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("a concrete class cannot declare an abstract method") COMMA_SOURCE_FILE_AT_LINE (663)) ;
        }
        GGS_formalParameterListForGeneration  var_cas_formalParameterListForGeneration = GGS_formalParameterListForGeneration ::constructor_emptyList () ;
        {
          GGS_formalParameterListAST::cEnumerator enumerator_27441 (operand_27110->mSignature, true) ;
          const GGS_formalParameterListAST::cElement * operand_27441 = NULL ;
          while (((operand_27441 = enumerator_27441.nextObject ()))) {
            macroValidPointer (operand_27441) ;
            var_cas_formalParameterListForGeneration.addAssign_operation (operand_27441->mFormalArgumentPassingMode, GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_27441->mFormalArgumentTypeName COMMA_SOURCE_FILE_AT_LINE (669)), operand_27441->mFormalArgumentName, operand_27441->mFormalArgumentName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (671))) ;
          }
        }
        const GGS_bool cond_28180 = operand_27110->mIsOverriding ;
        if (cond_28180.isBuiltAndTrue ()) {
          GGS_formalParameterSignature  var_cas_inheritedSignature ;
          GGS_location  var_cas_inheritedDeclarationLocation ;
          GGS_bool automatic_var_27992_0 ;
          GGS_bool automatic_var_27992_1 ;
          GGS_methodQualifier automatic_var_27992_2 ;
          if (var_cas_inheritedInstanceMethodMap.isBuilt ()) {
            var_cas_inheritedInstanceMethodMap (HERE)->method_searchInheritedKey (inLexique, operand_27110->mMethodName, automatic_var_27992_0, var_cas_inheritedSignature, var_cas_inheritedDeclarationLocation, automatic_var_27992_1, automatic_var_27992_2 COMMA_SOURCE_FILE_AT_LINE (678)) ;
          }
          ::routine_checkMethodSignatures (inLexique,  var_cas_formalParameterListForGeneration,  operand_27110->mMethodName.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (681)),  var_cas_inheritedSignature,  var_cas_inheritedDeclarationLocation COMMA_SOURCE_FILE_AT_LINE (679)) ;
        }else if (cond_28180.isBuiltAndFalse ()) {
          const GGS_bool cond_28363 = var_cas_inheritedInstanceMethodMap.reader_hasKey (operand_27110->mMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (685))) ;
          if (cond_28363.isBuiltAndTrue ()) {
            operand_27110->mMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("this method cannot be declared as abstract, it is already declared in super class") COMMA_SOURCE_FILE_AT_LINE (687)) ;
          }
        }
        var_cas_abstractMethodList.addAssign_operation (operand_27110->mIsOverriding, operand_27110->mMethodName, var_cas_formalParameterListForGeneration) ;
      }
    }
    GGS_methodDefinitionListForGeneration  var_cas_methodList = GGS_methodDefinitionListForGeneration ::constructor_emptyList () ;
    GGS_stringset  var_cas_definedMethodSet = GGS_stringset ::constructor_emptySet () ;
    const GGS_analysisContext var_cas_analysisContext = GGS_analysisContext::constructor_new (var_cas_inSemanticContext, var_cas_inPredefinedTypes, var_cas_selfType, GGS_string ("this")) ;
    {
      GGS_methodDefinitionListAST::cEnumerator enumerator_28741 (operand_25318->mMethodList, true) ;
      const GGS_methodDefinitionListAST::cElement * operand_28741 = NULL ;
      while (((operand_28741 = enumerator_28741.nextObject ()))) {
        macroValidPointer (operand_28741) ;
        GGS_formalParameterListForGeneration  var_cas_formalParameterListForGeneration = GGS_formalParameterListForGeneration ::constructor_emptyList () ;
        GGS_semanticInstructionListForGeneration  var_cas_semanticInstructionListForGeneration ;
        ::routine_analyzeRoutineBody (inLexique,  var_cas_analysisContext,  operand_28741->mSignature,  GGS_localConstantList ::constructor_emptyList (),  var_cas_allAttributeList,  GGS_string (""),  operand_28741->mInstructionList,  operand_28741->mEndOfMethodLocation,  var_cas_semanticInstructionListForGeneration,  var_cas_formalParameterListForGeneration COMMA_SOURCE_FILE_AT_LINE (703)) ;
        const GGS_bool cond_29880 = operand_28741->mIsOverriding ;
        if (cond_29880.isBuiltAndTrue ()) {
          GGS_formalParameterSignature  var_cas_inheritedSignature ;
          GGS_location  var_cas_inheritedDeclarationLocation ;
          GGS_bool var_cas_inheritedIsCategory ;
          GGS_bool automatic_var_29528_0 ;
          GGS_methodQualifier automatic_var_29528_1 ;
          if (var_cas_inheritedInstanceMethodMap.isBuilt ()) {
            var_cas_inheritedInstanceMethodMap (HERE)->method_searchInheritedKey (inLexique, operand_28741->mMethodName, var_cas_inheritedIsCategory, var_cas_inheritedSignature, var_cas_inheritedDeclarationLocation, automatic_var_29528_0, automatic_var_29528_1 COMMA_SOURCE_FILE_AT_LINE (719)) ;
          }
          ::routine_checkMethodSignatures (inLexique,  var_cas_formalParameterListForGeneration,  operand_28741->mMethodName.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (722)),  var_cas_inheritedSignature,  var_cas_inheritedDeclarationLocation COMMA_SOURCE_FILE_AT_LINE (720)) ;
          const GGS_bool cond_29865 = var_cas_inheritedIsCategory ;
          if (cond_29865.isBuiltAndTrue ()) {
            operand_28741->mMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("this method is declared in class, but overriden method is declared as multi-method") COMMA_SOURCE_FILE_AT_LINE (728)) ;
          }
        }else if (cond_29880.isBuiltAndFalse ()) {
          const GGS_bool cond_30069 = var_cas_inheritedInstanceMethodMap.reader_hasKey (operand_28741->mMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (729))) ;
          if (cond_30069.isBuiltAndTrue ()) {
            operand_28741->mMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("this method should be declared as overridding, as it is already declared in super class") COMMA_SOURCE_FILE_AT_LINE (731)) ;
          }
        }
        var_cas_definedMethodSet.addAssign_operation (operand_28741->mMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (733))) ;
        var_cas_methodList.addAssign_operation (operand_28741->mIsOverriding, operand_28741->mMethodName, var_cas_formalParameterListForGeneration, var_cas_semanticInstructionListForGeneration) ;
      }
    }
    const GGS_bool cond_30814 = (operand_25318->mIsAbstract).operator_not () ;
    if (cond_30814.isBuiltAndTrue ()) {
      {
        GGS_instanceMethodMap::cEnumerator enumerator_30412 (var_cas_inheritedInstanceMethodMap, true) ;
        const GGS_instanceMethodMap::cElement * operand_30412 = NULL ;
        while (((operand_30412 = enumerator_30412.nextObject ()))) {
          macroValidPointer (operand_30412) ;
          const GGS_bool cond_30785 = ((operand_30412->mInfo.mQualifier).operator_isEqual (GGS_methodQualifier::constructor_isAbstract (inLexique COMMA_SOURCE_FILE_AT_LINE (744)))).operator_or ((operand_30412->mInfo.mQualifier).operator_isEqual (GGS_methodQualifier::constructor_isOverridingAbstract (inLexique COMMA_SOURCE_FILE_AT_LINE (744)))) ;
          if (cond_30785.isBuiltAndTrue ()) {
            const GGS_bool cond_30766 = (var_cas_definedMethodSet.reader_hasKey (operand_30412->mKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (745)))).operator_not () ;
            if (cond_30766.isBuiltAndTrue ()) {
              operand_30412->mKey.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((GGS_string ("the '@")).operator_concat (operand_25318->mClassTypeName)).operator_concat (GGS_string ("' class is declared concrete, but the '"))).operator_concat (operand_30412->mKey)).operator_concat (GGS_string ("' method declared in a super class is not implemented")) COMMA_SOURCE_FILE_AT_LINE (747)) ;
            }
          }
        }
      }
    }
    GGS_string var_cas_sortString = var_cas_selfType.reader_key (inLexique COMMA_SOURCE_FILE_AT_LINE (752)) ;
    GGS_unifiedTypeMapProxy  var_cas_t = var_cas_selfType.reader_mSuperType (inLexique COMMA_SOURCE_FILE_AT_LINE (753)) ;
    GGS_uint _variant_31128 = var_cas_inSemanticContext.mTypeMap.reader_count ().add_operation (inLexique, GGS_uint (1U) COMMA_SOURCE_FILE_AT_LINE (754)) ;
    GGS_bool _condition_31128 (_variant_31128.isBuilt (), true) ;
    while (_condition_31128.isBuiltAndTrue ()) {
      _condition_31128 = (var_cas_t.reader_isNull (inLexique COMMA_SOURCE_FILE_AT_LINE (755))).operator_not () ;
      if (_condition_31128.isBuiltAndTrue ()) {
        if (_variant_31128.uintValue () == 0) {
          inLexique.onTheFlyRunTimeError ("loop variant error" COMMA_SOURCE_FILE_AT_LINE (758)) ;
          _condition_31128 = GGS_bool (false) ;
        }else{
          _variant_31128.decrement_operation (inLexique COMMA_HERE) ;
          var_cas_sortString = ((var_cas_t.reader_key (inLexique COMMA_SOURCE_FILE_AT_LINE (756))).operator_concat (GGS_string ("."))).operator_concat (var_cas_sortString) ;
          var_cas_t = var_cas_t.reader_mSuperType (inLexique COMMA_SOURCE_FILE_AT_LINE (757)) ;
        }
      }
    }
    var_cas_ioSemanticDeclarationListForGeneration.addAssign_operation (GGS_classTypeForGeneration ::constructor_new (inLexique, GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_25318->mClassTypeName COMMA_SOURCE_FILE_AT_LINE (761)), operand_25318->mIsAbstract, operand_25318->mClassTypeName, var_cas_superClassProxy, var_cas_allAttributeList, var_cas_typedAttributeList, var_cas_abstractMethodList, var_cas_methodList, var_cas_selfType.reader_mInstanceMethodMap (inLexique COMMA_SOURCE_FILE_AT_LINE (769)) COMMA_SOURCE_FILE_AT_LINE (760)), var_cas_sortString) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Implementation of routine "analyzeFunctionBody"               *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_analyzeFunctionBody (C_Compiler & inLexique,
                                const GGS_analysisContext  var_cas_inAnalysisContext,
                                const GGS_formalInputParameterListAST   var_cas_inFunctionSignature,
                                const GGS_semanticInstructionListAST   var_cas_inInstructionList,
                                const GGS_lstring   var_cas_inReturnVariableName,
                                const GGS_lstring   var_cas_inResultTypeName,
                                const GGS_location   var_cas_inEndOfFunctionLocation,
                                GGS_formalInputParameterListForGeneration  & var_cas_outSignatureForGeneration,
                                GGS_unifiedTypeMapProxy  & var_cas_outReturnedType,
                                GGS_string & var_cas_outResultVariableCppName,
                                GGS_semanticInstructionListForGeneration  & var_cas_outSemanticInstructionListForGeneration
                        COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_analyzeFunctionBody at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_variableMap  var_cas_variableMap = GGS_variableMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (789)) ;
  var_cas_outSignatureForGeneration = GGS_formalInputParameterListForGeneration ::constructor_emptyList () ;
  {
    GGS_formalInputParameterListAST::cEnumerator enumerator_32276 (var_cas_inFunctionSignature, true) ;
    const GGS_formalInputParameterListAST::cElement * operand_32276 = NULL ;
    while (((operand_32276 = enumerator_32276.nextObject ()))) {
      macroValidPointer (operand_32276) ;
      const GGS_unifiedTypeMapProxy  var_cas_parameterType = GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inAnalysisContext.mSemanticContext.mTypeMap, operand_32276->mFormalArgumentTypeName COMMA_SOURCE_FILE_AT_LINE (793)) ;
      const GGS_bool cond_32940 = operand_32276->mIsConstant ;
      if (cond_32940.isBuiltAndTrue ()) {
        const GGS_string var_cas_cppName = (GGS_string ("constinArgument_")).operator_concat (operand_32276->mFormalArgumentName.ggs_string ().reader_identifierRepresentation ()) ;
        var_cas_outSignatureForGeneration.addAssign_operation (var_cas_parameterType, var_cas_cppName, operand_32276->mIsUnused) ;
        const GGS_bool cond_32802 = operand_32276->mIsUnused ;
        if (cond_32802.isBuiltAndTrue ()) {
          var_cas_variableMap.modifier_insertConstantInputFormalArgumentDeclaredAsUnused (inLexique, operand_32276->mFormalArgumentName, var_cas_parameterType, var_cas_cppName, var_cas_cppName COMMA_SOURCE_FILE_AT_LINE (802)) ;
        }else if (cond_32802.isBuiltAndFalse ()) {
          var_cas_variableMap.modifier_insertConstantInputFormalArgument (inLexique, operand_32276->mFormalArgumentName, var_cas_parameterType, var_cas_cppName, var_cas_cppName COMMA_SOURCE_FILE_AT_LINE (804)) ;
        }
      }else if (cond_32940.isBuiltAndFalse ()) {
        const GGS_string var_cas_cppName = (GGS_string ("inArgument_")).operator_concat (operand_32276->mFormalArgumentName.ggs_string ().reader_identifierRepresentation ()) ;
        var_cas_outSignatureForGeneration.addAssign_operation (var_cas_parameterType, var_cas_cppName, operand_32276->mIsUnused) ;
        const GGS_bool cond_33295 = operand_32276->mIsUnused ;
        if (cond_33295.isBuiltAndTrue ()) {
          var_cas_variableMap.modifier_insertInputFormalArgumentDeclaredAsUnused (inLexique, operand_32276->mFormalArgumentName, var_cas_parameterType, var_cas_cppName, var_cas_cppName COMMA_SOURCE_FILE_AT_LINE (814)) ;
        }else if (cond_33295.isBuiltAndFalse ()) {
          var_cas_variableMap.modifier_insertInputFormalArgument (inLexique, operand_32276->mFormalArgumentName, var_cas_parameterType, var_cas_cppName, var_cas_cppName COMMA_SOURCE_FILE_AT_LINE (816)) ;
        }
      }
    }
  }
  var_cas_outReturnedType = GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inAnalysisContext.mSemanticContext.mTypeMap, var_cas_inResultTypeName COMMA_SOURCE_FILE_AT_LINE (821)) ;
  var_cas_outResultVariableCppName = (GGS_string ("result_")).operator_concat (var_cas_inResultTypeName.ggs_string ().reader_identifierRepresentation ()) ;
  var_cas_variableMap.modifier_insertOutputFormalArgument (inLexique, var_cas_inReturnVariableName, var_cas_outReturnedType, var_cas_outResultVariableCppName, var_cas_outResultVariableCppName COMMA_SOURCE_FILE_AT_LINE (823)) ;
  var_cas_outSemanticInstructionListForGeneration = GGS_semanticInstructionListForGeneration ::constructor_emptyList () ;
  {
    GGS_semanticInstructionListAST::cEnumerator enumerator_33975 (var_cas_inInstructionList, true) ;
    const GGS_semanticInstructionListAST::cElement * operand_33975 = NULL ;
    while (((operand_33975 = enumerator_33975.nextObject ()))) {
      macroValidPointer (operand_33975) ;
      { typeCategoryMethod__semanticInstructionAST__analyzeSemanticInstruction method = findCategoryMethod__semanticInstructionAST__analyzeSemanticInstruction (operand_33975->mInstruction.galgasObjectRunTimeInfo ()) ;
        if (method != NULL) {
          method (inLexique, operand_33975->mInstruction (HERE), var_cas_inAnalysisContext, var_cas_outSemanticInstructionListForGeneration, var_cas_variableMap COMMA_SOURCE_FILE_AT_LINE (827)) ;
        }
      }
    }
  }
  if (var_cas_variableMap.isBuilt ()) {
    var_cas_variableMap (HERE)->method_checkAutomatonStates (inLexique, var_cas_inEndOfFunctionLocation COMMA_SOURCE_FILE_AT_LINE (834)) ;
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_analyzeFunctionBody\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//    Category method '@functionDeclarationAST.performSemanticAnalysis'      *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__functionDeclarationAST__performSemanticAnalysis (C_Compiler & inLexique,
                                const cPtr_functionDeclarationAST * operand_34368,
                                const GGS_semanticContext  var_cas_inSemanticContext,
                                const GGS_predefinedTypes  var_cas_inPredefinedTypes,
                                GGS_semanticDeclarationSortedListForGeneration  & var_cas_ioSemanticDeclarationListForGeneration
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_34368 != NULL) {
    GGS_semanticInstructionListForGeneration  var_cas_semanticInstructionListForGeneration ;
    GGS_formalInputParameterListForGeneration  var_cas_formalInputParameterList ;
    GGS_unifiedTypeMapProxy  var_cas_returnType ;
    GGS_string var_cas_resultVariableCppName ;
    const GGS_analysisContext var_cas_analysisContext = GGS_analysisContext::constructor_new (var_cas_inSemanticContext, var_cas_inPredefinedTypes, GGS_unifiedTypeMapProxy ::constructor_null (inLexique COMMA_SOURCE_FILE_AT_LINE (852)), GGS_string ("")) ;
    ::routine_analyzeFunctionBody (inLexique,  var_cas_analysisContext,  operand_34368->mFormalArgumentList,  operand_34368->mFunctionInstructionList,  operand_34368->mResultVariableName,  operand_34368->mResultTypeName,  operand_34368->mEndOfFunctionInstructionList,  var_cas_formalInputParameterList,  var_cas_returnType,  var_cas_resultVariableCppName,  var_cas_semanticInstructionListForGeneration COMMA_SOURCE_FILE_AT_LINE (855)) ;
    var_cas_ioSemanticDeclarationListForGeneration.addAssign_operation (GGS_functionImplementationForGeneration ::constructor_new (inLexique, operand_34368->mFunctionName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (869)), var_cas_formalInputParameterList, var_cas_returnType, var_cas_resultVariableCppName, var_cas_semanticInstructionListForGeneration COMMA_SOURCE_FILE_AT_LINE (868)), GGS_string ("")) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//  Category method '@onceFunctionDeclarationAST.performSemanticAnalysis'    *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__onceFunctionDeclarationAST__performSemanticAnalysis (C_Compiler & inLexique,
                                const cPtr_onceFunctionDeclarationAST * operand_35628,
                                const GGS_semanticContext  var_cas_inSemanticContext,
                                const GGS_predefinedTypes  var_cas_inPredefinedTypes,
                                GGS_semanticDeclarationSortedListForGeneration  & var_cas_ioSemanticDeclarationListForGeneration
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_35628 != NULL) {
    GGS_semanticInstructionListForGeneration  var_cas_semanticInstructionListForGeneration ;
    GGS_unifiedTypeMapProxy  var_cas_returnType ;
    GGS_string var_cas_resultVariableCppName ;
    const GGS_analysisContext var_cas_analysisContext = GGS_analysisContext::constructor_new (var_cas_inSemanticContext, var_cas_inPredefinedTypes, GGS_unifiedTypeMapProxy ::constructor_null (inLexique COMMA_SOURCE_FILE_AT_LINE (893)), GGS_string ("")) ;
    GGS_formalInputParameterListForGeneration  automatic_var_36408_0 ;
    ::routine_analyzeFunctionBody (inLexique,  var_cas_analysisContext,  GGS_formalInputParameterListAST ::constructor_emptyList (),  operand_35628->mFunctionInstructionList,  operand_35628->mResultVariableName,  operand_35628->mResultTypeName,  operand_35628->mEndOfFunctionInstructionList,  automatic_var_36408_0,  var_cas_returnType,  var_cas_resultVariableCppName,  var_cas_semanticInstructionListForGeneration COMMA_SOURCE_FILE_AT_LINE (896)) ;
    var_cas_ioSemanticDeclarationListForGeneration.addAssign_operation (GGS_onceFunctionDeclarationForGeneration ::constructor_new (inLexique, operand_35628->mFunctionName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (910)), var_cas_returnType, var_cas_resultVariableCppName, var_cas_semanticInstructionListForGeneration COMMA_SOURCE_FILE_AT_LINE (909)), GGS_string ("")) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'e_filewrapperRegularFileMap'                     *
//                                                                           *
//---------------------------------------------------------------------------*

e_filewrapperRegularFileMap::e_filewrapperRegularFileMap (void) :
mWrapperDirectoryIndex (),
mWrapperFileIndex () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class map '@filewrapperRegularFileMap'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_filewrapperRegularFileMap ("filewrapperRegularFileMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_filewrapperRegularFileMap::
elementOf_GGS_filewrapperRegularFileMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_filewrapperRegularFileMap & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_filewrapperRegularFileMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mWrapperDirectoryIndex.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mWrapperFileIndex.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_filewrapperRegularFileMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_filewrapperRegularFileMap * ptr = dynamic_cast <const elementOf_GGS_filewrapperRegularFileMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mWrapperDirectoryIndex.operator_isEqual (ptr->mInfo.mWrapperDirectoryIndex)).boolValue ()
           && (mInfo.mWrapperFileIndex.operator_isEqual (ptr->mInfo.mWrapperFileIndex)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_filewrapperRegularFileMap::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_filewrapperRegularFileMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_filewrapperRegularFileMap * info = (e_filewrapperRegularFileMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperRegularFileMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_filewrapperRegularFileMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_filewrapperRegularFileMap * info = (e_filewrapperRegularFileMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperRegularFileMap GGS_filewrapperRegularFileMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_filewrapperRegularFileMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperRegularFileMap::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_filewrapperRegularFileMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_filewrapperRegularFileMap::
operator_isEqual (const GGS_filewrapperRegularFileMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_filewrapperRegularFileMap::
operator_isNotEqual (const GGS_filewrapperRegularFileMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperRegularFileMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperRegularFileMap::
insertElement (C_Compiler & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_uint & inParameter0,
               const GGS_uint & inParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap (THERE) ;
    e_filewrapperRegularFileMap info  ;
    info.mWrapperDirectoryIndex = inParameter0 ;
    info.mWrapperFileIndex = inParameter1 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_filewrapperRegularFileMap::
searchElement (C_Compiler & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_uint   & outParameter0,
               GGS_uint   & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    outParameter0 = node->mInfo.mWrapperDirectoryIndex ;
    outParameter1 = node->mInfo.mWrapperFileIndex ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_filewrapperRegularFileMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE (' '),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('g'),
  TO_UNICODE ('u'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('a'),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_filewrapperRegularFileMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_uint   & outParameter0,
                                GGS_uint   & outParameter1 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 0,
                 kSearchMessage_searchKey,
                 inKey,
                 outParameter0,
                 outParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_filewrapperRegularFileMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('a'),
  TO_UNICODE (' '),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('g'),
  TO_UNICODE ('u'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('a'),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_filewrapperRegularFileMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_uint & inParameter0,
                                const GGS_uint & inParameter1 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                NULL
                COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperRegularFileMap GGS_filewrapperRegularFileMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_filewrapperRegularFileMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_filewrapperRegularFileMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperRegularFileMap GGS_filewrapperRegularFileMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_filewrapperRegularFileMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_filewrapperRegularFileMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @filewrapperRegularFileMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_filewrapperRegularFileMap::cEnumerator::_mWrapperDirectoryIndex (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mWrapperDirectoryIndex ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_filewrapperRegularFileMap::cEnumerator::_mWrapperFileIndex (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mWrapperFileIndex ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_filewrapperRegularFileMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_filewrapperRegularFileMap * p = NULL ;
    macroMyNew (p, GGS_filewrapperRegularFileMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperRegularFileMap GGS_filewrapperRegularFileMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_filewrapperRegularFileMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_filewrapperRegularFileMap * p = dynamic_cast <const GGS_filewrapperRegularFileMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_filewrapperRegularFileMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_filewrapperRegularFileMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_filewrapperRegularFileMap ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperRegularFileMap GGS_filewrapperRegularFileMap::constructor_mapWithKeyAndValue (C_Compiler & inLexique,
                                             const GGS_lstring & inKey,
                                             const GGS_uint & inValue0,
                                             const GGS_uint & inValue1
                                             COMMA_LOCATION_ARGS) {
  GGS_filewrapperRegularFileMap result = constructor_emptyMap (inLexique COMMA_THERE) ;
  result.insertElement (inLexique,
                        0,
                        NULL,
                        inKey,
                        inValue0,
                        inValue1,
                        NULL
                        COMMA_THERE) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//       Implementation of routine "recursivelyEnumerateDirectories"         *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_recursivelyEnumerateDirectories (C_Compiler & inLexique,
                                const GGS_string  var_cas_inAbsoluteSourcePath,
                                const GGS_string  var_cas_inPathInWrapper,
                                const GGS_wrapperExtensionMap   var_cas_inExtensionMap,
                                GGS_wrapperFileSortedList  & var_cas_outWrapperFileSortedList,
                                GGS_wrapperDirectorySortedList  & var_cas_outWrapperDirectorySortedList,
                                GGS_uint  & var_cas_ioWrapperFileIndex,
                                GGS_uint  & var_cas_ioWrapperDirectoryIndex,
                                GGS_filewrapperRegularFileMap  & var_cas_ioRegularFileMap
                        COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_recursivelyEnumerateDirectories at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_uint  var_cas_currentDirectoryIndex = var_cas_ioWrapperDirectoryIndex ;
  var_cas_ioWrapperDirectoryIndex.increment_operation (inLexique COMMA_SOURCE_FILE_AT_LINE (945)) ;
  GGS_stringlist  var_cas_files = var_cas_inAbsoluteSourcePath.reader_regularFiles (GGS_bool (false)) ;
  var_cas_outWrapperFileSortedList = GGS_wrapperFileSortedList ::constructor_emptySortedList () ;
  {
    GGS_stringlist::cEnumerator enumerator_38014 (var_cas_files, true) ;
    const GGS_stringlist::cElement * operand_38014 = NULL ;
    while (((operand_38014 = enumerator_38014.nextObject ()))) {
      macroValidPointer (operand_38014) ;
      const GGS_bool cond_38521 = var_cas_inExtensionMap.reader_hasKey (operand_38014->mValue.reader_pathExtension ()) ;
      if (cond_38521.isBuiltAndTrue ()) {
        GGS_string var_cas_absoluteFilePath = ((var_cas_inAbsoluteSourcePath).operator_concat (GGS_string ("/"))).operator_concat (operand_38014->mValue) ;
        var_cas_outWrapperFileSortedList.addAssign_operation (operand_38014->mValue, var_cas_absoluteFilePath, var_cas_currentDirectoryIndex, var_cas_ioWrapperFileIndex) ;
        var_cas_ioRegularFileMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, (var_cas_inPathInWrapper).operator_concat (operand_38014->mValue), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (960)), var_cas_currentDirectoryIndex, var_cas_ioWrapperFileIndex COMMA_SOURCE_FILE_AT_LINE (959)) ;
        var_cas_ioWrapperFileIndex.increment_operation (inLexique COMMA_SOURCE_FILE_AT_LINE (964)) ;
      }
    }
  }
  GGS_stringlist  var_cas_directories = var_cas_inAbsoluteSourcePath.reader_directories (GGS_bool (false)) ;
  var_cas_outWrapperDirectorySortedList = GGS_wrapperDirectorySortedList ::constructor_emptySortedList () ;
  {
    GGS_stringlist::cEnumerator enumerator_38756 (var_cas_directories, true) ;
    const GGS_stringlist::cElement * operand_38756 = NULL ;
    while (((operand_38756 = enumerator_38756.nextObject ()))) {
      macroValidPointer (operand_38756) ;
      GGS_wrapperFileSortedList  var_cas_internalWrapperFileSortedList ;
      GGS_wrapperDirectorySortedList  var_cas_internalWrapperDirectorySortedList ;
      GGS_uint  var_cas_theDirectoryIndex = var_cas_ioWrapperDirectoryIndex ;
      ::routine_recursivelyEnumerateDirectories (inLexique,  ((var_cas_inAbsoluteSourcePath).operator_concat (GGS_string ("/"))).operator_concat (operand_38756->mValue),  ((var_cas_inPathInWrapper).operator_concat (operand_38756->mValue)).operator_concat (GGS_string ("/")),  var_cas_inExtensionMap,  var_cas_internalWrapperFileSortedList,  var_cas_internalWrapperDirectorySortedList,  var_cas_ioWrapperFileIndex,  var_cas_ioWrapperDirectoryIndex,  var_cas_ioRegularFileMap COMMA_SOURCE_FILE_AT_LINE (974)) ;
      var_cas_outWrapperDirectorySortedList.addAssign_operation (operand_38756->mValue, var_cas_internalWrapperFileSortedList, var_cas_internalWrapperDirectorySortedList, var_cas_theDirectoryIndex) ;
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_recursivelyEnumerateDirectories\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//   Category method '@filewrapperDeclarationAST.performSemanticAnalysis'    *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__filewrapperDeclarationAST__performSemanticAnalysis (C_Compiler & inLexique,
                                const cPtr_filewrapperDeclarationAST * operand_39590,
                                const GGS_semanticContext  var_cas_inSemanticContext,
                                const GGS_predefinedTypes  /* var_cas_inPredefinedTypes */,
                                GGS_semanticDeclarationSortedListForGeneration  & var_cas_ioSemanticDeclarationListForGeneration
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_39590 != NULL) {
    GGS_wrapperExtensionMap  var_cas_extensionMap = GGS_wrapperExtensionMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1001)) ;
    {
      GGS_lstringlist::cEnumerator enumerator_39874 (operand_39590->mFilewrapperExtensionList, true) ;
      const GGS_lstringlist::cElement * operand_39874 = NULL ;
      while (((operand_39874 = enumerator_39874.nextObject ()))) {
        macroValidPointer (operand_39874) ;
        var_cas_extensionMap.modifier_insertKey (inLexique, operand_39874->mValue COMMA_SOURCE_FILE_AT_LINE (1003)) ;
      }
    }
    GGS_filewrapperRegularFileMap  var_cas_regularFileMap = GGS_filewrapperRegularFileMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1006)) ;
    GGS_string var_cas_absoluteSourcePath ;
    const GGS_bool cond_40164 = (operand_39590->mFilewrapperPath.ggs_string ().reader_firstCharacterOrNul ()).operator_isEqual (GGS_char (TO_UNICODE ('/'))) ;
    if (cond_40164.isBuiltAndTrue ()) {
      var_cas_absoluteSourcePath = operand_39590->mFilewrapperPath.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1009)) ;
    }else if (cond_40164.isBuiltAndFalse ()) {
      var_cas_absoluteSourcePath = ((var_cas_inSemanticContext.reader_mSourceFileAbsolutePath (inLexique COMMA_SOURCE_FILE_AT_LINE (1011)).reader_stringByDeletingLastPathComponent ()).operator_concat (GGS_string ("/"))).operator_concat (operand_39590->mFilewrapperPath.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1011))) ;
    }
    const GGS_bool cond_40465 = (var_cas_absoluteSourcePath.reader_directoryExists ()).operator_not () ;
    if (cond_40465.isBuiltAndTrue ()) {
      operand_39590->mFilewrapperPath.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("The '")).operator_concat (var_cas_absoluteSourcePath)).operator_concat (GGS_string ("' directory does not exist")) COMMA_SOURCE_FILE_AT_LINE (1015)) ;
    }else if (cond_40465.isBuiltAndFalse ()) {
      GGS_wrapperFileSortedList  var_cas_wrapperFileSortedList ;
      GGS_wrapperDirectorySortedList  var_cas_wrapperDirectorySortedList ;
      GGS_uint  var_cas_wrapperFileIndex = GGS_uint (0U) ;
      GGS_uint  var_cas_wrapperDirectoryIndex = GGS_uint (0U) ;
      ::routine_recursivelyEnumerateDirectories (inLexique,  var_cas_absoluteSourcePath,  GGS_string ("/"),  var_cas_extensionMap,  var_cas_wrapperFileSortedList,  var_cas_wrapperDirectorySortedList,  var_cas_wrapperFileIndex,  var_cas_wrapperDirectoryIndex,  var_cas_regularFileMap COMMA_SOURCE_FILE_AT_LINE (1021)) ;
      {
        GGS_filewrapperTemplateListAST::cEnumerator enumerator_40980 (operand_39590->mFilewrapperTemplateList, true) ;
        const GGS_filewrapperTemplateListAST::cElement * operand_40980 = NULL ;
        while (((operand_40980 = enumerator_40980.nextObject ()))) {
          macroValidPointer (operand_40980) ;
          GGS_string var_cas_absoluteTemplatePath ;
          const GGS_bool cond_41167 = (operand_40980->mFilewrapperTemplatePath.ggs_string ().reader_firstCharacterOrNul ()).operator_isEqual (GGS_char (TO_UNICODE ('/'))) ;
          if (cond_41167.isBuiltAndTrue ()) {
            var_cas_absoluteTemplatePath = operand_40980->mFilewrapperTemplatePath.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1035)) ;
          }else if (cond_41167.isBuiltAndFalse ()) {
            var_cas_absoluteTemplatePath = ((var_cas_inSemanticContext.reader_mSourceFileAbsolutePath (inLexique COMMA_SOURCE_FILE_AT_LINE (1037)).reader_stringByDeletingLastPathComponent ()).operator_concat (GGS_string ("/"))).operator_concat (operand_40980->mFilewrapperTemplatePath.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1037))) ;
          }
          GGS_templateInstructionListAST  var_cas_resultingInstructionList ;
          const GGS_string _depExtension = GGS_string ("") ;
          const GGS_string _depPath = GGS_string ("") ;
          if (_depExtension.isBuilt () && _depPath.isBuilt ()) {
            C_Grammar_templateGrammar::_performSourceFileParsing_ (inLexique,
                                          _depExtension.string (),
                                          _depPath.string (),
                                          NULL,
                                          GGS_lstring ::constructor_new (inLexique, var_cas_absoluteTemplatePath, operand_40980->mFilewrapperTemplatePath.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (1040)) COMMA_SOURCE_FILE_AT_LINE (1040)),
                                          var_cas_resultingInstructionList
                                          COMMA_SOURCE_FILE_AT_LINE (1040)) ;
          }
          inLexique.printMessage (C_String ("LOGGING resultingInstructionList: ") + var_cas_resultingInstructionList.reader_description ().string () + "\n" COMMA_SOURCE_FILE_AT_LINE (1041)) ;
        }
      }
      var_cas_ioSemanticDeclarationListForGeneration.addAssign_operation (GGS_filewrapperDeclarationForGeneration ::constructor_new (inLexique, operand_39590->mFilewrapperName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1045)), operand_39590->mFilewrapperPath.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1046)), var_cas_extensionMap, var_cas_wrapperFileSortedList, var_cas_wrapperDirectorySortedList COMMA_SOURCE_FILE_AT_LINE (1044)), GGS_string ("")) ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//   Category method '@abstractCategoryMethodAST.performSemanticAnalysis'    *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__abstractCategoryMethodAST__performSemanticAnalysis (C_Compiler & inLexique,
                                const cPtr_abstractCategoryMethodAST * operand_42058,
                                const GGS_semanticContext  var_cas_inSemanticContext,
                                const GGS_predefinedTypes  /* var_cas_inPredefinedTypes */,
                                GGS_semanticDeclarationSortedListForGeneration  & var_cas_ioSemanticDeclarationListForGeneration
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_42058 != NULL) {
    const GGS_unifiedTypeMapProxy  var_cas_selfType = GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_42058->mTypeName COMMA_SOURCE_FILE_AT_LINE (1064)) ;
    const GGS_bool cond_42595 = (var_cas_selfType.reader_mTypeKindEnum (inLexique COMMA_SOURCE_FILE_AT_LINE (1066))).operator_isNotEqual (GGS_typeKindEnum::constructor_classType (inLexique COMMA_SOURCE_FILE_AT_LINE (1066))) ;
    if (cond_42595.isBuiltAndTrue ()) {
      operand_42058->mAbstractCategoryMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("cannot declare a category method: '@")).operator_concat (var_cas_selfType.reader_key (inLexique COMMA_SOURCE_FILE_AT_LINE (1067)))).operator_concat (GGS_string ("' is not a class")) COMMA_SOURCE_FILE_AT_LINE (1068)) ;
    }else if (cond_42595.isBuiltAndFalse ()) {
      const GGS_bool cond_42767 = var_cas_selfType.reader_mIsConcrete (inLexique COMMA_SOURCE_FILE_AT_LINE (1068)) ;
      if (cond_42767.isBuiltAndTrue ()) {
        operand_42058->mAbstractCategoryMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("cannot declare an abstract category method: '@")).operator_concat (var_cas_selfType.reader_key (inLexique COMMA_SOURCE_FILE_AT_LINE (1069)))).operator_concat (GGS_string ("' is not an abstract class")) COMMA_SOURCE_FILE_AT_LINE (1070)) ;
      }
    }
    GGS_formalParameterListForGeneration  var_cas_formalParameterListForGeneration = GGS_formalParameterListForGeneration ::constructor_emptyList () ;
    {
      GGS_formalParameterListAST::cEnumerator enumerator_42938 (operand_42058->mAbstractCategoryMethodFormalParameterList, true) ;
      const GGS_formalParameterListAST::cElement * operand_42938 = NULL ;
      while (((operand_42938 = enumerator_42938.nextObject ()))) {
        macroValidPointer (operand_42938) ;
        var_cas_formalParameterListForGeneration.addAssign_operation (operand_42938->mFormalArgumentPassingMode, GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_42938->mFormalArgumentTypeName COMMA_SOURCE_FILE_AT_LINE (1076)), operand_42938->mFormalArgumentName, operand_42938->mFormalArgumentName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1078))) ;
      }
    }
    var_cas_ioSemanticDeclarationListForGeneration.addAssign_operation (GGS_abstractCategoryMethodForGeneration ::constructor_new (inLexique, operand_42058->mTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1083)), operand_42058->mAbstractCategoryMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1084)), var_cas_formalParameterListForGeneration COMMA_SOURCE_FILE_AT_LINE (1082)), var_cas_selfType.reader_key (inLexique COMMA_SOURCE_FILE_AT_LINE (1087))) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//       Category method '@categoryMethodAST.performSemanticAnalysis'        *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__categoryMethodAST__performSemanticAnalysis (C_Compiler & inLexique,
                                const cPtr_categoryMethodAST * operand_43568,
                                const GGS_semanticContext  var_cas_inSemanticContext,
                                const GGS_predefinedTypes  var_cas_inPredefinedTypes,
                                GGS_semanticDeclarationSortedListForGeneration  & var_cas_ioSemanticDeclarationListForGeneration
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_43568 != NULL) {
    const GGS_unifiedTypeMapProxy  var_cas_selfType = GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_43568->mTypeName COMMA_SOURCE_FILE_AT_LINE (1099)) ;
    const GGS_bool cond_44078 = (var_cas_selfType.reader_mTypeKindEnum (inLexique COMMA_SOURCE_FILE_AT_LINE (1101))).operator_isNotEqual (GGS_typeKindEnum::constructor_classType (inLexique COMMA_SOURCE_FILE_AT_LINE (1101))) ;
    if (cond_44078.isBuiltAndTrue ()) {
      operand_43568->mCategoryMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("cannot declare a category method: '@")).operator_concat (var_cas_selfType.reader_key (inLexique COMMA_SOURCE_FILE_AT_LINE (1102)))).operator_concat (GGS_string ("' is not a class")) COMMA_SOURCE_FILE_AT_LINE (1103)) ;
    }
    GGS_formalParameterListForGeneration  var_cas_formalParameterListForGeneration = GGS_formalParameterListForGeneration ::constructor_emptyList () ;
    GGS_semanticInstructionListForGeneration  var_cas_semanticInstructionListForGeneration ;
    const GGS_analysisContext var_cas_analysisContext = GGS_analysisContext::constructor_new (var_cas_inSemanticContext, var_cas_inPredefinedTypes, var_cas_selfType, GGS_string ("object")) ;
    ::routine_analyzeRoutineBody (inLexique,  var_cas_analysisContext,  operand_43568->mCategoryMethodFormalParameterList,  GGS_localConstantList ::constructor_emptyList (),  var_cas_selfType.reader_mAllTypedAttributeList (inLexique COMMA_SOURCE_FILE_AT_LINE (1117)),  GGS_string ("object->"),  operand_43568->mCategoryMethodInstructionList,  operand_43568->mEndOfMethodLocation,  var_cas_semanticInstructionListForGeneration,  var_cas_formalParameterListForGeneration COMMA_SOURCE_FILE_AT_LINE (1113)) ;
    var_cas_ioSemanticDeclarationListForGeneration.addAssign_operation (GGS_categoryMethodForGeneration ::constructor_new (inLexique, operand_43568->mTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1126)), operand_43568->mCategoryMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1127)), var_cas_formalParameterListForGeneration, var_cas_selfType.reader_mAllTypedAttributeList (inLexique COMMA_SOURCE_FILE_AT_LINE (1129)), var_cas_semanticInstructionListForGeneration COMMA_SOURCE_FILE_AT_LINE (1125)), var_cas_selfType.reader_key (inLexique COMMA_SOURCE_FILE_AT_LINE (1132))) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//  Category method '@overridingCategoryMethodAST.performSemanticAnalysis'   *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__overridingCategoryMethodAST__performSemanticAnalysis (C_Compiler & inLexique,
                                const cPtr_overridingCategoryMethodAST * operand_45169,
                                const GGS_semanticContext  var_cas_inSemanticContext,
                                const GGS_predefinedTypes  var_cas_inPredefinedTypes,
                                GGS_semanticDeclarationSortedListForGeneration  & var_cas_ioSemanticDeclarationListForGeneration
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_45169 != NULL) {
    const GGS_unifiedTypeMapProxy  var_cas_selfType = GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_45169->mTypeName COMMA_SOURCE_FILE_AT_LINE (1144)) ;
    const GGS_bool cond_45689 = (var_cas_selfType.reader_mTypeKindEnum (inLexique COMMA_SOURCE_FILE_AT_LINE (1146))).operator_isNotEqual (GGS_typeKindEnum::constructor_classType (inLexique COMMA_SOURCE_FILE_AT_LINE (1146))) ;
    if (cond_45689.isBuiltAndTrue ()) {
      operand_45169->mOverridingCategoryMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("cannot declare a category method: '@")).operator_concat (var_cas_selfType.reader_key (inLexique COMMA_SOURCE_FILE_AT_LINE (1147)))).operator_concat (GGS_string ("' is not a class")) COMMA_SOURCE_FILE_AT_LINE (1148)) ;
    }
    GGS_string var_cas_baseTypeName = GGS_string ("") ;
    GGS_unifiedTypeMapProxy  var_cas_superType = var_cas_selfType.reader_mSuperType (inLexique COMMA_SOURCE_FILE_AT_LINE (1151)) ;
    GGS_formalParameterSignature  var_cas_inheritedSignature = GGS_formalParameterSignature ::constructor_emptyList () ;
    GGS_location  var_cas_inheritedDeclarationLocation = GGS_location (inLexique) ;
    GGS_uint _variant_46483 = var_cas_inSemanticContext.mTypeMap.reader_count ().add_operation (inLexique, GGS_uint (1U) COMMA_SOURCE_FILE_AT_LINE (1154)) ;
    GGS_bool _condition_46483 (_variant_46483.isBuilt (), true) ;
    while (_condition_46483.isBuiltAndTrue ()) {
      _condition_46483 = ((var_cas_superType.reader_isNull (inLexique COMMA_SOURCE_FILE_AT_LINE (1155))).operator_not ()).operator_and ((var_cas_baseTypeName).operator_isEqual (GGS_string (""))) ;
      if (_condition_46483.isBuiltAndTrue ()) {
        if (_variant_46483.uintValue () == 0) {
          inLexique.onTheFlyRunTimeError ("loop variant error" COMMA_SOURCE_FILE_AT_LINE (1164)) ;
          _condition_46483 = GGS_bool (false) ;
        }else{
          _variant_46483.decrement_operation (inLexique COMMA_HERE) ;
          const GGS_bool cond_46430 = var_cas_superType.reader_mInstanceMethodMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1156)).reader_hasKey (operand_45169->mOverridingCategoryMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1156))) ;
          if (cond_46430.isBuiltAndTrue ()) {
            GGS_methodQualifier var_cas_qualifier ;
            GGS_bool automatic_var_46304_0 ;
            GGS_bool automatic_var_46304_1 ;
            const GGS_instanceMethodMap  temp_46205 = var_cas_superType.reader_mInstanceMethodMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1158)) ;
            if (temp_46205.isBuilt ()) {
              temp_46205 (HERE)->method_searchKey (inLexique, operand_45169->mOverridingCategoryMethodName, automatic_var_46304_0, var_cas_inheritedSignature, var_cas_inheritedDeclarationLocation, automatic_var_46304_1, var_cas_qualifier COMMA_SOURCE_FILE_AT_LINE (1158)) ;
            }
            const GGS_bool cond_46417 = (var_cas_qualifier).operator_infOrEqual (GGS_methodQualifier::constructor_isBasicFinal (inLexique COMMA_SOURCE_FILE_AT_LINE (1159))) ;
            if (cond_46417.isBuiltAndTrue ()) {
              var_cas_baseTypeName = var_cas_superType.reader_key (inLexique COMMA_SOURCE_FILE_AT_LINE (1160)) ;
            }
          }
          var_cas_superType = var_cas_superType.reader_mSuperType (inLexique COMMA_SOURCE_FILE_AT_LINE (1163)) ;
        }
      }
    }
    GGS_formalParameterListForGeneration  var_cas_formalParameterListForGeneration = GGS_formalParameterListForGeneration ::constructor_emptyList () ;
    GGS_semanticInstructionListForGeneration  var_cas_semanticInstructionListForGeneration ;
    const GGS_analysisContext var_cas_analysisContext = GGS_analysisContext::constructor_new (var_cas_inSemanticContext, var_cas_inPredefinedTypes, var_cas_selfType, GGS_string ("object")) ;
    ::routine_analyzeRoutineBody (inLexique,  var_cas_analysisContext,  operand_45169->mOverridingCategoryMethodFormalParameterList,  GGS_localConstantList ::constructor_emptyList (),  var_cas_selfType.reader_mAllTypedAttributeList (inLexique COMMA_SOURCE_FILE_AT_LINE (1178)),  GGS_string ("object->"),  operand_45169->mOverridingCategoryMethodInstructionList,  operand_45169->mEndOfMethodLocation,  var_cas_semanticInstructionListForGeneration,  var_cas_formalParameterListForGeneration COMMA_SOURCE_FILE_AT_LINE (1174)) ;
    const GGS_bool cond_47385 = (var_cas_baseTypeName).operator_isNotEqual (GGS_string ("")) ;
    if (cond_47385.isBuiltAndTrue ()) {
      ::routine_checkMethodSignatures (inLexique,  var_cas_formalParameterListForGeneration,  operand_45169->mOverridingCategoryMethodName.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (1189)),  var_cas_inheritedSignature,  var_cas_inheritedDeclarationLocation COMMA_SOURCE_FILE_AT_LINE (1187)) ;
    }
    var_cas_ioSemanticDeclarationListForGeneration.addAssign_operation (GGS_overridingCategoryMethodForGeneration ::constructor_new (inLexique, operand_45169->mTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1196)), var_cas_baseTypeName, operand_45169->mOverridingCategoryMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1198)), var_cas_formalParameterListForGeneration, var_cas_selfType.reader_mAllTypedAttributeList (inLexique COMMA_SOURCE_FILE_AT_LINE (1200)), var_cas_semanticInstructionListForGeneration COMMA_SOURCE_FILE_AT_LINE (1195)), GGS_string ("{override}")) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//Category method '@overridingAbstractCategoryMethodAST.performSemanticAnalysis'*
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__overridingAbstractCategoryMethodAST__performSemanticAnalysis (C_Compiler & inLexique,
                                const cPtr_overridingAbstractCategoryMethodAST * operand_47883,
                                const GGS_semanticContext  var_cas_inSemanticContext,
                                const GGS_predefinedTypes  /* var_cas_inPredefinedTypes */,
                                GGS_semanticDeclarationSortedListForGeneration  & /* var_cas_ioSemanticDeclarationListForGeneration */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_47883 != NULL) {
    const GGS_unifiedTypeMapProxy  var_cas_selfType = GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_47883->mTypeName COMMA_SOURCE_FILE_AT_LINE (1215)) ;
    const GGS_bool cond_48424 = (var_cas_selfType.reader_mTypeKindEnum (inLexique COMMA_SOURCE_FILE_AT_LINE (1217))).operator_isNotEqual (GGS_typeKindEnum::constructor_classType (inLexique COMMA_SOURCE_FILE_AT_LINE (1217))) ;
    if (cond_48424.isBuiltAndTrue ()) {
      operand_47883->mOverridingCategoryMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("cannot declare a category method: '@")).operator_concat (var_cas_selfType.reader_key (inLexique COMMA_SOURCE_FILE_AT_LINE (1218)))).operator_concat (GGS_string ("' is not a class")) COMMA_SOURCE_FILE_AT_LINE (1219)) ;
    }else if (cond_48424.isBuiltAndFalse ()) {
      const GGS_bool cond_48598 = var_cas_selfType.reader_mIsConcrete (inLexique COMMA_SOURCE_FILE_AT_LINE (1219)) ;
      if (cond_48598.isBuiltAndTrue ()) {
        operand_47883->mOverridingCategoryMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("cannot declare an abstract category method: '@")).operator_concat (var_cas_selfType.reader_key (inLexique COMMA_SOURCE_FILE_AT_LINE (1220)))).operator_concat (GGS_string ("' is not an abstract class")) COMMA_SOURCE_FILE_AT_LINE (1221)) ;
      }
    }
    GGS_string var_cas_baseTypeName = GGS_string ("") ;
    GGS_unifiedTypeMapProxy  var_cas_superType = var_cas_selfType.reader_mSuperType (inLexique COMMA_SOURCE_FILE_AT_LINE (1224)) ;
    GGS_formalParameterSignature  var_cas_inheritedSignature = GGS_formalParameterSignature ::constructor_emptyList () ;
    GGS_location  var_cas_inheritedDeclarationLocation = GGS_location (inLexique) ;
    GGS_uint _variant_49392 = var_cas_inSemanticContext.mTypeMap.reader_count ().add_operation (inLexique, GGS_uint (1U) COMMA_SOURCE_FILE_AT_LINE (1227)) ;
    GGS_bool _condition_49392 (_variant_49392.isBuilt (), true) ;
    while (_condition_49392.isBuiltAndTrue ()) {
      _condition_49392 = ((var_cas_superType.reader_isNull (inLexique COMMA_SOURCE_FILE_AT_LINE (1228))).operator_not ()).operator_and ((var_cas_baseTypeName).operator_isEqual (GGS_string (""))) ;
      if (_condition_49392.isBuiltAndTrue ()) {
        if (_variant_49392.uintValue () == 0) {
          inLexique.onTheFlyRunTimeError ("loop variant error" COMMA_SOURCE_FILE_AT_LINE (1237)) ;
          _condition_49392 = GGS_bool (false) ;
        }else{
          _variant_49392.decrement_operation (inLexique COMMA_HERE) ;
          const GGS_bool cond_49339 = var_cas_superType.reader_mInstanceMethodMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1229)).reader_hasKey (operand_47883->mOverridingCategoryMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1229))) ;
          if (cond_49339.isBuiltAndTrue ()) {
            GGS_methodQualifier var_cas_qualifier ;
            GGS_bool automatic_var_49213_0 ;
            GGS_bool automatic_var_49213_1 ;
            const GGS_instanceMethodMap  temp_49114 = var_cas_superType.reader_mInstanceMethodMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1231)) ;
            if (temp_49114.isBuilt ()) {
              temp_49114 (HERE)->method_searchKey (inLexique, operand_47883->mOverridingCategoryMethodName, automatic_var_49213_0, var_cas_inheritedSignature, var_cas_inheritedDeclarationLocation, automatic_var_49213_1, var_cas_qualifier COMMA_SOURCE_FILE_AT_LINE (1231)) ;
            }
            const GGS_bool cond_49326 = (var_cas_qualifier).operator_infOrEqual (GGS_methodQualifier::constructor_isBasicFinal (inLexique COMMA_SOURCE_FILE_AT_LINE (1232))) ;
            if (cond_49326.isBuiltAndTrue ()) {
              var_cas_baseTypeName = var_cas_superType.reader_key (inLexique COMMA_SOURCE_FILE_AT_LINE (1233)) ;
            }
          }
          var_cas_superType = var_cas_superType.reader_mSuperType (inLexique COMMA_SOURCE_FILE_AT_LINE (1236)) ;
        }
      }
    }
    GGS_variableMap  var_cas_variableMap = GGS_variableMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1239)) ;
    GGS_formalParameterListForGeneration  var_cas_formalParameterListForGeneration ;
    ::routine_buildLocalVariableMapAndSignature (inLexique,  var_cas_inSemanticContext,  operand_47883->mOverridingCategoryMethodFormalParameterList,  var_cas_variableMap,  var_cas_formalParameterListForGeneration COMMA_SOURCE_FILE_AT_LINE (1241)) ;
    const GGS_bool cond_49951 = (var_cas_baseTypeName).operator_isNotEqual (GGS_string ("")) ;
    if (cond_49951.isBuiltAndTrue ()) {
      ::routine_checkMethodSignatures (inLexique,  var_cas_formalParameterListForGeneration,  operand_47883->mOverridingCategoryMethodName.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (1251)),  var_cas_inheritedSignature,  var_cas_inheritedDeclarationLocation COMMA_SOURCE_FILE_AT_LINE (1249)) ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Implementation of function "buildPredefinedTypes"              *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_predefinedTypes function_buildPredefinedTypes (C_Compiler & inLexique,
                                const GGS_semanticContext  var_cas_inSemanticContext COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER function_buildPredefinedTypes at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_predefinedTypes var_cas_outPredefinedTypes ;
  var_cas_outPredefinedTypes = GGS_predefinedTypes::constructor_new (GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, GGS_lstring ::constructor_new (inLexique, GGS_string ("location"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (1302)) COMMA_SOURCE_FILE_AT_LINE (1302)), GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, GGS_lstring ::constructor_new (inLexique, GGS_string ("bool"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (1303)) COMMA_SOURCE_FILE_AT_LINE (1303)), GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, GGS_lstring ::constructor_new (inLexique, GGS_string ("char"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (1304)) COMMA_SOURCE_FILE_AT_LINE (1304)), GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, GGS_lstring ::constructor_new (inLexique, GGS_string ("string"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (1305)) COMMA_SOURCE_FILE_AT_LINE (1305)), GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, GGS_lstring ::constructor_new (inLexique, GGS_string ("uint"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (1306)) COMMA_SOURCE_FILE_AT_LINE (1306)), GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, GGS_lstring ::constructor_new (inLexique, GGS_string ("sint"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (1307)) COMMA_SOURCE_FILE_AT_LINE (1307)), GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, GGS_lstring ::constructor_new (inLexique, GGS_string ("uint64"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (1308)) COMMA_SOURCE_FILE_AT_LINE (1308)), GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, GGS_lstring ::constructor_new (inLexique, GGS_string ("sint64"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (1309)) COMMA_SOURCE_FILE_AT_LINE (1309)), GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, GGS_lstring ::constructor_new (inLexique, GGS_string ("double"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (1310)) COMMA_SOURCE_FILE_AT_LINE (1310)), GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, GGS_lstring ::constructor_new (inLexique, GGS_string ("lbool"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (1311)) COMMA_SOURCE_FILE_AT_LINE (1311)), GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, GGS_lstring ::constructor_new (inLexique, GGS_string ("lchar"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (1312)) COMMA_SOURCE_FILE_AT_LINE (1312)), GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, GGS_lstring ::constructor_new (inLexique, GGS_string ("lstring"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (1313)) COMMA_SOURCE_FILE_AT_LINE (1313)), GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, GGS_lstring ::constructor_new (inLexique, GGS_string ("luint"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (1314)) COMMA_SOURCE_FILE_AT_LINE (1314)), GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, GGS_lstring ::constructor_new (inLexique, GGS_string ("lsint"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (1315)) COMMA_SOURCE_FILE_AT_LINE (1315)), GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, GGS_lstring ::constructor_new (inLexique, GGS_string ("luint64"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (1316)) COMMA_SOURCE_FILE_AT_LINE (1316)), GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, GGS_lstring ::constructor_new (inLexique, GGS_string ("lsint64"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (1317)) COMMA_SOURCE_FILE_AT_LINE (1317)), GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, GGS_lstring ::constructor_new (inLexique, GGS_string ("ldouble"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (1318)) COMMA_SOURCE_FILE_AT_LINE (1318))) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE function_buildPredefinedTypes\n") ;
  #endif
  return var_cas_outPredefinedTypes ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_buildPredefinedTypes (C_Compiler & inLexique,
                           const GGS_objectlist & inEffectiveParameterArray,
                           const GGS_location & inErrorLocation
                           COMMA_LOCATION_ARGS) {
  const GGS_semanticContext arg_0 = GGS_semanticContext::castFromObject (inLexique, inEffectiveParameterArray.reader_mValueAtIndex (inLexique, GGS_uint (0) COMMA_THERE), inErrorLocation COMMA_THERE) ;
  const GGS_predefinedTypes result = function_buildPredefinedTypes (inLexique,
                            arg_0
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

static const C_galgas_type_descriptorEX *
kArgumentTypeList_buildPredefinedTypes [1] = {& kTypeDescriptor_GGS_semanticContext} ;

const C_galgas_function_descriptorEX
kFunction_descriptor_buildPredefinedTypes ("buildPredefinedTypes",
                              functionForGenericCall_buildPredefinedTypes,
                              & kTypeDescriptor_GGS_predefinedTypes,
                              1,
                              kArgumentTypeList_buildPredefinedTypes) ;

//---------------------------------------------------------------------------*
//                                                                           *
//           Implementation of routine "performSemanticAnalysis"             *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_performSemanticAnalysis (C_Compiler & inLexique,
                                const GGS_semanticDeclarationListAST   var_cas_inDeclarationList,
                                const GGS_semanticContext  var_cas_inSemanticContext,
                                GGS_semanticDeclarationSortedListForGeneration  & var_cas_outDecoratedDeclarationListForGeneration
                        COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_performSemanticAnalysis at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  const GGS_predefinedTypes var_cas_predefinedTypes = function_buildPredefinedTypes (inLexique, var_cas_inSemanticContext COMMA_SOURCE_FILE_AT_LINE (1333)) ;
  var_cas_outDecoratedDeclarationListForGeneration = GGS_semanticDeclarationSortedListForGeneration ::constructor_emptySortedList () ;
  {
    GGS_semanticDeclarationListAST::cEnumerator enumerator_54491 (var_cas_inDeclarationList, true) ;
    const GGS_semanticDeclarationListAST::cElement * operand_54491 = NULL ;
    while (((operand_54491 = enumerator_54491.nextObject ()))) {
      macroValidPointer (operand_54491) ;
      { typeCategoryMethod__semanticDeclarationAST__performSemanticAnalysis method = findCategoryMethod__semanticDeclarationAST__performSemanticAnalysis (operand_54491->mSemanticDeclaration.galgasObjectRunTimeInfo ()) ;
        if (method != NULL) {
          method (inLexique, operand_54491->mSemanticDeclaration (HERE), var_cas_inSemanticContext, var_cas_predefinedTypes, var_cas_outDecoratedDeclarationListForGeneration COMMA_SOURCE_FILE_AT_LINE (1336)) ;
        }
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_performSemanticAnalysis\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      Prologue and epilogue actions                        *
//                                                                           *
//---------------------------------------------------------------------------*

static void prologueRoutineFor_semanticAnalysis (void) {
  enterCategoryMethod__semanticDeclarationAST__performSemanticAnalysis (category_method__semanticDeclarationAST__performSemanticAnalysis, gClassInfoFor__semanticDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__performSemanticAnalysis ((typeCategoryMethod__semanticDeclarationAST__performSemanticAnalysis) category_method__predefinedTypeAST__performSemanticAnalysis, gClassInfoFor__predefinedTypeAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__performSemanticAnalysis ((typeCategoryMethod__semanticDeclarationAST__performSemanticAnalysis) category_method__listDeclarationAST__performSemanticAnalysis, gClassInfoFor__listDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__performSemanticAnalysis ((typeCategoryMethod__semanticDeclarationAST__performSemanticAnalysis) category_method__sortedListDeclarationAST__performSemanticAnalysis, gClassInfoFor__sortedListDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__performSemanticAnalysis ((typeCategoryMethod__semanticDeclarationAST__performSemanticAnalysis) category_method__structDeclarationAST__performSemanticAnalysis, gClassInfoFor__structDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__performSemanticAnalysis ((typeCategoryMethod__semanticDeclarationAST__performSemanticAnalysis) category_method__enumDeclarationAST__performSemanticAnalysis, gClassInfoFor__enumDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__performSemanticAnalysis ((typeCategoryMethod__semanticDeclarationAST__performSemanticAnalysis) category_method__listmapDeclarationAST__performSemanticAnalysis, gClassInfoFor__listmapDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__performSemanticAnalysis ((typeCategoryMethod__semanticDeclarationAST__performSemanticAnalysis) category_method__mapDeclarationAST__performSemanticAnalysis, gClassInfoFor__mapDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__performSemanticAnalysis ((typeCategoryMethod__semanticDeclarationAST__performSemanticAnalysis) category_method__mapProxyDeclarationAST__performSemanticAnalysis, gClassInfoFor__mapProxyDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__performSemanticAnalysis ((typeCategoryMethod__semanticDeclarationAST__performSemanticAnalysis) category_method__externFunctionDeclarationAST__performSemanticAnalysis, gClassInfoFor__externFunctionDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__performSemanticAnalysis ((typeCategoryMethod__semanticDeclarationAST__performSemanticAnalysis) category_method__externRoutineDeclarationAST__performSemanticAnalysis, gClassInfoFor__externRoutineDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__performSemanticAnalysis ((typeCategoryMethod__semanticDeclarationAST__performSemanticAnalysis) category_method__routineDeclarationAST__performSemanticAnalysis, gClassInfoFor__routineDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__performSemanticAnalysis ((typeCategoryMethod__semanticDeclarationAST__performSemanticAnalysis) category_method__classDeclarationAST__performSemanticAnalysis, gClassInfoFor__classDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__performSemanticAnalysis ((typeCategoryMethod__semanticDeclarationAST__performSemanticAnalysis) category_method__functionDeclarationAST__performSemanticAnalysis, gClassInfoFor__functionDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__performSemanticAnalysis ((typeCategoryMethod__semanticDeclarationAST__performSemanticAnalysis) category_method__onceFunctionDeclarationAST__performSemanticAnalysis, gClassInfoFor__onceFunctionDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__performSemanticAnalysis ((typeCategoryMethod__semanticDeclarationAST__performSemanticAnalysis) category_method__filewrapperDeclarationAST__performSemanticAnalysis, gClassInfoFor__filewrapperDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__performSemanticAnalysis ((typeCategoryMethod__semanticDeclarationAST__performSemanticAnalysis) category_method__abstractCategoryMethodAST__performSemanticAnalysis, gClassInfoFor__abstractCategoryMethodAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__performSemanticAnalysis ((typeCategoryMethod__semanticDeclarationAST__performSemanticAnalysis) category_method__categoryMethodAST__performSemanticAnalysis, gClassInfoFor__categoryMethodAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__performSemanticAnalysis ((typeCategoryMethod__semanticDeclarationAST__performSemanticAnalysis) category_method__overridingCategoryMethodAST__performSemanticAnalysis, gClassInfoFor__overridingCategoryMethodAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__performSemanticAnalysis ((typeCategoryMethod__semanticDeclarationAST__performSemanticAnalysis) category_method__overridingAbstractCategoryMethodAST__performSemanticAnalysis, gClassInfoFor__overridingAbstractCategoryMethodAST.slotID ()) ;
}

//---------------------------------------------------------------------------*

static void epilogueRoutineFor_semanticAnalysis (void) {
  gDispatchTableForMethod__semanticDeclarationAST__performSemanticAnalysis.free () ;
}

//---------------------------------------------------------------------------*

C_PrologueEpilogue prologueEpilogueObjectFor_semanticAnalysis (prologueRoutineFor_semanticAnalysis, epilogueRoutineFor_semanticAnalysis) ;

//---------------------------------------------------------------------------*

