//---------------------------------------------------------------------------*
//                                                                           *
//                       File 'semanticAnalysis.cpp'                         *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                    november 10th, 2010, at 17h42'15"                      *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if CURRENT_LIBPM_VERSION != VERSION_OF_LIBPM_USED_BY_GALGAS_COMPILER
  #error "This file has been compiled with a version of GALGAS that uses libpm version VERSION_OF_LIBPM_USED_BY_GALGAS_COMPILER, different than the current version (CURRENT_LIBPM_VERSION) of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "galgas2/C_galgas_CLI_Options.h"
#include "semanticAnalysis.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "semanticAnalysis.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//             Include directives generated by grammar includes              *
//                                                                           *
//---------------------------------------------------------------------------*

#include "templateGrammar.h"

//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//            Implementation of routine "checkMethodSignatures"              *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_checkMethodSignatures (C_CompilerEx & inLexique,
                                const GGS_formalParameterListForGeneration   var_cas_inTestedSignature,
                                const GGS_location   var_cas_inErrorLocation,
                                const GGS_formalParameterSignature   var_cas_inReferenceSignature,
                                const GGS_location   var_cas_inReferenceLocation
                        COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_checkMethodSignatures at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  const GGS_bool cond_2809 = (var_cas_inTestedSignature.reader_length ()).operator_isNotEqual (var_cas_inReferenceSignature.reader_length ()) ;
  if (cond_2809.isBuiltAndTrue ()) {
    var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, (((GGS_string ("this method declares ")).operator_concat (var_cas_inTestedSignature.reader_length ().reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (43)))).operator_concat (GGS_string (" formal parameter(s), but overriden method declares "))).operator_concat (var_cas_inReferenceSignature.reader_length ().reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (44))) COMMA_SOURCE_FILE_AT_LINE (46)) ;
    var_cas_inReferenceLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("overriden method is declared here") COMMA_SOURCE_FILE_AT_LINE (47)) ;
  }else if (cond_2809.isBuiltAndFalse ()) {
    {
      GGS_formalParameterSignature::cEnumerator enumerator_2842 (var_cas_inReferenceSignature, true) ;
      const GGS_formalParameterSignature::cElement * operand_2842 = NULL ;
      GGS_formalParameterListForGeneration::cEnumerator enumerator_2877 (var_cas_inTestedSignature, true) ;
      const GGS_formalParameterListForGeneration::cElement * operand_2877 = NULL ;
      while (((operand_2842 = enumerator_2842.nextObject ()))
          && ((operand_2877 = enumerator_2877.nextObject ()))) {
        macroValidPointer (operand_2842) ;
        macroValidPointer (operand_2877) ;
        const GGS_bool cond_3314 = (operand_2842->mFormalArgumentPassingMode).operator_isNotEqual (operand_2877->mFormalArgumentPassingMode) ;
        if (cond_3314.isBuiltAndTrue ()) {
          operand_2877->mFormalArgumentName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, (((((GGS_string ("the '")).operator_concat (operand_2877->mFormalArgumentName)).operator_concat (GGS_string ("' formal parameter is declared as "))).operator_concat (operand_2877->mFormalArgumentPassingMode.reader_formalArgumentMessage (inLexique COMMA_SOURCE_FILE_AT_LINE (51)))).operator_concat (GGS_string (", but overriden method declares it as "))).operator_concat (operand_2842->mFormalArgumentPassingMode.reader_formalArgumentMessage (inLexique COMMA_SOURCE_FILE_AT_LINE (52))) COMMA_SOURCE_FILE_AT_LINE (53)) ;
          var_cas_inReferenceLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("overriden method is declared here") COMMA_SOURCE_FILE_AT_LINE (54)) ;
        }
        const GGS_bool cond_3718 = (operand_2877->mFormalArgumentType.reader_key (inLexique COMMA_SOURCE_FILE_AT_LINE (55))).operator_isNotEqual (operand_2842->mFormalArgumentType.reader_key (inLexique COMMA_SOURCE_FILE_AT_LINE (55))) ;
        if (cond_3718.isBuiltAndTrue ()) {
          operand_2877->mFormalArgumentName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((((GGS_string ("the '")).operator_concat (operand_2877->mFormalArgumentName)).operator_concat (GGS_string ("' formal parameter has the '@"))).operator_concat (operand_2877->mFormalArgumentType.reader_key (inLexique COMMA_SOURCE_FILE_AT_LINE (57)))).operator_concat (GGS_string ("' type, but overriden method declares with the '@"))).operator_concat (operand_2842->mFormalArgumentType.reader_key (inLexique COMMA_SOURCE_FILE_AT_LINE (58)))).operator_concat (GGS_string ("' type")) COMMA_SOURCE_FILE_AT_LINE (59)) ;
          var_cas_inReferenceLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("overriden method is declared here") COMMA_SOURCE_FILE_AT_LINE (60)) ;
        }
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_checkMethodSignatures\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Implementation of routine "checkReaderSignatures"              *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_checkReaderSignatures (C_CompilerEx & inLexique,
                                const GGS_formalInputParameterListForGeneration   var_cas_inTestedSignature,
                                const GGS_unifiedTypeMapProxy   var_cas_inReturnType,
                                const GGS_location   var_cas_inErrorLocation,
                                const GGS_unifiedTypeMapProxyList   var_cas_inReferenceSignature,
                                const GGS_unifiedTypeMapProxy   var_cas_inInheritedReturnType,
                                const GGS_location   var_cas_inReferenceLocation
                        COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_checkReaderSignatures at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  const GGS_bool cond_4756 = (var_cas_inReturnType.reader_key (inLexique COMMA_SOURCE_FILE_AT_LINE (79))).operator_isNotEqual (var_cas_inInheritedReturnType.reader_key (inLexique COMMA_SOURCE_FILE_AT_LINE (79))) ;
  if (cond_4756.isBuiltAndTrue ()) {
    var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((GGS_string ("the return type is '@")).operator_concat (var_cas_inReturnType.reader_key (inLexique COMMA_SOURCE_FILE_AT_LINE (81)))).operator_concat (GGS_string ("', but overriden reader names '@"))).operator_concat (var_cas_inInheritedReturnType.reader_key (inLexique COMMA_SOURCE_FILE_AT_LINE (82)))).operator_concat (GGS_string ("' as return type")) COMMA_SOURCE_FILE_AT_LINE (83)) ;
    var_cas_inReferenceLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("overriden reader is declared here") COMMA_SOURCE_FILE_AT_LINE (84)) ;
  }
  const GGS_bool cond_5102 = (var_cas_inTestedSignature.reader_length ()).operator_isNotEqual (var_cas_inReferenceSignature.reader_length ()) ;
  if (cond_5102.isBuiltAndTrue ()) {
    var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, (((GGS_string ("this reader declares ")).operator_concat (var_cas_inTestedSignature.reader_length ().reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (86)))).operator_concat (GGS_string (" formal parameter(s), but overriden reader declares "))).operator_concat (var_cas_inReferenceSignature.reader_length ().reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (87))) COMMA_SOURCE_FILE_AT_LINE (89)) ;
    var_cas_inReferenceLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("overriden reader is declared here") COMMA_SOURCE_FILE_AT_LINE (90)) ;
  }else if (cond_5102.isBuiltAndFalse ()) {
    {
      GGS_unifiedTypeMapProxyList::cEnumerator enumerator_5135 (var_cas_inReferenceSignature, true) ;
      const GGS_unifiedTypeMapProxyList::cElement * operand_5135 = NULL ;
      GGS_formalInputParameterListForGeneration::cEnumerator enumerator_5170 (var_cas_inTestedSignature, true) ;
      const GGS_formalInputParameterListForGeneration::cElement * operand_5170 = NULL ;
      while (((operand_5135 = enumerator_5135.nextObject ()))
          && ((operand_5170 = enumerator_5170.nextObject ()))) {
        macroValidPointer (operand_5135) ;
        macroValidPointer (operand_5170) ;
        const GGS_bool cond_5544 = (operand_5170->mFormalArgumentType.reader_key (inLexique COMMA_SOURCE_FILE_AT_LINE (92))).operator_isNotEqual (operand_5135->mType.reader_key (inLexique COMMA_SOURCE_FILE_AT_LINE (92))) ;
        if (cond_5544.isBuiltAndTrue ()) {
          operand_5170->mFormalArgumentName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((((GGS_string ("the '")).operator_concat (operand_5170->mFormalArgumentName)).operator_concat (GGS_string ("' formal parameter has the '@"))).operator_concat (operand_5170->mFormalArgumentType.reader_key (inLexique COMMA_SOURCE_FILE_AT_LINE (94)))).operator_concat (GGS_string ("' type, but overriden reader declares with the '@"))).operator_concat (operand_5135->mType.reader_key (inLexique COMMA_SOURCE_FILE_AT_LINE (95)))).operator_concat (GGS_string ("' type")) COMMA_SOURCE_FILE_AT_LINE (96)) ;
          var_cas_inReferenceLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("overriden reader is declared here") COMMA_SOURCE_FILE_AT_LINE (97)) ;
        }
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_checkReaderSignatures\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//    Category method '@semanticDeclarationAST.performSemanticAnalysis'      *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__semanticDeclarationAST__performSemanticAnalysis (C_CompilerEx &,
                                const cPtr_semanticDeclarationAST * operand_6039,
                                const GGS_semanticContext  /* var_cas_inSemanticContext */,
                                const GGS_predefinedTypes  /* var_cas_inPredefinedTypes */,
                                GGS_semanticDeclarationSortedListForGeneration  & /* var_cas_ioSemanticDeclarationListForGeneration */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_6039 != NULL) {
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//Virtual Table for category method '@semanticDeclarationAST.performSemanticAnalysis'*
//                                                                           *
//---------------------------------------------------------------------------*

static TC_UniqueArray <typeCategoryMethod__semanticDeclarationAST__performSemanticAnalysis> gDispatchTableForMethod__semanticDeclarationAST__performSemanticAnalysis ;

//---------------------------------------------------------------------------*

void
enterCategoryMethod__semanticDeclarationAST__performSemanticAnalysis (typeCategoryMethod__semanticDeclarationAST__performSemanticAnalysis inRoutine,
                     const PMSInt32 inClassID) {
  gDispatchTableForMethod__semanticDeclarationAST__performSemanticAnalysis.forceObjectAtIndex (inClassID, inRoutine, NULL COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

typeCategoryMethod__semanticDeclarationAST__performSemanticAnalysis
findCategoryMethod__semanticDeclarationAST__performSemanticAnalysis (AC_galgasClassRunTimeInformationEX * inClassPtr) {
  typeCategoryMethod__semanticDeclarationAST__performSemanticAnalysis result = NULL ;
  if (NULL != inClassPtr) {
    if (inClassPtr->slotID () < gDispatchTableForMethod__semanticDeclarationAST__performSemanticAnalysis.count ()) {
      result = gDispatchTableForMethod__semanticDeclarationAST__performSemanticAnalysis (inClassPtr->slotID () COMMA_HERE) ;
    }
    if (NULL == result) {
      AC_galgasClassRunTimeInformationEX * superClassPtr = inClassPtr->superClassPtr () ;
      if (superClassPtr != NULL) {
        result = findCategoryMethod__semanticDeclarationAST__performSemanticAnalysis (superClassPtr) ;
        gDispatchTableForMethod__semanticDeclarationAST__performSemanticAnalysis.forceObjectAtIndex (inClassPtr->slotID (), result, NULL COMMA_HERE) ;
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//       Category method '@predefinedTypeAST.performSemanticAnalysis'        *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__predefinedTypeAST__performSemanticAnalysis (C_CompilerEx & inLexique,
                                const cPtr_predefinedTypeAST * operand_6379,
                                const GGS_semanticContext  var_cas_inSemanticContext,
                                const GGS_predefinedTypes  /* var_cas_inPredefinedTypes */,
                                GGS_semanticDeclarationSortedListForGeneration  & var_cas_ioSemanticDeclarationListForGeneration
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_6379 != NULL) {
    var_cas_ioSemanticDeclarationListForGeneration.addAssign_operation (GGS_primitiveTypeForGeneration ::constructor_new (inLexique, GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, GGS_lstring ::constructor_new (inLexique, operand_6379->mPredefinedTypeName, GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (123)) COMMA_SOURCE_FILE_AT_LINE (123)), operand_6379->mPredefinedTypeName, operand_6379->mKind COMMA_SOURCE_FILE_AT_LINE (122)), GGS_string ("")) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'e_attributeIndexMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

e_attributeIndexMap::e_attributeIndexMap (void) :
mAttributeTypeIndex () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class map '@attributeIndexMap'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_attributeIndexMap ("attributeIndexMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_attributeIndexMap::
elementOf_GGS_attributeIndexMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_attributeIndexMap & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_attributeIndexMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mAttributeTypeIndex.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_attributeIndexMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_attributeIndexMap * ptr = dynamic_cast <const elementOf_GGS_attributeIndexMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mAttributeTypeIndex.operator_isEqual (ptr->mInfo.mAttributeTypeIndex)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_attributeIndexMap::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_attributeIndexMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_attributeIndexMap * info = (e_attributeIndexMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_attributeIndexMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_attributeIndexMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_attributeIndexMap * info = (e_attributeIndexMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_attributeIndexMap GGS_attributeIndexMap::
constructor_emptyMap (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_attributeIndexMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_attributeIndexMap::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_attributeIndexMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

void GGS_attributeIndexMap::modifier_insertFakeKey (C_CompilerEx & inCompiler,
                         const GGS_string & inKey,
                         const GGS_location & inHelperMessageErrorLocation,
                         const GGS_string & inHelperMessage
                         COMMA_LOCATION_ARGS) {
  e_attributeIndexMap info  ;
  internal_insertFakeKey (inCompiler,
                          (void *) & info,
                          inKey,
                          inHelperMessageErrorLocation,
                          inHelperMessage
                          COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_attributeIndexMap::
operator_isEqual (const GGS_attributeIndexMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_attributeIndexMap::
operator_isNotEqual (const GGS_attributeIndexMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_attributeIndexMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_attributeIndexMap::
insertElement (C_CompilerEx & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_unifiedTypeMapProxy & inParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap (THERE) ;
    e_attributeIndexMap info  ;
    info.mAttributeTypeIndex = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_attributeIndexMap::
searchElement (C_CompilerEx & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_unifiedTypeMapProxy   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inLexique, inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    outParameter0 = node->mInfo.mAttributeTypeIndex ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_attributeIndexMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('t'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('b'),
  TO_UNICODE ('u'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_attributeIndexMap::
method_searchKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                GGS_unifiedTypeMapProxy   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 0,
                 kSearchMessage_searchKey,
                 inKey,
                 outParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_attributeIndexMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('t'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('b'),
  TO_UNICODE ('u'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_attributeIndexMap::
modifier_insertKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_unifiedTypeMapProxy & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                NULL
                COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_attributeIndexMap GGS_attributeIndexMap::
constructor_mapWithMapToOverride (C_CompilerEx & /* inLexique */,
                                  const GGS_attributeIndexMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_attributeIndexMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_attributeIndexMap GGS_attributeIndexMap::
reader_overriddenMap (C_CompilerEx & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_attributeIndexMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_attributeIndexMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @attributeIndexMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_unifiedTypeMapProxy  & GGS_attributeIndexMap::cEnumerator::_mAttributeTypeIndex (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mAttributeTypeIndex ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_attributeIndexMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_attributeIndexMap * p = NULL ;
    macroMyNew (p, GGS_attributeIndexMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_attributeIndexMap GGS_attributeIndexMap::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_attributeIndexMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_attributeIndexMap * p = dynamic_cast <const GGS_attributeIndexMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_attributeIndexMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_attributeIndexMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_attributeIndexMap ;
}

//---------------------------------------------------------------------------*

GGS_attributeIndexMap GGS_attributeIndexMap::constructor_mapWithKeyAndValue (C_CompilerEx & inLexique,
                                             const GGS_lstring & inKey,
                                             const GGS_unifiedTypeMapProxy & inValue0
                                             COMMA_LOCATION_ARGS) {
  GGS_attributeIndexMap result = constructor_emptyMap (inLexique COMMA_THERE) ;
  result.insertElement (inLexique,
                        0,
                        NULL,
                        inKey,
                        inValue0,
                        NULL
                        COMMA_THERE) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Category method '@listDeclarationAST.performSemanticAnalysis'        *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__listDeclarationAST__performSemanticAnalysis (C_CompilerEx & inLexique,
                                const cPtr_listDeclarationAST * operand_7245,
                                const GGS_semanticContext  var_cas_inSemanticContext,
                                const GGS_predefinedTypes  /* var_cas_inPredefinedTypes */,
                                GGS_semanticDeclarationSortedListForGeneration  & var_cas_ioSemanticDeclarationListForGeneration
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_7245 != NULL) {
    GGS_typedAttributeList  var_cas_typedAttributeList = GGS_typedAttributeList ::constructor_emptyList () ;
    GGS_attributeIndexMap  var_cas_attributeMap = GGS_attributeIndexMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (148)) ;
    {
      GGS_attributeInCollectionListAST::cEnumerator enumerator_7546 (operand_7245->mAttributeList, true) ;
      const GGS_attributeInCollectionListAST::cElement * operand_7546 = NULL ;
      while (((operand_7546 = enumerator_7546.nextObject ()))) {
        macroValidPointer (operand_7546) ;
        GGS_unifiedTypeMapProxy  var_cas_t = GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_7546->mAttributeTypeName COMMA_SOURCE_FILE_AT_LINE (150)) ;
        GGS_bool var_cas_hasGetter = GGS_bool (true) ;
        GGS_bool var_cas_hasSetter = GGS_bool (true) ;
        var_cas_typedAttributeList.addAssign_operation (var_cas_t, operand_7546->mAttributeName, var_cas_hasSetter, var_cas_hasGetter) ;
        var_cas_attributeMap.modifier_insertKey (inLexique, operand_7546->mAttributeName, var_cas_t COMMA_SOURCE_FILE_AT_LINE (159)) ;
      }
    }
    var_cas_ioSemanticDeclarationListForGeneration.addAssign_operation (GGS_listTypeForGeneration ::constructor_new (inLexique, GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_7245->mListTypeName COMMA_SOURCE_FILE_AT_LINE (162)), var_cas_typedAttributeList COMMA_SOURCE_FILE_AT_LINE (161)), GGS_string ("")) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//   Category method '@sortedListDeclarationAST.performSemanticAnalysis'     *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__sortedListDeclarationAST__performSemanticAnalysis (C_CompilerEx & inLexique,
                                const cPtr_sortedListDeclarationAST * operand_8217,
                                const GGS_semanticContext  var_cas_inSemanticContext,
                                const GGS_predefinedTypes  /* var_cas_inPredefinedTypes */,
                                GGS_semanticDeclarationSortedListForGeneration  & var_cas_ioSemanticDeclarationListForGeneration
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_8217 != NULL) {
    GGS_typedAttributeList  var_cas_typedAttributeList = GGS_typedAttributeList ::constructor_emptyList () ;
    GGS_attributeIndexMap  var_cas_attributeMap = GGS_attributeIndexMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (179)) ;
    {
      GGS_attributeInCollectionListAST::cEnumerator enumerator_8533 (operand_8217->mAttributeList, true) ;
      const GGS_attributeInCollectionListAST::cElement * operand_8533 = NULL ;
      while (((operand_8533 = enumerator_8533.nextObject ()))) {
        macroValidPointer (operand_8533) ;
        GGS_unifiedTypeMapProxy  var_cas_t = GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_8533->mAttributeTypeName COMMA_SOURCE_FILE_AT_LINE (181)) ;
        GGS_bool var_cas_hasSetter = GGS_bool (true) ;
        GGS_bool var_cas_hasGetter = GGS_bool (true) ;
        var_cas_typedAttributeList.addAssign_operation (var_cas_t, operand_8533->mAttributeName, var_cas_hasSetter, var_cas_hasGetter) ;
        var_cas_attributeMap.modifier_insertKey (inLexique, operand_8533->mAttributeName, var_cas_t COMMA_SOURCE_FILE_AT_LINE (190)) ;
      }
    }
    GGS_stringset  var_cas_attributesUsedForSorting = GGS_stringset ::constructor_emptySet () ;
    GGS_sortDescriptorListForGeneration  var_cas_sortDescriptorList = GGS_sortDescriptorListForGeneration ::constructor_emptyList () ;
    {
      GGS_sortedListSortDescriptorListAST::cEnumerator enumerator_9021 (operand_8217->mSortDescriptorList, true) ;
      const GGS_sortedListSortDescriptorListAST::cElement * operand_9021 = NULL ;
      while (((operand_9021 = enumerator_9021.nextObject ()))) {
        macroValidPointer (operand_9021) ;
        GGS_unifiedTypeMapProxy  var_cas_type ;
        if (var_cas_attributeMap.isBuilt ()) {
          var_cas_attributeMap (HERE)->method_searchKey (inLexique, operand_9021->mSortedAttributeName, var_cas_type COMMA_SOURCE_FILE_AT_LINE (197)) ;
        }
        var_cas_sortDescriptorList.addAssign_operation (var_cas_type, operand_9021->mSortedAttributeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (198)), operand_9021->mAscending) ;
        const GGS_bool cond_9379 = var_cas_attributesUsedForSorting.reader_hasKey (operand_9021->mSortedAttributeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (199))) ;
        if (cond_9379.isBuiltAndTrue ()) {
          operand_9021->mSortedAttributeName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("the '")).operator_concat (operand_9021->mSortedAttributeName)).operator_concat (GGS_string ("' is already used for sorting")) COMMA_SOURCE_FILE_AT_LINE (201)) ;
        }
        var_cas_attributesUsedForSorting.addAssign_operation (operand_9021->mSortedAttributeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (202))) ;
      }
    }
    var_cas_ioSemanticDeclarationListForGeneration.addAssign_operation (GGS_sortedListTypeForGeneration ::constructor_new (inLexique, GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_8217->mSortedListTypeName COMMA_SOURCE_FILE_AT_LINE (206)), var_cas_typedAttributeList, var_cas_sortDescriptorList COMMA_SOURCE_FILE_AT_LINE (205)), GGS_string ("")) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//     Category method '@structDeclarationAST.performSemanticAnalysis'       *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__structDeclarationAST__performSemanticAnalysis (C_CompilerEx & inLexique,
                                const cPtr_structDeclarationAST * operand_9869,
                                const GGS_semanticContext  var_cas_inSemanticContext,
                                const GGS_predefinedTypes  /* var_cas_inPredefinedTypes */,
                                GGS_semanticDeclarationSortedListForGeneration  & var_cas_ioSemanticDeclarationListForGeneration
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_9869 != NULL) {
    GGS_typedAttributeList  var_cas_typedAttributeList = GGS_typedAttributeList ::constructor_emptyList () ;
    GGS_attributeIndexMap  var_cas_attributeMap = GGS_attributeIndexMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (223)) ;
    {
      GGS_attributeInCollectionListAST::cEnumerator enumerator_10170 (operand_9869->mAttributeList, true) ;
      const GGS_attributeInCollectionListAST::cElement * operand_10170 = NULL ;
      while (((operand_10170 = enumerator_10170.nextObject ()))) {
        macroValidPointer (operand_10170) ;
        GGS_unifiedTypeMapProxy  var_cas_t = GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_10170->mAttributeTypeName COMMA_SOURCE_FILE_AT_LINE (225)) ;
        {
          GGS_lstringlist::cEnumerator enumerator_10288 (operand_10170->mFeatureList, true) ;
          const GGS_lstringlist::cElement * operand_10288 = NULL ;
          while (((operand_10288 = enumerator_10288.nextObject ()))) {
            macroValidPointer (operand_10288) ;
            operand_10288->mValue.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("a struct attribute accepts no feature") COMMA_SOURCE_FILE_AT_LINE (228)) ;
          }
        }
        GGS_bool var_cas_hasSetter = GGS_bool (false) ;
        GGS_bool var_cas_hasGetter = GGS_bool (false) ;
        var_cas_typedAttributeList.addAssign_operation (var_cas_t, operand_10170->mAttributeName, var_cas_hasSetter, var_cas_hasGetter) ;
        var_cas_attributeMap.modifier_insertKey (inLexique, operand_10170->mAttributeName, var_cas_t COMMA_SOURCE_FILE_AT_LINE (237)) ;
      }
    }
    var_cas_ioSemanticDeclarationListForGeneration.addAssign_operation (GGS_structTypeForGeneration ::constructor_new (inLexique, GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_9869->mStructTypeName COMMA_SOURCE_FILE_AT_LINE (240)), var_cas_typedAttributeList COMMA_SOURCE_FILE_AT_LINE (239)), GGS_string ("")) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'e_constantIndexMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

e_constantIndexMap::e_constantIndexMap (void) :
mIndex () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class map '@constantIndexMap'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_constantIndexMap ("constantIndexMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_constantIndexMap::
elementOf_GGS_constantIndexMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_constantIndexMap & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_constantIndexMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mIndex.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_constantIndexMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_constantIndexMap * ptr = dynamic_cast <const elementOf_GGS_constantIndexMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mIndex.operator_isEqual (ptr->mInfo.mIndex)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_constantIndexMap::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_constantIndexMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_constantIndexMap * info = (e_constantIndexMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_constantIndexMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_constantIndexMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_constantIndexMap * info = (e_constantIndexMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_constantIndexMap GGS_constantIndexMap::
constructor_emptyMap (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_constantIndexMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_constantIndexMap::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_constantIndexMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

void GGS_constantIndexMap::modifier_insertFakeKey (C_CompilerEx & inCompiler,
                         const GGS_string & inKey,
                         const GGS_location & inHelperMessageErrorLocation,
                         const GGS_string & inHelperMessage
                         COMMA_LOCATION_ARGS) {
  e_constantIndexMap info  ;
  internal_insertFakeKey (inCompiler,
                          (void *) & info,
                          inKey,
                          inHelperMessageErrorLocation,
                          inHelperMessage
                          COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_constantIndexMap::
operator_isEqual (const GGS_constantIndexMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_constantIndexMap::
operator_isNotEqual (const GGS_constantIndexMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_constantIndexMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_constantIndexMap::
insertElement (C_CompilerEx & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_uint & inParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap (THERE) ;
    e_constantIndexMap info  ;
    info.mIndex = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_constantIndexMap::
searchElement (C_CompilerEx & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_uint   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inLexique, inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    outParameter0 = node->mInfo.mIndex ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_constantIndexMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE ('s'),
  TO_UNICODE ('t'),
  TO_UNICODE ('a'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_constantIndexMap::
method_searchKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                GGS_uint   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 0,
                 kSearchMessage_searchKey,
                 inKey,
                 outParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_constantIndexMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE ('s'),
  TO_UNICODE ('t'),
  TO_UNICODE ('a'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_constantIndexMap::
modifier_insertKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_uint & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                NULL
                COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_constantIndexMap GGS_constantIndexMap::
constructor_mapWithMapToOverride (C_CompilerEx & /* inLexique */,
                                  const GGS_constantIndexMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_constantIndexMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_constantIndexMap GGS_constantIndexMap::
reader_overriddenMap (C_CompilerEx & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_constantIndexMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_constantIndexMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @constantIndexMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_constantIndexMap::cEnumerator::_mIndex (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mIndex ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_constantIndexMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_constantIndexMap * p = NULL ;
    macroMyNew (p, GGS_constantIndexMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_constantIndexMap GGS_constantIndexMap::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_constantIndexMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_constantIndexMap * p = dynamic_cast <const GGS_constantIndexMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_constantIndexMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_constantIndexMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_constantIndexMap ;
}

//---------------------------------------------------------------------------*

GGS_constantIndexMap GGS_constantIndexMap::constructor_mapWithKeyAndValue (C_CompilerEx & inLexique,
                                             const GGS_lstring & inKey,
                                             const GGS_uint & inValue0
                                             COMMA_LOCATION_ARGS) {
  GGS_constantIndexMap result = constructor_emptyMap (inLexique COMMA_THERE) ;
  result.insertElement (inLexique,
                        0,
                        NULL,
                        inKey,
                        inValue0,
                        NULL
                        COMMA_THERE) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Category method '@enumDeclarationAST.performSemanticAnalysis'        *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__enumDeclarationAST__performSemanticAnalysis (C_CompilerEx & inLexique,
                                const cPtr_enumDeclarationAST * operand_11218,
                                const GGS_semanticContext  var_cas_inSemanticContext,
                                const GGS_predefinedTypes  /* var_cas_inPredefinedTypes */,
                                GGS_semanticDeclarationSortedListForGeneration  & var_cas_ioSemanticDeclarationListForGeneration
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_11218 != NULL) {
    GGS_stringlist  var_cas_constantList = GGS_stringlist ::constructor_emptyList () ;
    GGS_constantIndexMap  var_cas_constantMap = GGS_constantIndexMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (264)) ;
    {
      GGS_lstringlist::cEnumerator enumerator_11521 (operand_11218->mConstantList, true) ;
      const GGS_lstringlist::cElement * operand_11521 = NULL ;
      while (((operand_11521 = enumerator_11521.nextObject ()))) {
        macroValidPointer (operand_11521) ;
        var_cas_constantList.addAssign_operation (operand_11521->mValue.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (266))) ;
        var_cas_constantMap.modifier_insertKey (inLexique, operand_11521->mValue, var_cas_constantMap.reader_count () COMMA_SOURCE_FILE_AT_LINE (267)) ;
      }
    }
    const GGS_stringset  var_cas_constantSet = var_cas_constantMap.reader_allKeys (inLexique COMMA_SOURCE_FILE_AT_LINE (269)) ;
    GGS_enumMessageListForGeneration  var_cas_enumMessageList = GGS_enumMessageListForGeneration ::constructor_emptyList () ;
    GGS_stringset  var_cas_messageNameSet = GGS_stringset ::constructor_emptySet () ;
    {
      GGS_enumMessageListAST::cEnumerator enumerator_11842 (operand_11218->mEnumMessageList, true) ;
      const GGS_enumMessageListAST::cElement * operand_11842 = NULL ;
      while (((operand_11842 = enumerator_11842.nextObject ()))) {
        macroValidPointer (operand_11842) ;
        const GGS_bool cond_12003 = var_cas_messageNameSet.reader_hasKey (operand_11842->mEnumMessageName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (274))) ;
        if (cond_12003.isBuiltAndTrue ()) {
          operand_11842->mEnumMessageName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("this message is already declared for this enum type") COMMA_SOURCE_FILE_AT_LINE (276)) ;
        }
        var_cas_messageNameSet.addAssign_operation (operand_11842->mEnumMessageName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (277))) ;
        GGS_enumMessageAssociationSortedListForGeneration  var_cas_enumMessageAssociationSortedListForGeneration = GGS_enumMessageAssociationSortedListForGeneration ::constructor_emptySortedList () ;
        GGS_stringset  var_cas_usedConstantSet = GGS_stringset ::constructor_emptySet () ;
        {
          GGS_enumMessageAssociationListAST::cEnumerator enumerator_12293 (operand_11842->mMessageAssociationList, true) ;
          const GGS_enumMessageAssociationListAST::cElement * operand_12293 = NULL ;
          while (((operand_12293 = enumerator_12293.nextObject ()))) {
            macroValidPointer (operand_12293) ;
            GGS_uint  var_cas_constantIndex ;
            if (var_cas_constantMap.isBuilt ()) {
              var_cas_constantMap (HERE)->method_searchKey (inLexique, operand_12293->mConstantName, var_cas_constantIndex COMMA_SOURCE_FILE_AT_LINE (282)) ;
            }
            var_cas_usedConstantSet.addAssign_operation (operand_12293->mConstantName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (283))) ;
            var_cas_enumMessageAssociationSortedListForGeneration.addAssign_operation (var_cas_constantIndex, operand_12293->mConstantName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (286)), operand_12293->mMessage.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (287))) ;
          }
        }
        const GGS_stringset  var_cas_missedConstantSet = var_cas_constantSet.substract_operation (inLexique, var_cas_usedConstantSet COMMA_SOURCE_FILE_AT_LINE (290)) ;
        {
          GGS_stringset::cEnumerator enumerator_12704 (var_cas_missedConstantSet, true) ;
          while (enumerator_12704.hasCurrentObject ()) {
            operand_11842->mEnumMessageName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((GGS_string ("the '")).operator_concat (operand_11842->mEnumMessageName)).operator_concat (GGS_string ("' message definition does not name the '"))).operator_concat (enumerator_12704._key (HERE))).operator_concat (GGS_string ("' constant")) COMMA_SOURCE_FILE_AT_LINE (294)) ;
            enumerator_12704.next () ;
          }
        }
        var_cas_enumMessageList.addAssign_operation (operand_11842->mEnumMessageName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (295)), var_cas_enumMessageAssociationSortedListForGeneration) ;
      }
    }
    var_cas_ioSemanticDeclarationListForGeneration.addAssign_operation (GGS_enumTypeForGeneration ::constructor_new (inLexique, GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_11218->mEnumTypeName COMMA_SOURCE_FILE_AT_LINE (299)), var_cas_constantList, var_cas_enumMessageList COMMA_SOURCE_FILE_AT_LINE (298)), GGS_string ("")) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//     Category method '@listmapDeclarationAST.performSemanticAnalysis'      *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__listmapDeclarationAST__performSemanticAnalysis (C_CompilerEx & inLexique,
                                const cPtr_listmapDeclarationAST * operand_13343,
                                const GGS_semanticContext  var_cas_inSemanticContext,
                                const GGS_predefinedTypes  /* var_cas_inPredefinedTypes */,
                                GGS_semanticDeclarationSortedListForGeneration  & var_cas_ioSemanticDeclarationListForGeneration
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_13343 != NULL) {
    GGS_typeKindEnum var_cas_typeKindEnum ;
    GGS_typedAttributeList  var_cas_listTypeAttributeList ;
    GGS_bool automatic_var_13753_0 ;
    GGS_unifiedTypeMapProxy  automatic_var_13753_1 ;
    GGS_attributeMap  automatic_var_13753_2 ;
    GGS_typedAttributeList  automatic_var_13753_3 ;
    GGS_constructorMap  automatic_var_13753_4 ;
    GGS_readerMap  automatic_var_13753_5 ;
    GGS_modifierMap  automatic_var_13753_6 ;
    GGS_instanceMethodMap  automatic_var_13753_7 ;
    GGS_classMethodMap  automatic_var_13753_8 ;
    GGS_enumerationDescriptorList  automatic_var_13753_9 ;
    GGS_uint  automatic_var_13753_10 ;
    GGS_unifiedTypeMapProxyList  automatic_var_13753_11 ;
    GGS_nativeAttributeList  automatic_var_13753_12 ;
    GGS_stringset  automatic_var_13753_13 ;
    GGS_lstringlist  automatic_var_13753_14 ;
    GGS_typedAttributeList  automatic_var_13753_15 ;
    GGS_mapSearchMethodListAST  automatic_var_13753_16 ;
    GGS_mapSearchMethodListAST  automatic_var_13753_17 ;
    GGS_withAccessorMap  automatic_var_13753_18 ;
    GGS_bool automatic_var_13753_19 ;
    if (var_cas_inSemanticContext.mTypeMap.isBuilt ()) {
      var_cas_inSemanticContext.mTypeMap (HERE)->method_searchKey (inLexique, operand_13343->mAssociatedListTypeName, automatic_var_13753_0, automatic_var_13753_1, var_cas_typeKindEnum, var_cas_listTypeAttributeList, automatic_var_13753_2, automatic_var_13753_3, automatic_var_13753_4, automatic_var_13753_5, automatic_var_13753_6, automatic_var_13753_7, automatic_var_13753_8, automatic_var_13753_9, automatic_var_13753_10, automatic_var_13753_11, automatic_var_13753_12, automatic_var_13753_13, automatic_var_13753_14, automatic_var_13753_15, automatic_var_13753_16, automatic_var_13753_17, automatic_var_13753_18, automatic_var_13753_19 COMMA_SOURCE_FILE_AT_LINE (317)) ;
    }
    var_cas_ioSemanticDeclarationListForGeneration.addAssign_operation (GGS_listmapTypeForGeneration ::constructor_new (inLexique, GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_13343->mListmapTypeName COMMA_SOURCE_FILE_AT_LINE (320)), GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_13343->mAssociatedListTypeName COMMA_SOURCE_FILE_AT_LINE (321)), var_cas_listTypeAttributeList COMMA_SOURCE_FILE_AT_LINE (319)), GGS_string ("")) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map '@insertMethodMap'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_insertMethodMap ("insertMethodMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_insertMethodMap::
elementOf_GGS_insertMethodMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_insertMethodMap & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_insertMethodMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_insertMethodMap::
isEqualToMapElement (const AC_galgas_map_element * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_insertMethodMap::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_insertMethodMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_insertMethodMap * info = (e_insertMethodMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_insertMethodMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_insertMethodMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_insertMethodMap * info = (e_insertMethodMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_insertMethodMap GGS_insertMethodMap::
constructor_emptyMap (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_insertMethodMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_insertMethodMap::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_insertMethodMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

void GGS_insertMethodMap::modifier_insertFakeKey (C_CompilerEx & inCompiler,
                         const GGS_string & inKey,
                         const GGS_location & inHelperMessageErrorLocation,
                         const GGS_string & inHelperMessage
                         COMMA_LOCATION_ARGS) {
  e_insertMethodMap info  ;
  internal_insertFakeKey (inCompiler,
                          (void *) & info,
                          inKey,
                          inHelperMessageErrorLocation,
                          inHelperMessage
                          COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_insertMethodMap::
operator_isEqual (const GGS_insertMethodMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_insertMethodMap::
operator_isNotEqual (const GGS_insertMethodMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_insertMethodMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_insertMethodMap::
insertElement (C_CompilerEx & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap (THERE) ;
    e_insertMethodMap info  ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_insertMethodMap::
searchElement (C_CompilerEx & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inLexique, inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_insertMethodMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('s'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('o'),
  TO_UNICODE ('d'),
  TO_UNICODE ('i'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_insertMethodMap::
modifier_insertKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_insertKey,
                 inKey,
                NULL
                COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_insertMethodMap GGS_insertMethodMap::
constructor_mapWithMapToOverride (C_CompilerEx & /* inLexique */,
                                  const GGS_insertMethodMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_insertMethodMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_insertMethodMap GGS_insertMethodMap::
reader_overriddenMap (C_CompilerEx & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_insertMethodMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_insertMethodMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @insertMethodMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_insertMethodMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_insertMethodMap * p = NULL ;
    macroMyNew (p, GGS_insertMethodMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_insertMethodMap GGS_insertMethodMap::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_insertMethodMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_insertMethodMap * p = dynamic_cast <const GGS_insertMethodMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_insertMethodMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_insertMethodMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_insertMethodMap ;
}

//---------------------------------------------------------------------------*

GGS_insertMethodMap GGS_insertMethodMap::constructor_mapWithKeyAndValue (C_CompilerEx & inLexique,
                                             const GGS_lstring & inKey
                                             COMMA_LOCATION_ARGS) {
  GGS_insertMethodMap result = constructor_emptyMap (inLexique COMMA_THERE) ;
  result.insertElement (inLexique,
                        0,
                        NULL,
                        inKey,
                        NULL
                        COMMA_THERE) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map '@searchMethodMap'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_searchMethodMap ("searchMethodMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_searchMethodMap::
elementOf_GGS_searchMethodMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_searchMethodMap & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_searchMethodMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_searchMethodMap::
isEqualToMapElement (const AC_galgas_map_element * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_searchMethodMap::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_searchMethodMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_searchMethodMap * info = (e_searchMethodMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_searchMethodMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_searchMethodMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_searchMethodMap * info = (e_searchMethodMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_searchMethodMap GGS_searchMethodMap::
constructor_emptyMap (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_searchMethodMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_searchMethodMap::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_searchMethodMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

void GGS_searchMethodMap::modifier_insertFakeKey (C_CompilerEx & inCompiler,
                         const GGS_string & inKey,
                         const GGS_location & inHelperMessageErrorLocation,
                         const GGS_string & inHelperMessage
                         COMMA_LOCATION_ARGS) {
  e_searchMethodMap info  ;
  internal_insertFakeKey (inCompiler,
                          (void *) & info,
                          inKey,
                          inHelperMessageErrorLocation,
                          inHelperMessage
                          COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_searchMethodMap::
operator_isEqual (const GGS_searchMethodMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_searchMethodMap::
operator_isNotEqual (const GGS_searchMethodMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_searchMethodMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_searchMethodMap::
insertElement (C_CompilerEx & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap (THERE) ;
    e_searchMethodMap info  ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_searchMethodMap::
searchElement (C_CompilerEx & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inLexique, inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_searchMethodMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('s'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('c'),
  TO_UNICODE ('h'),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('o'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_searchMethodMap::
modifier_insertKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_insertKey,
                 inKey,
                NULL
                COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_searchMethodMap GGS_searchMethodMap::
constructor_mapWithMapToOverride (C_CompilerEx & /* inLexique */,
                                  const GGS_searchMethodMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_searchMethodMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_searchMethodMap GGS_searchMethodMap::
reader_overriddenMap (C_CompilerEx & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_searchMethodMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_searchMethodMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @searchMethodMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_searchMethodMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_searchMethodMap * p = NULL ;
    macroMyNew (p, GGS_searchMethodMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_searchMethodMap GGS_searchMethodMap::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_searchMethodMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_searchMethodMap * p = dynamic_cast <const GGS_searchMethodMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_searchMethodMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_searchMethodMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_searchMethodMap ;
}

//---------------------------------------------------------------------------*

GGS_searchMethodMap GGS_searchMethodMap::constructor_mapWithKeyAndValue (C_CompilerEx & inLexique,
                                             const GGS_lstring & inKey
                                             COMMA_LOCATION_ARGS) {
  GGS_searchMethodMap result = constructor_emptyMap (inLexique COMMA_THERE) ;
  result.insertElement (inLexique,
                        0,
                        NULL,
                        inKey,
                        NULL
                        COMMA_THERE) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'e_mapAutomatonStateMap'                       *
//                                                                           *
//---------------------------------------------------------------------------*

e_mapAutomatonStateMap::e_mapAutomatonStateMap (void) :
mStateIndex () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class map '@mapAutomatonStateMap'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_mapAutomatonStateMap ("mapAutomatonStateMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_mapAutomatonStateMap::
elementOf_GGS_mapAutomatonStateMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_mapAutomatonStateMap & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_mapAutomatonStateMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mStateIndex.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_mapAutomatonStateMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_mapAutomatonStateMap * ptr = dynamic_cast <const elementOf_GGS_mapAutomatonStateMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mStateIndex.operator_isEqual (ptr->mInfo.mStateIndex)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_mapAutomatonStateMap::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_mapAutomatonStateMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_mapAutomatonStateMap * info = (e_mapAutomatonStateMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_mapAutomatonStateMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_mapAutomatonStateMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_mapAutomatonStateMap * info = (e_mapAutomatonStateMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_mapAutomatonStateMap GGS_mapAutomatonStateMap::
constructor_emptyMap (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_mapAutomatonStateMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_mapAutomatonStateMap::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_mapAutomatonStateMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

void GGS_mapAutomatonStateMap::modifier_insertFakeKey (C_CompilerEx & inCompiler,
                         const GGS_string & inKey,
                         const GGS_location & inHelperMessageErrorLocation,
                         const GGS_string & inHelperMessage
                         COMMA_LOCATION_ARGS) {
  e_mapAutomatonStateMap info  ;
  internal_insertFakeKey (inCompiler,
                          (void *) & info,
                          inKey,
                          inHelperMessageErrorLocation,
                          inHelperMessage
                          COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_mapAutomatonStateMap::
operator_isEqual (const GGS_mapAutomatonStateMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_mapAutomatonStateMap::
operator_isNotEqual (const GGS_mapAutomatonStateMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_mapAutomatonStateMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_mapAutomatonStateMap::
insertElement (C_CompilerEx & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_uint & inParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap (THERE) ;
    e_mapAutomatonStateMap info  ;
    info.mStateIndex = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapAutomatonStateMap::
searchElement (C_CompilerEx & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_uint   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inLexique, inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    outParameter0 = node->mInfo.mStateIndex ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_mapAutomatonStateMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('u'),
  TO_UNICODE ('n'),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('a'),
  TO_UNICODE ('p'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('u'),
  TO_UNICODE ('t'),
  TO_UNICODE ('o'),
  TO_UNICODE ('m'),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('s'),
  TO_UNICODE ('t'),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_mapAutomatonStateMap::
method_searchKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                GGS_uint   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 0,
                 kSearchMessage_searchKey,
                 inKey,
                 outParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_mapAutomatonStateMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('i'),
  TO_UNICODE ('t'),
  TO_UNICODE ('i'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('o'),
  TO_UNICODE ('f'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('a'),
  TO_UNICODE ('p'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('u'),
  TO_UNICODE ('t'),
  TO_UNICODE ('o'),
  TO_UNICODE ('m'),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('s'),
  TO_UNICODE ('t'),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_mapAutomatonStateMap::
modifier_insertKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_uint & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                NULL
                COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_mapAutomatonStateMap GGS_mapAutomatonStateMap::
constructor_mapWithMapToOverride (C_CompilerEx & /* inLexique */,
                                  const GGS_mapAutomatonStateMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_mapAutomatonStateMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapAutomatonStateMap GGS_mapAutomatonStateMap::
reader_overriddenMap (C_CompilerEx & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_mapAutomatonStateMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_mapAutomatonStateMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @mapAutomatonStateMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_mapAutomatonStateMap::cEnumerator::_mStateIndex (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mStateIndex ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_mapAutomatonStateMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_mapAutomatonStateMap * p = NULL ;
    macroMyNew (p, GGS_mapAutomatonStateMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapAutomatonStateMap GGS_mapAutomatonStateMap::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_mapAutomatonStateMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_mapAutomatonStateMap * p = dynamic_cast <const GGS_mapAutomatonStateMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_mapAutomatonStateMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_mapAutomatonStateMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_mapAutomatonStateMap ;
}

//---------------------------------------------------------------------------*

GGS_mapAutomatonStateMap GGS_mapAutomatonStateMap::constructor_mapWithKeyAndValue (C_CompilerEx & inLexique,
                                             const GGS_lstring & inKey,
                                             const GGS_uint & inValue0
                                             COMMA_LOCATION_ARGS) {
  GGS_mapAutomatonStateMap result = constructor_emptyMap (inLexique COMMA_THERE) ;
  result.insertElement (inLexique,
                        0,
                        NULL,
                        inKey,
                        inValue0,
                        NULL
                        COMMA_THERE) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'e_mapAutomatonActionMap'                       *
//                                                                           *
//---------------------------------------------------------------------------*

e_mapAutomatonActionMap::e_mapAutomatonActionMap (void) :
mActionIndex () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class map '@mapAutomatonActionMap'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_mapAutomatonActionMap ("mapAutomatonActionMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_mapAutomatonActionMap::
elementOf_GGS_mapAutomatonActionMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_mapAutomatonActionMap & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_mapAutomatonActionMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mActionIndex.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_mapAutomatonActionMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_mapAutomatonActionMap * ptr = dynamic_cast <const elementOf_GGS_mapAutomatonActionMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mActionIndex.operator_isEqual (ptr->mInfo.mActionIndex)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_mapAutomatonActionMap::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_mapAutomatonActionMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_mapAutomatonActionMap * info = (e_mapAutomatonActionMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_mapAutomatonActionMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_mapAutomatonActionMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_mapAutomatonActionMap * info = (e_mapAutomatonActionMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_mapAutomatonActionMap GGS_mapAutomatonActionMap::
constructor_emptyMap (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_mapAutomatonActionMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_mapAutomatonActionMap::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_mapAutomatonActionMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

void GGS_mapAutomatonActionMap::modifier_insertFakeKey (C_CompilerEx & inCompiler,
                         const GGS_string & inKey,
                         const GGS_location & inHelperMessageErrorLocation,
                         const GGS_string & inHelperMessage
                         COMMA_LOCATION_ARGS) {
  e_mapAutomatonActionMap info  ;
  internal_insertFakeKey (inCompiler,
                          (void *) & info,
                          inKey,
                          inHelperMessageErrorLocation,
                          inHelperMessage
                          COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_mapAutomatonActionMap::
operator_isEqual (const GGS_mapAutomatonActionMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_mapAutomatonActionMap::
operator_isNotEqual (const GGS_mapAutomatonActionMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_mapAutomatonActionMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_mapAutomatonActionMap::
insertElement (C_CompilerEx & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_uint & inParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap (THERE) ;
    e_mapAutomatonActionMap info  ;
    info.mActionIndex = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapAutomatonActionMap::
searchElement (C_CompilerEx & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_uint   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inLexique, inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    outParameter0 = node->mInfo.mActionIndex ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_mapAutomatonActionMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('u'),
  TO_UNICODE ('n'),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('a'),
  TO_UNICODE ('p'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('u'),
  TO_UNICODE ('t'),
  TO_UNICODE ('o'),
  TO_UNICODE ('m'),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('c'),
  TO_UNICODE ('t'),
  TO_UNICODE ('i'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_mapAutomatonActionMap::
method_searchKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                GGS_uint   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 0,
                 kSearchMessage_searchKey,
                 inKey,
                 outParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_mapAutomatonActionMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('i'),
  TO_UNICODE ('t'),
  TO_UNICODE ('i'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('o'),
  TO_UNICODE ('f'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('a'),
  TO_UNICODE ('p'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('u'),
  TO_UNICODE ('t'),
  TO_UNICODE ('o'),
  TO_UNICODE ('m'),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('c'),
  TO_UNICODE ('t'),
  TO_UNICODE ('i'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_mapAutomatonActionMap::
modifier_insertKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_uint & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                NULL
                COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_mapAutomatonActionMap GGS_mapAutomatonActionMap::
constructor_mapWithMapToOverride (C_CompilerEx & /* inLexique */,
                                  const GGS_mapAutomatonActionMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_mapAutomatonActionMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapAutomatonActionMap GGS_mapAutomatonActionMap::
reader_overriddenMap (C_CompilerEx & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_mapAutomatonActionMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_mapAutomatonActionMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @mapAutomatonActionMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_mapAutomatonActionMap::cEnumerator::_mActionIndex (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mActionIndex ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_mapAutomatonActionMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_mapAutomatonActionMap * p = NULL ;
    macroMyNew (p, GGS_mapAutomatonActionMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapAutomatonActionMap GGS_mapAutomatonActionMap::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_mapAutomatonActionMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_mapAutomatonActionMap * p = dynamic_cast <const GGS_mapAutomatonActionMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_mapAutomatonActionMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_mapAutomatonActionMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_mapAutomatonActionMap ;
}

//---------------------------------------------------------------------------*

GGS_mapAutomatonActionMap GGS_mapAutomatonActionMap::constructor_mapWithKeyAndValue (C_CompilerEx & inLexique,
                                             const GGS_lstring & inKey,
                                             const GGS_uint & inValue0
                                             COMMA_LOCATION_ARGS) {
  GGS_mapAutomatonActionMap result = constructor_emptyMap (inLexique COMMA_THERE) ;
  result.insertElement (inLexique,
                        0,
                        NULL,
                        inKey,
                        inValue0,
                        NULL
                        COMMA_THERE) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@mapStateTransitionSortedList'               *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_mapStateTransitionSortedList::
elementOf_GGS_mapStateTransitionSortedList (const GGS_uint & argument_0,
                                const GGS_string& argument_1,
                                const GGS_uint & argument_2,
                                const GGS_string& argument_3,
                                const GGS_mapAutomatonMessageKind& argument_4,
                                const GGS_string& argument_5):
mActionIndex (argument_0),
mActionName (argument_1),
mTargetStateIndex (argument_2),
mTargetStateName (argument_3),
mTransitionMessageKind (argument_4),
mTransitionMessage (argument_5) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_mapStateTransitionSortedList::
isEqualToObject (const cSortedListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_mapStateTransitionSortedList * ptr = dynamic_cast <const elementOf_GGS_mapStateTransitionSortedList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mActionIndex.operator_isEqual (ptr->mActionIndex).boolValue ()
         && mActionName.operator_isEqual (ptr->mActionName).boolValue ()
         && mTargetStateIndex.operator_isEqual (ptr->mTargetStateIndex).boolValue ()
         && mTargetStateName.operator_isEqual (ptr->mTargetStateName).boolValue ()
         && mTransitionMessageKind.operator_isEqual (ptr->mTransitionMessageKind).boolValue ()
         && mTransitionMessage.operator_isEqual (ptr->mTransitionMessage).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

PMSInt32 elementOf_GGS_mapStateTransitionSortedList::
compareForSorting (const cSortedListElement * inOperand) const {
  const elementOf_GGS_mapStateTransitionSortedList * operand = (const elementOf_GGS_mapStateTransitionSortedList *) inOperand ;
  PMSInt32 result = mActionIndex.genericObjectCompare (operand->mActionIndex) ;
  return result ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_mapStateTransitionSortedList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mActionIndex.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mActionName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTargetStateIndex.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTargetStateName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTransitionMessageKind.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTransitionMessage.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               Sorted list '@mapStateTransitionSortedList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_mapStateTransitionSortedList ("mapStateTransitionSortedList", false, NULL) ;

//---------------------------------------------------------------------------*

GGS_mapStateTransitionSortedList::GGS_mapStateTransitionSortedList (void): AC_GGS_sortedlist () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_mapStateTransitionSortedList::
GGS_mapStateTransitionSortedList (const GGS_mapStateTransitionSortedList & inSource): AC_GGS_sortedlist (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_mapStateTransitionSortedList::
operator_isEqual (const GGS_mapStateTransitionSortedList & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_mapStateTransitionSortedList::
operator_isNotEqual (const GGS_mapStateTransitionSortedList & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_mapStateTransitionSortedList::
internalAppendValues (const GGS_uint & argument_0,
                    const GGS_string& argument_1,
                    const GGS_uint & argument_2,
                    const GGS_string& argument_3,
                    const GGS_mapAutomatonMessageKind& argument_4,
                    const GGS_string& argument_5) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_mapStateTransitionSortedList::
addAssign_operation (const GGS_uint & argument_0,
                                const GGS_string& argument_1,
                                const GGS_uint & argument_2,
                                const GGS_string& argument_3,
                                const GGS_mapAutomatonMessageKind& argument_4,
                                const GGS_string& argument_5) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5) ;
  }
}

//---------------------------------------------------------------------------*

GGS_mapStateTransitionSortedList GGS_mapStateTransitionSortedList::
operator_concat (const GGS_mapStateTransitionSortedList & inOperand) const {
  GGS_mapStateTransitionSortedList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_mapStateTransitionSortedList::
dotAssign_operation (const GGS_mapStateTransitionSortedList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      *this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_mapStateTransitionSortedList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_uint  p_0 = p->mActionIndex ;
          GGS_string p_1 = p->mActionName ;
          GGS_uint  p_2 = p->mTargetStateIndex ;
          GGS_string p_3 = p->mTargetStateName ;
          GGS_mapAutomatonMessageKind p_4 = p->mTransitionMessageKind ;
          GGS_string p_5 = p->mTransitionMessage ;
          internalAppendValues (p_0, p_1, p_2, p_3, p_4, p_5) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_mapStateTransitionSortedList::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mActionIndex,
                                ptr->mActionName,
                                ptr->mTargetStateIndex,
                                ptr->mTargetStateName,
                                ptr->mTransitionMessageKind,
                                ptr->mTransitionMessage) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_mapStateTransitionSortedList  GGS_mapStateTransitionSortedList::
constructor_emptySortedList (void) {
  GGS_mapStateTransitionSortedList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapStateTransitionSortedList  GGS_mapStateTransitionSortedList::
constructor_sortedListWithValue (const GGS_uint & argument_0,
                           const GGS_string& argument_1,
                           const GGS_uint & argument_2,
                           const GGS_string& argument_3,
                           const GGS_mapAutomatonMessageKind& argument_4,
                           const GGS_string& argument_5) {
  GGS_mapStateTransitionSortedList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2, argument_3, argument_4, argument_5) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_mapStateTransitionSortedList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@mapStateTransitionSortedList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_mapStateTransitionSortedList::
method_smallest (C_CompilerEx & inLexique,
                 GGS_uint & _out_0,
                 GGS_string& _out_1,
                 GGS_uint & _out_2,
                 GGS_string& _out_3,
                 GGS_mapAutomatonMessageKind& _out_4,
                 GGS_string& _out_5
                 COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mActionIndex ;
    _out_1 = ptr->mActionName ;
    _out_2 = ptr->mTargetStateIndex ;
    _out_3 = ptr->mTargetStateName ;
    _out_4 = ptr->mTransitionMessageKind ;
    _out_5 = ptr->mTransitionMessage ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
    _out_5.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapStateTransitionSortedList::
method_greatest (C_CompilerEx & inLexique,
             GGS_uint & _out_0,
             GGS_string& _out_1,
             GGS_uint & _out_2,
             GGS_string& _out_3,
             GGS_mapAutomatonMessageKind& _out_4,
             GGS_string& _out_5
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'greatest' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mActionIndex ;
    _out_1 = ptr->mActionName ;
    _out_2 = ptr->mTargetStateIndex ;
    _out_3 = ptr->mTargetStateName ;
    _out_4 = ptr->mTransitionMessageKind ;
    _out_5 = ptr->mTransitionMessage ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
    _out_5.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapStateTransitionSortedList::
modifier_popSmallest (C_CompilerEx & inLexique,
                 GGS_uint & _out_0,
                 GGS_string& _out_1,
                 GGS_uint & _out_2,
                 GGS_string& _out_3,
                 GGS_mapAutomatonMessageKind& _out_4,
                 GGS_string& _out_5
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popSmallest' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mActionIndex ;
    _out_1 = ptr->mActionName ;
    _out_2 = ptr->mTargetStateIndex ;
    _out_3 = ptr->mTargetStateName ;
    _out_4 = ptr->mTransitionMessageKind ;
    _out_5 = ptr->mTransitionMessage ;
    insulateList () ;
    _internalRemoveSmallest () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
    _out_5.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapStateTransitionSortedList::
modifier_popGreatest (C_CompilerEx & inLexique,
                GGS_uint & _out_0,
                GGS_string& _out_1,
                GGS_uint & _out_2,
                GGS_string& _out_3,
                GGS_mapAutomatonMessageKind& _out_4,
                GGS_string& _out_5
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popGreatest' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mActionIndex ;
    _out_1 = ptr->mActionName ;
    _out_2 = ptr->mTargetStateIndex ;
    _out_3 = ptr->mTargetStateName ;
    _out_4 = ptr->mTransitionMessageKind ;
    _out_5 = ptr->mTransitionMessage ;
    insulateList () ;
    _internalRemoveGreatest () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
    _out_5.drop () ;
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_mapStateTransitionSortedList::cEnumerator::_mActionIndex (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mActionIndex ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_mapStateTransitionSortedList::cEnumerator::_mActionName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mActionName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_mapStateTransitionSortedList::cEnumerator::_mTargetStateIndex (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mTargetStateIndex ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_mapStateTransitionSortedList::cEnumerator::_mTargetStateName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mTargetStateName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_mapAutomatonMessageKind & GGS_mapStateTransitionSortedList::cEnumerator::_mTransitionMessageKind (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mTransitionMessageKind ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_mapStateTransitionSortedList::cEnumerator::_mTransitionMessage (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mTransitionMessage ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_mapStateTransitionSortedList::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_mapStateTransitionSortedList * p = NULL ;
    macroMyNew (p, GGS_mapStateTransitionSortedList (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapStateTransitionSortedList GGS_mapStateTransitionSortedList::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_mapStateTransitionSortedList result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_mapStateTransitionSortedList * p = dynamic_cast <const GGS_mapStateTransitionSortedList *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_mapStateTransitionSortedList, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_mapStateTransitionSortedList::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_mapStateTransitionSortedList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@mapStateSortedList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_mapStateSortedList::
elementOf_GGS_mapStateSortedList (const GGS_uint & argument_0,
                                const GGS_string& argument_1,
                                const GGS_mapAutomatonMessageKind& argument_2,
                                const GGS_string& argument_3,
                                const GGS_mapStateTransitionSortedList & argument_4):
mStateIndex (argument_0),
mStateName (argument_1),
mStateMessageKind (argument_2),
mStateMessage (argument_3),
mTransitionList (argument_4) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_mapStateSortedList::
isEqualToObject (const cSortedListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_mapStateSortedList * ptr = dynamic_cast <const elementOf_GGS_mapStateSortedList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStateIndex.operator_isEqual (ptr->mStateIndex).boolValue ()
         && mStateName.operator_isEqual (ptr->mStateName).boolValue ()
         && mStateMessageKind.operator_isEqual (ptr->mStateMessageKind).boolValue ()
         && mStateMessage.operator_isEqual (ptr->mStateMessage).boolValue ()
         && mTransitionList.operator_isEqual (ptr->mTransitionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

PMSInt32 elementOf_GGS_mapStateSortedList::
compareForSorting (const cSortedListElement * inOperand) const {
  const elementOf_GGS_mapStateSortedList * operand = (const elementOf_GGS_mapStateSortedList *) inOperand ;
  PMSInt32 result = mStateIndex.genericObjectCompare (operand->mStateIndex) ;
  return result ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_mapStateSortedList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mStateIndex.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mStateName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mStateMessageKind.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mStateMessage.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTransitionList.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    Sorted list '@mapStateSortedList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_mapStateSortedList ("mapStateSortedList", false, NULL) ;

//---------------------------------------------------------------------------*

GGS_mapStateSortedList::GGS_mapStateSortedList (void): AC_GGS_sortedlist () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_mapStateSortedList::
GGS_mapStateSortedList (const GGS_mapStateSortedList & inSource): AC_GGS_sortedlist (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_mapStateSortedList::
operator_isEqual (const GGS_mapStateSortedList & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_mapStateSortedList::
operator_isNotEqual (const GGS_mapStateSortedList & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_mapStateSortedList::
internalAppendValues (const GGS_uint & argument_0,
                    const GGS_string& argument_1,
                    const GGS_mapAutomatonMessageKind& argument_2,
                    const GGS_string& argument_3,
                    const GGS_mapStateTransitionSortedList & argument_4) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_mapStateSortedList::
addAssign_operation (const GGS_uint & argument_0,
                                const GGS_string& argument_1,
                                const GGS_mapAutomatonMessageKind& argument_2,
                                const GGS_string& argument_3,
                                const GGS_mapStateTransitionSortedList & argument_4) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4) ;
  }
}

//---------------------------------------------------------------------------*

GGS_mapStateSortedList GGS_mapStateSortedList::
operator_concat (const GGS_mapStateSortedList & inOperand) const {
  GGS_mapStateSortedList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_mapStateSortedList::
dotAssign_operation (const GGS_mapStateSortedList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      *this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_mapStateSortedList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_uint  p_0 = p->mStateIndex ;
          GGS_string p_1 = p->mStateName ;
          GGS_mapAutomatonMessageKind p_2 = p->mStateMessageKind ;
          GGS_string p_3 = p->mStateMessage ;
          GGS_mapStateTransitionSortedList  p_4 = p->mTransitionList ;
          internalAppendValues (p_0, p_1, p_2, p_3, p_4) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_mapStateSortedList::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mStateIndex,
                                ptr->mStateName,
                                ptr->mStateMessageKind,
                                ptr->mStateMessage,
                                ptr->mTransitionList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_mapStateSortedList  GGS_mapStateSortedList::
constructor_emptySortedList (void) {
  GGS_mapStateSortedList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapStateSortedList  GGS_mapStateSortedList::
constructor_sortedListWithValue (const GGS_uint & argument_0,
                           const GGS_string& argument_1,
                           const GGS_mapAutomatonMessageKind& argument_2,
                           const GGS_string& argument_3,
                           const GGS_mapStateTransitionSortedList & argument_4) {
  GGS_mapStateSortedList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2, argument_3, argument_4) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_mapStateSortedList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@mapStateSortedList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_mapStateSortedList::
method_smallest (C_CompilerEx & inLexique,
                 GGS_uint & _out_0,
                 GGS_string& _out_1,
                 GGS_mapAutomatonMessageKind& _out_2,
                 GGS_string& _out_3,
                 GGS_mapStateTransitionSortedList & _out_4
                 COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mStateIndex ;
    _out_1 = ptr->mStateName ;
    _out_2 = ptr->mStateMessageKind ;
    _out_3 = ptr->mStateMessage ;
    _out_4 = ptr->mTransitionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapStateSortedList::
method_greatest (C_CompilerEx & inLexique,
             GGS_uint & _out_0,
             GGS_string& _out_1,
             GGS_mapAutomatonMessageKind& _out_2,
             GGS_string& _out_3,
             GGS_mapStateTransitionSortedList & _out_4
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'greatest' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mStateIndex ;
    _out_1 = ptr->mStateName ;
    _out_2 = ptr->mStateMessageKind ;
    _out_3 = ptr->mStateMessage ;
    _out_4 = ptr->mTransitionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapStateSortedList::
modifier_popSmallest (C_CompilerEx & inLexique,
                 GGS_uint & _out_0,
                 GGS_string& _out_1,
                 GGS_mapAutomatonMessageKind& _out_2,
                 GGS_string& _out_3,
                 GGS_mapStateTransitionSortedList & _out_4
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popSmallest' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mStateIndex ;
    _out_1 = ptr->mStateName ;
    _out_2 = ptr->mStateMessageKind ;
    _out_3 = ptr->mStateMessage ;
    _out_4 = ptr->mTransitionList ;
    insulateList () ;
    _internalRemoveSmallest () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapStateSortedList::
modifier_popGreatest (C_CompilerEx & inLexique,
                GGS_uint & _out_0,
                GGS_string& _out_1,
                GGS_mapAutomatonMessageKind& _out_2,
                GGS_string& _out_3,
                GGS_mapStateTransitionSortedList & _out_4
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popGreatest' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mStateIndex ;
    _out_1 = ptr->mStateName ;
    _out_2 = ptr->mStateMessageKind ;
    _out_3 = ptr->mStateMessage ;
    _out_4 = ptr->mTransitionList ;
    insulateList () ;
    _internalRemoveGreatest () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_mapStateSortedList::cEnumerator::_mStateIndex (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mStateIndex ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_mapStateSortedList::cEnumerator::_mStateName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mStateName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_mapAutomatonMessageKind & GGS_mapStateSortedList::cEnumerator::_mStateMessageKind (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mStateMessageKind ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_mapStateSortedList::cEnumerator::_mStateMessage (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mStateMessage ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_mapStateTransitionSortedList  & GGS_mapStateSortedList::cEnumerator::_mTransitionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mTransitionList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_mapStateSortedList::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_mapStateSortedList * p = NULL ;
    macroMyNew (p, GGS_mapStateSortedList (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapStateSortedList GGS_mapStateSortedList::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_mapStateSortedList result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_mapStateSortedList * p = dynamic_cast <const GGS_mapStateSortedList *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_mapStateSortedList, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_mapStateSortedList::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_mapStateSortedList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        Element of list '@branchBehaviourSortedListForMapOverride'         *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_branchBehaviourSortedListForMapOverride::
elementOf_GGS_branchBehaviourSortedListForMapOverride (const GGS_uint & argument_0,
                                const GGS_string& argument_1,
                                const GGS_uint & argument_2,
                                const GGS_string& argument_3,
                                const GGS_uint & argument_4,
                                const GGS_string& argument_5,
                                const GGS_mapAutomatonMessageKind& argument_6,
                                const GGS_string& argument_7):
mStartStateIndex (argument_0),
mStartStateName (argument_1),
mCurrentStateIndex (argument_2),
mCurrentStateName (argument_3),
mFinalStateIndex (argument_4),
mFinalStateName (argument_5),
mStateMessageKind (argument_6),
mBehaviourMessage (argument_7) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_branchBehaviourSortedListForMapOverride::
isEqualToObject (const cSortedListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_branchBehaviourSortedListForMapOverride * ptr = dynamic_cast <const elementOf_GGS_branchBehaviourSortedListForMapOverride *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartStateIndex.operator_isEqual (ptr->mStartStateIndex).boolValue ()
         && mStartStateName.operator_isEqual (ptr->mStartStateName).boolValue ()
         && mCurrentStateIndex.operator_isEqual (ptr->mCurrentStateIndex).boolValue ()
         && mCurrentStateName.operator_isEqual (ptr->mCurrentStateName).boolValue ()
         && mFinalStateIndex.operator_isEqual (ptr->mFinalStateIndex).boolValue ()
         && mFinalStateName.operator_isEqual (ptr->mFinalStateName).boolValue ()
         && mStateMessageKind.operator_isEqual (ptr->mStateMessageKind).boolValue ()
         && mBehaviourMessage.operator_isEqual (ptr->mBehaviourMessage).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

PMSInt32 elementOf_GGS_branchBehaviourSortedListForMapOverride::
compareForSorting (const cSortedListElement * inOperand) const {
  const elementOf_GGS_branchBehaviourSortedListForMapOverride * operand = (const elementOf_GGS_branchBehaviourSortedListForMapOverride *) inOperand ;
  PMSInt32 result = mStartStateIndex.genericObjectCompare (operand->mStartStateIndex) ;
  if (result == 0) {
    result = mCurrentStateIndex.genericObjectCompare (operand->mCurrentStateIndex) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_branchBehaviourSortedListForMapOverride::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mStartStateIndex.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mStartStateName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mCurrentStateIndex.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mCurrentStateName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFinalStateIndex.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFinalStateName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mStateMessageKind.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mBehaviourMessage.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Sorted list '@branchBehaviourSortedListForMapOverride'           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_branchBehaviourSortedListForMapOverride ("branchBehaviourSortedListForMapOverride", false, NULL) ;

//---------------------------------------------------------------------------*

GGS_branchBehaviourSortedListForMapOverride::GGS_branchBehaviourSortedListForMapOverride (void): AC_GGS_sortedlist () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_branchBehaviourSortedListForMapOverride::
GGS_branchBehaviourSortedListForMapOverride (const GGS_branchBehaviourSortedListForMapOverride & inSource): AC_GGS_sortedlist (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_branchBehaviourSortedListForMapOverride::
operator_isEqual (const GGS_branchBehaviourSortedListForMapOverride & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_branchBehaviourSortedListForMapOverride::
operator_isNotEqual (const GGS_branchBehaviourSortedListForMapOverride & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_branchBehaviourSortedListForMapOverride::
internalAppendValues (const GGS_uint & argument_0,
                    const GGS_string& argument_1,
                    const GGS_uint & argument_2,
                    const GGS_string& argument_3,
                    const GGS_uint & argument_4,
                    const GGS_string& argument_5,
                    const GGS_mapAutomatonMessageKind& argument_6,
                    const GGS_string& argument_7) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_branchBehaviourSortedListForMapOverride::
addAssign_operation (const GGS_uint & argument_0,
                                const GGS_string& argument_1,
                                const GGS_uint & argument_2,
                                const GGS_string& argument_3,
                                const GGS_uint & argument_4,
                                const GGS_string& argument_5,
                                const GGS_mapAutomatonMessageKind& argument_6,
                                const GGS_string& argument_7) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7) ;
  }
}

//---------------------------------------------------------------------------*

GGS_branchBehaviourSortedListForMapOverride GGS_branchBehaviourSortedListForMapOverride::
operator_concat (const GGS_branchBehaviourSortedListForMapOverride & inOperand) const {
  GGS_branchBehaviourSortedListForMapOverride result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_branchBehaviourSortedListForMapOverride::
dotAssign_operation (const GGS_branchBehaviourSortedListForMapOverride inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      *this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_branchBehaviourSortedListForMapOverride * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_uint  p_0 = p->mStartStateIndex ;
          GGS_string p_1 = p->mStartStateName ;
          GGS_uint  p_2 = p->mCurrentStateIndex ;
          GGS_string p_3 = p->mCurrentStateName ;
          GGS_uint  p_4 = p->mFinalStateIndex ;
          GGS_string p_5 = p->mFinalStateName ;
          GGS_mapAutomatonMessageKind p_6 = p->mStateMessageKind ;
          GGS_string p_7 = p->mBehaviourMessage ;
          internalAppendValues (p_0, p_1, p_2, p_3, p_4, p_5, p_6, p_7) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_branchBehaviourSortedListForMapOverride::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mStartStateIndex,
                                ptr->mStartStateName,
                                ptr->mCurrentStateIndex,
                                ptr->mCurrentStateName,
                                ptr->mFinalStateIndex,
                                ptr->mFinalStateName,
                                ptr->mStateMessageKind,
                                ptr->mBehaviourMessage) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_branchBehaviourSortedListForMapOverride  GGS_branchBehaviourSortedListForMapOverride::
constructor_emptySortedList (void) {
  GGS_branchBehaviourSortedListForMapOverride result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_branchBehaviourSortedListForMapOverride  GGS_branchBehaviourSortedListForMapOverride::
constructor_sortedListWithValue (const GGS_uint & argument_0,
                           const GGS_string& argument_1,
                           const GGS_uint & argument_2,
                           const GGS_string& argument_3,
                           const GGS_uint & argument_4,
                           const GGS_string& argument_5,
                           const GGS_mapAutomatonMessageKind& argument_6,
                           const GGS_string& argument_7) {
  GGS_branchBehaviourSortedListForMapOverride result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2, argument_3, argument_4, argument_5, argument_6, argument_7) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_branchBehaviourSortedListForMapOverride::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@branchBehaviourSortedListForMapOverride", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_branchBehaviourSortedListForMapOverride::
method_smallest (C_CompilerEx & inLexique,
                 GGS_uint & _out_0,
                 GGS_string& _out_1,
                 GGS_uint & _out_2,
                 GGS_string& _out_3,
                 GGS_uint & _out_4,
                 GGS_string& _out_5,
                 GGS_mapAutomatonMessageKind& _out_6,
                 GGS_string& _out_7
                 COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mStartStateIndex ;
    _out_1 = ptr->mStartStateName ;
    _out_2 = ptr->mCurrentStateIndex ;
    _out_3 = ptr->mCurrentStateName ;
    _out_4 = ptr->mFinalStateIndex ;
    _out_5 = ptr->mFinalStateName ;
    _out_6 = ptr->mStateMessageKind ;
    _out_7 = ptr->mBehaviourMessage ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
    _out_5.drop () ;
    _out_6.drop () ;
    _out_7.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_branchBehaviourSortedListForMapOverride::
method_greatest (C_CompilerEx & inLexique,
             GGS_uint & _out_0,
             GGS_string& _out_1,
             GGS_uint & _out_2,
             GGS_string& _out_3,
             GGS_uint & _out_4,
             GGS_string& _out_5,
             GGS_mapAutomatonMessageKind& _out_6,
             GGS_string& _out_7
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'greatest' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mStartStateIndex ;
    _out_1 = ptr->mStartStateName ;
    _out_2 = ptr->mCurrentStateIndex ;
    _out_3 = ptr->mCurrentStateName ;
    _out_4 = ptr->mFinalStateIndex ;
    _out_5 = ptr->mFinalStateName ;
    _out_6 = ptr->mStateMessageKind ;
    _out_7 = ptr->mBehaviourMessage ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
    _out_5.drop () ;
    _out_6.drop () ;
    _out_7.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_branchBehaviourSortedListForMapOverride::
modifier_popSmallest (C_CompilerEx & inLexique,
                 GGS_uint & _out_0,
                 GGS_string& _out_1,
                 GGS_uint & _out_2,
                 GGS_string& _out_3,
                 GGS_uint & _out_4,
                 GGS_string& _out_5,
                 GGS_mapAutomatonMessageKind& _out_6,
                 GGS_string& _out_7
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popSmallest' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mStartStateIndex ;
    _out_1 = ptr->mStartStateName ;
    _out_2 = ptr->mCurrentStateIndex ;
    _out_3 = ptr->mCurrentStateName ;
    _out_4 = ptr->mFinalStateIndex ;
    _out_5 = ptr->mFinalStateName ;
    _out_6 = ptr->mStateMessageKind ;
    _out_7 = ptr->mBehaviourMessage ;
    insulateList () ;
    _internalRemoveSmallest () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
    _out_5.drop () ;
    _out_6.drop () ;
    _out_7.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_branchBehaviourSortedListForMapOverride::
modifier_popGreatest (C_CompilerEx & inLexique,
                GGS_uint & _out_0,
                GGS_string& _out_1,
                GGS_uint & _out_2,
                GGS_string& _out_3,
                GGS_uint & _out_4,
                GGS_string& _out_5,
                GGS_mapAutomatonMessageKind& _out_6,
                GGS_string& _out_7
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popGreatest' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mStartStateIndex ;
    _out_1 = ptr->mStartStateName ;
    _out_2 = ptr->mCurrentStateIndex ;
    _out_3 = ptr->mCurrentStateName ;
    _out_4 = ptr->mFinalStateIndex ;
    _out_5 = ptr->mFinalStateName ;
    _out_6 = ptr->mStateMessageKind ;
    _out_7 = ptr->mBehaviourMessage ;
    insulateList () ;
    _internalRemoveGreatest () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
    _out_5.drop () ;
    _out_6.drop () ;
    _out_7.drop () ;
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_branchBehaviourSortedListForMapOverride::cEnumerator::_mStartStateIndex (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mStartStateIndex ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_branchBehaviourSortedListForMapOverride::cEnumerator::_mStartStateName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mStartStateName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_branchBehaviourSortedListForMapOverride::cEnumerator::_mCurrentStateIndex (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mCurrentStateIndex ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_branchBehaviourSortedListForMapOverride::cEnumerator::_mCurrentStateName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mCurrentStateName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_branchBehaviourSortedListForMapOverride::cEnumerator::_mFinalStateIndex (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mFinalStateIndex ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_branchBehaviourSortedListForMapOverride::cEnumerator::_mFinalStateName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mFinalStateName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_mapAutomatonMessageKind & GGS_branchBehaviourSortedListForMapOverride::cEnumerator::_mStateMessageKind (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mStateMessageKind ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_branchBehaviourSortedListForMapOverride::cEnumerator::_mBehaviourMessage (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mBehaviourMessage ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_branchBehaviourSortedListForMapOverride::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_branchBehaviourSortedListForMapOverride * p = NULL ;
    macroMyNew (p, GGS_branchBehaviourSortedListForMapOverride (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_branchBehaviourSortedListForMapOverride GGS_branchBehaviourSortedListForMapOverride::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_branchBehaviourSortedListForMapOverride result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_branchBehaviourSortedListForMapOverride * p = dynamic_cast <const GGS_branchBehaviourSortedListForMapOverride *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_branchBehaviourSortedListForMapOverride, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_branchBehaviourSortedListForMapOverride::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_branchBehaviourSortedListForMapOverride ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    Element of list '@mapOverrideList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_mapOverrideList::
elementOf_GGS_mapOverrideList (const GGS_lstring & argument_0,
                                const GGS_branchBehaviourSortedListForMapOverride & argument_1,
                                const GGS_branchBehaviourSortedListForMapOverride & argument_2
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mOverrideName (argument_0),
mBranchBehaviourSortedListForMapOverride (argument_1),
mBranchCombinationSortedListForMapOverride (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_mapOverrideList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_mapOverrideList * ptr = dynamic_cast <const elementOf_GGS_mapOverrideList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOverrideName.operator_isEqual (ptr->mOverrideName).boolValue ()
         && mBranchBehaviourSortedListForMapOverride.operator_isEqual (ptr->mBranchBehaviourSortedListForMapOverride).boolValue ()
         && mBranchCombinationSortedListForMapOverride.operator_isEqual (ptr->mBranchCombinationSortedListForMapOverride).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_mapOverrideList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOverrideName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mBranchBehaviourSortedListForMapOverride.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mBranchCombinationSortedListForMapOverride.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         List '@mapOverrideList'                           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_mapOverrideList ("mapOverrideList", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_mapOverrideList::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_branchBehaviourSortedListForMapOverride & argument_1,
                    const GGS_branchBehaviourSortedListForMapOverride & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_mapOverrideList::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_branchBehaviourSortedListForMapOverride & argument_1,
                    const GGS_branchBehaviourSortedListForMapOverride & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_mapOverrideList::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_branchBehaviourSortedListForMapOverride & argument_1,
                                const GGS_branchBehaviourSortedListForMapOverride & argument_2) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_mapOverrideList GGS_mapOverrideList::
operator_concat (const GGS_mapOverrideList & inOperand) const {
  GGS_mapOverrideList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_mapOverrideList::
dotAssign_operation (const GGS_mapOverrideList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_mapOverrideList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mOverrideName ;
          GGS_branchBehaviourSortedListForMapOverride  p_1 = p->mBranchBehaviourSortedListForMapOverride ;
          GGS_branchBehaviourSortedListForMapOverride  p_2 = p->mBranchCombinationSortedListForMapOverride ;
          internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_mapOverrideList::
modifier_prependValue (C_CompilerEx & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_branchBehaviourSortedListForMapOverride & argument_1,
                     const GGS_branchBehaviourSortedListForMapOverride & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapOverrideList::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mOverrideName,
                                ptr->mBranchBehaviourSortedListForMapOverride,
                                ptr->mBranchCombinationSortedListForMapOverride
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_mapOverrideList  GGS_mapOverrideList::
constructor_emptyList (void) {
  GGS_mapOverrideList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapOverrideList  GGS_mapOverrideList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_branchBehaviourSortedListForMapOverride & argument_1,
                                const GGS_branchBehaviourSortedListForMapOverride & argument_2) {
  GGS_mapOverrideList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_mapOverrideList::
internalSubListWithRange (GGS_mapOverrideList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mOverrideName, ptr->mBranchBehaviourSortedListForMapOverride, ptr->mBranchCombinationSortedListForMapOverride) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_mapOverrideList GGS_mapOverrideList::
reader_subListWithRange (C_CompilerEx & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_mapOverrideList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapOverrideList GGS_mapOverrideList::
reader_subListFromIndex (C_CompilerEx & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_mapOverrideList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_mapOverrideList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@mapOverrideList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_mapOverrideList::
method_first (C_CompilerEx & inLexique,
              GGS_lstring & _out_0,
              GGS_branchBehaviourSortedListForMapOverride & _out_1,
              GGS_branchBehaviourSortedListForMapOverride & _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mOverrideName ;
    _out_1 = ptr->mBranchBehaviourSortedListForMapOverride ;
    _out_2 = ptr->mBranchCombinationSortedListForMapOverride ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapOverrideList::
method_last (C_CompilerEx & inLexique,
             GGS_lstring & _out_0,
             GGS_branchBehaviourSortedListForMapOverride & _out_1,
             GGS_branchBehaviourSortedListForMapOverride & _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mOverrideName ;
    _out_1 = ptr->mBranchBehaviourSortedListForMapOverride ;
    _out_2 = ptr->mBranchCombinationSortedListForMapOverride ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapOverrideList::
modifier_popFirst (C_CompilerEx & inLexique,
                 GGS_lstring & _out_0,
                 GGS_branchBehaviourSortedListForMapOverride & _out_1,
                 GGS_branchBehaviourSortedListForMapOverride & _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mOverrideName ;
    _out_1 = ptr->mBranchBehaviourSortedListForMapOverride ;
    _out_2 = ptr->mBranchCombinationSortedListForMapOverride ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapOverrideList::
modifier_popLast (C_CompilerEx & inLexique,
                GGS_lstring & _out_0,
                GGS_branchBehaviourSortedListForMapOverride & _out_1,
                GGS_branchBehaviourSortedListForMapOverride & _out_2
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mOverrideName ;
    _out_1 = ptr->mBranchBehaviourSortedListForMapOverride ;
    _out_2 = ptr->mBranchCombinationSortedListForMapOverride ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapOverrideList::
reader_mOverrideNameAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mOverrideName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_branchBehaviourSortedListForMapOverride  GGS_mapOverrideList::
reader_mBranchBehaviourSortedListForMapOverrideAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_branchBehaviourSortedListForMapOverride  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mBranchBehaviourSortedListForMapOverride ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_branchBehaviourSortedListForMapOverride  GGS_mapOverrideList::
reader_mBranchCombinationSortedListForMapOverrideAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_branchBehaviourSortedListForMapOverride  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mBranchCombinationSortedListForMapOverride ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_mapOverrideList::
modifier_setMOverrideNameAtIndex (C_CompilerEx & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mOverrideName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_mapOverrideList::
modifier_setMBranchBehaviourSortedListForMapOverrideAtIndex (C_CompilerEx & inLexique,
                              const GGS_branchBehaviourSortedListForMapOverride  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mBranchBehaviourSortedListForMapOverride = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_mapOverrideList::
modifier_setMBranchCombinationSortedListForMapOverrideAtIndex (C_CompilerEx & inLexique,
                              const GGS_branchBehaviourSortedListForMapOverride  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mBranchCombinationSortedListForMapOverride = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_mapOverrideList::cEnumerator::_mOverrideName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mOverrideName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_branchBehaviourSortedListForMapOverride  & GGS_mapOverrideList::cEnumerator::_mBranchBehaviourSortedListForMapOverride (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mBranchBehaviourSortedListForMapOverride ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_branchBehaviourSortedListForMapOverride  & GGS_mapOverrideList::cEnumerator::_mBranchCombinationSortedListForMapOverride (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mBranchCombinationSortedListForMapOverride ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_mapOverrideList::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_mapOverrideList * p = NULL ;
    macroMyNew (p, GGS_mapOverrideList (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapOverrideList GGS_mapOverrideList::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_mapOverrideList result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_mapOverrideList * p = dynamic_cast <const GGS_mapOverrideList *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_mapOverrideList, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_mapOverrideList::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_mapOverrideList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//       Category method '@mapDeclarationAST.performSemanticAnalysis'        *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__mapDeclarationAST__performSemanticAnalysis (C_CompilerEx & inLexique,
                                const cPtr_mapDeclarationAST * operand_16813,
                                const GGS_semanticContext  var_cas_inSemanticContext,
                                const GGS_predefinedTypes  var_cas_inPredefinedTypes,
                                GGS_semanticDeclarationSortedListForGeneration  & var_cas_ioSemanticDeclarationListForGeneration
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_16813 != NULL) {
    GGS_stringset  var_cas_initialStateSet = GGS_stringset ::constructor_emptySet () ;
    {
      GGS_insertMethodListAST::cEnumerator enumerator_17081 (operand_16813->mInsertMethodList, true) ;
      const GGS_insertMethodListAST::cElement * operand_17081 = NULL ;
      while (((operand_17081 = enumerator_17081.nextObject ()))) {
        macroValidPointer (operand_17081) ;
        const GGS_bool cond_17377 = (operand_16813->mMapStateList.reader_length ()).operator_strictSup (GGS_uint (0U)) ;
        if (cond_17377.isBuiltAndTrue ()) {
          const GGS_bool cond_17295 = (operand_17081->mInitialStateName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (423))).operator_isEqual (GGS_string ("")) ;
          if (cond_17295.isBuiltAndTrue ()) {
            operand_17081->mInsertMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("the '")).operator_concat (operand_17081->mInsertMethodName)).operator_concat (GGS_string ("' insert method should name an automaton state")) COMMA_SOURCE_FILE_AT_LINE (425)) ;
          }else if (cond_17295.isBuiltAndFalse ()) {
            var_cas_initialStateSet.addAssign_operation (operand_17081->mInitialStateName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (426))) ;
          }
        }else if (cond_17377.isBuiltAndFalse ()) {
          const GGS_bool cond_17539 = (operand_17081->mInitialStateName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (428))).operator_isNotEqual (GGS_string ("")) ;
          if (cond_17539.isBuiltAndTrue ()) {
            operand_17081->mInsertMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("the '")).operator_concat (operand_17081->mInsertMethodName)).operator_concat (GGS_string ("' insert method should not name an automaton state")) COMMA_SOURCE_FILE_AT_LINE (430)) ;
          }
        }
      }
    }
    GGS_mapAutomatonActionMap  var_cas_mapAutomatonActionMap = GGS_mapAutomatonActionMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (433)) ;
    {
      GGS_mapSearchMethodListAST::cEnumerator enumerator_17684 (operand_16813->mSearchMethodList, true) ;
      const GGS_mapSearchMethodListAST::cElement * operand_17684 = NULL ;
      while (((operand_17684 = enumerator_17684.nextObject ()))) {
        macroValidPointer (operand_17684) ;
        const GGS_bool cond_18210 = (operand_16813->mMapStateList.reader_length ()).operator_strictSup (GGS_uint (0U)) ;
        if (cond_18210.isBuiltAndTrue ()) {
          const GGS_bool cond_17894 = (operand_17684->mActionName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (436))).operator_isEqual (GGS_string ("")) ;
          if (cond_17894.isBuiltAndTrue ()) {
            operand_17684->mSearchMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("the '")).operator_concat (operand_17684->mSearchMethodName)).operator_concat (GGS_string ("' search method should name an automaton action")) COMMA_SOURCE_FILE_AT_LINE (438)) ;
          }else if (cond_17894.isBuiltAndFalse ()) {
            const GGS_bool cond_18195 = (var_cas_mapAutomatonActionMap.reader_hasKey (operand_17684->mActionName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (438)))).operator_not () ;
            if (cond_18195.isBuiltAndTrue ()) {
              var_cas_mapAutomatonActionMap.modifier_insertKey (inLexique, operand_17684->mActionName, var_cas_mapAutomatonActionMap.reader_count () COMMA_SOURCE_FILE_AT_LINE (440)) ;
            }
          }
        }else if (cond_18210.isBuiltAndFalse ()) {
          const GGS_bool cond_18367 = (operand_17684->mActionName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (444))).operator_isNotEqual (GGS_string ("")) ;
          if (cond_18367.isBuiltAndTrue ()) {
            operand_17684->mSearchMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("the '")).operator_concat (operand_17684->mSearchMethodName)).operator_concat (GGS_string ("' search method should not name an automaton action")) COMMA_SOURCE_FILE_AT_LINE (446)) ;
          }
        }
      }
    }
    GGS_mapAutomatonStateMap  var_cas_mapAutomatonStateMap = GGS_mapAutomatonStateMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (449)) ;
    {
      GGS_mapStateList::cEnumerator enumerator_18497 (operand_16813->mMapStateList, true) ;
      const GGS_mapStateList::cElement * operand_18497 = NULL ;
      while (((operand_18497 = enumerator_18497.nextObject ()))) {
        macroValidPointer (operand_18497) ;
        var_cas_mapAutomatonStateMap.modifier_insertKey (inLexique, operand_18497->mStateName, var_cas_mapAutomatonStateMap.reader_count () COMMA_SOURCE_FILE_AT_LINE (451)) ;
      }
    }
    {
      GGS_mapStateList::cEnumerator enumerator_18623 (operand_16813->mMapStateList, true) ;
      const GGS_mapStateList::cElement * operand_18623 = NULL ;
      while (((operand_18623 = enumerator_18623.nextObject ()))) {
        macroValidPointer (operand_18623) ;
        {
          GGS_mapStateTransitionList::cEnumerator enumerator_18654 (operand_18623->mTransitionList, true) ;
          const GGS_mapStateTransitionList::cElement * operand_18654 = NULL ;
          while (((operand_18654 = enumerator_18654.nextObject ()))) {
            macroValidPointer (operand_18654) ;
            GGS_uint  automatic_var_18717_0 ;
            if (var_cas_mapAutomatonStateMap.isBuilt ()) {
              var_cas_mapAutomatonStateMap (HERE)->method_searchKey (inLexique, operand_18654->mTargetStateName, automatic_var_18717_0 COMMA_SOURCE_FILE_AT_LINE (455)) ;
            }
          }
        }
      }
    }
    const GGS_stringset  var_cas_allActions = var_cas_mapAutomatonActionMap.reader_allKeys (inLexique COMMA_SOURCE_FILE_AT_LINE (459)) ;
    GGS_mapStateSortedList  var_cas_mapStateSortedList = GGS_mapStateSortedList ::constructor_emptySortedList () ;
    {
      GGS_mapStateList::cEnumerator enumerator_18950 (operand_16813->mMapStateList, true) ;
      const GGS_mapStateList::cElement * operand_18950 = NULL ;
      while (((operand_18950 = enumerator_18950.nextObject ()))) {
        macroValidPointer (operand_18950) ;
        GGS_stringset  var_cas_actionsForCurrentState = GGS_stringset ::constructor_emptySet () ;
        GGS_mapStateTransitionSortedList  var_cas_mapStateTransitionSortedList = GGS_mapStateTransitionSortedList ::constructor_emptySortedList () ;
        {
          GGS_mapStateTransitionList::cEnumerator enumerator_19115 (operand_18950->mTransitionList, true) ;
          const GGS_mapStateTransitionList::cElement * operand_19115 = NULL ;
          while (((operand_19115 = enumerator_19115.nextObject ()))) {
            macroValidPointer (operand_19115) ;
            GGS_uint  var_cas_actionIndex ;
            if (var_cas_mapAutomatonActionMap.isBuilt ()) {
              var_cas_mapAutomatonActionMap (HERE)->method_searchKey (inLexique, operand_19115->mActionName, var_cas_actionIndex COMMA_SOURCE_FILE_AT_LINE (466)) ;
            }
            const GGS_bool cond_19386 = var_cas_actionsForCurrentState.reader_hasKey (operand_19115->mActionName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (467))) ;
            if (cond_19386.isBuiltAndTrue ()) {
              operand_19115->mActionName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("the '")).operator_concat (operand_19115->mActionName)).operator_concat (GGS_string ("' action is already used for this state")) COMMA_SOURCE_FILE_AT_LINE (469)) ;
            }
            var_cas_actionsForCurrentState.addAssign_operation (operand_19115->mActionName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (470))) ;
            GGS_uint  var_cas_targetStateIndex ;
            if (var_cas_mapAutomatonStateMap.isBuilt ()) {
              var_cas_mapAutomatonStateMap (HERE)->method_searchKey (inLexique, operand_19115->mTargetStateName, var_cas_targetStateIndex COMMA_SOURCE_FILE_AT_LINE (472)) ;
            }
            var_cas_mapStateTransitionSortedList.addAssign_operation (var_cas_actionIndex, operand_19115->mActionName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (475)), var_cas_targetStateIndex, operand_19115->mTargetStateName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (477)), operand_19115->mTransitionMessageKind, operand_19115->mTransitionMessage.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (479))) ;
          }
        }
        GGS_uint  var_cas_stateIndex ;
        if (var_cas_mapAutomatonStateMap.isBuilt ()) {
          var_cas_mapAutomatonStateMap (HERE)->method_searchKey (inLexique, operand_18950->mStateName, var_cas_stateIndex COMMA_SOURCE_FILE_AT_LINE (483)) ;
        }
        var_cas_mapStateSortedList.addAssign_operation (var_cas_stateIndex, operand_18950->mStateName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (486)), operand_18950->mStateMessageKind, operand_18950->mStateMessage.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (488)), var_cas_mapStateTransitionSortedList) ;
        GGS_stringset  var_cas_missingActions = var_cas_allActions.substract_operation (inLexique, var_cas_actionsForCurrentState COMMA_SOURCE_FILE_AT_LINE (491)) ;
        const GGS_bool cond_20410 = (var_cas_missingActions.reader_count ()).operator_strictSup (GGS_uint (0U)) ;
        if (cond_20410.isBuiltAndTrue ()) {
          GGS_string var_cas_s = GGS_string ("") ;
          {
            GGS_stringset::cEnumerator enumerator_20217 (var_cas_missingActions, true) ;
            if (enumerator_20217 .hasCurrentObject ()) {
              bool _foreach_loop_20217 ;
              do{
                var_cas_s.appendCString ("'") ;
                var_cas_s.dotAssign_operation (enumerator_20217._key (HERE)) ;
                var_cas_s.appendCString ("'") ;
                enumerator_20217.next () ;
                _foreach_loop_20217 = (enumerator_20217 .hasCurrentObject ()) ;
                if (_foreach_loop_20217) {
                  var_cas_s.appendCString (", ") ;
                }
              }while (_foreach_loop_20217) ;
            }
          }
          operand_18950->mStateName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, (GGS_string ("the following actions are not named in a transition from this state: ")).operator_concat (var_cas_s) COMMA_SOURCE_FILE_AT_LINE (499)) ;
        }
      }
    }
    GGS_stringset  var_cas_accessibleStates = var_cas_initialStateSet ;
    GGS_bool var_cas_progress = GGS_bool (true) ;
    GGS_uint _variant_20998 = operand_16813->mMapStateList.reader_length ().add_operation (inLexique, GGS_uint (1U) COMMA_SOURCE_FILE_AT_LINE (504)) ;
    GGS_bool _condition_20998 (_variant_20998.isBuilt (), true) ;
    while (_condition_20998.isBuiltAndTrue ()) {
      _condition_20998 = var_cas_progress ;
      if (_condition_20998.isBuiltAndTrue ()) {
        if (_variant_20998.uintValue () == 0) {
          inLexique.onTheFlyRunTimeError ("loop variant error" COMMA_SOURCE_FILE_AT_LINE (516)) ;
          _condition_20998 = GGS_bool (false) ;
        }else{
          _variant_20998.decrement_operation (inLexique COMMA_HERE) ;
          var_cas_progress = GGS_bool (false) ;
          {
            GGS_mapStateList::cEnumerator enumerator_20652 (operand_16813->mMapStateList, true) ;
            const GGS_mapStateList::cElement * operand_20652 = NULL ;
            while (((operand_20652 = enumerator_20652.nextObject ()))) {
              macroValidPointer (operand_20652) ;
              const GGS_bool cond_20969 = var_cas_accessibleStates.reader_hasKey (operand_20652->mStateName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (507))) ;
              if (cond_20969.isBuiltAndTrue ()) {
                {
                  GGS_mapStateTransitionList::cEnumerator enumerator_20748 (operand_20652->mTransitionList, true) ;
                  const GGS_mapStateTransitionList::cElement * operand_20748 = NULL ;
                  while (((operand_20748 = enumerator_20748.nextObject ()))) {
                    macroValidPointer (operand_20748) ;
                    const GGS_bool cond_20932 = (var_cas_accessibleStates.reader_hasKey (operand_20748->mTargetStateName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (509)))).operator_not () ;
                    if (cond_20932.isBuiltAndTrue ()) {
                      var_cas_accessibleStates.addAssign_operation (operand_20748->mTargetStateName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (510))) ;
                      var_cas_progress = GGS_bool (true) ;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    const GGS_stringset  var_cas_uselessStates = var_cas_mapAutomatonStateMap.reader_allKeys (inLexique COMMA_SOURCE_FILE_AT_LINE (517)).substract_operation (inLexique, var_cas_accessibleStates COMMA_SOURCE_FILE_AT_LINE (517)) ;
    const GGS_bool cond_21335 = (var_cas_uselessStates.reader_count ()).operator_strictSup (GGS_uint (0U)) ;
    if (cond_21335.isBuiltAndTrue ()) {
      GGS_string var_cas_s = GGS_string ("") ;
      {
        GGS_stringset::cEnumerator enumerator_21177 (var_cas_uselessStates, true) ;
        if (enumerator_21177 .hasCurrentObject ()) {
          bool _foreach_loop_21177 ;
          do{
            var_cas_s.appendCString ("'") ;
            var_cas_s.dotAssign_operation (enumerator_21177._key (HERE)) ;
            var_cas_s.appendCString ("'") ;
            enumerator_21177.next () ;
            _foreach_loop_21177 = (enumerator_21177 .hasCurrentObject ()) ;
            if (_foreach_loop_21177) {
              var_cas_s.appendCString (", ") ;
            }
          }while (_foreach_loop_21177) ;
        }
      }
      GGS_location (inLexique).reader_location (inLexique COMMA_HERE).signalGGSSemanticWarning (inLexique, (GGS_string ("the following map automaton states are useless: ")).operator_concat (var_cas_s) COMMA_SOURCE_FILE_AT_LINE (524)) ;
    }
    GGS_stringset  var_cas_neededAssociations = GGS_stringset ::constructor_emptySet () ;
    GGS_stringset  var_cas_accessibilityGraph = GGS_stringset ::constructor_emptySet () ;
    {
      GGS_mapAutomatonStateMap::cEnumerator enumerator_21547 (var_cas_mapAutomatonStateMap, true) ;
      const GGS_mapAutomatonStateMap::cElement * operand_21547 = NULL ;
      while (((operand_21547 = enumerator_21547.nextObject ()))) {
        macroValidPointer (operand_21547) ;
        GGS_stringset  var_cas_reachableStates = GGS_stringset ::constructor_emptySet () ;
        var_cas_reachableStates.addAssign_operation (operand_21547->mKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (532))) ;
        GGS_bool var_cas_progress = GGS_bool (true) ;
        GGS_uint _variant_22229 = var_cas_mapAutomatonStateMap.reader_count ().add_operation (inLexique, GGS_uint (1U) COMMA_SOURCE_FILE_AT_LINE (534)) ;
        GGS_bool _condition_22229 (_variant_22229.isBuilt (), true) ;
        while (_condition_22229.isBuiltAndTrue ()) {
          _condition_22229 = var_cas_progress ;
          if (_condition_22229.isBuiltAndTrue ()) {
            if (_variant_22229.uintValue () == 0) {
              inLexique.onTheFlyRunTimeError ("loop variant error" COMMA_SOURCE_FILE_AT_LINE (547)) ;
              _condition_22229 = GGS_bool (false) ;
            }else{
              _variant_22229.decrement_operation (inLexique COMMA_HERE) ;
              var_cas_progress = GGS_bool (false) ;
              {
                GGS_mapStateList::cEnumerator enumerator_21779 (operand_16813->mMapStateList, true) ;
                const GGS_mapStateList::cElement * operand_21779 = NULL ;
                while (((operand_21779 = enumerator_21779.nextObject ()))) {
                  macroValidPointer (operand_21779) ;
                  const GGS_bool cond_22196 = var_cas_reachableStates.reader_hasKey (operand_21779->mStateName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (537))) ;
                  if (cond_22196.isBuiltAndTrue ()) {
                    {
                      GGS_mapStateTransitionList::cEnumerator enumerator_21878 (operand_21779->mTransitionList, true) ;
                      const GGS_mapStateTransitionList::cElement * operand_21878 = NULL ;
                      while (((operand_21878 = enumerator_21878.nextObject ()))) {
                        macroValidPointer (operand_21878) ;
                        const GGS_bool cond_22155 = (var_cas_reachableStates.reader_hasKey (operand_21878->mTargetStateName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (539)))).operator_not () ;
                        if (cond_22155.isBuiltAndTrue ()) {
                          var_cas_reachableStates.addAssign_operation (operand_21878->mTargetStateName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (540))) ;
                          var_cas_accessibilityGraph.addAssign_operation (((operand_21547->mKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (541))).operator_concat (GGS_string (":"))).operator_concat (operand_21878->mTargetStateName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (541)))) ;
                          var_cas_progress = GGS_bool (true) ;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        {
          GGS_stringset::cEnumerator enumerator_22264 (var_cas_reachableStates, true) ;
          while (enumerator_22264.hasCurrentObject ()) {
            const GGS_bool cond_22371 = (operand_21547->mKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (549))).operator_isNotEqual (enumerator_22264._key (HERE)) ;
            if (cond_22371.isBuiltAndTrue ()) {
              var_cas_neededAssociations.addAssign_operation (((operand_21547->mKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (550))).operator_concat (GGS_string (":"))).operator_concat (enumerator_22264._key (HERE))) ;
            }
            enumerator_22264.next () ;
          }
        }
      }
    }
    {
      GGS_mapOverrideBlockListAST::cEnumerator enumerator_22450 (operand_16813->mMapOverrideBlockListAST, true) ;
      const GGS_mapOverrideBlockListAST::cElement * operand_22450 = NULL ;
      while (((operand_22450 = enumerator_22450.nextObject ()))) {
        macroValidPointer (operand_22450) ;
        GGS_stringset  var_cas_handledAssociations = GGS_stringset ::constructor_emptySet () ;
        GGS_stringset  var_cas_neededCombinaisons = GGS_stringset ::constructor_emptySet () ;
        {
          GGS_mapOverrideBlockDescriptorAST::cEnumerator enumerator_22592 (operand_22450->mMapOverrideBlockDescriptor1AST, true) ;
          const GGS_mapOverrideBlockDescriptorAST::cElement * operand_22592 = NULL ;
          while (((operand_22592 = enumerator_22592.nextObject ()))) {
            macroValidPointer (operand_22592) ;
            GGS_uint  var_cas_startStateNameIndex ;
            if (var_cas_mapAutomatonStateMap.isBuilt ()) {
              var_cas_mapAutomatonStateMap (HERE)->method_searchKey (inLexique, operand_22592->mLeftState, var_cas_startStateNameIndex COMMA_SOURCE_FILE_AT_LINE (560)) ;
            }
            GGS_uint  var_cas_currentStateNameIndex ;
            if (var_cas_mapAutomatonStateMap.isBuilt ()) {
              var_cas_mapAutomatonStateMap (HERE)->method_searchKey (inLexique, operand_22592->mRightState, var_cas_currentStateNameIndex COMMA_SOURCE_FILE_AT_LINE (562)) ;
            }
            const GGS_string var_cas_association = ((operand_22592->mLeftState.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (563))).operator_concat (GGS_string (":"))).operator_concat (operand_22592->mRightState.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (563))) ;
            const GGS_bool cond_23053 = (var_cas_neededAssociations.reader_hasKey (var_cas_association)).operator_not () ;
            if (cond_23053.isBuiltAndTrue ()) {
              operand_22592->mRightState.reader_location (inLexique COMMA_HERE).signalGGSSemanticWarning (inLexique, ((GGS_string ("the '")).operator_concat (var_cas_association)).operator_concat (GGS_string ("' association is useless")) COMMA_SOURCE_FILE_AT_LINE (565)) ;
            }
            const GGS_bool cond_23220 = var_cas_handledAssociations.reader_hasKey (var_cas_association) ;
            if (cond_23220.isBuiltAndTrue ()) {
              operand_22592->mRightState.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("the '")).operator_concat (var_cas_association)).operator_concat (GGS_string ("' association is already defined")) COMMA_SOURCE_FILE_AT_LINE (570)) ;
            }
            var_cas_handledAssociations.addAssign_operation (var_cas_association) ;
            GGS_uint  var_cas_finalStateNameIndex ;
            if (var_cas_mapAutomatonStateMap.isBuilt ()) {
              var_cas_mapAutomatonStateMap (HERE)->method_searchKey (inLexique, operand_22592->mResultingState, var_cas_finalStateNameIndex COMMA_SOURCE_FILE_AT_LINE (573)) ;
            }
            const GGS_bool cond_23864 = (operand_22592->mLeftState.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (574))).operator_isNotEqual (operand_22592->mRightState.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (574))) ;
            if (cond_23864.isBuiltAndTrue ()) {
              var_cas_neededCombinaisons.addAssign_operation (((operand_22592->mLeftState.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (575))).operator_concat (GGS_string (":"))).operator_concat (operand_22592->mRightState.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (575)))) ;
              var_cas_neededCombinaisons.addAssign_operation (((operand_22592->mRightState.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (576))).operator_concat (GGS_string (":"))).operator_concat (operand_22592->mLeftState.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (576)))) ;
              const GGS_bool cond_23849 = (var_cas_accessibilityGraph.reader_hasKey (((operand_22592->mLeftState.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (577))).operator_concat (GGS_string (":"))).operator_concat (operand_22592->mRightState.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (577))))).operator_not () ;
              if (cond_23849.isBuiltAndTrue ()) {
                operand_22592->mRightState.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((GGS_string ("the '")).operator_concat (operand_22592->mRightState)).operator_concat (GGS_string ("' state is not reachable from '"))).operator_concat (operand_22592->mLeftState)).operator_concat (GGS_string ("' state")) COMMA_SOURCE_FILE_AT_LINE (581)) ;
              }
            }
            if (operand_22592->mTransitionMessage.isBuilt ()) {
              ::routine_check_K_escapeCharacters (inLexique,  operand_22592->mTransitionMessage COMMA_SOURCE_FILE_AT_LINE (583)) ;
            }
          }
        }
        GGS_stringset  var_cas_forgottenAssociations = var_cas_neededAssociations.substract_operation (inLexique, var_cas_handledAssociations COMMA_SOURCE_FILE_AT_LINE (585)) ;
        const GGS_bool cond_24290 = (var_cas_forgottenAssociations.reader_count ()).operator_strictSup (GGS_uint (0U)) ;
        if (cond_24290.isBuiltAndTrue ()) {
          GGS_string var_cas_s = GGS_string ("") ;
          {
            GGS_stringset::cEnumerator enumerator_24129 (var_cas_forgottenAssociations, true) ;
            while (enumerator_24129.hasCurrentObject ()) {
              var_cas_s.appendCString ("\n"
                "  - ") ;
              var_cas_s.dotAssign_operation (enumerator_24129._key (HERE)) ;
              enumerator_24129.next () ;
            }
          }
          GGS_location (inLexique).reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((var_cas_forgottenAssociations.reader_count ().reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (591))).operator_concat (GGS_string (" associations should be defined:"))).operator_concat (var_cas_s) COMMA_SOURCE_FILE_AT_LINE (592)) ;
        }
        GGS_stringset  var_cas_definedCombinaisons = GGS_stringset ::constructor_emptySet () ;
        {
          GGS_mapOverrideBlockDescriptorAST::cEnumerator enumerator_24387 (operand_22450->mMapOverrideBlockDescriptor2AST, true) ;
          const GGS_mapOverrideBlockDescriptorAST::cElement * operand_24387 = NULL ;
          while (((operand_24387 = enumerator_24387.nextObject ()))) {
            macroValidPointer (operand_24387) ;
            GGS_uint  var_cas_branchStateNameIndex ;
            if (var_cas_mapAutomatonStateMap.isBuilt ()) {
              var_cas_mapAutomatonStateMap (HERE)->method_searchKey (inLexique, operand_24387->mLeftState, var_cas_branchStateNameIndex COMMA_SOURCE_FILE_AT_LINE (596)) ;
            }
            GGS_uint  var_cas_otherBranchStateNameIndex ;
            if (var_cas_mapAutomatonStateMap.isBuilt ()) {
              var_cas_mapAutomatonStateMap (HERE)->method_searchKey (inLexique, operand_24387->mRightState, var_cas_otherBranchStateNameIndex COMMA_SOURCE_FILE_AT_LINE (598)) ;
            }
            const GGS_string var_cas_combinaison = ((operand_24387->mLeftState.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (599))).operator_concat (GGS_string (":"))).operator_concat (operand_24387->mRightState.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (599))) ;
            const GGS_bool cond_24883 = (var_cas_neededCombinaisons.reader_hasKey (var_cas_combinaison)).operator_not () ;
            if (cond_24883.isBuiltAndTrue ()) {
              operand_24387->mRightState.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((GGS_string ("the '")).operator_concat (operand_24387->mLeftState)).operator_concat (GGS_string (":"))).operator_concat (operand_24387->mRightState)).operator_concat (GGS_string ("' combinaison is useless")) COMMA_SOURCE_FILE_AT_LINE (603)) ;
            }
            const GGS_bool cond_25069 = var_cas_definedCombinaisons.reader_hasKey (var_cas_combinaison) ;
            if (cond_25069.isBuiltAndTrue ()) {
              operand_24387->mRightState.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((GGS_string ("the '")).operator_concat (operand_24387->mLeftState)).operator_concat (GGS_string (":"))).operator_concat (operand_24387->mRightState)).operator_concat (GGS_string ("' combinaison is already defined")) COMMA_SOURCE_FILE_AT_LINE (607)) ;
            }
            var_cas_definedCombinaisons.addAssign_operation (var_cas_combinaison) ;
            const GGS_bool cond_25278 = (operand_24387->mMessageKind).operator_isEqual (GGS_mapAutomatonMessageKind::constructor_noMessage (inLexique COMMA_SOURCE_FILE_AT_LINE (609))) ;
            if (cond_25278.isBuiltAndTrue ()) {
              var_cas_definedCombinaisons.addAssign_operation (((operand_24387->mRightState.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (610))).operator_concat (GGS_string (":"))).operator_concat (operand_24387->mLeftState.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (610)))) ;
            }
            GGS_uint  var_cas_resultingStateNameIndex ;
            if (var_cas_mapAutomatonStateMap.isBuilt ()) {
              var_cas_mapAutomatonStateMap (HERE)->method_searchKey (inLexique, operand_24387->mResultingState, var_cas_resultingStateNameIndex COMMA_SOURCE_FILE_AT_LINE (613)) ;
            }
            const GGS_bool cond_25771 = (((operand_24387->mLeftState.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (614))).operator_isNotEqual (operand_24387->mResultingState.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (614)))).operator_and ((operand_24387->mRightState.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (615))).operator_isNotEqual (operand_24387->mResultingState.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (615))))).operator_and ((var_cas_accessibilityGraph.reader_hasKey (((operand_24387->mLeftState.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (616))).operator_concat (GGS_string (":"))).operator_concat (operand_24387->mResultingState.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (616))))).operator_not ()) ;
            if (cond_25771.isBuiltAndTrue ()) {
              operand_24387->mResultingState.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((GGS_string ("the '")).operator_concat (operand_24387->mResultingState)).operator_concat (GGS_string ("' state cannot be reached from the '"))).operator_concat (operand_24387->mResultingState)).operator_concat (GGS_string ("' state")) COMMA_SOURCE_FILE_AT_LINE (619)) ;
            }
            if (operand_24387->mTransitionMessage.isBuilt ()) {
              ::routine_check_K_escapeCharacters (inLexique,  operand_24387->mTransitionMessage COMMA_SOURCE_FILE_AT_LINE (620)) ;
            }
          }
        }
        const GGS_bool cond_26314 = (var_cas_forgottenAssociations.reader_count ()).operator_isEqual (GGS_uint (0U)) ;
        if (cond_26314.isBuiltAndTrue ()) {
          GGS_stringset  var_cas_forgottenCombinaisons = var_cas_neededCombinaisons.substract_operation (inLexique, var_cas_definedCombinaisons COMMA_SOURCE_FILE_AT_LINE (623)) ;
          const GGS_bool cond_26301 = (var_cas_forgottenCombinaisons.reader_count ()).operator_strictSup (GGS_uint (0U)) ;
          if (cond_26301.isBuiltAndTrue ()) {
            GGS_string var_cas_s = GGS_string ("") ;
            {
              GGS_stringset::cEnumerator enumerator_26136 (var_cas_forgottenCombinaisons, true) ;
              while (enumerator_26136.hasCurrentObject ()) {
                var_cas_s.appendCString ("\n"
                  "  - ") ;
                var_cas_s.dotAssign_operation (enumerator_26136._key (HERE)) ;
                enumerator_26136.next () ;
              }
            }
            GGS_location (inLexique).reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((var_cas_forgottenCombinaisons.reader_count ().reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (629))).operator_concat (GGS_string (" combinaisons are forgotten:"))).operator_concat (var_cas_s) COMMA_SOURCE_FILE_AT_LINE (630)) ;
          }
        }
      }
    }
    GGS_typedAttributeList  var_cas_typedAttributeList = GGS_typedAttributeList ::constructor_emptyList () ;
    GGS_attributeIndexMap  var_cas_attributeMap = GGS_attributeIndexMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (635)) ;
    {
      GGS_attributeInCollectionListAST::cEnumerator enumerator_26487 (operand_16813->mAttributeList, true) ;
      const GGS_attributeInCollectionListAST::cElement * operand_26487 = NULL ;
      while (((operand_26487 = enumerator_26487.nextObject ()))) {
        macroValidPointer (operand_26487) ;
        GGS_unifiedTypeMapProxy  var_cas_t = GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_26487->mAttributeTypeName COMMA_SOURCE_FILE_AT_LINE (637)) ;
        GGS_bool var_cas_hasSetter = GGS_bool (true) ;
        GGS_bool var_cas_hasGetter = GGS_bool (true) ;
        var_cas_typedAttributeList.addAssign_operation (var_cas_t, operand_26487->mAttributeName, var_cas_hasSetter, var_cas_hasGetter) ;
        var_cas_attributeMap.modifier_insertKey (inLexique, operand_26487->mAttributeName, var_cas_t COMMA_SOURCE_FILE_AT_LINE (646)) ;
      }
    }
    GGS_insertMethodMap  var_cas_insertMethodMap = GGS_insertMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (649)) ;
    {
      GGS_insertMethodListAST::cEnumerator enumerator_26909 (operand_16813->mInsertMethodList, true) ;
      const GGS_insertMethodListAST::cElement * operand_26909 = NULL ;
      while (((operand_26909 = enumerator_26909.nextObject ()))) {
        macroValidPointer (operand_26909) ;
        var_cas_insertMethodMap.modifier_insertKey (inLexique, operand_26909->mInsertMethodName COMMA_SOURCE_FILE_AT_LINE (651)) ;
        {
          GGS_stringlist::cEnumerator enumerator_27045 (operand_26909->mErrorMessage.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (653)).reader_componentsSeparatedByString (GGS_string ("%%")), true) ;
          const GGS_stringlist::cElement * operand_27045 = NULL ;
          while (((operand_27045 = enumerator_27045.nextObject ()))) {
            macroValidPointer (operand_27045) ;
            GGS_stringlist  var_cas_explodedArray = operand_27045->mValue.reader_componentsSeparatedByString (GGS_string ("%")) ;
            GGS_string automatic_var_27220_0 ;
            var_cas_explodedArray.modifier_popFirst (inLexique, automatic_var_27220_0 COMMA_SOURCE_FILE_AT_LINE (655)) ;
            {
              GGS_stringlist::cEnumerator enumerator_27250 (var_cas_explodedArray, true) ;
              const GGS_stringlist::cElement * operand_27250 = NULL ;
              while (((operand_27250 = enumerator_27250.nextObject ()))) {
                macroValidPointer (operand_27250) ;
                const GGS_bool cond_27538 = (operand_27250->mValue.reader_length ()).operator_strictSup (GGS_uint (0U)) ;
                if (cond_27538.isBuiltAndTrue ()) {
                  const GGS_char var_cas_c = operand_27250->mValue.reader_characterAtIndex (inLexique, GGS_uint (0U) COMMA_SOURCE_FILE_AT_LINE (658)) ;
                  const GGS_bool cond_27521 = ((var_cas_c).operator_isNotEqual (GGS_char (TO_UNICODE ('K')))).operator_and ((var_cas_c).operator_isNotEqual (GGS_char (TO_UNICODE ('L')))) ;
                  if (cond_27521.isBuiltAndTrue ()) {
                    operand_26909->mErrorMessage.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("only '%K', '%L' and '%%' escape sequences are allowed in an insert error message") COMMA_SOURCE_FILE_AT_LINE (661)) ;
                  }
                }
              }
            }
          }
        }
        {
          GGS_stringlist::cEnumerator enumerator_27666 (operand_26909->mShadowErrorMessage.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (666)).reader_componentsSeparatedByString (GGS_string ("%%")), true) ;
          const GGS_stringlist::cElement * operand_27666 = NULL ;
          while (((operand_27666 = enumerator_27666.nextObject ()))) {
            macroValidPointer (operand_27666) ;
            GGS_stringlist  var_cas_explodedArray = operand_27666->mValue.reader_componentsSeparatedByString (GGS_string ("%")) ;
            GGS_string automatic_var_27847_0 ;
            var_cas_explodedArray.modifier_popFirst (inLexique, automatic_var_27847_0 COMMA_SOURCE_FILE_AT_LINE (668)) ;
            {
              GGS_stringlist::cEnumerator enumerator_27877 (var_cas_explodedArray, true) ;
              const GGS_stringlist::cElement * operand_27877 = NULL ;
              while (((operand_27877 = enumerator_27877.nextObject ()))) {
                macroValidPointer (operand_27877) ;
                const GGS_bool cond_28164 = (operand_27877->mValue.reader_length ()).operator_strictSup (GGS_uint (0U)) ;
                if (cond_28164.isBuiltAndTrue ()) {
                  const GGS_char var_cas_c = operand_27877->mValue.reader_characterAtIndex (inLexique, GGS_uint (0U) COMMA_SOURCE_FILE_AT_LINE (671)) ;
                  const GGS_bool cond_28147 = ((var_cas_c).operator_isNotEqual (GGS_char (TO_UNICODE ('K')))).operator_and ((var_cas_c).operator_isNotEqual (GGS_char (TO_UNICODE ('L')))) ;
                  if (cond_28147.isBuiltAndTrue ()) {
                    operand_26909->mErrorMessage.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("only '%K', '%L' and '%%' escape sequences are allowed in a shadow error message") COMMA_SOURCE_FILE_AT_LINE (674)) ;
                  }
                }
              }
            }
          }
        }
      }
    }
    GGS_searchMethodMap  var_cas_searchMethodMap = GGS_searchMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (680)) ;
    {
      GGS_mapSearchMethodListAST::cEnumerator enumerator_28325 (operand_16813->mSearchMethodList, true) ;
      const GGS_mapSearchMethodListAST::cElement * operand_28325 = NULL ;
      while (((operand_28325 = enumerator_28325.nextObject ()))) {
        macroValidPointer (operand_28325) ;
        const GGS_bool cond_28438 = (operand_16813->mMapStateList.reader_length ()).operator_isEqual (GGS_uint (0U)) ;
        if (cond_28438.isBuiltAndTrue ()) {
          var_cas_searchMethodMap.modifier_insertKey (inLexique, operand_28325->mSearchMethodName COMMA_SOURCE_FILE_AT_LINE (683)) ;
        }else if (cond_28438.isBuiltAndFalse ()) {
          var_cas_searchMethodMap.modifier_insertKey (inLexique, operand_28325->mSearchMethodName COMMA_SOURCE_FILE_AT_LINE (685)) ;
        }
        {
          GGS_stringlist::cEnumerator enumerator_28582 (operand_28325->mErrorMessage.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (688)).reader_componentsSeparatedByString (GGS_string ("%%")), true) ;
          const GGS_stringlist::cElement * operand_28582 = NULL ;
          while (((operand_28582 = enumerator_28582.nextObject ()))) {
            macroValidPointer (operand_28582) ;
            GGS_stringlist  var_cas_explodedArray = operand_28582->mValue.reader_componentsSeparatedByString (GGS_string ("%")) ;
            GGS_string automatic_var_28757_0 ;
            var_cas_explodedArray.modifier_popFirst (inLexique, automatic_var_28757_0 COMMA_SOURCE_FILE_AT_LINE (690)) ;
            {
              GGS_stringlist::cEnumerator enumerator_28787 (var_cas_explodedArray, true) ;
              const GGS_stringlist::cElement * operand_28787 = NULL ;
              while (((operand_28787 = enumerator_28787.nextObject ()))) {
                macroValidPointer (operand_28787) ;
                const GGS_bool cond_29053 = (operand_28787->mValue.reader_length ()).operator_strictSup (GGS_uint (0U)) ;
                if (cond_29053.isBuiltAndTrue ()) {
                  const GGS_char var_cas_c = operand_28787->mValue.reader_characterAtIndex (inLexique, GGS_uint (0U) COMMA_SOURCE_FILE_AT_LINE (693)) ;
                  const GGS_bool cond_29036 = (var_cas_c).operator_isNotEqual (GGS_char (TO_UNICODE ('K'))) ;
                  if (cond_29036.isBuiltAndTrue ()) {
                    operand_28325->mErrorMessage.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("only '%K' and '%%' escape sequences are allowed in a search error message") COMMA_SOURCE_FILE_AT_LINE (696)) ;
                  }
                }
              }
            }
          }
        }
      }
    }
    {
      GGS_mapRemoveMethodListAST::cEnumerator enumerator_29166 (operand_16813->mRemoveMethodList, true) ;
      const GGS_mapRemoveMethodListAST::cElement * operand_29166 = NULL ;
      while (((operand_29166 = enumerator_29166.nextObject ()))) {
        macroValidPointer (operand_29166) ;
        var_cas_insertMethodMap.modifier_insertKey (inLexique, operand_29166->mMethodName COMMA_SOURCE_FILE_AT_LINE (703)) ;
        {
          GGS_stringlist::cEnumerator enumerator_29292 (operand_29166->mErrorMessage.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (705)).reader_componentsSeparatedByString (GGS_string ("%%")), true) ;
          const GGS_stringlist::cElement * operand_29292 = NULL ;
          while (((operand_29292 = enumerator_29292.nextObject ()))) {
            macroValidPointer (operand_29292) ;
            GGS_stringlist  var_cas_explodedArray = operand_29292->mValue.reader_componentsSeparatedByString (GGS_string ("%")) ;
            GGS_string automatic_var_29467_0 ;
            var_cas_explodedArray.modifier_popFirst (inLexique, automatic_var_29467_0 COMMA_SOURCE_FILE_AT_LINE (707)) ;
            {
              GGS_stringlist::cEnumerator enumerator_29497 (var_cas_explodedArray, true) ;
              const GGS_stringlist::cElement * operand_29497 = NULL ;
              while (((operand_29497 = enumerator_29497.nextObject ()))) {
                macroValidPointer (operand_29497) ;
                const GGS_bool cond_29763 = (operand_29497->mValue.reader_length ()).operator_strictSup (GGS_uint (0U)) ;
                if (cond_29763.isBuiltAndTrue ()) {
                  const GGS_char var_cas_c = operand_29497->mValue.reader_characterAtIndex (inLexique, GGS_uint (0U) COMMA_SOURCE_FILE_AT_LINE (710)) ;
                  const GGS_bool cond_29746 = (var_cas_c).operator_isNotEqual (GGS_char (TO_UNICODE ('K'))) ;
                  if (cond_29746.isBuiltAndTrue ()) {
                    operand_29166->mErrorMessage.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("only '%K' and '%%' escape sequences are allowed in a remove error message") COMMA_SOURCE_FILE_AT_LINE (713)) ;
                  }
                }
              }
            }
          }
        }
      }
    }
    {
        GGS_uint var_cas_IDX (true, 0) ;
      GGS_insertOrReplaceDeclarationListAST::cEnumerator enumerator_29935 (operand_16813->mInsertOrReplaceDeclarationListAST, true) ;
      const GGS_insertOrReplaceDeclarationListAST::cElement * operand_29935 = NULL ;
      while (((operand_29935 = enumerator_29935.nextObject ()))) {
        macroValidPointer (operand_29935) ;
        const GGS_bool cond_30082 = (var_cas_IDX).operator_strictSup (GGS_uint (0U)) ;
        if (cond_30082.isBuiltAndTrue ()) {
          operand_29935->mInsertOrReplaceDeclarationLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticWarning (inLexique, GGS_string ("the 'insertOrReplace' modifier is already declared") COMMA_SOURCE_FILE_AT_LINE (721)) ;
        }
        var_cas_IDX.mValue ++ ;
      }
    }
    const GGS_bool var_cas_hasInsertOrReplaceModifier = (operand_16813->mInsertOrReplaceDeclarationListAST.reader_length ()).operator_strictSup (GGS_uint (0U)) ;
    const GGS_bool cond_30597 = (var_cas_hasInsertOrReplaceModifier).operator_and (var_cas_insertMethodMap.reader_hasKey (GGS_string ("insertOrReplace"))) ;
    if (cond_30597.isBuiltAndTrue ()) {
      GGS_location  var_cas_insertOrReplaceDeclarationLocation ;
      if (operand_16813->mInsertOrReplaceDeclarationListAST.isBuilt ()) {
        operand_16813->mInsertOrReplaceDeclarationListAST (HERE)->method_first (inLexique, var_cas_insertOrReplaceDeclarationLocation COMMA_SOURCE_FILE_AT_LINE (727)) ;
      }
      var_cas_insertOrReplaceDeclarationLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("the insertOrReplace' modifier cannot be declared : an insert modifier or a remove modifier has been declared with this name") COMMA_SOURCE_FILE_AT_LINE (729)) ;
    }
    GGS_withAccessorMap  var_cas_withAccessorMap = GGS_withAccessorMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (731)) ;
    var_cas_withAccessorMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("hasKey"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (732)), var_cas_inPredefinedTypes.mStringType COMMA_SOURCE_FILE_AT_LINE (732)) ;
    {
      GGS_mapSearchMethodListAST::cEnumerator enumerator_30804 (operand_16813->mSearchMethodList, true) ;
      const GGS_mapSearchMethodListAST::cElement * operand_30804 = NULL ;
      while (((operand_30804 = enumerator_30804.nextObject ()))) {
        macroValidPointer (operand_30804) ;
        var_cas_withAccessorMap.modifier_insertKey (inLexique, operand_30804->mSearchMethodName, var_cas_inPredefinedTypes.mLStringType COMMA_SOURCE_FILE_AT_LINE (734)) ;
      }
    }
    var_cas_ioSemanticDeclarationListForGeneration.addAssign_operation (GGS_mapTypeForGeneration ::constructor_new (inLexique, GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_16813->mMapTypeName COMMA_SOURCE_FILE_AT_LINE (741)), operand_16813->mMapTypeName, var_cas_typedAttributeList, operand_16813->mInsertMethodList, operand_16813->mSearchMethodList, operand_16813->mRemoveMethodList, var_cas_hasInsertOrReplaceModifier, var_cas_withAccessorMap COMMA_SOURCE_FILE_AT_LINE (740)), GGS_string ("")) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//    Category method '@mapProxyDeclarationAST.performSemanticAnalysis'      *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__mapProxyDeclarationAST__performSemanticAnalysis (C_CompilerEx & inLexique,
                                const cPtr_mapProxyDeclarationAST * operand_31443,
                                const GGS_semanticContext  var_cas_inSemanticContext,
                                const GGS_predefinedTypes  /* var_cas_inPredefinedTypes */,
                                GGS_semanticDeclarationSortedListForGeneration  & var_cas_ioSemanticDeclarationListForGeneration
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_31443 != NULL) {
    GGS_typedAttributeList  var_cas_listTypeAttributeList ;
    GGS_mapSearchMethodListAST  var_cas_searchMethodList ;
    GGS_bool automatic_var_31870_0 ;
    GGS_unifiedTypeMapProxy  automatic_var_31870_1 ;
    GGS_typeKindEnum automatic_var_31870_2 ;
    GGS_typedAttributeList  automatic_var_31870_3 ;
    GGS_attributeMap  automatic_var_31870_4 ;
    GGS_constructorMap  automatic_var_31870_5 ;
    GGS_readerMap  automatic_var_31870_6 ;
    GGS_modifierMap  automatic_var_31870_7 ;
    GGS_instanceMethodMap  automatic_var_31870_8 ;
    GGS_classMethodMap  automatic_var_31870_9 ;
    GGS_enumerationDescriptorList  automatic_var_31870_10 ;
    GGS_uint  automatic_var_31870_11 ;
    GGS_unifiedTypeMapProxyList  automatic_var_31870_12 ;
    GGS_nativeAttributeList  automatic_var_31870_13 ;
    GGS_stringset  automatic_var_31870_14 ;
    GGS_lstringlist  automatic_var_31870_15 ;
    GGS_typedAttributeList  automatic_var_31870_16 ;
    GGS_mapSearchMethodListAST  automatic_var_31870_17 ;
    GGS_withAccessorMap  automatic_var_31870_18 ;
    GGS_bool automatic_var_31870_19 ;
    if (var_cas_inSemanticContext.mTypeMap.isBuilt ()) {
      var_cas_inSemanticContext.mTypeMap (HERE)->method_searchKey (inLexique, operand_31443->mAssociatedMapTypeName, automatic_var_31870_0, automatic_var_31870_1, automatic_var_31870_2, automatic_var_31870_3, automatic_var_31870_4, var_cas_listTypeAttributeList, automatic_var_31870_5, automatic_var_31870_6, automatic_var_31870_7, automatic_var_31870_8, automatic_var_31870_9, automatic_var_31870_10, automatic_var_31870_11, automatic_var_31870_12, automatic_var_31870_13, automatic_var_31870_14, automatic_var_31870_15, automatic_var_31870_16, var_cas_searchMethodList, automatic_var_31870_17, automatic_var_31870_18, automatic_var_31870_19 COMMA_SOURCE_FILE_AT_LINE (764)) ;
    }
    var_cas_ioSemanticDeclarationListForGeneration.addAssign_operation (GGS_mapProxyTypeForGeneration ::constructor_new (inLexique, GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_31443->mMapProxyTypeName COMMA_SOURCE_FILE_AT_LINE (767)), GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_31443->mAssociatedMapTypeName COMMA_SOURCE_FILE_AT_LINE (768)), var_cas_listTypeAttributeList, var_cas_searchMethodList COMMA_SOURCE_FILE_AT_LINE (766)), GGS_string ("")) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class map '@declaredMethodMap'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_declaredMethodMap ("declaredMethodMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_declaredMethodMap::
elementOf_GGS_declaredMethodMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_declaredMethodMap & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_declaredMethodMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_declaredMethodMap::
isEqualToMapElement (const AC_galgas_map_element * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_declaredMethodMap::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_declaredMethodMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_declaredMethodMap * info = (e_declaredMethodMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_declaredMethodMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_declaredMethodMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_declaredMethodMap * info = (e_declaredMethodMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_declaredMethodMap GGS_declaredMethodMap::
constructor_emptyMap (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_declaredMethodMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_declaredMethodMap::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_declaredMethodMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

void GGS_declaredMethodMap::modifier_insertFakeKey (C_CompilerEx & inCompiler,
                         const GGS_string & inKey,
                         const GGS_location & inHelperMessageErrorLocation,
                         const GGS_string & inHelperMessage
                         COMMA_LOCATION_ARGS) {
  e_declaredMethodMap info  ;
  internal_insertFakeKey (inCompiler,
                          (void *) & info,
                          inKey,
                          inHelperMessageErrorLocation,
                          inHelperMessage
                          COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_declaredMethodMap::
operator_isEqual (const GGS_declaredMethodMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_declaredMethodMap::
operator_isNotEqual (const GGS_declaredMethodMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_declaredMethodMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_declaredMethodMap::
insertElement (C_CompilerEx & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap (THERE) ;
    e_declaredMethodMap info  ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_declaredMethodMap::
searchElement (C_CompilerEx & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inLexique, inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_declaredMethodMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('o'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (' '),
  TO_UNICODE ('f'),
  TO_UNICODE ('o'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE ('s'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_declaredMethodMap::
modifier_insertKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_insertKey,
                 inKey,
                NULL
                COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_declaredMethodMap GGS_declaredMethodMap::
constructor_mapWithMapToOverride (C_CompilerEx & /* inLexique */,
                                  const GGS_declaredMethodMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_declaredMethodMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_declaredMethodMap GGS_declaredMethodMap::
reader_overriddenMap (C_CompilerEx & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_declaredMethodMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_declaredMethodMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @declaredMethodMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_declaredMethodMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_declaredMethodMap * p = NULL ;
    macroMyNew (p, GGS_declaredMethodMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_declaredMethodMap GGS_declaredMethodMap::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_declaredMethodMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_declaredMethodMap * p = dynamic_cast <const GGS_declaredMethodMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_declaredMethodMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_declaredMethodMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_declaredMethodMap ;
}

//---------------------------------------------------------------------------*

GGS_declaredMethodMap GGS_declaredMethodMap::constructor_mapWithKeyAndValue (C_CompilerEx & inLexique,
                                             const GGS_lstring & inKey
                                             COMMA_LOCATION_ARGS) {
  GGS_declaredMethodMap result = constructor_emptyMap (inLexique COMMA_THERE) ;
  result.insertElement (inLexique,
                        0,
                        NULL,
                        inKey,
                        NULL
                        COMMA_THERE) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Implementation of routine "buildLocalVariableMapAndSignature"        *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_buildLocalVariableMapAndSignature (C_CompilerEx & inLexique,
                                const GGS_semanticContext  var_cas_inSemanticContext,
                                const GGS_formalParameterListAST   var_cas_inRoutineSignatureAST,
                                GGS_variableMap  & var_cas_ioVariableMap,
                                GGS_formalParameterListForGeneration  & var_cas_outRoutineSignature
                        COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_buildLocalVariableMapAndSignature at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  var_cas_outRoutineSignature = GGS_formalParameterListForGeneration ::constructor_emptyList () ;
  {
    GGS_formalParameterListAST::cEnumerator enumerator_32887 (var_cas_inRoutineSignatureAST, true) ;
    const GGS_formalParameterListAST::cElement * operand_32887 = NULL ;
    while (((operand_32887 = enumerator_32887.nextObject ()))) {
      macroValidPointer (operand_32887) ;
      const GGS_unifiedTypeMapProxy  var_cas_type = GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_32887->mFormalArgumentTypeName COMMA_SOURCE_FILE_AT_LINE (792)) ;
      GGS_string var_cas_formalArgumentCppName ;
      switch (operand_32887->mFormalArgumentPassingMode.enumValue ()) {
      case GGS_formalArgumentPassingModeAST::enum_argumentIn:
        {
        var_cas_formalArgumentCppName = (GGS_string ("inArgument_")).operator_concat (operand_32887->mFormalArgumentName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (796)).reader_identifierRepresentation ()) ;
        const GGS_bool cond_33373 = operand_32887->mIsUnused ;
        if (cond_33373.isBuiltAndTrue ()) {
          var_cas_ioVariableMap.modifier_insertInputFormalArgumentDeclaredAsUnused (inLexique, operand_32887->mFormalArgumentName, var_cas_type, var_cas_formalArgumentCppName, var_cas_formalArgumentCppName COMMA_SOURCE_FILE_AT_LINE (798)) ;
        }else if (cond_33373.isBuiltAndFalse ()) {
          var_cas_ioVariableMap.modifier_insertInputFormalArgument (inLexique, operand_32887->mFormalArgumentName, var_cas_type, var_cas_formalArgumentCppName, var_cas_formalArgumentCppName COMMA_SOURCE_FILE_AT_LINE (800)) ;
        }
        }
        break ;
      case GGS_formalArgumentPassingModeAST::enum_argumentOut:
        {
        var_cas_formalArgumentCppName = (GGS_string ("outArgument_")).operator_concat (operand_32887->mFormalArgumentName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (803)).reader_identifierRepresentation ()) ;
        var_cas_ioVariableMap.modifier_insertOutputFormalArgument (inLexique, operand_32887->mFormalArgumentName, var_cas_type, var_cas_formalArgumentCppName, var_cas_formalArgumentCppName COMMA_SOURCE_FILE_AT_LINE (804)) ;
        }
        break ;
      case GGS_formalArgumentPassingModeAST::enum_argumentInOut:
        {
        var_cas_formalArgumentCppName = (GGS_string ("ioArgument_")).operator_concat (operand_32887->mFormalArgumentName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (806)).reader_identifierRepresentation ()) ;
        const GGS_bool cond_34084 = operand_32887->mIsUnused ;
        if (cond_34084.isBuiltAndTrue ()) {
          var_cas_ioVariableMap.modifier_insertInputOutputFormalArgumentDeclaredAsUnused (inLexique, operand_32887->mFormalArgumentName, var_cas_type, var_cas_formalArgumentCppName, var_cas_formalArgumentCppName COMMA_SOURCE_FILE_AT_LINE (808)) ;
        }else if (cond_34084.isBuiltAndFalse ()) {
          var_cas_ioVariableMap.modifier_insertInputOutputFormalArgument (inLexique, operand_32887->mFormalArgumentName, var_cas_type, var_cas_formalArgumentCppName, var_cas_formalArgumentCppName COMMA_SOURCE_FILE_AT_LINE (810)) ;
        }
        }
        break ;
      case GGS_formalArgumentPassingModeAST::enum_argumentConstantIn:
        {
        var_cas_formalArgumentCppName = (GGS_string ("constinArgument_")).operator_concat (operand_32887->mFormalArgumentName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (813)).reader_identifierRepresentation ()) ;
        const GGS_bool cond_34558 = operand_32887->mIsUnused ;
        if (cond_34558.isBuiltAndTrue ()) {
          var_cas_ioVariableMap.modifier_insertConstantInputFormalArgumentDeclaredAsUnused (inLexique, operand_32887->mFormalArgumentName, var_cas_type, var_cas_formalArgumentCppName, var_cas_formalArgumentCppName COMMA_SOURCE_FILE_AT_LINE (815)) ;
        }else if (cond_34558.isBuiltAndFalse ()) {
          var_cas_ioVariableMap.modifier_insertConstantInputFormalArgument (inLexique, operand_32887->mFormalArgumentName, var_cas_type, var_cas_formalArgumentCppName, var_cas_formalArgumentCppName COMMA_SOURCE_FILE_AT_LINE (817)) ;
        }
        }
        break ;
      case GGS_formalArgumentPassingModeAST::kNotBuilt:
        break ;
      }
      var_cas_outRoutineSignature.addAssign_operation (operand_32887->mFormalArgumentPassingMode, var_cas_type, operand_32887->mFormalArgumentName, var_cas_formalArgumentCppName) ;
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_buildLocalVariableMapAndSignature\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Implementation of routine "analyzeRoutineBody"               *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_analyzeRoutineBody (C_CompilerEx & inLexique,
                                const GGS_analysisContext  var_cas_inAnalysisContext,
                                const GGS_formalParameterListAST   var_cas_inRoutineSignatureAST,
                                const GGS_localConstantList   var_cas_inLocalConstantList,
                                const GGS_typedAttributeList   var_cas_inTypedAttributeList,
                                const GGS_string  var_cas_inAttributeVariableNamePrefix,
                                const GGS_semanticInstructionListAST   var_cas_inInstructionList,
                                const GGS_location   var_cas_inEndOfMethodLocation,
                                GGS_semanticInstructionListForGeneration  & var_cas_outSemanticInstructionListForGeneration,
                                GGS_formalParameterListForGeneration  & var_cas_outRoutineSignature
                        COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_analyzeRoutineBody at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_variableMap  var_cas_variableMap = GGS_variableMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (837)) ;
  {
    GGS_localConstantList::cEnumerator enumerator_35513 (var_cas_inLocalConstantList, true) ;
    const GGS_localConstantList::cElement * operand_35513 = NULL ;
    while (((operand_35513 = enumerator_35513.nextObject ()))) {
      macroValidPointer (operand_35513) ;
      const GGS_bool cond_35645 = operand_35513->mNoWarningIfUnused ;
      if (cond_35645.isBuiltAndTrue ()) {
        var_cas_variableMap.modifier_insertUsedLocalConstant (inLexique, operand_35513->mName, operand_35513->mType, operand_35513->mCppName, function_selfMarkName (inLexique COMMA_SOURCE_FILE_AT_LINE (841)) COMMA_SOURCE_FILE_AT_LINE (841)) ;
      }else if (cond_35645.isBuiltAndFalse ()) {
        var_cas_variableMap.modifier_insertLocalConstant (inLexique, operand_35513->mName, operand_35513->mType, operand_35513->mCppName, function_selfMarkName (inLexique COMMA_SOURCE_FILE_AT_LINE (843)) COMMA_SOURCE_FILE_AT_LINE (843)) ;
      }
    }
  }
  {
    GGS_typedAttributeList::cEnumerator enumerator_35821 (var_cas_inTypedAttributeList, true) ;
    const GGS_typedAttributeList::cElement * operand_35821 = NULL ;
    while (((operand_35821 = enumerator_35821.nextObject ()))) {
      macroValidPointer (operand_35821) ;
      var_cas_variableMap.modifier_insertNonMutableAttribute (inLexique, operand_35821->mAttributeName, operand_35821->mAttributeTypeProxy, ((var_cas_inAttributeVariableNamePrefix).operator_concat (GGS_string ("mAttribute_"))).operator_concat (operand_35821->mAttributeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (851)).reader_identifierRepresentation ()), function_selfMarkName (inLexique COMMA_SOURCE_FILE_AT_LINE (852)) COMMA_SOURCE_FILE_AT_LINE (848)) ;
    }
  }
  ::routine_buildLocalVariableMapAndSignature (inLexique,  var_cas_inAnalysisContext.mSemanticContext,  var_cas_inRoutineSignatureAST,  var_cas_variableMap,  var_cas_outRoutineSignature COMMA_SOURCE_FILE_AT_LINE (856)) ;
  var_cas_outSemanticInstructionListForGeneration = GGS_semanticInstructionListForGeneration ::constructor_emptyList () ;
  {
    GGS_semanticInstructionListAST::cEnumerator enumerator_36405 (var_cas_inInstructionList, true) ;
    const GGS_semanticInstructionListAST::cElement * operand_36405 = NULL ;
    while (((operand_36405 = enumerator_36405.nextObject ()))) {
      macroValidPointer (operand_36405) ;
      { typeCategoryMethod__semanticInstructionAST__analyzeSemanticInstruction method = findCategoryMethod__semanticInstructionAST__analyzeSemanticInstruction (operand_36405->mInstruction.galgasObjectRunTimeInfo ()) ;
        if (method != NULL) {
          method (inLexique, operand_36405->mInstruction (HERE), var_cas_inAnalysisContext, var_cas_outSemanticInstructionListForGeneration, var_cas_variableMap COMMA_SOURCE_FILE_AT_LINE (865)) ;
        }
      }
    }
  }
  if (var_cas_variableMap.isBuilt ()) {
    var_cas_variableMap (HERE)->method_checkAutomatonStates (inLexique, var_cas_inEndOfMethodLocation COMMA_SOURCE_FILE_AT_LINE (872)) ;
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_analyzeRoutineBody\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
// Category method '@externFunctionDeclarationAST.performSemanticAnalysis'   *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__externFunctionDeclarationAST__performSemanticAnalysis (C_CompilerEx & inLexique,
                                const cPtr_externFunctionDeclarationAST * operand_36802,
                                const GGS_semanticContext  var_cas_inSemanticContext,
                                const GGS_predefinedTypes  /* var_cas_inPredefinedTypes */,
                                GGS_semanticDeclarationSortedListForGeneration  & var_cas_ioSemanticDeclarationListForGeneration
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_36802 != NULL) {
    GGS_formalInputParameterListForGeneration  var_cas_formalArgumentList = GGS_formalInputParameterListForGeneration ::constructor_emptyList () ;
    {
      GGS_formalInputParameterListAST::cEnumerator enumerator_37080 (operand_36802->mFormalArgumentList, true) ;
      const GGS_formalInputParameterListAST::cElement * operand_37080 = NULL ;
      while (((operand_37080 = enumerator_37080.nextObject ()))) {
        macroValidPointer (operand_37080) ;
        var_cas_formalArgumentList.addAssign_operation (GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_37080->mFormalArgumentTypeName COMMA_SOURCE_FILE_AT_LINE (885)), operand_37080->mFormalArgumentName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (886)), operand_37080->mFormalArgumentName, operand_37080->mIsUnused) ;
      }
    }
    var_cas_ioSemanticDeclarationListForGeneration.addAssign_operation (GGS_functionPrototypeDeclarationForGeneration ::constructor_new (inLexique, operand_36802->mFunctionName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (892)), var_cas_formalArgumentList, GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_36802->mResultTypeName COMMA_SOURCE_FILE_AT_LINE (894)) COMMA_SOURCE_FILE_AT_LINE (891)), GGS_string ("")) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//  Category method '@externRoutineDeclarationAST.performSemanticAnalysis'   *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__externRoutineDeclarationAST__performSemanticAnalysis (C_CompilerEx & inLexique,
                                const cPtr_externRoutineDeclarationAST * operand_37710,
                                const GGS_semanticContext  var_cas_inSemanticContext,
                                const GGS_predefinedTypes  /* var_cas_inPredefinedTypes */,
                                GGS_semanticDeclarationSortedListForGeneration  & var_cas_ioSemanticDeclarationListForGeneration
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_37710 != NULL) {
    GGS_formalParameterListForGeneration  var_cas_formalArgumentList = GGS_formalParameterListForGeneration ::constructor_emptyList () ;
    {
      GGS_formalParameterListAST::cEnumerator enumerator_37983 (operand_37710->mFormalArgumentList, true) ;
      const GGS_formalParameterListAST::cElement * operand_37983 = NULL ;
      while (((operand_37983 = enumerator_37983.nextObject ()))) {
        macroValidPointer (operand_37983) ;
        var_cas_formalArgumentList.addAssign_operation (operand_37983->mFormalArgumentPassingMode, GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_37983->mFormalArgumentTypeName COMMA_SOURCE_FILE_AT_LINE (911)), operand_37983->mFormalArgumentName, operand_37983->mFormalArgumentName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (913))) ;
      }
    }
    var_cas_ioSemanticDeclarationListForGeneration.addAssign_operation (GGS_routinePrototypeDeclarationForGeneration ::constructor_new (inLexique, operand_37710->mRoutineName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (917)), var_cas_formalArgumentList COMMA_SOURCE_FILE_AT_LINE (916)), GGS_string ("")) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//     Category method '@routineDeclarationAST.performSemanticAnalysis'      *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__routineDeclarationAST__performSemanticAnalysis (C_CompilerEx & inLexique,
                                const cPtr_routineDeclarationAST * operand_38538,
                                const GGS_semanticContext  var_cas_inSemanticContext,
                                const GGS_predefinedTypes  var_cas_inPredefinedTypes,
                                GGS_semanticDeclarationSortedListForGeneration  & var_cas_ioSemanticDeclarationListForGeneration
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_38538 != NULL) {
    GGS_formalParameterListForGeneration  var_cas_formalArgumentList = GGS_formalParameterListForGeneration ::constructor_emptyList () ;
    GGS_semanticInstructionListForGeneration  var_cas_instructionList ;
    const GGS_analysisContext var_cas_analysisContext = GGS_analysisContext::constructor_new (var_cas_inSemanticContext, var_cas_inPredefinedTypes, GGS_unifiedTypeMapProxy ::constructor_null (inLexique COMMA_SOURCE_FILE_AT_LINE (937)), GGS_string ("")) ;
    ::routine_analyzeRoutineBody (inLexique,  var_cas_analysisContext,  operand_38538->mFormalArgumentList,  GGS_localConstantList ::constructor_emptyList (),  GGS_typedAttributeList ::constructor_emptyList (),  GGS_string (""),  operand_38538->mRoutineInstructionList,  operand_38538->mEndOfRoutineInstructionList,  var_cas_instructionList,  var_cas_formalArgumentList COMMA_SOURCE_FILE_AT_LINE (940)) ;
    var_cas_ioSemanticDeclarationListForGeneration.addAssign_operation (GGS_routineImplementationForGeneration ::constructor_new (inLexique, operand_38538->mRoutineName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (953)), var_cas_formalArgumentList, var_cas_instructionList COMMA_SOURCE_FILE_AT_LINE (952)), GGS_string ("")) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Category method '@classDeclarationAST.performSemanticAnalysis'       *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__classDeclarationAST__performSemanticAnalysis (C_CompilerEx & inLexique,
                                const cPtr_classDeclarationAST * operand_39584,
                                const GGS_semanticContext  var_cas_inSemanticContext,
                                const GGS_predefinedTypes  var_cas_inPredefinedTypes,
                                GGS_semanticDeclarationSortedListForGeneration  & var_cas_ioSemanticDeclarationListForGeneration
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_39584 != NULL) {
    const GGS_unifiedTypeMapProxy  var_cas_selfType = GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_39584->mClassTypeName COMMA_SOURCE_FILE_AT_LINE (969)) ;
    GGS_unifiedTypeMapProxy  var_cas_superClassProxy ;
    GGS_typedAttributeList  var_cas_allAttributeList ;
    GGS_instanceMethodMap  var_cas_inheritedInstanceMethodMap ;
    const GGS_bool cond_40950 = (operand_39584->mSuperClassName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (976))).operator_isEqual (GGS_string ("")) ;
    if (cond_40950.isBuiltAndTrue ()) {
      var_cas_superClassProxy = GGS_unifiedTypeMapProxy ::constructor_null (inLexique COMMA_SOURCE_FILE_AT_LINE (977)) ;
      var_cas_allAttributeList = GGS_typedAttributeList ::constructor_emptyList () ;
      var_cas_inheritedInstanceMethodMap = GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (979)) ;
      GGS_bool var_cas_generatedInSeparateFileFeature = GGS_bool (false) ;
      const GGS_bool cond_40938 = (operand_39584->mClassFeatureList.reader_length ()).operator_strictSup (GGS_uint (0U)) ;
      if (cond_40938.isBuiltAndTrue ()) {
        {
          GGS_lstringlist::cEnumerator enumerator_40535 (operand_39584->mClassFeatureList, true) ;
          const GGS_lstringlist::cElement * operand_40535 = NULL ;
          while (((operand_40535 = enumerator_40535.nextObject ()))) {
            macroValidPointer (operand_40535) ;
            const GGS_bool cond_40807 = (operand_40535->mValue.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (983))).operator_isEqual (GGS_string ("generatedInSeparateFile")) ;
            if (cond_40807.isBuiltAndTrue ()) {
              const GGS_bool cond_40738 = var_cas_generatedInSeparateFileFeature ;
              if (cond_40738.isBuiltAndTrue ()) {
                operand_40535->mValue.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("the 'generatedInSeparateFile' is already named") COMMA_SOURCE_FILE_AT_LINE (986)) ;
              }
              var_cas_generatedInSeparateFileFeature = GGS_bool (true) ;
            }else if (cond_40807.isBuiltAndFalse ()) {
              operand_40535->mValue.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("only the 'generatedInSeparateFile' feature is allowed here") COMMA_SOURCE_FILE_AT_LINE (990)) ;
            }
          }
        }
      }
    }else if (cond_40950.isBuiltAndFalse ()) {
      var_cas_superClassProxy = GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_39584->mSuperClassName COMMA_SOURCE_FILE_AT_LINE (994)) ;
      var_cas_allAttributeList = var_cas_superClassProxy.reader_mAllTypedAttributeList (inLexique COMMA_SOURCE_FILE_AT_LINE (995)) ;
      var_cas_inheritedInstanceMethodMap = var_cas_superClassProxy.reader_mInstanceMethodMap (inLexique COMMA_SOURCE_FILE_AT_LINE (996)) ;
      const GGS_bool cond_41375 = (operand_39584->mClassFeatureList.reader_length ()).operator_strictSup (GGS_uint (0U)) ;
      if (cond_41375.isBuiltAndTrue ()) {
        {
          GGS_lstringlist::cEnumerator enumerator_41269 (operand_39584->mClassFeatureList, true) ;
          const GGS_lstringlist::cElement * operand_41269 = NULL ;
          while (((operand_41269 = enumerator_41269.nextObject ()))) {
            macroValidPointer (operand_41269) ;
            operand_41269->mValue.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("a class that has a super may not have any feature") COMMA_SOURCE_FILE_AT_LINE (1000)) ;
          }
        }
      }
    }
    GGS_typedAttributeList  var_cas_typedAttributeList = GGS_typedAttributeList ::constructor_emptyList () ;
    GGS_attributeIndexMap  var_cas_attributeMap = GGS_attributeIndexMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1005)) ;
    {
      GGS_attributeInCollectionListAST::cEnumerator enumerator_41543 (operand_39584->mAttributeList, true) ;
      const GGS_attributeInCollectionListAST::cElement * operand_41543 = NULL ;
      while (((operand_41543 = enumerator_41543.nextObject ()))) {
        macroValidPointer (operand_41543) ;
        GGS_unifiedTypeMapProxy  var_cas_t = GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_41543->mAttributeTypeName COMMA_SOURCE_FILE_AT_LINE (1007)) ;
        GGS_bool var_cas_hasSetter = GGS_bool (false) ;
        GGS_bool var_cas_hasGetter = GGS_bool (true) ;
        {
          GGS_lstringlist::cEnumerator enumerator_41722 (operand_41543->mFeatureList, true) ;
          const GGS_lstringlist::cElement * operand_41722 = NULL ;
          while (((operand_41722 = enumerator_41722.nextObject ()))) {
            macroValidPointer (operand_41722) ;
            const GGS_bool cond_41917 = (operand_41722->mValue.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1011))).operator_isEqual (GGS_string ("setter")) ;
            if (cond_41917.isBuiltAndTrue ()) {
              const GGS_bool cond_41872 = var_cas_hasSetter ;
              if (cond_41872.isBuiltAndTrue ()) {
                operand_41722->mValue.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("the 'setter' feature is already named") COMMA_SOURCE_FILE_AT_LINE (1014)) ;
              }
              var_cas_hasSetter = GGS_bool (true) ;
            }else if (cond_41917.isBuiltAndFalse ()) {
              const GGS_bool cond_42108 = (operand_41722->mValue.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1016))).operator_isEqual (GGS_string ("nogetter")) ;
              if (cond_42108.isBuiltAndTrue ()) {
                const GGS_bool cond_42063 = (var_cas_hasGetter).operator_not () ;
                if (cond_42063.isBuiltAndTrue ()) {
                  operand_41722->mValue.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("the 'nogetter' feature is already named") COMMA_SOURCE_FILE_AT_LINE (1019)) ;
                }
                var_cas_hasGetter = GGS_bool (false) ;
              }else if (cond_42108.isBuiltAndFalse ()) {
                operand_41722->mValue.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("only the 'setter' or 'nogetter' are allowed here") COMMA_SOURCE_FILE_AT_LINE (1023)) ;
              }
            }
          }
        }
        var_cas_typedAttributeList.addAssign_operation (var_cas_t, operand_41543->mAttributeName, var_cas_hasSetter, var_cas_hasGetter) ;
        var_cas_allAttributeList.addAssign_operation (var_cas_t, operand_41543->mAttributeName, var_cas_hasSetter, var_cas_hasGetter) ;
        var_cas_attributeMap.modifier_insertKey (inLexique, operand_41543->mAttributeName, var_cas_t COMMA_SOURCE_FILE_AT_LINE (1037)) ;
      }
    }
    GGS_declaredMethodMap  var_cas_classMethodMap = GGS_declaredMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1040)) ;
    {
      GGS_abstractMethodDefinitionListAST::cEnumerator enumerator_42608 (operand_39584->mAbstractMethodList, true) ;
      const GGS_abstractMethodDefinitionListAST::cElement * operand_42608 = NULL ;
      while (((operand_42608 = enumerator_42608.nextObject ()))) {
        macroValidPointer (operand_42608) ;
        var_cas_classMethodMap.modifier_insertKey (inLexique, operand_42608->mMethodName COMMA_SOURCE_FILE_AT_LINE (1042)) ;
      }
    }
    {
      GGS_methodDefinitionListAST::cEnumerator enumerator_42696 (operand_39584->mMethodList, true) ;
      const GGS_methodDefinitionListAST::cElement * operand_42696 = NULL ;
      while (((operand_42696 = enumerator_42696.nextObject ()))) {
        macroValidPointer (operand_42696) ;
        var_cas_classMethodMap.modifier_insertKey (inLexique, operand_42696->mMethodName COMMA_SOURCE_FILE_AT_LINE (1045)) ;
      }
    }
    GGS_abstractMethodDefinitionListForGeneration  var_cas_abstractMethodList = GGS_abstractMethodDefinitionListForGeneration ::constructor_emptyList () ;
    {
      GGS_abstractMethodDefinitionListAST::cEnumerator enumerator_42895 (operand_39584->mAbstractMethodList, true) ;
      const GGS_abstractMethodDefinitionListAST::cElement * operand_42895 = NULL ;
      while (((operand_42895 = enumerator_42895.nextObject ()))) {
        macroValidPointer (operand_42895) ;
        const GGS_bool cond_43081 = (operand_39584->mIsAbstract).operator_not () ;
        if (cond_43081.isBuiltAndTrue ()) {
          operand_42895->mMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("a concrete class cannot declare an abstract method") COMMA_SOURCE_FILE_AT_LINE (1053)) ;
        }
        GGS_formalParameterListForGeneration  var_cas_formalParameterListForGeneration = GGS_formalParameterListForGeneration ::constructor_emptyList () ;
        {
          GGS_formalParameterListAST::cEnumerator enumerator_43226 (operand_42895->mSignature, true) ;
          const GGS_formalParameterListAST::cElement * operand_43226 = NULL ;
          while (((operand_43226 = enumerator_43226.nextObject ()))) {
            macroValidPointer (operand_43226) ;
            var_cas_formalParameterListForGeneration.addAssign_operation (operand_43226->mFormalArgumentPassingMode, GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_43226->mFormalArgumentTypeName COMMA_SOURCE_FILE_AT_LINE (1059)), operand_43226->mFormalArgumentName, operand_43226->mFormalArgumentName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1061))) ;
          }
        }
        const GGS_bool cond_43965 = operand_42895->mIsOverriding ;
        if (cond_43965.isBuiltAndTrue ()) {
          GGS_formalParameterSignature  var_cas_inheritedSignature ;
          GGS_location  var_cas_inheritedDeclarationLocation ;
          GGS_bool automatic_var_43777_0 ;
          GGS_bool automatic_var_43777_1 ;
          GGS_methodQualifier automatic_var_43777_2 ;
          if (var_cas_inheritedInstanceMethodMap.isBuilt ()) {
            var_cas_inheritedInstanceMethodMap (HERE)->method_searchInheritedKey (inLexique, operand_42895->mMethodName, automatic_var_43777_0, var_cas_inheritedSignature, var_cas_inheritedDeclarationLocation, automatic_var_43777_1, automatic_var_43777_2 COMMA_SOURCE_FILE_AT_LINE (1068)) ;
          }
          ::routine_checkMethodSignatures (inLexique,  var_cas_formalParameterListForGeneration,  operand_42895->mMethodName.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (1071)),  var_cas_inheritedSignature,  var_cas_inheritedDeclarationLocation COMMA_SOURCE_FILE_AT_LINE (1069)) ;
        }else if (cond_43965.isBuiltAndFalse ()) {
          const GGS_bool cond_44148 = var_cas_inheritedInstanceMethodMap.reader_hasKey (operand_42895->mMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1075))) ;
          if (cond_44148.isBuiltAndTrue ()) {
            operand_42895->mMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("this method cannot be declared as abstract, it is already declared in super class") COMMA_SOURCE_FILE_AT_LINE (1077)) ;
          }
        }
        var_cas_abstractMethodList.addAssign_operation (operand_42895->mIsOverriding, operand_42895->mMethodName, var_cas_formalParameterListForGeneration) ;
      }
    }
    GGS_methodDefinitionListForGeneration  var_cas_methodList = GGS_methodDefinitionListForGeneration ::constructor_emptyList () ;
    GGS_stringset  var_cas_definedMethodSet = GGS_stringset ::constructor_emptySet () ;
    const GGS_analysisContext var_cas_analysisContext = GGS_analysisContext::constructor_new (var_cas_inSemanticContext, var_cas_inPredefinedTypes, var_cas_selfType, GGS_string ("this")) ;
    {
      GGS_methodDefinitionListAST::cEnumerator enumerator_44526 (operand_39584->mMethodList, true) ;
      const GGS_methodDefinitionListAST::cElement * operand_44526 = NULL ;
      while (((operand_44526 = enumerator_44526.nextObject ()))) {
        macroValidPointer (operand_44526) ;
        GGS_formalParameterListForGeneration  var_cas_formalParameterListForGeneration = GGS_formalParameterListForGeneration ::constructor_emptyList () ;
        GGS_semanticInstructionListForGeneration  var_cas_semanticInstructionListForGeneration ;
        ::routine_analyzeRoutineBody (inLexique,  var_cas_analysisContext,  operand_44526->mSignature,  GGS_localConstantList ::constructor_emptyList (),  var_cas_allAttributeList,  GGS_string (""),  operand_44526->mInstructionList,  operand_44526->mEndOfMethodLocation,  var_cas_semanticInstructionListForGeneration,  var_cas_formalParameterListForGeneration COMMA_SOURCE_FILE_AT_LINE (1093)) ;
        const GGS_bool cond_45665 = operand_44526->mIsOverriding ;
        if (cond_45665.isBuiltAndTrue ()) {
          GGS_formalParameterSignature  var_cas_inheritedSignature ;
          GGS_location  var_cas_inheritedDeclarationLocation ;
          GGS_bool var_cas_inheritedIsCategory ;
          GGS_bool automatic_var_45313_0 ;
          GGS_methodQualifier automatic_var_45313_1 ;
          if (var_cas_inheritedInstanceMethodMap.isBuilt ()) {
            var_cas_inheritedInstanceMethodMap (HERE)->method_searchInheritedKey (inLexique, operand_44526->mMethodName, var_cas_inheritedIsCategory, var_cas_inheritedSignature, var_cas_inheritedDeclarationLocation, automatic_var_45313_0, automatic_var_45313_1 COMMA_SOURCE_FILE_AT_LINE (1109)) ;
          }
          ::routine_checkMethodSignatures (inLexique,  var_cas_formalParameterListForGeneration,  operand_44526->mMethodName.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (1112)),  var_cas_inheritedSignature,  var_cas_inheritedDeclarationLocation COMMA_SOURCE_FILE_AT_LINE (1110)) ;
          const GGS_bool cond_45650 = var_cas_inheritedIsCategory ;
          if (cond_45650.isBuiltAndTrue ()) {
            operand_44526->mMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("this method is declared in class, but overriden method is declared as multi-method") COMMA_SOURCE_FILE_AT_LINE (1118)) ;
          }
        }else if (cond_45665.isBuiltAndFalse ()) {
          const GGS_bool cond_45854 = var_cas_inheritedInstanceMethodMap.reader_hasKey (operand_44526->mMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1119))) ;
          if (cond_45854.isBuiltAndTrue ()) {
            operand_44526->mMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("this method should be declared as overridding, as it is already declared in super class") COMMA_SOURCE_FILE_AT_LINE (1121)) ;
          }
        }
        var_cas_definedMethodSet.addAssign_operation (operand_44526->mMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1123))) ;
        var_cas_methodList.addAssign_operation (operand_44526->mIsOverriding, operand_44526->mMethodName, var_cas_formalParameterListForGeneration, var_cas_semanticInstructionListForGeneration) ;
      }
    }
    const GGS_bool cond_46599 = (operand_39584->mIsAbstract).operator_not () ;
    if (cond_46599.isBuiltAndTrue ()) {
      {
        GGS_instanceMethodMap::cEnumerator enumerator_46197 (var_cas_inheritedInstanceMethodMap, true) ;
        const GGS_instanceMethodMap::cElement * operand_46197 = NULL ;
        while (((operand_46197 = enumerator_46197.nextObject ()))) {
          macroValidPointer (operand_46197) ;
          const GGS_bool cond_46570 = ((operand_46197->mInfo.mQualifier).operator_isEqual (GGS_methodQualifier::constructor_isAbstract (inLexique COMMA_SOURCE_FILE_AT_LINE (1134)))).operator_or ((operand_46197->mInfo.mQualifier).operator_isEqual (GGS_methodQualifier::constructor_isOverridingAbstract (inLexique COMMA_SOURCE_FILE_AT_LINE (1134)))) ;
          if (cond_46570.isBuiltAndTrue ()) {
            const GGS_bool cond_46551 = (var_cas_definedMethodSet.reader_hasKey (operand_46197->mKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1135)))).operator_not () ;
            if (cond_46551.isBuiltAndTrue ()) {
              operand_46197->mKey.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((GGS_string ("the '@")).operator_concat (operand_39584->mClassTypeName)).operator_concat (GGS_string ("' class is declared concrete, but the '"))).operator_concat (operand_46197->mKey)).operator_concat (GGS_string ("' method declared in a super class is not implemented")) COMMA_SOURCE_FILE_AT_LINE (1137)) ;
            }
          }
        }
      }
    }
    GGS_string var_cas_sortString = var_cas_selfType.reader_key (inLexique COMMA_SOURCE_FILE_AT_LINE (1142)) ;
    GGS_unifiedTypeMapProxy  var_cas_t = var_cas_selfType.reader_mSuperType (inLexique COMMA_SOURCE_FILE_AT_LINE (1143)) ;
    GGS_uint _variant_46913 = var_cas_inSemanticContext.mTypeMap.reader_count ().add_operation (inLexique, GGS_uint (1U) COMMA_SOURCE_FILE_AT_LINE (1144)) ;
    GGS_bool _condition_46913 (_variant_46913.isBuilt (), true) ;
    while (_condition_46913.isBuiltAndTrue ()) {
      _condition_46913 = (var_cas_t.reader_isNull (inLexique COMMA_SOURCE_FILE_AT_LINE (1145))).operator_not () ;
      if (_condition_46913.isBuiltAndTrue ()) {
        if (_variant_46913.uintValue () == 0) {
          inLexique.onTheFlyRunTimeError ("loop variant error" COMMA_SOURCE_FILE_AT_LINE (1148)) ;
          _condition_46913 = GGS_bool (false) ;
        }else{
          _variant_46913.decrement_operation (inLexique COMMA_HERE) ;
          var_cas_sortString = ((var_cas_t.reader_key (inLexique COMMA_SOURCE_FILE_AT_LINE (1146))).operator_concat (GGS_string ("."))).operator_concat (var_cas_sortString) ;
          var_cas_t = var_cas_t.reader_mSuperType (inLexique COMMA_SOURCE_FILE_AT_LINE (1147)) ;
        }
      }
    }
    var_cas_ioSemanticDeclarationListForGeneration.addAssign_operation (GGS_classTypeForGeneration ::constructor_new (inLexique, GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_39584->mClassTypeName COMMA_SOURCE_FILE_AT_LINE (1151)), operand_39584->mIsAbstract, operand_39584->mClassTypeName, var_cas_superClassProxy, var_cas_allAttributeList, var_cas_typedAttributeList, var_cas_abstractMethodList, var_cas_methodList, var_cas_selfType.reader_mInstanceMethodMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1159)), var_cas_selfType.reader_mGenerateHeaderInSeparateFile (inLexique COMMA_SOURCE_FILE_AT_LINE (1160)) COMMA_SOURCE_FILE_AT_LINE (1150)), var_cas_sortString) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Implementation of routine "analyzeFunctionBody"               *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_analyzeFunctionBody (C_CompilerEx & inLexique,
                                const GGS_analysisContext  var_cas_inAnalysisContext,
                                const GGS_formalInputParameterListAST   var_cas_inFunctionSignature,
                                const GGS_typedAttributeList   var_cas_inTypedAttributeList,
                                const GGS_string  var_cas_inAttributeVariableNamePrefix,
                                const GGS_semanticInstructionListAST   var_cas_inInstructionList,
                                const GGS_lstring   var_cas_inReturnVariableName,
                                const GGS_lstring   var_cas_inResultTypeName,
                                const GGS_location   var_cas_inEndOfFunctionLocation,
                                GGS_formalInputParameterListForGeneration  & var_cas_outSignatureForGeneration,
                                GGS_unifiedTypeMapProxy  & var_cas_outReturnedType,
                                GGS_string & var_cas_outResultVariableCppName,
                                GGS_semanticInstructionListForGeneration  & var_cas_outSemanticInstructionListForGeneration
                        COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_analyzeFunctionBody at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_variableMap  var_cas_variableMap = GGS_variableMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1182)) ;
  {
    GGS_typedAttributeList::cEnumerator enumerator_48113 (var_cas_inTypedAttributeList, true) ;
    const GGS_typedAttributeList::cElement * operand_48113 = NULL ;
    while (((operand_48113 = enumerator_48113.nextObject ()))) {
      macroValidPointer (operand_48113) ;
      var_cas_variableMap.modifier_insertNonMutableAttribute (inLexique, operand_48113->mAttributeName, operand_48113->mAttributeTypeProxy, ((var_cas_inAttributeVariableNamePrefix).operator_concat (GGS_string ("mAttribute_"))).operator_concat (operand_48113->mAttributeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1188)).reader_identifierRepresentation ()), function_selfMarkName (inLexique COMMA_SOURCE_FILE_AT_LINE (1189)) COMMA_SOURCE_FILE_AT_LINE (1185)) ;
    }
  }
  var_cas_outSignatureForGeneration = GGS_formalInputParameterListForGeneration ::constructor_emptyList () ;
  {
    GGS_formalInputParameterListAST::cEnumerator enumerator_48505 (var_cas_inFunctionSignature, true) ;
    const GGS_formalInputParameterListAST::cElement * operand_48505 = NULL ;
    while (((operand_48505 = enumerator_48505.nextObject ()))) {
      macroValidPointer (operand_48505) ;
      const GGS_unifiedTypeMapProxy  var_cas_parameterType = GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inAnalysisContext.mSemanticContext.mTypeMap, operand_48505->mFormalArgumentTypeName COMMA_SOURCE_FILE_AT_LINE (1195)) ;
      const GGS_bool cond_49207 = operand_48505->mIsConstant ;
      if (cond_49207.isBuiltAndTrue ()) {
        const GGS_string var_cas_cppName = (GGS_string ("constinArgument_")).operator_concat (operand_48505->mFormalArgumentName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1197)).reader_identifierRepresentation ()) ;
        var_cas_outSignatureForGeneration.addAssign_operation (var_cas_parameterType, var_cas_cppName, operand_48505->mFormalArgumentName, operand_48505->mIsUnused) ;
        const GGS_bool cond_49069 = operand_48505->mIsUnused ;
        if (cond_49069.isBuiltAndTrue ()) {
          var_cas_variableMap.modifier_insertConstantInputFormalArgumentDeclaredAsUnused (inLexique, operand_48505->mFormalArgumentName, var_cas_parameterType, var_cas_cppName, var_cas_cppName COMMA_SOURCE_FILE_AT_LINE (1205)) ;
        }else if (cond_49069.isBuiltAndFalse ()) {
          var_cas_variableMap.modifier_insertConstantInputFormalArgument (inLexique, operand_48505->mFormalArgumentName, var_cas_parameterType, var_cas_cppName, var_cas_cppName COMMA_SOURCE_FILE_AT_LINE (1207)) ;
        }
      }else if (cond_49207.isBuiltAndFalse ()) {
        const GGS_string var_cas_cppName = (GGS_string ("inArgument_")).operator_concat (operand_48505->mFormalArgumentName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1210)).reader_identifierRepresentation ()) ;
        var_cas_outSignatureForGeneration.addAssign_operation (var_cas_parameterType, var_cas_cppName, operand_48505->mFormalArgumentName, operand_48505->mIsUnused) ;
        const GGS_bool cond_49600 = operand_48505->mIsUnused ;
        if (cond_49600.isBuiltAndTrue ()) {
          var_cas_variableMap.modifier_insertInputFormalArgumentDeclaredAsUnused (inLexique, operand_48505->mFormalArgumentName, var_cas_parameterType, var_cas_cppName, var_cas_cppName COMMA_SOURCE_FILE_AT_LINE (1218)) ;
        }else if (cond_49600.isBuiltAndFalse ()) {
          var_cas_variableMap.modifier_insertInputFormalArgument (inLexique, operand_48505->mFormalArgumentName, var_cas_parameterType, var_cas_cppName, var_cas_cppName COMMA_SOURCE_FILE_AT_LINE (1220)) ;
        }
      }
    }
  }
  var_cas_outReturnedType = GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inAnalysisContext.mSemanticContext.mTypeMap, var_cas_inResultTypeName COMMA_SOURCE_FILE_AT_LINE (1225)) ;
  var_cas_outResultVariableCppName = (GGS_string ("result_")).operator_concat (var_cas_inResultTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1226)).reader_identifierRepresentation ()) ;
  var_cas_variableMap.modifier_insertOutputFormalArgument (inLexique, var_cas_inReturnVariableName, var_cas_outReturnedType, var_cas_outResultVariableCppName, var_cas_outResultVariableCppName COMMA_SOURCE_FILE_AT_LINE (1227)) ;
  var_cas_outSemanticInstructionListForGeneration = GGS_semanticInstructionListForGeneration ::constructor_emptyList () ;
  {
    GGS_semanticInstructionListAST::cEnumerator enumerator_50289 (var_cas_inInstructionList, true) ;
    const GGS_semanticInstructionListAST::cElement * operand_50289 = NULL ;
    while (((operand_50289 = enumerator_50289.nextObject ()))) {
      macroValidPointer (operand_50289) ;
      { typeCategoryMethod__semanticInstructionAST__analyzeSemanticInstruction method = findCategoryMethod__semanticInstructionAST__analyzeSemanticInstruction (operand_50289->mInstruction.galgasObjectRunTimeInfo ()) ;
        if (method != NULL) {
          method (inLexique, operand_50289->mInstruction (HERE), var_cas_inAnalysisContext, var_cas_outSemanticInstructionListForGeneration, var_cas_variableMap COMMA_SOURCE_FILE_AT_LINE (1231)) ;
        }
      }
    }
  }
  if (var_cas_variableMap.isBuilt ()) {
    var_cas_variableMap (HERE)->method_checkAutomatonStates (inLexique, var_cas_inEndOfFunctionLocation COMMA_SOURCE_FILE_AT_LINE (1238)) ;
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_analyzeFunctionBody\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//    Category method '@functionDeclarationAST.performSemanticAnalysis'      *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__functionDeclarationAST__performSemanticAnalysis (C_CompilerEx & inLexique,
                                const cPtr_functionDeclarationAST * operand_50682,
                                const GGS_semanticContext  var_cas_inSemanticContext,
                                const GGS_predefinedTypes  var_cas_inPredefinedTypes,
                                GGS_semanticDeclarationSortedListForGeneration  & var_cas_ioSemanticDeclarationListForGeneration
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_50682 != NULL) {
    GGS_semanticInstructionListForGeneration  var_cas_semanticInstructionListForGeneration ;
    GGS_formalInputParameterListForGeneration  var_cas_formalInputParameterList ;
    GGS_unifiedTypeMapProxy  var_cas_returnType ;
    GGS_string var_cas_resultVariableCppName ;
    const GGS_analysisContext var_cas_analysisContext = GGS_analysisContext::constructor_new (var_cas_inSemanticContext, var_cas_inPredefinedTypes, GGS_unifiedTypeMapProxy ::constructor_null (inLexique COMMA_SOURCE_FILE_AT_LINE (1256)), GGS_string ("")) ;
    ::routine_analyzeFunctionBody (inLexique,  var_cas_analysisContext,  operand_50682->mFormalArgumentList,  GGS_typedAttributeList ::constructor_emptyList (),  GGS_string (""),  operand_50682->mFunctionInstructionList,  operand_50682->mResultVariableName,  operand_50682->mResultTypeName,  operand_50682->mEndOfFunctionInstructionList,  var_cas_formalInputParameterList,  var_cas_returnType,  var_cas_resultVariableCppName,  var_cas_semanticInstructionListForGeneration COMMA_SOURCE_FILE_AT_LINE (1259)) ;
    var_cas_ioSemanticDeclarationListForGeneration.addAssign_operation (GGS_functionImplementationForGeneration ::constructor_new (inLexique, operand_50682->mFunctionName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1275)), var_cas_formalInputParameterList, var_cas_returnType, var_cas_resultVariableCppName, var_cas_semanticInstructionListForGeneration COMMA_SOURCE_FILE_AT_LINE (1274)), GGS_string ("")) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//  Category method '@onceFunctionDeclarationAST.performSemanticAnalysis'    *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__onceFunctionDeclarationAST__performSemanticAnalysis (C_CompilerEx & inLexique,
                                const cPtr_onceFunctionDeclarationAST * operand_51987,
                                const GGS_semanticContext  var_cas_inSemanticContext,
                                const GGS_predefinedTypes  var_cas_inPredefinedTypes,
                                GGS_semanticDeclarationSortedListForGeneration  & var_cas_ioSemanticDeclarationListForGeneration
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_51987 != NULL) {
    GGS_semanticInstructionListForGeneration  var_cas_semanticInstructionListForGeneration ;
    GGS_unifiedTypeMapProxy  var_cas_returnType ;
    GGS_string var_cas_resultVariableCppName ;
    const GGS_analysisContext var_cas_analysisContext = GGS_analysisContext::constructor_new (var_cas_inSemanticContext, var_cas_inPredefinedTypes, GGS_unifiedTypeMapProxy ::constructor_null (inLexique COMMA_SOURCE_FILE_AT_LINE (1299)), GGS_string ("")) ;
    GGS_formalInputParameterListForGeneration  automatic_var_52812_0 ;
    ::routine_analyzeFunctionBody (inLexique,  var_cas_analysisContext,  GGS_formalInputParameterListAST ::constructor_emptyList (),  GGS_typedAttributeList ::constructor_emptyList (),  GGS_string (""),  operand_51987->mFunctionInstructionList,  operand_51987->mResultVariableName,  operand_51987->mResultTypeName,  operand_51987->mEndOfFunctionInstructionList,  automatic_var_52812_0,  var_cas_returnType,  var_cas_resultVariableCppName,  var_cas_semanticInstructionListForGeneration COMMA_SOURCE_FILE_AT_LINE (1302)) ;
    var_cas_ioSemanticDeclarationListForGeneration.addAssign_operation (GGS_onceFunctionDeclarationForGeneration ::constructor_new (inLexique, operand_51987->mFunctionName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1318)), var_cas_returnType, var_cas_resultVariableCppName, var_cas_semanticInstructionListForGeneration COMMA_SOURCE_FILE_AT_LINE (1317)), GGS_string ("")) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//   Category method '@filewrapperDeclarationAST.performSemanticAnalysis'    *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__filewrapperDeclarationAST__performSemanticAnalysis (C_CompilerEx & inLexique,
                                const cPtr_filewrapperDeclarationAST * operand_53504,
                                const GGS_semanticContext  var_cas_inSemanticContext,
                                const GGS_predefinedTypes  var_cas_inPredefinedTypes,
                                GGS_semanticDeclarationSortedListForGeneration  & var_cas_ioSemanticDeclarationListForGeneration
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_53504 != NULL) {
    GGS_wrapperFileMap  var_cas_wrapperFileMap ;
    GGS_wrapperDirectoryMap  var_cas_wrapperDirectoryMap ;
    GGS_lstring  automatic_var_53921_0 ;
    GGS_lstringlist  automatic_var_53921_1 ;
    GGS_filewrapperTemplateMap  automatic_var_53921_2 ;
    if (var_cas_inSemanticContext.mFilewrapperMap.isBuilt ()) {
      var_cas_inSemanticContext.mFilewrapperMap (HERE)->method_searchKey (inLexique, operand_53504->mFilewrapperName, automatic_var_53921_0, automatic_var_53921_1, var_cas_wrapperFileMap, var_cas_wrapperDirectoryMap, automatic_var_53921_2 COMMA_SOURCE_FILE_AT_LINE (1341)) ;
    }
    GGS_string var_cas_absoluteSourcePath ;
    const GGS_bool cond_54105 = (operand_53504->mFilewrapperPath.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1351)).reader_firstCharacterOrNul ()).operator_isEqual (GGS_char (TO_UNICODE ('/'))) ;
    if (cond_54105.isBuiltAndTrue ()) {
      var_cas_absoluteSourcePath = operand_53504->mFilewrapperPath.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1352)) ;
    }else if (cond_54105.isBuiltAndFalse ()) {
      var_cas_absoluteSourcePath = ((var_cas_inSemanticContext.reader_mSourceFileAbsolutePath (inLexique COMMA_SOURCE_FILE_AT_LINE (1354)).reader_stringByDeletingLastPathComponent ()).operator_concat (GGS_string ("/"))).operator_concat (operand_53504->mFilewrapperPath.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1354))) ;
    }
    const GGS_bool cond_54406 = (var_cas_absoluteSourcePath.reader_directoryExists ()).operator_not () ;
    if (cond_54406.isBuiltAndTrue ()) {
      operand_53504->mFilewrapperPath.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("The '")).operator_concat (var_cas_absoluteSourcePath)).operator_concat (GGS_string ("' directory does not exist")) COMMA_SOURCE_FILE_AT_LINE (1358)) ;
    }else if (cond_54406.isBuiltAndFalse ()) {
      GGS_filewrapperTemplateListForGeneration  var_cas_filewrapperTemplateListForGeneration = GGS_filewrapperTemplateListForGeneration ::constructor_emptyList () ;
      {
        GGS_filewrapperTemplateListAST::cEnumerator enumerator_54574 (operand_53504->mFilewrapperTemplateList, true) ;
        const GGS_filewrapperTemplateListAST::cElement * operand_54574 = NULL ;
        while (((operand_54574 = enumerator_54574.nextObject ()))) {
          macroValidPointer (operand_54574) ;
          const GGS_bool cond_54811 = (operand_54574->mFilewrapperTemplatePath.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1362)).reader_firstCharacterOrNul ()).operator_isEqual (GGS_char (TO_UNICODE ('/'))) ;
          if (cond_54811.isBuiltAndTrue ()) {
            operand_54574->mFilewrapperTemplatePath.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("the path should not begin with a '/'; it is relative to filewrapper path '")).operator_concat (var_cas_absoluteSourcePath)).operator_concat (GGS_string ("'")) COMMA_SOURCE_FILE_AT_LINE (1364)) ;
          }
          const GGS_string var_cas_absoluteTemplatePath = ((var_cas_absoluteSourcePath).operator_concat (GGS_string ("/"))).operator_concat (operand_54574->mFilewrapperTemplatePath) ;
          GGS_templateInstructionListAST  var_cas_resultingInstructionList ;
          const GGS_string _depExtension = GGS_string ("") ;
          const GGS_string _depPath = GGS_string ("") ;
          if (_depExtension.isBuilt () && _depPath.isBuilt ()) {
            C_Grammar_templateGrammar::_performSourceFileParsing_ (inLexique,
                                          _depExtension.string (),
                                          _depPath.string (),
                                          NULL,
                                          GGS_lstring ::constructor_new (inLexique, var_cas_absoluteTemplatePath, operand_54574->mFilewrapperTemplatePath.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (1368)) COMMA_SOURCE_FILE_AT_LINE (1368)),
                                          var_cas_resultingInstructionList
                                          COMMA_SOURCE_FILE_AT_LINE (1368)) ;
          }
          GGS_templateVariableMap  var_cas_templateVariableMap = GGS_templateVariableMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1370)) ;
          GGS_formalInputParameterListForGeneration  var_cas_filewrapperTemplateFormalInputParameters = GGS_formalInputParameterListForGeneration ::constructor_emptyList () ;
          {
            GGS_formalTemplateInputParameterListAST::cEnumerator enumerator_55387 (operand_54574->mFilewrapperTemplateFormalInputParameters, true) ;
            const GGS_formalTemplateInputParameterListAST::cElement * operand_55387 = NULL ;
            while (((operand_55387 = enumerator_55387.nextObject ()))) {
              macroValidPointer (operand_55387) ;
              GGS_unifiedTypeMapProxy  var_cas_type = GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_55387->mFormalArgumentTypeName COMMA_SOURCE_FILE_AT_LINE (1373)) ;
              const GGS_string var_cas_cppVarName = (GGS_string ("in_")).operator_concat (operand_55387->mFormalArgumentName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1374)).reader_identifierRepresentation ()) ;
              var_cas_templateVariableMap.modifier_insertKey (inLexique, operand_55387->mFormalArgumentName, var_cas_type, var_cas_cppVarName COMMA_SOURCE_FILE_AT_LINE (1375)) ;
              var_cas_filewrapperTemplateFormalInputParameters.addAssign_operation (var_cas_type, var_cas_cppVarName, operand_55387->mFormalArgumentName, GGS_bool (true)) ;
            }
          }
          GGS_templateInstructionListForGeneration  var_cas_templateInstructionListForGeneration = GGS_templateInstructionListForGeneration ::constructor_emptyList () ;
          const GGS_templateAnalysisContext var_cas_templateAnalysisContext = GGS_templateAnalysisContext::constructor_new (var_cas_inSemanticContext, var_cas_inPredefinedTypes, var_cas_templateVariableMap) ;
          ::routine_templateInstructionListAnalysis (inLexique,  var_cas_templateAnalysisContext,  var_cas_resultingInstructionList,  var_cas_templateInstructionListForGeneration COMMA_SOURCE_FILE_AT_LINE (1385)) ;
          var_cas_filewrapperTemplateListForGeneration.addAssign_operation (operand_54574->mFilewrapperTemplateName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1388)), var_cas_filewrapperTemplateFormalInputParameters, var_cas_templateInstructionListForGeneration) ;
        }
      }
      var_cas_ioSemanticDeclarationListForGeneration.addAssign_operation (GGS_filewrapperDeclarationForGeneration ::constructor_new (inLexique, operand_53504->mFilewrapperName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1395)), operand_53504->mFilewrapperPath.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1396)), var_cas_wrapperFileMap, var_cas_wrapperDirectoryMap, var_cas_filewrapperTemplateListForGeneration COMMA_SOURCE_FILE_AT_LINE (1394)), GGS_string ("")) ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//   Category method '@abstractCategoryMethodAST.performSemanticAnalysis'    *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__abstractCategoryMethodAST__performSemanticAnalysis (C_CompilerEx & inLexique,
                                const cPtr_abstractCategoryMethodAST * operand_56930,
                                const GGS_semanticContext  var_cas_inSemanticContext,
                                const GGS_predefinedTypes  /* var_cas_inPredefinedTypes */,
                                GGS_semanticDeclarationSortedListForGeneration  & var_cas_ioSemanticDeclarationListForGeneration
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_56930 != NULL) {
    const GGS_unifiedTypeMapProxy  var_cas_selfType = GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_56930->mTypeName COMMA_SOURCE_FILE_AT_LINE (1414)) ;
    const GGS_bool cond_57467 = (var_cas_selfType.reader_mTypeKindEnum (inLexique COMMA_SOURCE_FILE_AT_LINE (1416))).operator_isNotEqual (GGS_typeKindEnum::constructor_classType (inLexique COMMA_SOURCE_FILE_AT_LINE (1416))) ;
    if (cond_57467.isBuiltAndTrue ()) {
      operand_56930->mAbstractCategoryMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("cannot declare a category method: '@")).operator_concat (var_cas_selfType.reader_key (inLexique COMMA_SOURCE_FILE_AT_LINE (1417)))).operator_concat (GGS_string ("' is not a class")) COMMA_SOURCE_FILE_AT_LINE (1418)) ;
    }else if (cond_57467.isBuiltAndFalse ()) {
      const GGS_bool cond_57639 = var_cas_selfType.reader_mIsConcrete (inLexique COMMA_SOURCE_FILE_AT_LINE (1418)) ;
      if (cond_57639.isBuiltAndTrue ()) {
        operand_56930->mAbstractCategoryMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("cannot declare an abstract category method: '@")).operator_concat (var_cas_selfType.reader_key (inLexique COMMA_SOURCE_FILE_AT_LINE (1419)))).operator_concat (GGS_string ("' is not an abstract class")) COMMA_SOURCE_FILE_AT_LINE (1420)) ;
      }
    }
    GGS_formalParameterListForGeneration  var_cas_formalParameterListForGeneration = GGS_formalParameterListForGeneration ::constructor_emptyList () ;
    {
      GGS_formalParameterListAST::cEnumerator enumerator_57810 (operand_56930->mAbstractCategoryMethodFormalParameterList, true) ;
      const GGS_formalParameterListAST::cElement * operand_57810 = NULL ;
      while (((operand_57810 = enumerator_57810.nextObject ()))) {
        macroValidPointer (operand_57810) ;
        var_cas_formalParameterListForGeneration.addAssign_operation (operand_57810->mFormalArgumentPassingMode, GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_57810->mFormalArgumentTypeName COMMA_SOURCE_FILE_AT_LINE (1426)), operand_57810->mFormalArgumentName, operand_57810->mFormalArgumentName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1428))) ;
      }
    }
    var_cas_ioSemanticDeclarationListForGeneration.addAssign_operation (GGS_abstractCategoryMethodForGeneration ::constructor_new (inLexique, operand_56930->mTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1433)), operand_56930->mAbstractCategoryMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1434)), var_cas_formalParameterListForGeneration COMMA_SOURCE_FILE_AT_LINE (1432)), GGS_string ("~")) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//       Category method '@categoryMethodAST.performSemanticAnalysis'        *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__categoryMethodAST__performSemanticAnalysis (C_CompilerEx & inLexique,
                                const cPtr_categoryMethodAST * operand_58484,
                                const GGS_semanticContext  var_cas_inSemanticContext,
                                const GGS_predefinedTypes  var_cas_inPredefinedTypes,
                                GGS_semanticDeclarationSortedListForGeneration  & var_cas_ioSemanticDeclarationListForGeneration
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_58484 != NULL) {
    const GGS_unifiedTypeMapProxy  var_cas_selfType = GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_58484->mTypeName COMMA_SOURCE_FILE_AT_LINE (1449)) ;
    const GGS_bool cond_58994 = (var_cas_selfType.reader_mTypeKindEnum (inLexique COMMA_SOURCE_FILE_AT_LINE (1451))).operator_isNotEqual (GGS_typeKindEnum::constructor_classType (inLexique COMMA_SOURCE_FILE_AT_LINE (1451))) ;
    if (cond_58994.isBuiltAndTrue ()) {
      operand_58484->mCategoryMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("cannot declare a category method: '@")).operator_concat (var_cas_selfType.reader_key (inLexique COMMA_SOURCE_FILE_AT_LINE (1452)))).operator_concat (GGS_string ("' is not a class")) COMMA_SOURCE_FILE_AT_LINE (1453)) ;
    }
    GGS_formalParameterListForGeneration  var_cas_formalParameterListForGeneration = GGS_formalParameterListForGeneration ::constructor_emptyList () ;
    GGS_semanticInstructionListForGeneration  var_cas_semanticInstructionListForGeneration ;
    const GGS_analysisContext var_cas_analysisContext = GGS_analysisContext::constructor_new (var_cas_inSemanticContext, var_cas_inPredefinedTypes, var_cas_selfType, GGS_string ("object")) ;
    ::routine_analyzeRoutineBody (inLexique,  var_cas_analysisContext,  operand_58484->mCategoryMethodFormalParameterList,  GGS_localConstantList ::constructor_emptyList (),  var_cas_selfType.reader_mAllTypedAttributeList (inLexique COMMA_SOURCE_FILE_AT_LINE (1467)),  GGS_string ("object->"),  operand_58484->mCategoryMethodInstructionList,  operand_58484->mEndOfMethodLocation,  var_cas_semanticInstructionListForGeneration,  var_cas_formalParameterListForGeneration COMMA_SOURCE_FILE_AT_LINE (1463)) ;
    var_cas_ioSemanticDeclarationListForGeneration.addAssign_operation (GGS_categoryMethodForGeneration ::constructor_new (inLexique, operand_58484->mTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1476)), operand_58484->mCategoryMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1477)), var_cas_formalParameterListForGeneration, var_cas_selfType.reader_mAllTypedAttributeList (inLexique COMMA_SOURCE_FILE_AT_LINE (1479)), var_cas_semanticInstructionListForGeneration COMMA_SOURCE_FILE_AT_LINE (1475)), GGS_string ("~")) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//  Category method '@overridingCategoryMethodAST.performSemanticAnalysis'   *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__overridingCategoryMethodAST__performSemanticAnalysis (C_CompilerEx & inLexique,
                                const cPtr_overridingCategoryMethodAST * operand_60129,
                                const GGS_semanticContext  var_cas_inSemanticContext,
                                const GGS_predefinedTypes  var_cas_inPredefinedTypes,
                                GGS_semanticDeclarationSortedListForGeneration  & var_cas_ioSemanticDeclarationListForGeneration
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_60129 != NULL) {
    const GGS_unifiedTypeMapProxy  var_cas_selfType = GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_60129->mTypeName COMMA_SOURCE_FILE_AT_LINE (1494)) ;
    const GGS_bool cond_60649 = (var_cas_selfType.reader_mTypeKindEnum (inLexique COMMA_SOURCE_FILE_AT_LINE (1496))).operator_isNotEqual (GGS_typeKindEnum::constructor_classType (inLexique COMMA_SOURCE_FILE_AT_LINE (1496))) ;
    if (cond_60649.isBuiltAndTrue ()) {
      operand_60129->mOverridingCategoryMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("cannot declare a category method: '@")).operator_concat (var_cas_selfType.reader_key (inLexique COMMA_SOURCE_FILE_AT_LINE (1497)))).operator_concat (GGS_string ("' is not a class")) COMMA_SOURCE_FILE_AT_LINE (1498)) ;
    }
    GGS_string var_cas_baseTypeName = GGS_string ("") ;
    GGS_unifiedTypeMapProxy  var_cas_superType = var_cas_selfType.reader_mSuperType (inLexique COMMA_SOURCE_FILE_AT_LINE (1501)) ;
    GGS_formalParameterSignature  var_cas_inheritedSignature = GGS_formalParameterSignature ::constructor_emptyList () ;
    GGS_location  var_cas_inheritedDeclarationLocation = GGS_location (inLexique) ;
    GGS_uint _variant_61443 = var_cas_inSemanticContext.mTypeMap.reader_count ().add_operation (inLexique, GGS_uint (1U) COMMA_SOURCE_FILE_AT_LINE (1504)) ;
    GGS_bool _condition_61443 (_variant_61443.isBuilt (), true) ;
    while (_condition_61443.isBuiltAndTrue ()) {
      _condition_61443 = ((var_cas_superType.reader_isNull (inLexique COMMA_SOURCE_FILE_AT_LINE (1505))).operator_not ()).operator_and ((var_cas_baseTypeName).operator_isEqual (GGS_string (""))) ;
      if (_condition_61443.isBuiltAndTrue ()) {
        if (_variant_61443.uintValue () == 0) {
          inLexique.onTheFlyRunTimeError ("loop variant error" COMMA_SOURCE_FILE_AT_LINE (1514)) ;
          _condition_61443 = GGS_bool (false) ;
        }else{
          _variant_61443.decrement_operation (inLexique COMMA_HERE) ;
          const GGS_bool cond_61390 = var_cas_superType.reader_mInstanceMethodMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1506)).reader_hasKey (operand_60129->mOverridingCategoryMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1506))) ;
          if (cond_61390.isBuiltAndTrue ()) {
            GGS_methodQualifier var_cas_qualifier ;
            GGS_bool automatic_var_61264_0 ;
            GGS_bool automatic_var_61264_1 ;
            const GGS_instanceMethodMap  temp_61165 = var_cas_superType.reader_mInstanceMethodMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1508)) ;
            if (temp_61165.isBuilt ()) {
              temp_61165 (HERE)->method_searchKey (inLexique, operand_60129->mOverridingCategoryMethodName, automatic_var_61264_0, var_cas_inheritedSignature, var_cas_inheritedDeclarationLocation, automatic_var_61264_1, var_cas_qualifier COMMA_SOURCE_FILE_AT_LINE (1508)) ;
            }
            const GGS_bool cond_61377 = (var_cas_qualifier).operator_infOrEqual (GGS_methodQualifier::constructor_isBasicFinal (inLexique COMMA_SOURCE_FILE_AT_LINE (1509))) ;
            if (cond_61377.isBuiltAndTrue ()) {
              var_cas_baseTypeName = var_cas_superType.reader_key (inLexique COMMA_SOURCE_FILE_AT_LINE (1510)) ;
            }
          }
          var_cas_superType = var_cas_superType.reader_mSuperType (inLexique COMMA_SOURCE_FILE_AT_LINE (1513)) ;
        }
      }
    }
    GGS_formalParameterListForGeneration  var_cas_formalParameterListForGeneration = GGS_formalParameterListForGeneration ::constructor_emptyList () ;
    GGS_semanticInstructionListForGeneration  var_cas_semanticInstructionListForGeneration ;
    const GGS_analysisContext var_cas_analysisContext = GGS_analysisContext::constructor_new (var_cas_inSemanticContext, var_cas_inPredefinedTypes, var_cas_selfType, GGS_string ("object")) ;
    ::routine_analyzeRoutineBody (inLexique,  var_cas_analysisContext,  operand_60129->mOverridingCategoryMethodFormalParameterList,  GGS_localConstantList ::constructor_emptyList (),  var_cas_selfType.reader_mAllTypedAttributeList (inLexique COMMA_SOURCE_FILE_AT_LINE (1528)),  GGS_string ("object->"),  operand_60129->mOverridingCategoryMethodInstructionList,  operand_60129->mEndOfMethodLocation,  var_cas_semanticInstructionListForGeneration,  var_cas_formalParameterListForGeneration COMMA_SOURCE_FILE_AT_LINE (1524)) ;
    const GGS_bool cond_62345 = (var_cas_baseTypeName).operator_isNotEqual (GGS_string ("")) ;
    if (cond_62345.isBuiltAndTrue ()) {
      ::routine_checkMethodSignatures (inLexique,  var_cas_formalParameterListForGeneration,  operand_60129->mOverridingCategoryMethodName.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (1539)),  var_cas_inheritedSignature,  var_cas_inheritedDeclarationLocation COMMA_SOURCE_FILE_AT_LINE (1537)) ;
    }
    var_cas_ioSemanticDeclarationListForGeneration.addAssign_operation (GGS_overridingCategoryMethodForGeneration ::constructor_new (inLexique, operand_60129->mTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1546)), var_cas_baseTypeName, operand_60129->mOverridingCategoryMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1548)), var_cas_formalParameterListForGeneration, var_cas_selfType.reader_mAllTypedAttributeList (inLexique COMMA_SOURCE_FILE_AT_LINE (1550)), var_cas_semanticInstructionListForGeneration COMMA_SOURCE_FILE_AT_LINE (1545)), GGS_string ("~")) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//Category method '@overridingAbstractCategoryMethodAST.performSemanticAnalysis'*
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__overridingAbstractCategoryMethodAST__performSemanticAnalysis (C_CompilerEx & inLexique,
                                const cPtr_overridingAbstractCategoryMethodAST * operand_62889,
                                const GGS_semanticContext  var_cas_inSemanticContext,
                                const GGS_predefinedTypes  /* var_cas_inPredefinedTypes */,
                                GGS_semanticDeclarationSortedListForGeneration  & /* var_cas_ioSemanticDeclarationListForGeneration */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_62889 != NULL) {
    const GGS_unifiedTypeMapProxy  var_cas_selfType = GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_62889->mTypeName COMMA_SOURCE_FILE_AT_LINE (1565)) ;
    const GGS_bool cond_63430 = (var_cas_selfType.reader_mTypeKindEnum (inLexique COMMA_SOURCE_FILE_AT_LINE (1567))).operator_isNotEqual (GGS_typeKindEnum::constructor_classType (inLexique COMMA_SOURCE_FILE_AT_LINE (1567))) ;
    if (cond_63430.isBuiltAndTrue ()) {
      operand_62889->mOverridingCategoryMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("cannot declare a category method: '@")).operator_concat (var_cas_selfType.reader_key (inLexique COMMA_SOURCE_FILE_AT_LINE (1568)))).operator_concat (GGS_string ("' is not a class")) COMMA_SOURCE_FILE_AT_LINE (1569)) ;
    }else if (cond_63430.isBuiltAndFalse ()) {
      const GGS_bool cond_63604 = var_cas_selfType.reader_mIsConcrete (inLexique COMMA_SOURCE_FILE_AT_LINE (1569)) ;
      if (cond_63604.isBuiltAndTrue ()) {
        operand_62889->mOverridingCategoryMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("cannot declare an abstract category method: '@")).operator_concat (var_cas_selfType.reader_key (inLexique COMMA_SOURCE_FILE_AT_LINE (1570)))).operator_concat (GGS_string ("' is not an abstract class")) COMMA_SOURCE_FILE_AT_LINE (1571)) ;
      }
    }
    GGS_string var_cas_baseTypeName = GGS_string ("") ;
    GGS_unifiedTypeMapProxy  var_cas_superType = var_cas_selfType.reader_mSuperType (inLexique COMMA_SOURCE_FILE_AT_LINE (1574)) ;
    GGS_formalParameterSignature  var_cas_inheritedSignature = GGS_formalParameterSignature ::constructor_emptyList () ;
    GGS_location  var_cas_inheritedDeclarationLocation = GGS_location (inLexique) ;
    GGS_uint _variant_64398 = var_cas_inSemanticContext.mTypeMap.reader_count ().add_operation (inLexique, GGS_uint (1U) COMMA_SOURCE_FILE_AT_LINE (1577)) ;
    GGS_bool _condition_64398 (_variant_64398.isBuilt (), true) ;
    while (_condition_64398.isBuiltAndTrue ()) {
      _condition_64398 = ((var_cas_superType.reader_isNull (inLexique COMMA_SOURCE_FILE_AT_LINE (1578))).operator_not ()).operator_and ((var_cas_baseTypeName).operator_isEqual (GGS_string (""))) ;
      if (_condition_64398.isBuiltAndTrue ()) {
        if (_variant_64398.uintValue () == 0) {
          inLexique.onTheFlyRunTimeError ("loop variant error" COMMA_SOURCE_FILE_AT_LINE (1587)) ;
          _condition_64398 = GGS_bool (false) ;
        }else{
          _variant_64398.decrement_operation (inLexique COMMA_HERE) ;
          const GGS_bool cond_64345 = var_cas_superType.reader_mInstanceMethodMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1579)).reader_hasKey (operand_62889->mOverridingCategoryMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1579))) ;
          if (cond_64345.isBuiltAndTrue ()) {
            GGS_methodQualifier var_cas_qualifier ;
            GGS_bool automatic_var_64219_0 ;
            GGS_bool automatic_var_64219_1 ;
            const GGS_instanceMethodMap  temp_64120 = var_cas_superType.reader_mInstanceMethodMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1581)) ;
            if (temp_64120.isBuilt ()) {
              temp_64120 (HERE)->method_searchKey (inLexique, operand_62889->mOverridingCategoryMethodName, automatic_var_64219_0, var_cas_inheritedSignature, var_cas_inheritedDeclarationLocation, automatic_var_64219_1, var_cas_qualifier COMMA_SOURCE_FILE_AT_LINE (1581)) ;
            }
            const GGS_bool cond_64332 = (var_cas_qualifier).operator_infOrEqual (GGS_methodQualifier::constructor_isBasicFinal (inLexique COMMA_SOURCE_FILE_AT_LINE (1582))) ;
            if (cond_64332.isBuiltAndTrue ()) {
              var_cas_baseTypeName = var_cas_superType.reader_key (inLexique COMMA_SOURCE_FILE_AT_LINE (1583)) ;
            }
          }
          var_cas_superType = var_cas_superType.reader_mSuperType (inLexique COMMA_SOURCE_FILE_AT_LINE (1586)) ;
        }
      }
    }
    GGS_variableMap  var_cas_variableMap = GGS_variableMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1589)) ;
    GGS_formalParameterListForGeneration  var_cas_formalParameterListForGeneration ;
    ::routine_buildLocalVariableMapAndSignature (inLexique,  var_cas_inSemanticContext,  operand_62889->mOverridingCategoryMethodFormalParameterList,  var_cas_variableMap,  var_cas_formalParameterListForGeneration COMMA_SOURCE_FILE_AT_LINE (1591)) ;
    const GGS_bool cond_64957 = (var_cas_baseTypeName).operator_isNotEqual (GGS_string ("")) ;
    if (cond_64957.isBuiltAndTrue ()) {
      ::routine_checkMethodSignatures (inLexique,  var_cas_formalParameterListForGeneration,  operand_62889->mOverridingCategoryMethodName.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (1601)),  var_cas_inheritedSignature,  var_cas_inheritedDeclarationLocation COMMA_SOURCE_FILE_AT_LINE (1599)) ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//   Category method '@abstractCategoryReaderAST.performSemanticAnalysis'    *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__abstractCategoryReaderAST__performSemanticAnalysis (C_CompilerEx & inLexique,
                                const cPtr_abstractCategoryReaderAST * operand_65122,
                                const GGS_semanticContext  var_cas_inSemanticContext,
                                const GGS_predefinedTypes  /* var_cas_inPredefinedTypes */,
                                GGS_semanticDeclarationSortedListForGeneration  & var_cas_ioSemanticDeclarationListForGeneration
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_65122 != NULL) {
    const GGS_unifiedTypeMapProxy  var_cas_selfType = GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_65122->mTypeName COMMA_SOURCE_FILE_AT_LINE (1616)) ;
    const GGS_bool cond_65659 = (var_cas_selfType.reader_mTypeKindEnum (inLexique COMMA_SOURCE_FILE_AT_LINE (1618))).operator_isNotEqual (GGS_typeKindEnum::constructor_classType (inLexique COMMA_SOURCE_FILE_AT_LINE (1618))) ;
    if (cond_65659.isBuiltAndTrue ()) {
      operand_65122->mAbstractCategoryReaderName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("cannot declare a category reader: '@")).operator_concat (var_cas_selfType.reader_key (inLexique COMMA_SOURCE_FILE_AT_LINE (1619)))).operator_concat (GGS_string ("' is not a class")) COMMA_SOURCE_FILE_AT_LINE (1620)) ;
    }else if (cond_65659.isBuiltAndFalse ()) {
      const GGS_bool cond_65831 = var_cas_selfType.reader_mIsConcrete (inLexique COMMA_SOURCE_FILE_AT_LINE (1620)) ;
      if (cond_65831.isBuiltAndTrue ()) {
        operand_65122->mAbstractCategoryReaderName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("cannot declare an abstract category reader: '@")).operator_concat (var_cas_selfType.reader_key (inLexique COMMA_SOURCE_FILE_AT_LINE (1621)))).operator_concat (GGS_string ("' is not an abstract class")) COMMA_SOURCE_FILE_AT_LINE (1622)) ;
      }
    }
    GGS_formalInputParameterListForGeneration  var_cas_formalParameterListForGeneration = GGS_formalInputParameterListForGeneration ::constructor_emptyList () ;
    {
      GGS_formalInputParameterListAST::cEnumerator enumerator_66012 (operand_65122->mAbstractCategoryReaderFormalInputParameterList, true) ;
      const GGS_formalInputParameterListAST::cElement * operand_66012 = NULL ;
      while (((operand_66012 = enumerator_66012.nextObject ()))) {
        macroValidPointer (operand_66012) ;
        var_cas_formalParameterListForGeneration.addAssign_operation (GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_66012->mFormalArgumentTypeName COMMA_SOURCE_FILE_AT_LINE (1627)), operand_66012->mFormalArgumentName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1628)), operand_66012->mFormalArgumentName, operand_66012->mIsUnused) ;
      }
    }
    var_cas_ioSemanticDeclarationListForGeneration.addAssign_operation (GGS_abstractCategoryReaderForGeneration ::constructor_new (inLexique, operand_65122->mTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1635)), operand_65122->mAbstractCategoryReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1636)), GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_65122->mAbstractCategoryReaderReturnedTypeName COMMA_SOURCE_FILE_AT_LINE (1637)), var_cas_formalParameterListForGeneration COMMA_SOURCE_FILE_AT_LINE (1634)), GGS_string ("~")) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//       Category method '@categoryReaderAST.performSemanticAnalysis'        *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__categoryReaderAST__performSemanticAnalysis (C_CompilerEx & inLexique,
                                const cPtr_categoryReaderAST * operand_66778,
                                const GGS_semanticContext  var_cas_inSemanticContext,
                                const GGS_predefinedTypes  var_cas_inPredefinedTypes,
                                GGS_semanticDeclarationSortedListForGeneration  & var_cas_ioSemanticDeclarationListForGeneration
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_66778 != NULL) {
    const GGS_unifiedTypeMapProxy  var_cas_selfType = GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_66778->mTypeName COMMA_SOURCE_FILE_AT_LINE (1654)) ;
    const GGS_bool cond_67289 = (var_cas_selfType.reader_mTypeKindEnum (inLexique COMMA_SOURCE_FILE_AT_LINE (1656))).operator_isNotEqual (GGS_typeKindEnum::constructor_classType (inLexique COMMA_SOURCE_FILE_AT_LINE (1656))) ;
    if (cond_67289.isBuiltAndTrue ()) {
      operand_66778->mCategoryReaderName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("cannot declare a category reader: '@")).operator_concat (var_cas_selfType.reader_key (inLexique COMMA_SOURCE_FILE_AT_LINE (1657)))).operator_concat (GGS_string ("' is not a class")) COMMA_SOURCE_FILE_AT_LINE (1658)) ;
    }
    const GGS_analysisContext var_cas_analysisContext = GGS_analysisContext::constructor_new (var_cas_inSemanticContext, var_cas_inPredefinedTypes, var_cas_selfType, GGS_string ("object")) ;
    GGS_unifiedTypeMapProxy  var_cas_returnType ;
    GGS_string var_cas_returnVariableCppName ;
    GGS_formalInputParameterListForGeneration  var_cas_formalParameterListForGeneration ;
    GGS_semanticInstructionListForGeneration  var_cas_semanticInstructionListForGeneration ;
    ::routine_analyzeFunctionBody (inLexique,  var_cas_analysisContext,  operand_66778->mCategoryReaderFormalInputParameterList,  var_cas_selfType.reader_mAllTypedAttributeList (inLexique COMMA_SOURCE_FILE_AT_LINE (1673)),  GGS_string ("object->"),  operand_66778->mCategoryReaderInstructionList,  operand_66778->mCategoryReaderReturnedVariableName,  operand_66778->mCategoryReaderReturnedTypeName,  operand_66778->mEndOfReaderLocation,  var_cas_formalParameterListForGeneration,  var_cas_returnType,  var_cas_returnVariableCppName,  var_cas_semanticInstructionListForGeneration COMMA_SOURCE_FILE_AT_LINE (1670)) ;
    var_cas_ioSemanticDeclarationListForGeneration.addAssign_operation (GGS_categoryReaderForGeneration ::constructor_new (inLexique, operand_66778->mTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1686)), operand_66778->mCategoryReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1687)), var_cas_returnType, var_cas_returnVariableCppName, var_cas_formalParameterListForGeneration, var_cas_selfType.reader_mAllTypedAttributeList (inLexique COMMA_SOURCE_FILE_AT_LINE (1691)), var_cas_semanticInstructionListForGeneration COMMA_SOURCE_FILE_AT_LINE (1685)), GGS_string ("~")) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//  Category method '@overridingCategoryReaderAST.performSemanticAnalysis'   *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__overridingCategoryReaderAST__performSemanticAnalysis (C_CompilerEx & inLexique,
                                const cPtr_overridingCategoryReaderAST * operand_68621,
                                const GGS_semanticContext  var_cas_inSemanticContext,
                                const GGS_predefinedTypes  var_cas_inPredefinedTypes,
                                GGS_semanticDeclarationSortedListForGeneration  & var_cas_ioSemanticDeclarationListForGeneration
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_68621 != NULL) {
    const GGS_unifiedTypeMapProxy  var_cas_selfType = GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_68621->mTypeName COMMA_SOURCE_FILE_AT_LINE (1706)) ;
    const GGS_bool cond_69141 = (var_cas_selfType.reader_mTypeKindEnum (inLexique COMMA_SOURCE_FILE_AT_LINE (1708))).operator_isNotEqual (GGS_typeKindEnum::constructor_classType (inLexique COMMA_SOURCE_FILE_AT_LINE (1708))) ;
    if (cond_69141.isBuiltAndTrue ()) {
      operand_68621->mOverridingCategoryReaderName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("cannot declare a category reader: '@")).operator_concat (var_cas_selfType.reader_key (inLexique COMMA_SOURCE_FILE_AT_LINE (1709)))).operator_concat (GGS_string ("' is not a class")) COMMA_SOURCE_FILE_AT_LINE (1710)) ;
    }
    GGS_string var_cas_baseTypeName = GGS_string ("") ;
    GGS_unifiedTypeMapProxy  var_cas_superType = var_cas_selfType.reader_mSuperType (inLexique COMMA_SOURCE_FILE_AT_LINE (1713)) ;
    GGS_unifiedTypeMapProxyList  var_cas_inheritedSignature = GGS_unifiedTypeMapProxyList ::constructor_emptyList () ;
    GGS_unifiedTypeMapProxy  var_cas_inheritedReturnType = GGS_unifiedTypeMapProxy ::constructor_null (inLexique COMMA_SOURCE_FILE_AT_LINE (1715)) ;
    GGS_location  var_cas_inheritedDeclarationLocation = GGS_location (inLexique) ;
    GGS_uint _variant_70054 = var_cas_inSemanticContext.mTypeMap.reader_count ().add_operation (inLexique, GGS_uint (1U) COMMA_SOURCE_FILE_AT_LINE (1717)) ;
    GGS_bool _condition_70054 (_variant_70054.isBuilt (), true) ;
    while (_condition_70054.isBuiltAndTrue ()) {
      _condition_70054 = ((var_cas_superType.reader_isNull (inLexique COMMA_SOURCE_FILE_AT_LINE (1718))).operator_not ()).operator_and ((var_cas_baseTypeName).operator_isEqual (GGS_string (""))) ;
      if (_condition_70054.isBuiltAndTrue ()) {
        if (_variant_70054.uintValue () == 0) {
          inLexique.onTheFlyRunTimeError ("loop variant error" COMMA_SOURCE_FILE_AT_LINE (1735)) ;
          _condition_70054 = GGS_bool (false) ;
        }else{
          _variant_70054.decrement_operation (inLexique COMMA_HERE) ;
          const GGS_bool cond_70001 = var_cas_superType.reader_mReaderMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1719)).reader_hasKey (operand_68621->mOverridingCategoryReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1719))) ;
          if (cond_70001.isBuiltAndTrue ()) {
            GGS_methodQualifier var_cas_qualifier ;
            GGS_bool automatic_var_69875_0 ;
            GGS_bool automatic_var_69875_1 ;
            const GGS_readerMap  temp_69692 = var_cas_superType.reader_mReaderMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1721)) ;
            if (temp_69692.isBuilt ()) {
              temp_69692 (HERE)->method_searchKey (inLexique, operand_68621->mOverridingCategoryReaderName, automatic_var_69875_0, var_cas_inheritedSignature, var_cas_inheritedDeclarationLocation, automatic_var_69875_1, var_cas_inheritedReturnType, var_cas_qualifier COMMA_SOURCE_FILE_AT_LINE (1721)) ;
            }
            const GGS_bool cond_69988 = (var_cas_qualifier).operator_infOrEqual (GGS_methodQualifier::constructor_isBasicFinal (inLexique COMMA_SOURCE_FILE_AT_LINE (1730))) ;
            if (cond_69988.isBuiltAndTrue ()) {
              var_cas_baseTypeName = var_cas_superType.reader_key (inLexique COMMA_SOURCE_FILE_AT_LINE (1731)) ;
            }
          }
          var_cas_superType = var_cas_superType.reader_mSuperType (inLexique COMMA_SOURCE_FILE_AT_LINE (1734)) ;
        }
      }
    }
    const GGS_analysisContext var_cas_analysisContext = GGS_analysisContext::constructor_new (var_cas_inSemanticContext, var_cas_inPredefinedTypes, var_cas_selfType, GGS_string ("object")) ;
    GGS_unifiedTypeMapProxy  var_cas_returnType ;
    GGS_string var_cas_returnVariableCppName ;
    GGS_formalInputParameterListForGeneration  var_cas_formalParameterListForGeneration ;
    GGS_semanticInstructionListForGeneration  var_cas_semanticInstructionListForGeneration ;
    ::routine_analyzeFunctionBody (inLexique,  var_cas_analysisContext,  operand_68621->mOverridingCategoryReaderFormalInputParameterList,  var_cas_selfType.reader_mAllTypedAttributeList (inLexique COMMA_SOURCE_FILE_AT_LINE (1750)),  GGS_string ("object->"),  operand_68621->mOverridingCategoryReaderInstructionList,  operand_68621->mOverridingCategoryReaderReturnedVariableName,  operand_68621->mOverridingCategoryReaderReturnedTypeName,  operand_68621->mEndOfReaderLocation,  var_cas_formalParameterListForGeneration,  var_cas_returnType,  var_cas_returnVariableCppName,  var_cas_semanticInstructionListForGeneration COMMA_SOURCE_FILE_AT_LINE (1747)) ;
    const GGS_bool cond_71175 = (var_cas_baseTypeName).operator_isNotEqual (GGS_string ("")) ;
    if (cond_71175.isBuiltAndTrue ()) {
      ::routine_checkReaderSignatures (inLexique,  var_cas_formalParameterListForGeneration,  var_cas_returnType,  operand_68621->mOverridingCategoryReaderName.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (1766)),  var_cas_inheritedSignature,  var_cas_inheritedReturnType,  var_cas_inheritedDeclarationLocation COMMA_SOURCE_FILE_AT_LINE (1763)) ;
    }
    var_cas_ioSemanticDeclarationListForGeneration.addAssign_operation (GGS_overrideCategoryReaderForGeneration ::constructor_new (inLexique, operand_68621->mTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1774)), var_cas_baseTypeName, operand_68621->mOverridingCategoryReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1776)), var_cas_returnType, var_cas_returnVariableCppName, var_cas_formalParameterListForGeneration, var_cas_selfType.reader_mAllTypedAttributeList (inLexique COMMA_SOURCE_FILE_AT_LINE (1780)), var_cas_semanticInstructionListForGeneration COMMA_SOURCE_FILE_AT_LINE (1773)), GGS_string ("~")) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//Category method '@overridingAbstractCategoryReaderAST.performSemanticAnalysis'*
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__overridingAbstractCategoryReaderAST__performSemanticAnalysis (C_CompilerEx & inLexique,
                                const cPtr_overridingAbstractCategoryReaderAST * operand_71760,
                                const GGS_semanticContext  var_cas_inSemanticContext,
                                const GGS_predefinedTypes  /* var_cas_inPredefinedTypes */,
                                GGS_semanticDeclarationSortedListForGeneration  & /* var_cas_ioSemanticDeclarationListForGeneration */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_71760 != NULL) {
    const GGS_unifiedTypeMapProxy  var_cas_selfType = GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_71760->mTypeName COMMA_SOURCE_FILE_AT_LINE (1795)) ;
    const GGS_unifiedTypeMapProxy  var_cas_returnType = GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_71760->mAbstractCategoryReaderReturnedTypeName COMMA_SOURCE_FILE_AT_LINE (1797)) ;
    const GGS_bool cond_72464 = (var_cas_selfType.reader_mTypeKindEnum (inLexique COMMA_SOURCE_FILE_AT_LINE (1799))).operator_isNotEqual (GGS_typeKindEnum::constructor_classType (inLexique COMMA_SOURCE_FILE_AT_LINE (1799))) ;
    if (cond_72464.isBuiltAndTrue ()) {
      operand_71760->mAbstractCategoryReaderName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("cannot declare a category reader: '@")).operator_concat (var_cas_selfType.reader_key (inLexique COMMA_SOURCE_FILE_AT_LINE (1800)))).operator_concat (GGS_string ("' is not a class")) COMMA_SOURCE_FILE_AT_LINE (1801)) ;
    }else if (cond_72464.isBuiltAndFalse ()) {
      const GGS_bool cond_72636 = var_cas_selfType.reader_mIsConcrete (inLexique COMMA_SOURCE_FILE_AT_LINE (1801)) ;
      if (cond_72636.isBuiltAndTrue ()) {
        operand_71760->mAbstractCategoryReaderName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("cannot declare an abstract category reader: '@")).operator_concat (var_cas_selfType.reader_key (inLexique COMMA_SOURCE_FILE_AT_LINE (1802)))).operator_concat (GGS_string ("' is not an abstract class")) COMMA_SOURCE_FILE_AT_LINE (1803)) ;
      }
    }
    GGS_string var_cas_baseTypeName = GGS_string ("") ;
    GGS_unifiedTypeMapProxy  var_cas_superType = var_cas_selfType.reader_mSuperType (inLexique COMMA_SOURCE_FILE_AT_LINE (1806)) ;
    GGS_unifiedTypeMapProxyList  var_cas_inheritedSignature = GGS_unifiedTypeMapProxyList ::constructor_emptyList () ;
    GGS_unifiedTypeMapProxy  var_cas_inheritedReturnType = GGS_unifiedTypeMapProxy ::constructor_null (inLexique COMMA_SOURCE_FILE_AT_LINE (1808)) ;
    GGS_location  var_cas_inheritedDeclarationLocation = GGS_location (inLexique) ;
    GGS_uint _variant_73538 = var_cas_inSemanticContext.mTypeMap.reader_count ().add_operation (inLexique, GGS_uint (1U) COMMA_SOURCE_FILE_AT_LINE (1810)) ;
    GGS_bool _condition_73538 (_variant_73538.isBuilt (), true) ;
    while (_condition_73538.isBuiltAndTrue ()) {
      _condition_73538 = ((var_cas_superType.reader_isNull (inLexique COMMA_SOURCE_FILE_AT_LINE (1811))).operator_not ()).operator_and ((var_cas_baseTypeName).operator_isEqual (GGS_string (""))) ;
      if (_condition_73538.isBuiltAndTrue ()) {
        if (_variant_73538.uintValue () == 0) {
          inLexique.onTheFlyRunTimeError ("loop variant error" COMMA_SOURCE_FILE_AT_LINE (1827)) ;
          _condition_73538 = GGS_bool (false) ;
        }else{
          _variant_73538.decrement_operation (inLexique COMMA_HERE) ;
          const GGS_bool cond_73485 = var_cas_superType.reader_mReaderMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1812)).reader_hasKey (operand_71760->mAbstractCategoryReaderName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1812))) ;
          if (cond_73485.isBuiltAndTrue ()) {
            GGS_methodQualifier var_cas_qualifier ;
            GGS_bool automatic_var_73359_0 ;
            GGS_bool automatic_var_73359_1 ;
            const GGS_readerMap  temp_73185 = var_cas_superType.reader_mReaderMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1814)) ;
            if (temp_73185.isBuilt ()) {
              temp_73185 (HERE)->method_searchKey (inLexique, operand_71760->mAbstractCategoryReaderName, automatic_var_73359_0, var_cas_inheritedSignature, var_cas_inheritedDeclarationLocation, automatic_var_73359_1, var_cas_inheritedReturnType, var_cas_qualifier COMMA_SOURCE_FILE_AT_LINE (1814)) ;
            }
            const GGS_bool cond_73472 = (var_cas_qualifier).operator_infOrEqual (GGS_methodQualifier::constructor_isBasicFinal (inLexique COMMA_SOURCE_FILE_AT_LINE (1822))) ;
            if (cond_73472.isBuiltAndTrue ()) {
              var_cas_baseTypeName = var_cas_superType.reader_key (inLexique COMMA_SOURCE_FILE_AT_LINE (1823)) ;
            }
          }
          var_cas_superType = var_cas_superType.reader_mSuperType (inLexique COMMA_SOURCE_FILE_AT_LINE (1826)) ;
        }
      }
    }
    const GGS_bool cond_74229 = (var_cas_baseTypeName).operator_isNotEqual (GGS_string ("")) ;
    if (cond_74229.isBuiltAndTrue ()) {
      GGS_formalInputParameterListForGeneration  var_cas_formalParameterListForGeneration = GGS_formalInputParameterListForGeneration ::constructor_emptyList () ;
      {
        GGS_formalInputParameterListAST::cEnumerator enumerator_73745 (operand_71760->mAbstractCategoryReaderFormalInputParameterList, true) ;
        const GGS_formalInputParameterListAST::cElement * operand_73745 = NULL ;
        while (((operand_73745 = enumerator_73745.nextObject ()))) {
          macroValidPointer (operand_73745) ;
          var_cas_formalParameterListForGeneration.addAssign_operation (GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, operand_73745->mFormalArgumentTypeName COMMA_SOURCE_FILE_AT_LINE (1833)), operand_73745->mFormalArgumentName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1834)), operand_73745->mFormalArgumentName, operand_73745->mIsUnused) ;
        }
      }
      ::routine_checkReaderSignatures (inLexique,  var_cas_formalParameterListForGeneration,  var_cas_returnType,  operand_71760->mAbstractCategoryReaderName.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (1842)),  var_cas_inheritedSignature,  var_cas_inheritedReturnType,  var_cas_inheritedDeclarationLocation COMMA_SOURCE_FILE_AT_LINE (1839)) ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Implementation of function "buildPredefinedTypes"              *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_predefinedTypes function_buildPredefinedTypes (C_CompilerEx & inLexique,
                                const GGS_semanticContext  var_cas_inSemanticContext COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER function_buildPredefinedTypes at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_predefinedTypes var_cas_outPredefinedTypes ;
  var_cas_outPredefinedTypes = GGS_predefinedTypes::constructor_new (GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, GGS_lstring ::constructor_new (inLexique, GGS_string ("location"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (1861)) COMMA_SOURCE_FILE_AT_LINE (1861)), GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, GGS_lstring ::constructor_new (inLexique, GGS_string ("bool"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (1862)) COMMA_SOURCE_FILE_AT_LINE (1862)), GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, GGS_lstring ::constructor_new (inLexique, GGS_string ("char"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (1863)) COMMA_SOURCE_FILE_AT_LINE (1863)), GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, GGS_lstring ::constructor_new (inLexique, GGS_string ("string"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (1864)) COMMA_SOURCE_FILE_AT_LINE (1864)), GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, GGS_lstring ::constructor_new (inLexique, GGS_string ("uint"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (1865)) COMMA_SOURCE_FILE_AT_LINE (1865)), GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, GGS_lstring ::constructor_new (inLexique, GGS_string ("sint"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (1866)) COMMA_SOURCE_FILE_AT_LINE (1866)), GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, GGS_lstring ::constructor_new (inLexique, GGS_string ("uint64"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (1867)) COMMA_SOURCE_FILE_AT_LINE (1867)), GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, GGS_lstring ::constructor_new (inLexique, GGS_string ("sint64"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (1868)) COMMA_SOURCE_FILE_AT_LINE (1868)), GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, GGS_lstring ::constructor_new (inLexique, GGS_string ("double"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (1869)) COMMA_SOURCE_FILE_AT_LINE (1869)), GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, GGS_lstring ::constructor_new (inLexique, GGS_string ("lbool"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (1870)) COMMA_SOURCE_FILE_AT_LINE (1870)), GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, GGS_lstring ::constructor_new (inLexique, GGS_string ("lchar"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (1871)) COMMA_SOURCE_FILE_AT_LINE (1871)), GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, GGS_lstring ::constructor_new (inLexique, GGS_string ("lstring"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (1872)) COMMA_SOURCE_FILE_AT_LINE (1872)), GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, GGS_lstring ::constructor_new (inLexique, GGS_string ("luint"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (1873)) COMMA_SOURCE_FILE_AT_LINE (1873)), GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, GGS_lstring ::constructor_new (inLexique, GGS_string ("lsint"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (1874)) COMMA_SOURCE_FILE_AT_LINE (1874)), GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, GGS_lstring ::constructor_new (inLexique, GGS_string ("luint64"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (1875)) COMMA_SOURCE_FILE_AT_LINE (1875)), GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, GGS_lstring ::constructor_new (inLexique, GGS_string ("lsint64"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (1876)) COMMA_SOURCE_FILE_AT_LINE (1876)), GGS_unifiedTypeMapProxy ::constructor_searchKey (inLexique, var_cas_inSemanticContext.mTypeMap, GGS_lstring ::constructor_new (inLexique, GGS_string ("ldouble"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (1877)) COMMA_SOURCE_FILE_AT_LINE (1877))) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE function_buildPredefinedTypes\n") ;
  #endif
  return var_cas_outPredefinedTypes ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_buildPredefinedTypes (C_CompilerEx & inLexique,
                           const GGS_objectlist & inEffectiveParameterArray,
                           const GGS_location & inErrorLocation
                           COMMA_LOCATION_ARGS) {
  const GGS_semanticContext arg_0 = GGS_semanticContext::castFromObject (inLexique, inEffectiveParameterArray.reader_mValueAtIndex (inLexique, GGS_uint (0) COMMA_THERE), inErrorLocation COMMA_THERE) ;
  const GGS_predefinedTypes result = function_buildPredefinedTypes (inLexique,
                            arg_0
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

static const C_galgas_type_descriptorEX *
kArgumentTypeList_buildPredefinedTypes [1] = {& kTypeDescriptor_GGS_semanticContext} ;

const C_galgas_function_descriptorEX
kFunction_descriptor_buildPredefinedTypes ("buildPredefinedTypes",
                              functionForGenericCall_buildPredefinedTypes,
                              & kTypeDescriptor_GGS_predefinedTypes,
                              1,
                              kArgumentTypeList_buildPredefinedTypes) ;

//---------------------------------------------------------------------------*
//                                                                           *
//           Implementation of routine "performSemanticAnalysis"             *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_performSemanticAnalysis (C_CompilerEx & inLexique,
                                const GGS_semanticDeclarationListAST   var_cas_inDeclarationList,
                                const GGS_semanticContext  var_cas_inSemanticContext,
                                GGS_semanticDeclarationSortedListForGeneration  & var_cas_outDecoratedDeclarationListForGeneration
                        COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_performSemanticAnalysis at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  const GGS_predefinedTypes var_cas_predefinedTypes = function_buildPredefinedTypes (inLexique, var_cas_inSemanticContext COMMA_SOURCE_FILE_AT_LINE (1892)) ;
  var_cas_outDecoratedDeclarationListForGeneration = GGS_semanticDeclarationSortedListForGeneration ::constructor_emptySortedList () ;
  {
    GGS_semanticDeclarationListAST::cEnumerator enumerator_77323 (var_cas_inDeclarationList, true) ;
    const GGS_semanticDeclarationListAST::cElement * operand_77323 = NULL ;
    while (((operand_77323 = enumerator_77323.nextObject ()))) {
      macroValidPointer (operand_77323) ;
      { typeCategoryMethod__semanticDeclarationAST__performSemanticAnalysis method = findCategoryMethod__semanticDeclarationAST__performSemanticAnalysis (operand_77323->mSemanticDeclaration.galgasObjectRunTimeInfo ()) ;
        if (method != NULL) {
          method (inLexique, operand_77323->mSemanticDeclaration (HERE), var_cas_inSemanticContext, var_cas_predefinedTypes, var_cas_outDecoratedDeclarationListForGeneration COMMA_SOURCE_FILE_AT_LINE (1895)) ;
        }
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_performSemanticAnalysis\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      Prologue and epilogue actions                        *
//                                                                           *
//---------------------------------------------------------------------------*

static void prologueRoutineFor_semanticAnalysis (void) {
  enterCategoryMethod__semanticDeclarationAST__performSemanticAnalysis (category_method__semanticDeclarationAST__performSemanticAnalysis, gClassInfoFor__semanticDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__performSemanticAnalysis ((typeCategoryMethod__semanticDeclarationAST__performSemanticAnalysis) category_method__predefinedTypeAST__performSemanticAnalysis, gClassInfoFor__predefinedTypeAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__performSemanticAnalysis ((typeCategoryMethod__semanticDeclarationAST__performSemanticAnalysis) category_method__listDeclarationAST__performSemanticAnalysis, gClassInfoFor__listDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__performSemanticAnalysis ((typeCategoryMethod__semanticDeclarationAST__performSemanticAnalysis) category_method__sortedListDeclarationAST__performSemanticAnalysis, gClassInfoFor__sortedListDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__performSemanticAnalysis ((typeCategoryMethod__semanticDeclarationAST__performSemanticAnalysis) category_method__structDeclarationAST__performSemanticAnalysis, gClassInfoFor__structDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__performSemanticAnalysis ((typeCategoryMethod__semanticDeclarationAST__performSemanticAnalysis) category_method__enumDeclarationAST__performSemanticAnalysis, gClassInfoFor__enumDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__performSemanticAnalysis ((typeCategoryMethod__semanticDeclarationAST__performSemanticAnalysis) category_method__listmapDeclarationAST__performSemanticAnalysis, gClassInfoFor__listmapDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__performSemanticAnalysis ((typeCategoryMethod__semanticDeclarationAST__performSemanticAnalysis) category_method__mapDeclarationAST__performSemanticAnalysis, gClassInfoFor__mapDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__performSemanticAnalysis ((typeCategoryMethod__semanticDeclarationAST__performSemanticAnalysis) category_method__mapProxyDeclarationAST__performSemanticAnalysis, gClassInfoFor__mapProxyDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__performSemanticAnalysis ((typeCategoryMethod__semanticDeclarationAST__performSemanticAnalysis) category_method__externFunctionDeclarationAST__performSemanticAnalysis, gClassInfoFor__externFunctionDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__performSemanticAnalysis ((typeCategoryMethod__semanticDeclarationAST__performSemanticAnalysis) category_method__externRoutineDeclarationAST__performSemanticAnalysis, gClassInfoFor__externRoutineDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__performSemanticAnalysis ((typeCategoryMethod__semanticDeclarationAST__performSemanticAnalysis) category_method__routineDeclarationAST__performSemanticAnalysis, gClassInfoFor__routineDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__performSemanticAnalysis ((typeCategoryMethod__semanticDeclarationAST__performSemanticAnalysis) category_method__classDeclarationAST__performSemanticAnalysis, gClassInfoFor__classDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__performSemanticAnalysis ((typeCategoryMethod__semanticDeclarationAST__performSemanticAnalysis) category_method__functionDeclarationAST__performSemanticAnalysis, gClassInfoFor__functionDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__performSemanticAnalysis ((typeCategoryMethod__semanticDeclarationAST__performSemanticAnalysis) category_method__onceFunctionDeclarationAST__performSemanticAnalysis, gClassInfoFor__onceFunctionDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__performSemanticAnalysis ((typeCategoryMethod__semanticDeclarationAST__performSemanticAnalysis) category_method__filewrapperDeclarationAST__performSemanticAnalysis, gClassInfoFor__filewrapperDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__performSemanticAnalysis ((typeCategoryMethod__semanticDeclarationAST__performSemanticAnalysis) category_method__abstractCategoryMethodAST__performSemanticAnalysis, gClassInfoFor__abstractCategoryMethodAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__performSemanticAnalysis ((typeCategoryMethod__semanticDeclarationAST__performSemanticAnalysis) category_method__categoryMethodAST__performSemanticAnalysis, gClassInfoFor__categoryMethodAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__performSemanticAnalysis ((typeCategoryMethod__semanticDeclarationAST__performSemanticAnalysis) category_method__overridingCategoryMethodAST__performSemanticAnalysis, gClassInfoFor__overridingCategoryMethodAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__performSemanticAnalysis ((typeCategoryMethod__semanticDeclarationAST__performSemanticAnalysis) category_method__overridingAbstractCategoryMethodAST__performSemanticAnalysis, gClassInfoFor__overridingAbstractCategoryMethodAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__performSemanticAnalysis ((typeCategoryMethod__semanticDeclarationAST__performSemanticAnalysis) category_method__abstractCategoryReaderAST__performSemanticAnalysis, gClassInfoFor__abstractCategoryReaderAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__performSemanticAnalysis ((typeCategoryMethod__semanticDeclarationAST__performSemanticAnalysis) category_method__categoryReaderAST__performSemanticAnalysis, gClassInfoFor__categoryReaderAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__performSemanticAnalysis ((typeCategoryMethod__semanticDeclarationAST__performSemanticAnalysis) category_method__overridingCategoryReaderAST__performSemanticAnalysis, gClassInfoFor__overridingCategoryReaderAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__performSemanticAnalysis ((typeCategoryMethod__semanticDeclarationAST__performSemanticAnalysis) category_method__overridingAbstractCategoryReaderAST__performSemanticAnalysis, gClassInfoFor__overridingAbstractCategoryReaderAST.slotID ()) ;
}

//---------------------------------------------------------------------------*

static void epilogueRoutineFor_semanticAnalysis (void) {
  gDispatchTableForMethod__semanticDeclarationAST__performSemanticAnalysis.free () ;
}

//---------------------------------------------------------------------------*

C_PrologueEpilogue prologueEpilogueObjectFor_semanticAnalysis (prologueRoutineFor_semanticAnalysis, epilogueRoutineFor_semanticAnalysis) ;

//---------------------------------------------------------------------------*

