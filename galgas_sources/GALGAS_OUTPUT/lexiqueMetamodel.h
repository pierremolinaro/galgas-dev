//---------------------------------------------------------------------------*
//                                                                           *
//                        File 'lexiqueMetamodel.h'                          *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                       may 29th, 2009, at 11h34'39"                        *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

#ifndef lexiqueMetamodel_DEFINED
#define lexiqueMetamodel_DEFINED

#include <string.h>

//---------------------------------------------------------------------------*

#include "galgas/C_GGS_Object.h"
#include "galgas/GGS_location.h"
#include "galgas/GGS_lbool.h"
#include "galgas/GGS_lchar.h"
#include "galgas/GGS_lstring.h"
#include "galgas/GGS_ldouble.h"
#include "galgas/GGS_luint.h"
#include "galgas/GGS_lsint.h"
#include "galgas/GGS_luint64.h"
#include "galgas/GGS_lsint64.h"
#include "galgas/GGS_stringset.h"
#include "galgas/GGS_binaryset.h"
#include "galgas/GGS_filewrapper.h"
#include "galgas/predefined_types.h"
#include "galgas/AC_galgas_class.h"
#include "galgas/AC_galgas_domain.h"
#include "galgas/AC_galgas_mapindex.h"
#include "galgas/AC_galgas_map.h"
#include "galgas/AC_galgas_listmap.h"
#include "galgas/AC_galgas_list.h"
#include "galgas/AC_galgas_sortedlist.h"

//---------------------------------------------------------------------------*

#include "galgas/C_Lexique.h"

//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                          Class Predeclarations                            *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_templateDelimitorList ;
class GGS_templateReplacementList ;
class GGS_lexicalImplicitRuleList ;
class GGS_lexicalErrorMessageDeclarationList ;
class GGS_lexicalAttributeList ;
class GGS_lexicalStyleList ;
class GGS_terminalDeclarationList ;
class GGS_lexicalListEntryList ;
class GGS_lexicalListDeclarationList ;
class GGS_lexicalExpression ;
class cPtr_lexicalExpression ;
class GGS_lexicalExplicitRuleList ;
class GGS_lexicalOrExpression ;
class cPtr_lexicalOrExpression ;
class GGS_lexicalCharacterSetMatch ;
class cPtr_lexicalCharacterSetMatch ;
class GGS_lexicalCharacterMatch ;
class cPtr_lexicalCharacterMatch ;
class GGS_lexicalCharacterIntervalMatch ;
class cPtr_lexicalCharacterIntervalMatch ;
class GGS_lexicalStringMatch ;
class cPtr_lexicalStringMatch ;
class GGS_lexicalStringNotMatch ;
class cPtr_lexicalStringNotMatch ;
class GGS_lexicalInstruction ;
class cPtr_lexicalInstruction ;
class GGS_lexicalSendDefaultAction ;
class cPtr_lexicalSendDefaultAction ;
class GGS_lexicalStructuredSendInstruction ;
class cPtr_lexicalStructuredSendInstruction ;
class GGS_lexicalSimpleSendInstruction ;
class cPtr_lexicalSimpleSendInstruction ;
class GGS_lexicalSendTerminalByDefault ;
class cPtr_lexicalSendTerminalByDefault ;
class GGS_lexicalErrorByDefault ;
class cPtr_lexicalErrorByDefault ;
class GGS_lexicalSendSearchList ;
class GGS_lexicalRepeatInstruction ;
class cPtr_lexicalRepeatInstruction ;
class GGS_lexicalWhileBranchList ;
class GGS_lexicalSelectInstruction ;
class cPtr_lexicalSelectInstruction ;
class GGS_lexicalInstructionList ;
class GGS_lexicalSelectBranchList ;
class GGS_lexicalActionInstruction ;
class cPtr_lexicalActionInstruction ;
class GGS_lexicalActualArgument ;
class cPtr_lexicalActualArgument ;
class GGS_lexicalRoutineCallActualArgumentList ;
class GGS_lexicalFormalInputArgument ;
class cPtr_lexicalFormalInputArgument ;
class GGS_lexicalFunctionCallActualArgumentList ;
class GGS_lexicalAttributeInputOutputArgument ;
class cPtr_lexicalAttributeInputOutputArgument ;
class GGS_lexicalAttributeInputArgument ;
class cPtr_lexicalAttributeInputArgument ;
class GGS_lexicalCharacterInputArgument ;
class cPtr_lexicalCharacterInputArgument ;
class GGS_lexicalCurrentCharacterInputArgument ;
class cPtr_lexicalCurrentCharacterInputArgument ;
class GGS_lexicalFunctionInputArgument ;
class cPtr_lexicalFunctionInputArgument ;
class GGS_lexicalDropInstruction ;
class cPtr_lexicalDropInstruction ;
class GGS_lexicalErrorInstruction ;
class cPtr_lexicalErrorInstruction ;
class GGS_lexicalWarningInstruction ;
class cPtr_lexicalWarningInstruction ;
class GGS_lexicalTagInstruction ;
class cPtr_lexicalTagInstruction ;
class GGS_lexicalRewindInstruction ;
class cPtr_lexicalRewindInstruction ;
class GGS_lexicalLogInstruction ;
class cPtr_lexicalLogInstruction ;
class GGS_lexiqueComponentRoot ;
class cPtr_lexiqueComponentRoot ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      list '@templateDelimitorList'                        *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_templateDelimitorList ;

class GGS_templateDelimitorList : public AC_galgas_list {
  public : typedef elementOf_GGS_templateDelimitorList cElement ;

//--- Constructor 'emptyList'
  public : static GGS_templateDelimitorList constructor_emptyList (void) ;
  public : static GGS_templateDelimitorList constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_lstring & argument_2) ;
//--- Get sublist
  protected : void
  internalSubListWithRange (GGS_templateDelimitorList & ioList,
                            const sint32 inFirstIndex,
                            const sint32 inCount) const ;

  public : GGS_templateDelimitorList
  reader_subListWithRange (C_Compiler & inLexique,
                           const GGS_uint & inFirstIndex,
                           const GGS_uint & inCount
                           COMMA_LOCATION_ARGS) const ;

  public : GGS_templateDelimitorList
  reader_subListFromIndex (C_Compiler & inLexique,
                           const GGS_uint & inIndex
                           COMMA_LOCATION_ARGS) const ;

//--- Get first object
  public : inline cElement * firstObject (void) const {
    return (cElement *) internalFirstObject () ;
  }
//--- Get last object
  public : inline cElement * lastObject (void) const {
    return (cElement *) internalLastObject () ;
  }
//--- Operator () used for method call
  public : const GGS_templateDelimitorList * operator () (UNUSED_LOCATION_ARGS) const { return this ;} 
//--- Method 'first'
  public : void method_first (C_Compiler & inLexique,
                              GGS_lstring & _out_0,
                              GGS_lstringlist & _out_1,
                              GGS_lstring & _out_2
                              COMMA_LOCATION_ARGS) const ;
//--- Method 'last'
  public : void method_last (C_Compiler & inLexique,
                             GGS_lstring & _out_0,
                             GGS_lstringlist & _out_1,
                             GGS_lstring & _out_2
                             COMMA_LOCATION_ARGS) const ;
//--- Modifier 'popLast'
  public : void modifier_popLast (C_Compiler & inLexique,
                                GGS_lstring & _out_0,
                                GGS_lstringlist & _out_1,
                                GGS_lstring & _out_2
                                COMMA_LOCATION_ARGS) ;
//--- Modifier 'popFirst'
  public : void modifier_popFirst (C_Compiler & inLexique,
                                 GGS_lstring & _out_0,
                                 GGS_lstringlist & _out_1,
                                 GGS_lstring & _out_2
                                 COMMA_LOCATION_ARGS) ;
//--- Handle '.=' operator
  public : void _dotAssign_operation (const GGS_templateDelimitorList inOperand) ;

//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_lstring & argument_2) ;
//--- Handling '.' GALGAS operator
  public : GGS_templateDelimitorList _operator_concat (const GGS_templateDelimitorList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_lstring & argument_2
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lstring & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_lstring & argument_2
                                COMMA_LOCATION_ARGS) ;

  protected : void _internalPrependValues (const GGS_lstring & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_lstring & argument_2
                                COMMA_LOCATION_ARGS) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--------------------------------- Direct Read Access
  public : GGS_lstring 
  reader_mStartStringAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const ;
  public : GGS_lstringlist 
  reader_mOptionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const ;
  public : GGS_lstring 
  reader_mEndStringAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const ;

//--------------------------------- Direct Write Access
  public : void
  modifier_setMStartStringAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const ;
  public : void
  modifier_setMOptionListAtIndex (C_Compiler & inLexique,
                              const GGS_lstringlist  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const ;
  public : void
  modifier_setMEndStringAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const ;

//--------------------------------- List Enumerator
  public : class cEnumerator : public cAbstractListEnumerator {
  //--- Constructor
    public : inline cEnumerator (const GGS_templateDelimitorList & inList,
                                 const bool inAscending) :
    cAbstractListEnumerator (inList, inAscending) {
    }
  //--- Iterator method
    public : inline cElement * nextObject (void) {
      return (cElement *) internalNextObject () ;
    }
  public : /* const */ GGS_lstring   & _mStartString (LOCATION_ARGS) const ;
  public : /* const */ GGS_lstringlist   & _mOptionList (LOCATION_ARGS) const ;
  public : /* const */ GGS_lstring   & _mEndString (LOCATION_ARGS) const ;
  } ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     list '@templateReplacementList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_templateReplacementList ;

class GGS_templateReplacementList : public AC_galgas_list {
  public : typedef elementOf_GGS_templateReplacementList cElement ;

//--- Constructor 'emptyList'
  public : static GGS_templateReplacementList constructor_emptyList (void) ;
  public : static GGS_templateReplacementList constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2) ;
//--- Get sublist
  protected : void
  internalSubListWithRange (GGS_templateReplacementList & ioList,
                            const sint32 inFirstIndex,
                            const sint32 inCount) const ;

  public : GGS_templateReplacementList
  reader_subListWithRange (C_Compiler & inLexique,
                           const GGS_uint & inFirstIndex,
                           const GGS_uint & inCount
                           COMMA_LOCATION_ARGS) const ;

  public : GGS_templateReplacementList
  reader_subListFromIndex (C_Compiler & inLexique,
                           const GGS_uint & inIndex
                           COMMA_LOCATION_ARGS) const ;

//--- Get first object
  public : inline cElement * firstObject (void) const {
    return (cElement *) internalFirstObject () ;
  }
//--- Get last object
  public : inline cElement * lastObject (void) const {
    return (cElement *) internalLastObject () ;
  }
//--- Operator () used for method call
  public : const GGS_templateReplacementList * operator () (UNUSED_LOCATION_ARGS) const { return this ;} 
//--- Method 'first'
  public : void method_first (C_Compiler & inLexique,
                              GGS_lstring & _out_0,
                              GGS_lstring & _out_1,
                              GGS_lstring & _out_2
                              COMMA_LOCATION_ARGS) const ;
//--- Method 'last'
  public : void method_last (C_Compiler & inLexique,
                             GGS_lstring & _out_0,
                             GGS_lstring & _out_1,
                             GGS_lstring & _out_2
                             COMMA_LOCATION_ARGS) const ;
//--- Modifier 'popLast'
  public : void modifier_popLast (C_Compiler & inLexique,
                                GGS_lstring & _out_0,
                                GGS_lstring & _out_1,
                                GGS_lstring & _out_2
                                COMMA_LOCATION_ARGS) ;
//--- Modifier 'popFirst'
  public : void modifier_popFirst (C_Compiler & inLexique,
                                 GGS_lstring & _out_0,
                                 GGS_lstring & _out_1,
                                 GGS_lstring & _out_2
                                 COMMA_LOCATION_ARGS) ;
//--- Handle '.=' operator
  public : void _dotAssign_operation (const GGS_templateReplacementList inOperand) ;

//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2) ;
//--- Handling '.' GALGAS operator
  public : GGS_templateReplacementList _operator_concat (const GGS_templateReplacementList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2
                                COMMA_LOCATION_ARGS) ;

  protected : void _internalPrependValues (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2
                                COMMA_LOCATION_ARGS) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--------------------------------- Direct Read Access
  public : GGS_lstring 
  reader_mMatchStringAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const ;
  public : GGS_lstring 
  reader_mReplacementStringAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const ;
  public : GGS_lstring 
  reader_mReplacementFunctionAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const ;

//--------------------------------- Direct Write Access
  public : void
  modifier_setMMatchStringAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const ;
  public : void
  modifier_setMReplacementStringAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const ;
  public : void
  modifier_setMReplacementFunctionAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const ;

//--------------------------------- List Enumerator
  public : class cEnumerator : public cAbstractListEnumerator {
  //--- Constructor
    public : inline cEnumerator (const GGS_templateReplacementList & inList,
                                 const bool inAscending) :
    cAbstractListEnumerator (inList, inAscending) {
    }
  //--- Iterator method
    public : inline cElement * nextObject (void) {
      return (cElement *) internalNextObject () ;
    }
  public : /* const */ GGS_lstring   & _mMatchString (LOCATION_ARGS) const ;
  public : /* const */ GGS_lstring   & _mReplacementString (LOCATION_ARGS) const ;
  public : /* const */ GGS_lstring   & _mReplacementFunction (LOCATION_ARGS) const ;
  } ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     list '@lexicalImplicitRuleList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_lexicalImplicitRuleList ;

class GGS_lexicalImplicitRuleList : public AC_galgas_list {
  public : typedef elementOf_GGS_lexicalImplicitRuleList cElement ;

//--- Constructor 'emptyList'
  public : static GGS_lexicalImplicitRuleList constructor_emptyList (void) ;
  public : static GGS_lexicalImplicitRuleList constructor_listWithValue (const GGS_lstring & argument_0) ;
//--- Get sublist
  protected : void
  internalSubListWithRange (GGS_lexicalImplicitRuleList & ioList,
                            const sint32 inFirstIndex,
                            const sint32 inCount) const ;

  public : GGS_lexicalImplicitRuleList
  reader_subListWithRange (C_Compiler & inLexique,
                           const GGS_uint & inFirstIndex,
                           const GGS_uint & inCount
                           COMMA_LOCATION_ARGS) const ;

  public : GGS_lexicalImplicitRuleList
  reader_subListFromIndex (C_Compiler & inLexique,
                           const GGS_uint & inIndex
                           COMMA_LOCATION_ARGS) const ;

//--- Get first object
  public : inline cElement * firstObject (void) const {
    return (cElement *) internalFirstObject () ;
  }
//--- Get last object
  public : inline cElement * lastObject (void) const {
    return (cElement *) internalLastObject () ;
  }
//--- Operator () used for method call
  public : const GGS_lexicalImplicitRuleList * operator () (UNUSED_LOCATION_ARGS) const { return this ;} 
//--- Method 'first'
  public : void method_first (C_Compiler & inLexique,
                              GGS_lstring & _out_0
                              COMMA_LOCATION_ARGS) const ;
//--- Method 'last'
  public : void method_last (C_Compiler & inLexique,
                             GGS_lstring & _out_0
                             COMMA_LOCATION_ARGS) const ;
//--- Modifier 'popLast'
  public : void modifier_popLast (C_Compiler & inLexique,
                                GGS_lstring & _out_0
                                COMMA_LOCATION_ARGS) ;
//--- Modifier 'popFirst'
  public : void modifier_popFirst (C_Compiler & inLexique,
                                 GGS_lstring & _out_0
                                 COMMA_LOCATION_ARGS) ;
//--- Handle '.=' operator
  public : void _dotAssign_operation (const GGS_lexicalImplicitRuleList inOperand) ;

//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lstring & argument_0) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalImplicitRuleList _operator_concat (const GGS_lexicalImplicitRuleList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & inLexique,
                                const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) ;

  protected : void _internalPrependValues (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--------------------------------- Direct Read Access
  public : GGS_lstring 
  reader_mListNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const ;

//--------------------------------- Direct Write Access
  public : void
  modifier_setMListNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const ;

//--------------------------------- List Enumerator
  public : class cEnumerator : public cAbstractListEnumerator {
  //--- Constructor
    public : inline cEnumerator (const GGS_lexicalImplicitRuleList & inList,
                                 const bool inAscending) :
    cAbstractListEnumerator (inList, inAscending) {
    }
  //--- Iterator method
    public : inline cElement * nextObject (void) {
      return (cElement *) internalNextObject () ;
    }
  public : /* const */ GGS_lstring   & _mListName (LOCATION_ARGS) const ;
  } ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                list '@lexicalErrorMessageDeclarationList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_lexicalErrorMessageDeclarationList ;

class GGS_lexicalErrorMessageDeclarationList : public AC_galgas_list {
  public : typedef elementOf_GGS_lexicalErrorMessageDeclarationList cElement ;

//--- Constructor 'emptyList'
  public : static GGS_lexicalErrorMessageDeclarationList constructor_emptyList (void) ;
  public : static GGS_lexicalErrorMessageDeclarationList constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) ;
//--- Get sublist
  protected : void
  internalSubListWithRange (GGS_lexicalErrorMessageDeclarationList & ioList,
                            const sint32 inFirstIndex,
                            const sint32 inCount) const ;

  public : GGS_lexicalErrorMessageDeclarationList
  reader_subListWithRange (C_Compiler & inLexique,
                           const GGS_uint & inFirstIndex,
                           const GGS_uint & inCount
                           COMMA_LOCATION_ARGS) const ;

  public : GGS_lexicalErrorMessageDeclarationList
  reader_subListFromIndex (C_Compiler & inLexique,
                           const GGS_uint & inIndex
                           COMMA_LOCATION_ARGS) const ;

//--- Get first object
  public : inline cElement * firstObject (void) const {
    return (cElement *) internalFirstObject () ;
  }
//--- Get last object
  public : inline cElement * lastObject (void) const {
    return (cElement *) internalLastObject () ;
  }
//--- Operator () used for method call
  public : const GGS_lexicalErrorMessageDeclarationList * operator () (UNUSED_LOCATION_ARGS) const { return this ;} 
//--- Method 'first'
  public : void method_first (C_Compiler & inLexique,
                              GGS_lstring & _out_0,
                              GGS_lstring & _out_1
                              COMMA_LOCATION_ARGS) const ;
//--- Method 'last'
  public : void method_last (C_Compiler & inLexique,
                             GGS_lstring & _out_0,
                             GGS_lstring & _out_1
                             COMMA_LOCATION_ARGS) const ;
//--- Modifier 'popLast'
  public : void modifier_popLast (C_Compiler & inLexique,
                                GGS_lstring & _out_0,
                                GGS_lstring & _out_1
                                COMMA_LOCATION_ARGS) ;
//--- Modifier 'popFirst'
  public : void modifier_popFirst (C_Compiler & inLexique,
                                 GGS_lstring & _out_0,
                                 GGS_lstring & _out_1
                                 COMMA_LOCATION_ARGS) ;
//--- Handle '.=' operator
  public : void _dotAssign_operation (const GGS_lexicalErrorMessageDeclarationList inOperand) ;

//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalErrorMessageDeclarationList _operator_concat (const GGS_lexicalErrorMessageDeclarationList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) ;

  protected : void _internalPrependValues (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--------------------------------- Direct Read Access
  public : GGS_lstring 
  reader_mMessageNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const ;
  public : GGS_lstring 
  reader_mMessageValueAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const ;

//--------------------------------- Direct Write Access
  public : void
  modifier_setMMessageNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const ;
  public : void
  modifier_setMMessageValueAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const ;

//--------------------------------- List Enumerator
  public : class cEnumerator : public cAbstractListEnumerator {
  //--- Constructor
    public : inline cEnumerator (const GGS_lexicalErrorMessageDeclarationList & inList,
                                 const bool inAscending) :
    cAbstractListEnumerator (inList, inAscending) {
    }
  //--- Iterator method
    public : inline cElement * nextObject (void) {
      return (cElement *) internalNextObject () ;
    }
  public : /* const */ GGS_lstring   & _mMessageName (LOCATION_ARGS) const ;
  public : /* const */ GGS_lstring   & _mMessageValue (LOCATION_ARGS) const ;
  } ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       list '@lexicalAttributeList'                        *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_lexicalAttributeList ;

class GGS_lexicalAttributeList : public AC_galgas_list {
  public : typedef elementOf_GGS_lexicalAttributeList cElement ;

//--- Constructor 'emptyList'
  public : static GGS_lexicalAttributeList constructor_emptyList (void) ;
  public : static GGS_lexicalAttributeList constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) ;
//--- Get sublist
  protected : void
  internalSubListWithRange (GGS_lexicalAttributeList & ioList,
                            const sint32 inFirstIndex,
                            const sint32 inCount) const ;

  public : GGS_lexicalAttributeList
  reader_subListWithRange (C_Compiler & inLexique,
                           const GGS_uint & inFirstIndex,
                           const GGS_uint & inCount
                           COMMA_LOCATION_ARGS) const ;

  public : GGS_lexicalAttributeList
  reader_subListFromIndex (C_Compiler & inLexique,
                           const GGS_uint & inIndex
                           COMMA_LOCATION_ARGS) const ;

//--- Get first object
  public : inline cElement * firstObject (void) const {
    return (cElement *) internalFirstObject () ;
  }
//--- Get last object
  public : inline cElement * lastObject (void) const {
    return (cElement *) internalLastObject () ;
  }
//--- Operator () used for method call
  public : const GGS_lexicalAttributeList * operator () (UNUSED_LOCATION_ARGS) const { return this ;} 
//--- Method 'first'
  public : void method_first (C_Compiler & inLexique,
                              GGS_lstring & _out_0,
                              GGS_lstring & _out_1
                              COMMA_LOCATION_ARGS) const ;
//--- Method 'last'
  public : void method_last (C_Compiler & inLexique,
                             GGS_lstring & _out_0,
                             GGS_lstring & _out_1
                             COMMA_LOCATION_ARGS) const ;
//--- Modifier 'popLast'
  public : void modifier_popLast (C_Compiler & inLexique,
                                GGS_lstring & _out_0,
                                GGS_lstring & _out_1
                                COMMA_LOCATION_ARGS) ;
//--- Modifier 'popFirst'
  public : void modifier_popFirst (C_Compiler & inLexique,
                                 GGS_lstring & _out_0,
                                 GGS_lstring & _out_1
                                 COMMA_LOCATION_ARGS) ;
//--- Handle '.=' operator
  public : void _dotAssign_operation (const GGS_lexicalAttributeList inOperand) ;

//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalAttributeList _operator_concat (const GGS_lexicalAttributeList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) ;

  protected : void _internalPrependValues (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--------------------------------- Direct Read Access
  public : GGS_lstring 
  reader_mTypeNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const ;
  public : GGS_lstring 
  reader_mNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const ;

//--------------------------------- Direct Write Access
  public : void
  modifier_setMTypeNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const ;
  public : void
  modifier_setMNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const ;

//--------------------------------- List Enumerator
  public : class cEnumerator : public cAbstractListEnumerator {
  //--- Constructor
    public : inline cEnumerator (const GGS_lexicalAttributeList & inList,
                                 const bool inAscending) :
    cAbstractListEnumerator (inList, inAscending) {
    }
  //--- Iterator method
    public : inline cElement * nextObject (void) {
      return (cElement *) internalNextObject () ;
    }
  public : /* const */ GGS_lstring   & _mTypeName (LOCATION_ARGS) const ;
  public : /* const */ GGS_lstring   & _mName (LOCATION_ARGS) const ;
  } ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         list '@lexicalStyleList'                          *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_lexicalStyleList ;

class GGS_lexicalStyleList : public AC_galgas_list {
  public : typedef elementOf_GGS_lexicalStyleList cElement ;

//--- Constructor 'emptyList'
  public : static GGS_lexicalStyleList constructor_emptyList (void) ;
  public : static GGS_lexicalStyleList constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) ;
//--- Get sublist
  protected : void
  internalSubListWithRange (GGS_lexicalStyleList & ioList,
                            const sint32 inFirstIndex,
                            const sint32 inCount) const ;

  public : GGS_lexicalStyleList
  reader_subListWithRange (C_Compiler & inLexique,
                           const GGS_uint & inFirstIndex,
                           const GGS_uint & inCount
                           COMMA_LOCATION_ARGS) const ;

  public : GGS_lexicalStyleList
  reader_subListFromIndex (C_Compiler & inLexique,
                           const GGS_uint & inIndex
                           COMMA_LOCATION_ARGS) const ;

//--- Get first object
  public : inline cElement * firstObject (void) const {
    return (cElement *) internalFirstObject () ;
  }
//--- Get last object
  public : inline cElement * lastObject (void) const {
    return (cElement *) internalLastObject () ;
  }
//--- Operator () used for method call
  public : const GGS_lexicalStyleList * operator () (UNUSED_LOCATION_ARGS) const { return this ;} 
//--- Method 'first'
  public : void method_first (C_Compiler & inLexique,
                              GGS_lstring & _out_0,
                              GGS_lstring & _out_1
                              COMMA_LOCATION_ARGS) const ;
//--- Method 'last'
  public : void method_last (C_Compiler & inLexique,
                             GGS_lstring & _out_0,
                             GGS_lstring & _out_1
                             COMMA_LOCATION_ARGS) const ;
//--- Modifier 'popLast'
  public : void modifier_popLast (C_Compiler & inLexique,
                                GGS_lstring & _out_0,
                                GGS_lstring & _out_1
                                COMMA_LOCATION_ARGS) ;
//--- Modifier 'popFirst'
  public : void modifier_popFirst (C_Compiler & inLexique,
                                 GGS_lstring & _out_0,
                                 GGS_lstring & _out_1
                                 COMMA_LOCATION_ARGS) ;
//--- Handle '.=' operator
  public : void _dotAssign_operation (const GGS_lexicalStyleList inOperand) ;

//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalStyleList _operator_concat (const GGS_lexicalStyleList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) ;

  protected : void _internalPrependValues (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--------------------------------- Direct Read Access
  public : GGS_lstring 
  reader_mNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const ;
  public : GGS_lstring 
  reader_mCommentAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const ;

//--------------------------------- Direct Write Access
  public : void
  modifier_setMNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const ;
  public : void
  modifier_setMCommentAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const ;

//--------------------------------- List Enumerator
  public : class cEnumerator : public cAbstractListEnumerator {
  //--- Constructor
    public : inline cEnumerator (const GGS_lexicalStyleList & inList,
                                 const bool inAscending) :
    cAbstractListEnumerator (inList, inAscending) {
    }
  //--- Iterator method
    public : inline cElement * nextObject (void) {
      return (cElement *) internalNextObject () ;
    }
  public : /* const */ GGS_lstring   & _mName (LOCATION_ARGS) const ;
  public : /* const */ GGS_lstring   & _mComment (LOCATION_ARGS) const ;
  } ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     list '@terminalDeclarationList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_terminalDeclarationList ;

class GGS_terminalDeclarationList : public AC_galgas_list {
  public : typedef elementOf_GGS_terminalDeclarationList cElement ;

//--- Constructor 'emptyList'
  public : static GGS_terminalDeclarationList constructor_emptyList (void) ;
  public : static GGS_terminalDeclarationList constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_lstringlist & argument_4) ;
//--- Get sublist
  protected : void
  internalSubListWithRange (GGS_terminalDeclarationList & ioList,
                            const sint32 inFirstIndex,
                            const sint32 inCount) const ;

  public : GGS_terminalDeclarationList
  reader_subListWithRange (C_Compiler & inLexique,
                           const GGS_uint & inFirstIndex,
                           const GGS_uint & inCount
                           COMMA_LOCATION_ARGS) const ;

  public : GGS_terminalDeclarationList
  reader_subListFromIndex (C_Compiler & inLexique,
                           const GGS_uint & inIndex
                           COMMA_LOCATION_ARGS) const ;

//--- Get first object
  public : inline cElement * firstObject (void) const {
    return (cElement *) internalFirstObject () ;
  }
//--- Get last object
  public : inline cElement * lastObject (void) const {
    return (cElement *) internalLastObject () ;
  }
//--- Operator () used for method call
  public : const GGS_terminalDeclarationList * operator () (UNUSED_LOCATION_ARGS) const { return this ;} 
//--- Method 'first'
  public : void method_first (C_Compiler & inLexique,
                              GGS_lstring & _out_0,
                              GGS_lstringlist & _out_1,
                              GGS_lstring & _out_2,
                              GGS_lstring & _out_3,
                              GGS_lstringlist & _out_4
                              COMMA_LOCATION_ARGS) const ;
//--- Method 'last'
  public : void method_last (C_Compiler & inLexique,
                             GGS_lstring & _out_0,
                             GGS_lstringlist & _out_1,
                             GGS_lstring & _out_2,
                             GGS_lstring & _out_3,
                             GGS_lstringlist & _out_4
                             COMMA_LOCATION_ARGS) const ;
//--- Modifier 'popLast'
  public : void modifier_popLast (C_Compiler & inLexique,
                                GGS_lstring & _out_0,
                                GGS_lstringlist & _out_1,
                                GGS_lstring & _out_2,
                                GGS_lstring & _out_3,
                                GGS_lstringlist & _out_4
                                COMMA_LOCATION_ARGS) ;
//--- Modifier 'popFirst'
  public : void modifier_popFirst (C_Compiler & inLexique,
                                 GGS_lstring & _out_0,
                                 GGS_lstringlist & _out_1,
                                 GGS_lstring & _out_2,
                                 GGS_lstring & _out_3,
                                 GGS_lstringlist & _out_4
                                 COMMA_LOCATION_ARGS) ;
//--- Handle '.=' operator
  public : void _dotAssign_operation (const GGS_terminalDeclarationList inOperand) ;

//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_lstringlist & argument_4) ;
//--- Handling '.' GALGAS operator
  public : GGS_terminalDeclarationList _operator_concat (const GGS_terminalDeclarationList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_lstringlist & argument_4
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lstring & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_lstringlist & argument_4
                                COMMA_LOCATION_ARGS) ;

  protected : void _internalPrependValues (const GGS_lstring & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_lstringlist & argument_4
                                COMMA_LOCATION_ARGS) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--------------------------------- Direct Read Access
  public : GGS_lstring 
  reader_mNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const ;
  public : GGS_lstringlist 
  reader_mSentAttributeListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const ;
  public : GGS_lstring 
  reader_mErrorMessageAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const ;
  public : GGS_lstring 
  reader_mStyleAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const ;
  public : GGS_lstringlist 
  reader_mOptionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const ;

//--------------------------------- Direct Write Access
  public : void
  modifier_setMNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const ;
  public : void
  modifier_setMSentAttributeListAtIndex (C_Compiler & inLexique,
                              const GGS_lstringlist  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const ;
  public : void
  modifier_setMErrorMessageAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const ;
  public : void
  modifier_setMStyleAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const ;
  public : void
  modifier_setMOptionListAtIndex (C_Compiler & inLexique,
                              const GGS_lstringlist  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const ;

//--------------------------------- List Enumerator
  public : class cEnumerator : public cAbstractListEnumerator {
  //--- Constructor
    public : inline cEnumerator (const GGS_terminalDeclarationList & inList,
                                 const bool inAscending) :
    cAbstractListEnumerator (inList, inAscending) {
    }
  //--- Iterator method
    public : inline cElement * nextObject (void) {
      return (cElement *) internalNextObject () ;
    }
  public : /* const */ GGS_lstring   & _mName (LOCATION_ARGS) const ;
  public : /* const */ GGS_lstringlist   & _mSentAttributeList (LOCATION_ARGS) const ;
  public : /* const */ GGS_lstring   & _mErrorMessage (LOCATION_ARGS) const ;
  public : /* const */ GGS_lstring   & _mStyle (LOCATION_ARGS) const ;
  public : /* const */ GGS_lstringlist   & _mOptionList (LOCATION_ARGS) const ;
  } ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       list '@lexicalListEntryList'                        *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_lexicalListEntryList ;

class GGS_lexicalListEntryList : public AC_galgas_list {
  public : typedef elementOf_GGS_lexicalListEntryList cElement ;

//--- Constructor 'emptyList'
  public : static GGS_lexicalListEntryList constructor_emptyList (void) ;
  public : static GGS_lexicalListEntryList constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstringlist & argument_2) ;
//--- Get sublist
  protected : void
  internalSubListWithRange (GGS_lexicalListEntryList & ioList,
                            const sint32 inFirstIndex,
                            const sint32 inCount) const ;

  public : GGS_lexicalListEntryList
  reader_subListWithRange (C_Compiler & inLexique,
                           const GGS_uint & inFirstIndex,
                           const GGS_uint & inCount
                           COMMA_LOCATION_ARGS) const ;

  public : GGS_lexicalListEntryList
  reader_subListFromIndex (C_Compiler & inLexique,
                           const GGS_uint & inIndex
                           COMMA_LOCATION_ARGS) const ;

//--- Get first object
  public : inline cElement * firstObject (void) const {
    return (cElement *) internalFirstObject () ;
  }
//--- Get last object
  public : inline cElement * lastObject (void) const {
    return (cElement *) internalLastObject () ;
  }
//--- Operator () used for method call
  public : const GGS_lexicalListEntryList * operator () (UNUSED_LOCATION_ARGS) const { return this ;} 
//--- Method 'first'
  public : void method_first (C_Compiler & inLexique,
                              GGS_lstring & _out_0,
                              GGS_lstring & _out_1,
                              GGS_lstringlist & _out_2
                              COMMA_LOCATION_ARGS) const ;
//--- Method 'last'
  public : void method_last (C_Compiler & inLexique,
                             GGS_lstring & _out_0,
                             GGS_lstring & _out_1,
                             GGS_lstringlist & _out_2
                             COMMA_LOCATION_ARGS) const ;
//--- Modifier 'popLast'
  public : void modifier_popLast (C_Compiler & inLexique,
                                GGS_lstring & _out_0,
                                GGS_lstring & _out_1,
                                GGS_lstringlist & _out_2
                                COMMA_LOCATION_ARGS) ;
//--- Modifier 'popFirst'
  public : void modifier_popFirst (C_Compiler & inLexique,
                                 GGS_lstring & _out_0,
                                 GGS_lstring & _out_1,
                                 GGS_lstringlist & _out_2
                                 COMMA_LOCATION_ARGS) ;
//--- Handle '.=' operator
  public : void _dotAssign_operation (const GGS_lexicalListEntryList inOperand) ;

//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstringlist & argument_2) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalListEntryList _operator_concat (const GGS_lexicalListEntryList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstringlist & argument_2
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstringlist & argument_2
                                COMMA_LOCATION_ARGS) ;

  protected : void _internalPrependValues (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstringlist & argument_2
                                COMMA_LOCATION_ARGS) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--------------------------------- Direct Read Access
  public : GGS_lstring 
  reader_mEntrySpellingAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const ;
  public : GGS_lstring 
  reader_mTerminalSpellingAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const ;
  public : GGS_lstringlist 
  reader_mOptionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const ;

//--------------------------------- Direct Write Access
  public : void
  modifier_setMEntrySpellingAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const ;
  public : void
  modifier_setMTerminalSpellingAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const ;
  public : void
  modifier_setMOptionListAtIndex (C_Compiler & inLexique,
                              const GGS_lstringlist  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const ;

//--------------------------------- List Enumerator
  public : class cEnumerator : public cAbstractListEnumerator {
  //--- Constructor
    public : inline cEnumerator (const GGS_lexicalListEntryList & inList,
                                 const bool inAscending) :
    cAbstractListEnumerator (inList, inAscending) {
    }
  //--- Iterator method
    public : inline cElement * nextObject (void) {
      return (cElement *) internalNextObject () ;
    }
  public : /* const */ GGS_lstring   & _mEntrySpelling (LOCATION_ARGS) const ;
  public : /* const */ GGS_lstring   & _mTerminalSpelling (LOCATION_ARGS) const ;
  public : /* const */ GGS_lstringlist   & _mOptionList (LOCATION_ARGS) const ;
  } ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    list '@lexicalListDeclarationList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_lexicalListDeclarationList ;

class GGS_lexicalListDeclarationList : public AC_galgas_list {
  public : typedef elementOf_GGS_lexicalListDeclarationList cElement ;

//--- Constructor 'emptyList'
  public : static GGS_lexicalListDeclarationList constructor_emptyList (void) ;
  public : static GGS_lexicalListDeclarationList constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstringlist & argument_3,
                                const GGS_lexicalListEntryList & argument_4) ;
//--- Get sublist
  protected : void
  internalSubListWithRange (GGS_lexicalListDeclarationList & ioList,
                            const sint32 inFirstIndex,
                            const sint32 inCount) const ;

  public : GGS_lexicalListDeclarationList
  reader_subListWithRange (C_Compiler & inLexique,
                           const GGS_uint & inFirstIndex,
                           const GGS_uint & inCount
                           COMMA_LOCATION_ARGS) const ;

  public : GGS_lexicalListDeclarationList
  reader_subListFromIndex (C_Compiler & inLexique,
                           const GGS_uint & inIndex
                           COMMA_LOCATION_ARGS) const ;

//--- Get first object
  public : inline cElement * firstObject (void) const {
    return (cElement *) internalFirstObject () ;
  }
//--- Get last object
  public : inline cElement * lastObject (void) const {
    return (cElement *) internalLastObject () ;
  }
//--- Operator () used for method call
  public : const GGS_lexicalListDeclarationList * operator () (UNUSED_LOCATION_ARGS) const { return this ;} 
//--- Method 'first'
  public : void method_first (C_Compiler & inLexique,
                              GGS_lstring & _out_0,
                              GGS_lstring & _out_1,
                              GGS_lstring & _out_2,
                              GGS_lstringlist & _out_3,
                              GGS_lexicalListEntryList & _out_4
                              COMMA_LOCATION_ARGS) const ;
//--- Method 'last'
  public : void method_last (C_Compiler & inLexique,
                             GGS_lstring & _out_0,
                             GGS_lstring & _out_1,
                             GGS_lstring & _out_2,
                             GGS_lstringlist & _out_3,
                             GGS_lexicalListEntryList & _out_4
                             COMMA_LOCATION_ARGS) const ;
//--- Modifier 'popLast'
  public : void modifier_popLast (C_Compiler & inLexique,
                                GGS_lstring & _out_0,
                                GGS_lstring & _out_1,
                                GGS_lstring & _out_2,
                                GGS_lstringlist & _out_3,
                                GGS_lexicalListEntryList & _out_4
                                COMMA_LOCATION_ARGS) ;
//--- Modifier 'popFirst'
  public : void modifier_popFirst (C_Compiler & inLexique,
                                 GGS_lstring & _out_0,
                                 GGS_lstring & _out_1,
                                 GGS_lstring & _out_2,
                                 GGS_lstringlist & _out_3,
                                 GGS_lexicalListEntryList & _out_4
                                 COMMA_LOCATION_ARGS) ;
//--- Handle '.=' operator
  public : void _dotAssign_operation (const GGS_lexicalListDeclarationList inOperand) ;

//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstringlist & argument_3,
                                const GGS_lexicalListEntryList & argument_4) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalListDeclarationList _operator_concat (const GGS_lexicalListDeclarationList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstringlist & argument_3,
                                const GGS_lexicalListEntryList & argument_4
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstringlist & argument_3,
                                const GGS_lexicalListEntryList & argument_4
                                COMMA_LOCATION_ARGS) ;

  protected : void _internalPrependValues (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstringlist & argument_3,
                                const GGS_lexicalListEntryList & argument_4
                                COMMA_LOCATION_ARGS) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--------------------------------- Direct Read Access
  public : GGS_lstring 
  reader_mNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const ;
  public : GGS_lstring 
  reader_mStyleAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const ;
  public : GGS_lstring 
  reader_mErrorMessageAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const ;
  public : GGS_lstringlist 
  reader_mSentAttributeListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const ;
  public : GGS_lexicalListEntryList 
  reader_mEntryListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const ;

//--------------------------------- Direct Write Access
  public : void
  modifier_setMNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const ;
  public : void
  modifier_setMStyleAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const ;
  public : void
  modifier_setMErrorMessageAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const ;
  public : void
  modifier_setMSentAttributeListAtIndex (C_Compiler & inLexique,
                              const GGS_lstringlist  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const ;
  public : void
  modifier_setMEntryListAtIndex (C_Compiler & inLexique,
                              const GGS_lexicalListEntryList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const ;

//--------------------------------- List Enumerator
  public : class cEnumerator : public cAbstractListEnumerator {
  //--- Constructor
    public : inline cEnumerator (const GGS_lexicalListDeclarationList & inList,
                                 const bool inAscending) :
    cAbstractListEnumerator (inList, inAscending) {
    }
  //--- Iterator method
    public : inline cElement * nextObject (void) {
      return (cElement *) internalNextObject () ;
    }
  public : /* const */ GGS_lstring   & _mName (LOCATION_ARGS) const ;
  public : /* const */ GGS_lstring   & _mStyle (LOCATION_ARGS) const ;
  public : /* const */ GGS_lstring   & _mErrorMessage (LOCATION_ARGS) const ;
  public : /* const */ GGS_lstringlist   & _mSentAttributeList (LOCATION_ARGS) const ;
  public : /* const */ GGS_lexicalListEntryList   & _mEntryList (LOCATION_ARGS) const ;
  } ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_lexicalExpression'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalExpression : public AC_galgas_class {
//--- Default constructor
  public : inline GGS_lexicalExpression (void) :
  AC_galgas_class () {}

//--- Pointer assignment constructor
  public : GGS_lexicalExpression (cPtr__AC_galgas_class * inPointer) ;

//--- Object assignment constructor
  public : GGS_lexicalExpression (cPtr__AC_galgas_class & inObject) ;

//--- _castFrom class method (implements cast expression)
  public : static GGS_lexicalExpression
  _castFrom (C_Compiler & inLexique,
             cPtr__AC_galgas_class * inPointer,
             const bool inUseKindOfClass,
             const GGS_location & inErrorLocation
             COMMA_LOCATION_ARGS) ;

//--- getPtr
  public : inline cPtr_lexicalExpression * getPtr (void) const {
    return (cPtr_lexicalExpression *) mPointer ;
  }

//--- 'description' reader
  public : virtual const char * actualTypeName (void) const ;

//--- Readers

//--- Modifiers

//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalExpression * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalExpression * operator () (LOCATION_ARGS) const {
      return (cPtr_lexicalExpression *) mPointer ;
    }
  #endif

//--- Galgas RTTI
AC_galgasClassRunTimeInformation * _galgasObjectRunTimeInfo (void) const ;

} ;

//---------------------------------------------------------------------------*

extern C_galgasRootClassRunTimeInformation gClassInfoFor__lexicalExpression ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     list '@lexicalExplicitRuleList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_lexicalExplicitRuleList ;

class GGS_lexicalExplicitRuleList : public AC_galgas_list {
  public : typedef elementOf_GGS_lexicalExplicitRuleList cElement ;

//--- Constructor 'emptyList'
  public : static GGS_lexicalExplicitRuleList constructor_emptyList (void) ;
  public : static GGS_lexicalExplicitRuleList constructor_listWithValue (const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalInstructionList & argument_1) ;
//--- Get sublist
  protected : void
  internalSubListWithRange (GGS_lexicalExplicitRuleList & ioList,
                            const sint32 inFirstIndex,
                            const sint32 inCount) const ;

  public : GGS_lexicalExplicitRuleList
  reader_subListWithRange (C_Compiler & inLexique,
                           const GGS_uint & inFirstIndex,
                           const GGS_uint & inCount
                           COMMA_LOCATION_ARGS) const ;

  public : GGS_lexicalExplicitRuleList
  reader_subListFromIndex (C_Compiler & inLexique,
                           const GGS_uint & inIndex
                           COMMA_LOCATION_ARGS) const ;

//--- Get first object
  public : inline cElement * firstObject (void) const {
    return (cElement *) internalFirstObject () ;
  }
//--- Get last object
  public : inline cElement * lastObject (void) const {
    return (cElement *) internalLastObject () ;
  }
//--- Operator () used for method call
  public : const GGS_lexicalExplicitRuleList * operator () (UNUSED_LOCATION_ARGS) const { return this ;} 
//--- Method 'first'
  public : void method_first (C_Compiler & inLexique,
                              GGS_lexicalExpression & _out_0,
                              GGS_lexicalInstructionList & _out_1
                              COMMA_LOCATION_ARGS) const ;
//--- Method 'last'
  public : void method_last (C_Compiler & inLexique,
                             GGS_lexicalExpression & _out_0,
                             GGS_lexicalInstructionList & _out_1
                             COMMA_LOCATION_ARGS) const ;
//--- Modifier 'popLast'
  public : void modifier_popLast (C_Compiler & inLexique,
                                GGS_lexicalExpression & _out_0,
                                GGS_lexicalInstructionList & _out_1
                                COMMA_LOCATION_ARGS) ;
//--- Modifier 'popFirst'
  public : void modifier_popFirst (C_Compiler & inLexique,
                                 GGS_lexicalExpression & _out_0,
                                 GGS_lexicalInstructionList & _out_1
                                 COMMA_LOCATION_ARGS) ;
//--- Handle '.=' operator
  public : void _dotAssign_operation (const GGS_lexicalExplicitRuleList inOperand) ;

//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalInstructionList & argument_1) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalExplicitRuleList _operator_concat (const GGS_lexicalExplicitRuleList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & inLexique,
                                const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalInstructionList & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalInstructionList & argument_1
                                COMMA_LOCATION_ARGS) ;

  protected : void _internalPrependValues (const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalInstructionList & argument_1
                                COMMA_LOCATION_ARGS) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--------------------------------- Direct Read Access
  public : GGS_lexicalExpression 
  reader_mLexicalRuleExpressionAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const ;
  public : GGS_lexicalInstructionList 
  reader_mInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const ;

//--------------------------------- Direct Write Access
  public : void
  modifier_setMLexicalRuleExpressionAtIndex (C_Compiler & inLexique,
                              const GGS_lexicalExpression  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const ;
  public : void
  modifier_setMInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_lexicalInstructionList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const ;

//--------------------------------- List Enumerator
  public : class cEnumerator : public cAbstractListEnumerator {
  //--- Constructor
    public : inline cEnumerator (const GGS_lexicalExplicitRuleList & inList,
                                 const bool inAscending) :
    cAbstractListEnumerator (inList, inAscending) {
    }
  //--- Iterator method
    public : inline cElement * nextObject (void) {
      return (cElement *) internalNextObject () ;
    }
  public : /* const */ GGS_lexicalExpression   & _mLexicalRuleExpression (LOCATION_ARGS) const ;
  public : /* const */ GGS_lexicalInstructionList   & _mInstructionList (LOCATION_ARGS) const ;
  } ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_lexicalOrExpression'                   *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalOrExpression : public GGS_lexicalExpression {
//--- Default constructor
  public : inline GGS_lexicalOrExpression (void) :
  GGS_lexicalExpression () {}

//--- Pointer assignment constructor
  public : GGS_lexicalOrExpression (cPtr__AC_galgas_class * inPointer) ;

//--- Object assignment constructor
  public : GGS_lexicalOrExpression (cPtr__AC_galgas_class & inObject) ;

//--- _castFrom class method (implements cast expression)
  public : static GGS_lexicalOrExpression
  _castFrom (C_Compiler & inLexique,
             cPtr__AC_galgas_class * inPointer,
             const bool inUseKindOfClass,
             const GGS_location & inErrorLocation
             COMMA_LOCATION_ARGS) ;

//--- 'new' constructor
  public : static GGS_lexicalOrExpression constructor_new (C_Compiler & inLexique,
                                const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalExpression & argument_1
                                COMMA_LOCATION_ARGS) ;

//--- getPtr
  public : inline cPtr_lexicalOrExpression * getPtr (void) const {
    return (cPtr_lexicalOrExpression *) mPointer ;
  }

//--- 'description' reader
  public : virtual const char * actualTypeName (void) const ;

//--- Readers
  public : GGS_lexicalExpression  reader_mLeftOperand (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_lexicalExpression  reader_mRightOperand (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;

//--- Modifiers

//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalOrExpression * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalOrExpression * operator () (LOCATION_ARGS) const {
      return (cPtr_lexicalOrExpression *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*

extern C_galgasClassRunTimeInformation gClassInfoFor__lexicalOrExpression ;

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_lexicalCharacterSetMatch'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalCharacterSetMatch : public GGS_lexicalExpression {
//--- Default constructor
  public : inline GGS_lexicalCharacterSetMatch (void) :
  GGS_lexicalExpression () {}

//--- Pointer assignment constructor
  public : GGS_lexicalCharacterSetMatch (cPtr__AC_galgas_class * inPointer) ;

//--- Object assignment constructor
  public : GGS_lexicalCharacterSetMatch (cPtr__AC_galgas_class & inObject) ;

//--- _castFrom class method (implements cast expression)
  public : static GGS_lexicalCharacterSetMatch
  _castFrom (C_Compiler & inLexique,
             cPtr__AC_galgas_class * inPointer,
             const bool inUseKindOfClass,
             const GGS_location & inErrorLocation
             COMMA_LOCATION_ARGS) ;

//--- 'new' constructor
  public : static GGS_lexicalCharacterSetMatch constructor_new (C_Compiler & inLexique,
                                const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) ;

//--- getPtr
  public : inline cPtr_lexicalCharacterSetMatch * getPtr (void) const {
    return (cPtr_lexicalCharacterSetMatch *) mPointer ;
  }

//--- 'description' reader
  public : virtual const char * actualTypeName (void) const ;

//--- Readers
  public : GGS_lstring  reader_mCharacterSetName (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;

//--- Modifiers

//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalCharacterSetMatch * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalCharacterSetMatch * operator () (LOCATION_ARGS) const {
      return (cPtr_lexicalCharacterSetMatch *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*

extern C_galgasClassRunTimeInformation gClassInfoFor__lexicalCharacterSetMatch ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_lexicalCharacterMatch'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalCharacterMatch : public GGS_lexicalExpression {
//--- Default constructor
  public : inline GGS_lexicalCharacterMatch (void) :
  GGS_lexicalExpression () {}

//--- Pointer assignment constructor
  public : GGS_lexicalCharacterMatch (cPtr__AC_galgas_class * inPointer) ;

//--- Object assignment constructor
  public : GGS_lexicalCharacterMatch (cPtr__AC_galgas_class & inObject) ;

//--- _castFrom class method (implements cast expression)
  public : static GGS_lexicalCharacterMatch
  _castFrom (C_Compiler & inLexique,
             cPtr__AC_galgas_class * inPointer,
             const bool inUseKindOfClass,
             const GGS_location & inErrorLocation
             COMMA_LOCATION_ARGS) ;

//--- 'new' constructor
  public : static GGS_lexicalCharacterMatch constructor_new (C_Compiler & inLexique,
                                const GGS_lchar & argument_0
                                COMMA_LOCATION_ARGS) ;

//--- getPtr
  public : inline cPtr_lexicalCharacterMatch * getPtr (void) const {
    return (cPtr_lexicalCharacterMatch *) mPointer ;
  }

//--- 'description' reader
  public : virtual const char * actualTypeName (void) const ;

//--- Readers
  public : GGS_lchar  reader_mCharacter (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;

//--- Modifiers

//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalCharacterMatch * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalCharacterMatch * operator () (LOCATION_ARGS) const {
      return (cPtr_lexicalCharacterMatch *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*

extern C_galgasClassRunTimeInformation gClassInfoFor__lexicalCharacterMatch ;

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_lexicalCharacterIntervalMatch'              *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalCharacterIntervalMatch : public GGS_lexicalExpression {
//--- Default constructor
  public : inline GGS_lexicalCharacterIntervalMatch (void) :
  GGS_lexicalExpression () {}

//--- Pointer assignment constructor
  public : GGS_lexicalCharacterIntervalMatch (cPtr__AC_galgas_class * inPointer) ;

//--- Object assignment constructor
  public : GGS_lexicalCharacterIntervalMatch (cPtr__AC_galgas_class & inObject) ;

//--- _castFrom class method (implements cast expression)
  public : static GGS_lexicalCharacterIntervalMatch
  _castFrom (C_Compiler & inLexique,
             cPtr__AC_galgas_class * inPointer,
             const bool inUseKindOfClass,
             const GGS_location & inErrorLocation
             COMMA_LOCATION_ARGS) ;

//--- 'new' constructor
  public : static GGS_lexicalCharacterIntervalMatch constructor_new (C_Compiler & inLexique,
                                const GGS_lchar & argument_0,
                                const GGS_lchar & argument_1
                                COMMA_LOCATION_ARGS) ;

//--- getPtr
  public : inline cPtr_lexicalCharacterIntervalMatch * getPtr (void) const {
    return (cPtr_lexicalCharacterIntervalMatch *) mPointer ;
  }

//--- 'description' reader
  public : virtual const char * actualTypeName (void) const ;

//--- Readers
  public : GGS_lchar  reader_mLowerBound (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_lchar  reader_mUpperBound (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;

//--- Modifiers

//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalCharacterIntervalMatch * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalCharacterIntervalMatch * operator () (LOCATION_ARGS) const {
      return (cPtr_lexicalCharacterIntervalMatch *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*

extern C_galgasClassRunTimeInformation gClassInfoFor__lexicalCharacterIntervalMatch ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_lexicalStringMatch'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalStringMatch : public GGS_lexicalExpression {
//--- Default constructor
  public : inline GGS_lexicalStringMatch (void) :
  GGS_lexicalExpression () {}

//--- Pointer assignment constructor
  public : GGS_lexicalStringMatch (cPtr__AC_galgas_class * inPointer) ;

//--- Object assignment constructor
  public : GGS_lexicalStringMatch (cPtr__AC_galgas_class & inObject) ;

//--- _castFrom class method (implements cast expression)
  public : static GGS_lexicalStringMatch
  _castFrom (C_Compiler & inLexique,
             cPtr__AC_galgas_class * inPointer,
             const bool inUseKindOfClass,
             const GGS_location & inErrorLocation
             COMMA_LOCATION_ARGS) ;

//--- 'new' constructor
  public : static GGS_lexicalStringMatch constructor_new (C_Compiler & inLexique,
                                const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) ;

//--- getPtr
  public : inline cPtr_lexicalStringMatch * getPtr (void) const {
    return (cPtr_lexicalStringMatch *) mPointer ;
  }

//--- 'description' reader
  public : virtual const char * actualTypeName (void) const ;

//--- Readers
  public : GGS_lstring  reader_mString (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;

//--- Modifiers

//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalStringMatch * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalStringMatch * operator () (LOCATION_ARGS) const {
      return (cPtr_lexicalStringMatch *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*

extern C_galgasClassRunTimeInformation gClassInfoFor__lexicalStringMatch ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_lexicalStringNotMatch'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalStringNotMatch : public GGS_lexicalExpression {
//--- Default constructor
  public : inline GGS_lexicalStringNotMatch (void) :
  GGS_lexicalExpression () {}

//--- Pointer assignment constructor
  public : GGS_lexicalStringNotMatch (cPtr__AC_galgas_class * inPointer) ;

//--- Object assignment constructor
  public : GGS_lexicalStringNotMatch (cPtr__AC_galgas_class & inObject) ;

//--- _castFrom class method (implements cast expression)
  public : static GGS_lexicalStringNotMatch
  _castFrom (C_Compiler & inLexique,
             cPtr__AC_galgas_class * inPointer,
             const bool inUseKindOfClass,
             const GGS_location & inErrorLocation
             COMMA_LOCATION_ARGS) ;

//--- 'new' constructor
  public : static GGS_lexicalStringNotMatch constructor_new (C_Compiler & inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) ;

//--- getPtr
  public : inline cPtr_lexicalStringNotMatch * getPtr (void) const {
    return (cPtr_lexicalStringNotMatch *) mPointer ;
  }

//--- 'description' reader
  public : virtual const char * actualTypeName (void) const ;

//--- Readers
  public : GGS_lstring  reader_mString (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_lstring  reader_mErrorMessage (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;

//--- Modifiers

//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalStringNotMatch * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalStringNotMatch * operator () (LOCATION_ARGS) const {
      return (cPtr_lexicalStringNotMatch *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*

extern C_galgasClassRunTimeInformation gClassInfoFor__lexicalStringNotMatch ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_lexicalInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalInstruction : public AC_galgas_class {
//--- Default constructor
  public : inline GGS_lexicalInstruction (void) :
  AC_galgas_class () {}

//--- Pointer assignment constructor
  public : GGS_lexicalInstruction (cPtr__AC_galgas_class * inPointer) ;

//--- Object assignment constructor
  public : GGS_lexicalInstruction (cPtr__AC_galgas_class & inObject) ;

//--- _castFrom class method (implements cast expression)
  public : static GGS_lexicalInstruction
  _castFrom (C_Compiler & inLexique,
             cPtr__AC_galgas_class * inPointer,
             const bool inUseKindOfClass,
             const GGS_location & inErrorLocation
             COMMA_LOCATION_ARGS) ;

//--- getPtr
  public : inline cPtr_lexicalInstruction * getPtr (void) const {
    return (cPtr_lexicalInstruction *) mPointer ;
  }

//--- 'description' reader
  public : virtual const char * actualTypeName (void) const ;

//--- Readers

//--- Modifiers

//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalInstruction * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalInstruction * operator () (LOCATION_ARGS) const {
      return (cPtr_lexicalInstruction *) mPointer ;
    }
  #endif

//--- Galgas RTTI
AC_galgasClassRunTimeInformation * _galgasObjectRunTimeInfo (void) const ;

} ;

//---------------------------------------------------------------------------*

extern C_galgasRootClassRunTimeInformation gClassInfoFor__lexicalInstruction ;

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_lexicalSendDefaultAction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalSendDefaultAction : public AC_galgas_class {
//--- Default constructor
  public : inline GGS_lexicalSendDefaultAction (void) :
  AC_galgas_class () {}

//--- Pointer assignment constructor
  public : GGS_lexicalSendDefaultAction (cPtr__AC_galgas_class * inPointer) ;

//--- Object assignment constructor
  public : GGS_lexicalSendDefaultAction (cPtr__AC_galgas_class & inObject) ;

//--- _castFrom class method (implements cast expression)
  public : static GGS_lexicalSendDefaultAction
  _castFrom (C_Compiler & inLexique,
             cPtr__AC_galgas_class * inPointer,
             const bool inUseKindOfClass,
             const GGS_location & inErrorLocation
             COMMA_LOCATION_ARGS) ;

//--- getPtr
  public : inline cPtr_lexicalSendDefaultAction * getPtr (void) const {
    return (cPtr_lexicalSendDefaultAction *) mPointer ;
  }

//--- 'description' reader
  public : virtual const char * actualTypeName (void) const ;

//--- Readers

//--- Modifiers

//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalSendDefaultAction * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalSendDefaultAction * operator () (LOCATION_ARGS) const {
      return (cPtr_lexicalSendDefaultAction *) mPointer ;
    }
  #endif

//--- Galgas RTTI
AC_galgasClassRunTimeInformation * _galgasObjectRunTimeInfo (void) const ;

} ;

//---------------------------------------------------------------------------*

extern C_galgasRootClassRunTimeInformation gClassInfoFor__lexicalSendDefaultAction ;

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_lexicalStructuredSendInstruction'             *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalStructuredSendInstruction : public GGS_lexicalInstruction {
//--- Default constructor
  public : inline GGS_lexicalStructuredSendInstruction (void) :
  GGS_lexicalInstruction () {}

//--- Pointer assignment constructor
  public : GGS_lexicalStructuredSendInstruction (cPtr__AC_galgas_class * inPointer) ;

//--- Object assignment constructor
  public : GGS_lexicalStructuredSendInstruction (cPtr__AC_galgas_class & inObject) ;

//--- _castFrom class method (implements cast expression)
  public : static GGS_lexicalStructuredSendInstruction
  _castFrom (C_Compiler & inLexique,
             cPtr__AC_galgas_class * inPointer,
             const bool inUseKindOfClass,
             const GGS_location & inErrorLocation
             COMMA_LOCATION_ARGS) ;

//--- 'new' constructor
  public : static GGS_lexicalStructuredSendInstruction constructor_new (C_Compiler & inLexique,
                                const GGS_lexicalSendSearchList & argument_0,
                                const GGS_lexicalSendDefaultAction & argument_1
                                COMMA_LOCATION_ARGS) ;

//--- getPtr
  public : inline cPtr_lexicalStructuredSendInstruction * getPtr (void) const {
    return (cPtr_lexicalStructuredSendInstruction *) mPointer ;
  }

//--- 'description' reader
  public : virtual const char * actualTypeName (void) const ;

//--- Readers
  public : GGS_lexicalSendSearchList  reader_mLexicalSendSearchList (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_lexicalSendDefaultAction  reader_mLexicalSendDefaultAction (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;

//--- Modifiers

//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalStructuredSendInstruction * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalStructuredSendInstruction * operator () (LOCATION_ARGS) const {
      return (cPtr_lexicalStructuredSendInstruction *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*

extern C_galgasClassRunTimeInformation gClassInfoFor__lexicalStructuredSendInstruction ;

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_lexicalSimpleSendInstruction'               *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalSimpleSendInstruction : public GGS_lexicalInstruction {
//--- Default constructor
  public : inline GGS_lexicalSimpleSendInstruction (void) :
  GGS_lexicalInstruction () {}

//--- Pointer assignment constructor
  public : GGS_lexicalSimpleSendInstruction (cPtr__AC_galgas_class * inPointer) ;

//--- Object assignment constructor
  public : GGS_lexicalSimpleSendInstruction (cPtr__AC_galgas_class & inObject) ;

//--- _castFrom class method (implements cast expression)
  public : static GGS_lexicalSimpleSendInstruction
  _castFrom (C_Compiler & inLexique,
             cPtr__AC_galgas_class * inPointer,
             const bool inUseKindOfClass,
             const GGS_location & inErrorLocation
             COMMA_LOCATION_ARGS) ;

//--- 'new' constructor
  public : static GGS_lexicalSimpleSendInstruction constructor_new (C_Compiler & inLexique,
                                const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) ;

//--- getPtr
  public : inline cPtr_lexicalSimpleSendInstruction * getPtr (void) const {
    return (cPtr_lexicalSimpleSendInstruction *) mPointer ;
  }

//--- 'description' reader
  public : virtual const char * actualTypeName (void) const ;

//--- Readers
  public : GGS_lstring  reader_mSentTerminal (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;

//--- Modifiers

//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalSimpleSendInstruction * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalSimpleSendInstruction * operator () (LOCATION_ARGS) const {
      return (cPtr_lexicalSimpleSendInstruction *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*

extern C_galgasClassRunTimeInformation gClassInfoFor__lexicalSimpleSendInstruction ;

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_lexicalSendTerminalByDefault'               *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalSendTerminalByDefault : public GGS_lexicalSendDefaultAction {
//--- Default constructor
  public : inline GGS_lexicalSendTerminalByDefault (void) :
  GGS_lexicalSendDefaultAction () {}

//--- Pointer assignment constructor
  public : GGS_lexicalSendTerminalByDefault (cPtr__AC_galgas_class * inPointer) ;

//--- Object assignment constructor
  public : GGS_lexicalSendTerminalByDefault (cPtr__AC_galgas_class & inObject) ;

//--- _castFrom class method (implements cast expression)
  public : static GGS_lexicalSendTerminalByDefault
  _castFrom (C_Compiler & inLexique,
             cPtr__AC_galgas_class * inPointer,
             const bool inUseKindOfClass,
             const GGS_location & inErrorLocation
             COMMA_LOCATION_ARGS) ;

//--- 'new' constructor
  public : static GGS_lexicalSendTerminalByDefault constructor_new (C_Compiler & inLexique,
                                const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) ;

//--- getPtr
  public : inline cPtr_lexicalSendTerminalByDefault * getPtr (void) const {
    return (cPtr_lexicalSendTerminalByDefault *) mPointer ;
  }

//--- 'description' reader
  public : virtual const char * actualTypeName (void) const ;

//--- Readers
  public : GGS_lstring  reader_mDefaultSentTerminal (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;

//--- Modifiers

//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalSendTerminalByDefault * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalSendTerminalByDefault * operator () (LOCATION_ARGS) const {
      return (cPtr_lexicalSendTerminalByDefault *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*

extern C_galgasClassRunTimeInformation gClassInfoFor__lexicalSendTerminalByDefault ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_lexicalErrorByDefault'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalErrorByDefault : public GGS_lexicalSendDefaultAction {
//--- Default constructor
  public : inline GGS_lexicalErrorByDefault (void) :
  GGS_lexicalSendDefaultAction () {}

//--- Pointer assignment constructor
  public : GGS_lexicalErrorByDefault (cPtr__AC_galgas_class * inPointer) ;

//--- Object assignment constructor
  public : GGS_lexicalErrorByDefault (cPtr__AC_galgas_class & inObject) ;

//--- _castFrom class method (implements cast expression)
  public : static GGS_lexicalErrorByDefault
  _castFrom (C_Compiler & inLexique,
             cPtr__AC_galgas_class * inPointer,
             const bool inUseKindOfClass,
             const GGS_location & inErrorLocation
             COMMA_LOCATION_ARGS) ;

//--- 'new' constructor
  public : static GGS_lexicalErrorByDefault constructor_new (C_Compiler & inLexique,
                                const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) ;

//--- getPtr
  public : inline cPtr_lexicalErrorByDefault * getPtr (void) const {
    return (cPtr_lexicalErrorByDefault *) mPointer ;
  }

//--- 'description' reader
  public : virtual const char * actualTypeName (void) const ;

//--- Readers
  public : GGS_lstring  reader_mDefaultErrorMessageName (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;

//--- Modifiers

//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalErrorByDefault * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalErrorByDefault * operator () (LOCATION_ARGS) const {
      return (cPtr_lexicalErrorByDefault *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*

extern C_galgasClassRunTimeInformation gClassInfoFor__lexicalErrorByDefault ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      list '@lexicalSendSearchList'                        *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_lexicalSendSearchList ;

class GGS_lexicalSendSearchList : public AC_galgas_list {
  public : typedef elementOf_GGS_lexicalSendSearchList cElement ;

//--- Constructor 'emptyList'
  public : static GGS_lexicalSendSearchList constructor_emptyList (void) ;
  public : static GGS_lexicalSendSearchList constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) ;
//--- Get sublist
  protected : void
  internalSubListWithRange (GGS_lexicalSendSearchList & ioList,
                            const sint32 inFirstIndex,
                            const sint32 inCount) const ;

  public : GGS_lexicalSendSearchList
  reader_subListWithRange (C_Compiler & inLexique,
                           const GGS_uint & inFirstIndex,
                           const GGS_uint & inCount
                           COMMA_LOCATION_ARGS) const ;

  public : GGS_lexicalSendSearchList
  reader_subListFromIndex (C_Compiler & inLexique,
                           const GGS_uint & inIndex
                           COMMA_LOCATION_ARGS) const ;

//--- Get first object
  public : inline cElement * firstObject (void) const {
    return (cElement *) internalFirstObject () ;
  }
//--- Get last object
  public : inline cElement * lastObject (void) const {
    return (cElement *) internalLastObject () ;
  }
//--- Operator () used for method call
  public : const GGS_lexicalSendSearchList * operator () (UNUSED_LOCATION_ARGS) const { return this ;} 
//--- Method 'first'
  public : void method_first (C_Compiler & inLexique,
                              GGS_lstring & _out_0,
                              GGS_lstring & _out_1
                              COMMA_LOCATION_ARGS) const ;
//--- Method 'last'
  public : void method_last (C_Compiler & inLexique,
                             GGS_lstring & _out_0,
                             GGS_lstring & _out_1
                             COMMA_LOCATION_ARGS) const ;
//--- Modifier 'popLast'
  public : void modifier_popLast (C_Compiler & inLexique,
                                GGS_lstring & _out_0,
                                GGS_lstring & _out_1
                                COMMA_LOCATION_ARGS) ;
//--- Modifier 'popFirst'
  public : void modifier_popFirst (C_Compiler & inLexique,
                                 GGS_lstring & _out_0,
                                 GGS_lstring & _out_1
                                 COMMA_LOCATION_ARGS) ;
//--- Handle '.=' operator
  public : void _dotAssign_operation (const GGS_lexicalSendSearchList inOperand) ;

//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalSendSearchList _operator_concat (const GGS_lexicalSendSearchList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) ;

  protected : void _internalPrependValues (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--------------------------------- Direct Read Access
  public : GGS_lstring 
  reader_mAttributeNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const ;
  public : GGS_lstring 
  reader_mSearchListNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const ;

//--------------------------------- Direct Write Access
  public : void
  modifier_setMAttributeNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const ;
  public : void
  modifier_setMSearchListNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const ;

//--------------------------------- List Enumerator
  public : class cEnumerator : public cAbstractListEnumerator {
  //--- Constructor
    public : inline cEnumerator (const GGS_lexicalSendSearchList & inList,
                                 const bool inAscending) :
    cAbstractListEnumerator (inList, inAscending) {
    }
  //--- Iterator method
    public : inline cElement * nextObject (void) {
      return (cElement *) internalNextObject () ;
    }
  public : /* const */ GGS_lstring   & _mAttributeName (LOCATION_ARGS) const ;
  public : /* const */ GGS_lstring   & _mSearchListName (LOCATION_ARGS) const ;
  } ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_lexicalRepeatInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalRepeatInstruction : public GGS_lexicalInstruction {
//--- Default constructor
  public : inline GGS_lexicalRepeatInstruction (void) :
  GGS_lexicalInstruction () {}

//--- Pointer assignment constructor
  public : GGS_lexicalRepeatInstruction (cPtr__AC_galgas_class * inPointer) ;

//--- Object assignment constructor
  public : GGS_lexicalRepeatInstruction (cPtr__AC_galgas_class & inObject) ;

//--- _castFrom class method (implements cast expression)
  public : static GGS_lexicalRepeatInstruction
  _castFrom (C_Compiler & inLexique,
             cPtr__AC_galgas_class * inPointer,
             const bool inUseKindOfClass,
             const GGS_location & inErrorLocation
             COMMA_LOCATION_ARGS) ;

//--- 'new' constructor
  public : static GGS_lexicalRepeatInstruction constructor_new (C_Compiler & inLexique,
                                const GGS_lexicalInstructionList & argument_0,
                                const GGS_lexicalWhileBranchList & argument_1
                                COMMA_LOCATION_ARGS) ;

//--- getPtr
  public : inline cPtr_lexicalRepeatInstruction * getPtr (void) const {
    return (cPtr_lexicalRepeatInstruction *) mPointer ;
  }

//--- 'description' reader
  public : virtual const char * actualTypeName (void) const ;

//--- Readers
  public : GGS_lexicalInstructionList  reader_mRepeatedInstructionList (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_lexicalWhileBranchList  reader_mLexicalWhileBranchList (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;

//--- Modifiers

//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalRepeatInstruction * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalRepeatInstruction * operator () (LOCATION_ARGS) const {
      return (cPtr_lexicalRepeatInstruction *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*

extern C_galgasClassRunTimeInformation gClassInfoFor__lexicalRepeatInstruction ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      list '@lexicalWhileBranchList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_lexicalWhileBranchList ;

class GGS_lexicalWhileBranchList : public AC_galgas_list {
  public : typedef elementOf_GGS_lexicalWhileBranchList cElement ;

//--- Constructor 'emptyList'
  public : static GGS_lexicalWhileBranchList constructor_emptyList (void) ;
  public : static GGS_lexicalWhileBranchList constructor_listWithValue (const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalInstructionList & argument_1) ;
//--- Get sublist
  protected : void
  internalSubListWithRange (GGS_lexicalWhileBranchList & ioList,
                            const sint32 inFirstIndex,
                            const sint32 inCount) const ;

  public : GGS_lexicalWhileBranchList
  reader_subListWithRange (C_Compiler & inLexique,
                           const GGS_uint & inFirstIndex,
                           const GGS_uint & inCount
                           COMMA_LOCATION_ARGS) const ;

  public : GGS_lexicalWhileBranchList
  reader_subListFromIndex (C_Compiler & inLexique,
                           const GGS_uint & inIndex
                           COMMA_LOCATION_ARGS) const ;

//--- Get first object
  public : inline cElement * firstObject (void) const {
    return (cElement *) internalFirstObject () ;
  }
//--- Get last object
  public : inline cElement * lastObject (void) const {
    return (cElement *) internalLastObject () ;
  }
//--- Operator () used for method call
  public : const GGS_lexicalWhileBranchList * operator () (UNUSED_LOCATION_ARGS) const { return this ;} 
//--- Method 'first'
  public : void method_first (C_Compiler & inLexique,
                              GGS_lexicalExpression & _out_0,
                              GGS_lexicalInstructionList & _out_1
                              COMMA_LOCATION_ARGS) const ;
//--- Method 'last'
  public : void method_last (C_Compiler & inLexique,
                             GGS_lexicalExpression & _out_0,
                             GGS_lexicalInstructionList & _out_1
                             COMMA_LOCATION_ARGS) const ;
//--- Modifier 'popLast'
  public : void modifier_popLast (C_Compiler & inLexique,
                                GGS_lexicalExpression & _out_0,
                                GGS_lexicalInstructionList & _out_1
                                COMMA_LOCATION_ARGS) ;
//--- Modifier 'popFirst'
  public : void modifier_popFirst (C_Compiler & inLexique,
                                 GGS_lexicalExpression & _out_0,
                                 GGS_lexicalInstructionList & _out_1
                                 COMMA_LOCATION_ARGS) ;
//--- Handle '.=' operator
  public : void _dotAssign_operation (const GGS_lexicalWhileBranchList inOperand) ;

//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalInstructionList & argument_1) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalWhileBranchList _operator_concat (const GGS_lexicalWhileBranchList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & inLexique,
                                const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalInstructionList & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalInstructionList & argument_1
                                COMMA_LOCATION_ARGS) ;

  protected : void _internalPrependValues (const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalInstructionList & argument_1
                                COMMA_LOCATION_ARGS) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--------------------------------- Direct Read Access
  public : GGS_lexicalExpression 
  reader_mWhileExpressionAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const ;
  public : GGS_lexicalInstructionList 
  reader_mWhileInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const ;

//--------------------------------- Direct Write Access
  public : void
  modifier_setMWhileExpressionAtIndex (C_Compiler & inLexique,
                              const GGS_lexicalExpression  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const ;
  public : void
  modifier_setMWhileInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_lexicalInstructionList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const ;

//--------------------------------- List Enumerator
  public : class cEnumerator : public cAbstractListEnumerator {
  //--- Constructor
    public : inline cEnumerator (const GGS_lexicalWhileBranchList & inList,
                                 const bool inAscending) :
    cAbstractListEnumerator (inList, inAscending) {
    }
  //--- Iterator method
    public : inline cElement * nextObject (void) {
      return (cElement *) internalNextObject () ;
    }
  public : /* const */ GGS_lexicalExpression   & _mWhileExpression (LOCATION_ARGS) const ;
  public : /* const */ GGS_lexicalInstructionList   & _mWhileInstructionList (LOCATION_ARGS) const ;
  } ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_lexicalSelectInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalSelectInstruction : public GGS_lexicalInstruction {
//--- Default constructor
  public : inline GGS_lexicalSelectInstruction (void) :
  GGS_lexicalInstruction () {}

//--- Pointer assignment constructor
  public : GGS_lexicalSelectInstruction (cPtr__AC_galgas_class * inPointer) ;

//--- Object assignment constructor
  public : GGS_lexicalSelectInstruction (cPtr__AC_galgas_class & inObject) ;

//--- _castFrom class method (implements cast expression)
  public : static GGS_lexicalSelectInstruction
  _castFrom (C_Compiler & inLexique,
             cPtr__AC_galgas_class * inPointer,
             const bool inUseKindOfClass,
             const GGS_location & inErrorLocation
             COMMA_LOCATION_ARGS) ;

//--- 'new' constructor
  public : static GGS_lexicalSelectInstruction constructor_new (C_Compiler & inLexique,
                                const GGS_lexicalSelectBranchList & argument_0,
                                const GGS_lexicalInstructionList & argument_1
                                COMMA_LOCATION_ARGS) ;

//--- getPtr
  public : inline cPtr_lexicalSelectInstruction * getPtr (void) const {
    return (cPtr_lexicalSelectInstruction *) mPointer ;
  }

//--- 'description' reader
  public : virtual const char * actualTypeName (void) const ;

//--- Readers
  public : GGS_lexicalSelectBranchList  reader_mLexicalWhileBranchList (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_lexicalInstructionList  reader_mDefaultInstructionList (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;

//--- Modifiers

//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalSelectInstruction * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalSelectInstruction * operator () (LOCATION_ARGS) const {
      return (cPtr_lexicalSelectInstruction *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*

extern C_galgasClassRunTimeInformation gClassInfoFor__lexicalSelectInstruction ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      list '@lexicalInstructionList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_lexicalInstructionList ;

class GGS_lexicalInstructionList : public AC_galgas_list {
  public : typedef elementOf_GGS_lexicalInstructionList cElement ;

//--- Constructor 'emptyList'
  public : static GGS_lexicalInstructionList constructor_emptyList (void) ;
  public : static GGS_lexicalInstructionList constructor_listWithValue (const GGS_lexicalInstruction & argument_0) ;
//--- Get sublist
  protected : void
  internalSubListWithRange (GGS_lexicalInstructionList & ioList,
                            const sint32 inFirstIndex,
                            const sint32 inCount) const ;

  public : GGS_lexicalInstructionList
  reader_subListWithRange (C_Compiler & inLexique,
                           const GGS_uint & inFirstIndex,
                           const GGS_uint & inCount
                           COMMA_LOCATION_ARGS) const ;

  public : GGS_lexicalInstructionList
  reader_subListFromIndex (C_Compiler & inLexique,
                           const GGS_uint & inIndex
                           COMMA_LOCATION_ARGS) const ;

//--- Get first object
  public : inline cElement * firstObject (void) const {
    return (cElement *) internalFirstObject () ;
  }
//--- Get last object
  public : inline cElement * lastObject (void) const {
    return (cElement *) internalLastObject () ;
  }
//--- Operator () used for method call
  public : const GGS_lexicalInstructionList * operator () (UNUSED_LOCATION_ARGS) const { return this ;} 
//--- Method 'first'
  public : void method_first (C_Compiler & inLexique,
                              GGS_lexicalInstruction & _out_0
                              COMMA_LOCATION_ARGS) const ;
//--- Method 'last'
  public : void method_last (C_Compiler & inLexique,
                             GGS_lexicalInstruction & _out_0
                             COMMA_LOCATION_ARGS) const ;
//--- Modifier 'popLast'
  public : void modifier_popLast (C_Compiler & inLexique,
                                GGS_lexicalInstruction & _out_0
                                COMMA_LOCATION_ARGS) ;
//--- Modifier 'popFirst'
  public : void modifier_popFirst (C_Compiler & inLexique,
                                 GGS_lexicalInstruction & _out_0
                                 COMMA_LOCATION_ARGS) ;
//--- Handle '.=' operator
  public : void _dotAssign_operation (const GGS_lexicalInstructionList inOperand) ;

//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lexicalInstruction & argument_0) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalInstructionList _operator_concat (const GGS_lexicalInstructionList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & inLexique,
                                const GGS_lexicalInstruction & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lexicalInstruction & argument_0
                                COMMA_LOCATION_ARGS) ;

  protected : void _internalPrependValues (const GGS_lexicalInstruction & argument_0
                                COMMA_LOCATION_ARGS) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--------------------------------- Direct Read Access
  public : GGS_lexicalInstruction 
  reader_mInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const ;

//--------------------------------- Direct Write Access
  public : void
  modifier_setMInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_lexicalInstruction  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const ;

//--------------------------------- List Enumerator
  public : class cEnumerator : public cAbstractListEnumerator {
  //--- Constructor
    public : inline cEnumerator (const GGS_lexicalInstructionList & inList,
                                 const bool inAscending) :
    cAbstractListEnumerator (inList, inAscending) {
    }
  //--- Iterator method
    public : inline cElement * nextObject (void) {
      return (cElement *) internalNextObject () ;
    }
  public : /* const */ GGS_lexicalInstruction   & _mInstructionList (LOCATION_ARGS) const ;
  } ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     list '@lexicalSelectBranchList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_lexicalSelectBranchList ;

class GGS_lexicalSelectBranchList : public AC_galgas_list {
  public : typedef elementOf_GGS_lexicalSelectBranchList cElement ;

//--- Constructor 'emptyList'
  public : static GGS_lexicalSelectBranchList constructor_emptyList (void) ;
  public : static GGS_lexicalSelectBranchList constructor_listWithValue (const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalInstructionList & argument_1) ;
//--- Get sublist
  protected : void
  internalSubListWithRange (GGS_lexicalSelectBranchList & ioList,
                            const sint32 inFirstIndex,
                            const sint32 inCount) const ;

  public : GGS_lexicalSelectBranchList
  reader_subListWithRange (C_Compiler & inLexique,
                           const GGS_uint & inFirstIndex,
                           const GGS_uint & inCount
                           COMMA_LOCATION_ARGS) const ;

  public : GGS_lexicalSelectBranchList
  reader_subListFromIndex (C_Compiler & inLexique,
                           const GGS_uint & inIndex
                           COMMA_LOCATION_ARGS) const ;

//--- Get first object
  public : inline cElement * firstObject (void) const {
    return (cElement *) internalFirstObject () ;
  }
//--- Get last object
  public : inline cElement * lastObject (void) const {
    return (cElement *) internalLastObject () ;
  }
//--- Operator () used for method call
  public : const GGS_lexicalSelectBranchList * operator () (UNUSED_LOCATION_ARGS) const { return this ;} 
//--- Method 'first'
  public : void method_first (C_Compiler & inLexique,
                              GGS_lexicalExpression & _out_0,
                              GGS_lexicalInstructionList & _out_1
                              COMMA_LOCATION_ARGS) const ;
//--- Method 'last'
  public : void method_last (C_Compiler & inLexique,
                             GGS_lexicalExpression & _out_0,
                             GGS_lexicalInstructionList & _out_1
                             COMMA_LOCATION_ARGS) const ;
//--- Modifier 'popLast'
  public : void modifier_popLast (C_Compiler & inLexique,
                                GGS_lexicalExpression & _out_0,
                                GGS_lexicalInstructionList & _out_1
                                COMMA_LOCATION_ARGS) ;
//--- Modifier 'popFirst'
  public : void modifier_popFirst (C_Compiler & inLexique,
                                 GGS_lexicalExpression & _out_0,
                                 GGS_lexicalInstructionList & _out_1
                                 COMMA_LOCATION_ARGS) ;
//--- Handle '.=' operator
  public : void _dotAssign_operation (const GGS_lexicalSelectBranchList inOperand) ;

//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalInstructionList & argument_1) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalSelectBranchList _operator_concat (const GGS_lexicalSelectBranchList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & inLexique,
                                const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalInstructionList & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalInstructionList & argument_1
                                COMMA_LOCATION_ARGS) ;

  protected : void _internalPrependValues (const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalInstructionList & argument_1
                                COMMA_LOCATION_ARGS) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--------------------------------- Direct Read Access
  public : GGS_lexicalExpression 
  reader_mSelectExpressionAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const ;
  public : GGS_lexicalInstructionList 
  reader_mSelectInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const ;

//--------------------------------- Direct Write Access
  public : void
  modifier_setMSelectExpressionAtIndex (C_Compiler & inLexique,
                              const GGS_lexicalExpression  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const ;
  public : void
  modifier_setMSelectInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_lexicalInstructionList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const ;

//--------------------------------- List Enumerator
  public : class cEnumerator : public cAbstractListEnumerator {
  //--- Constructor
    public : inline cEnumerator (const GGS_lexicalSelectBranchList & inList,
                                 const bool inAscending) :
    cAbstractListEnumerator (inList, inAscending) {
    }
  //--- Iterator method
    public : inline cElement * nextObject (void) {
      return (cElement *) internalNextObject () ;
    }
  public : /* const */ GGS_lexicalExpression   & _mSelectExpression (LOCATION_ARGS) const ;
  public : /* const */ GGS_lexicalInstructionList   & _mSelectInstructionList (LOCATION_ARGS) const ;
  } ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_lexicalActionInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalActionInstruction : public GGS_lexicalInstruction {
//--- Default constructor
  public : inline GGS_lexicalActionInstruction (void) :
  GGS_lexicalInstruction () {}

//--- Pointer assignment constructor
  public : GGS_lexicalActionInstruction (cPtr__AC_galgas_class * inPointer) ;

//--- Object assignment constructor
  public : GGS_lexicalActionInstruction (cPtr__AC_galgas_class & inObject) ;

//--- _castFrom class method (implements cast expression)
  public : static GGS_lexicalActionInstruction
  _castFrom (C_Compiler & inLexique,
             cPtr__AC_galgas_class * inPointer,
             const bool inUseKindOfClass,
             const GGS_location & inErrorLocation
             COMMA_LOCATION_ARGS) ;

//--- 'new' constructor
  public : static GGS_lexicalActionInstruction constructor_new (C_Compiler & inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lexicalRoutineCallActualArgumentList & argument_1,
                                const GGS_lstringlist & argument_2
                                COMMA_LOCATION_ARGS) ;

//--- getPtr
  public : inline cPtr_lexicalActionInstruction * getPtr (void) const {
    return (cPtr_lexicalActionInstruction *) mPointer ;
  }

//--- 'description' reader
  public : virtual const char * actualTypeName (void) const ;

//--- Readers
  public : GGS_lstring  reader_mActionName (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_lexicalRoutineCallActualArgumentList  reader_mActualArgumentList (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_lstringlist  reader_mErrorMessageList (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;

//--- Modifiers

//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalActionInstruction * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalActionInstruction * operator () (LOCATION_ARGS) const {
      return (cPtr_lexicalActionInstruction *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*

extern C_galgasClassRunTimeInformation gClassInfoFor__lexicalActionInstruction ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_lexicalActualArgument'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalActualArgument : public AC_galgas_class {
//--- Default constructor
  public : inline GGS_lexicalActualArgument (void) :
  AC_galgas_class () {}

//--- Pointer assignment constructor
  public : GGS_lexicalActualArgument (cPtr__AC_galgas_class * inPointer) ;

//--- Object assignment constructor
  public : GGS_lexicalActualArgument (cPtr__AC_galgas_class & inObject) ;

//--- _castFrom class method (implements cast expression)
  public : static GGS_lexicalActualArgument
  _castFrom (C_Compiler & inLexique,
             cPtr__AC_galgas_class * inPointer,
             const bool inUseKindOfClass,
             const GGS_location & inErrorLocation
             COMMA_LOCATION_ARGS) ;

//--- getPtr
  public : inline cPtr_lexicalActualArgument * getPtr (void) const {
    return (cPtr_lexicalActualArgument *) mPointer ;
  }

//--- 'description' reader
  public : virtual const char * actualTypeName (void) const ;

//--- Readers

//--- Modifiers

//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalActualArgument * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalActualArgument * operator () (LOCATION_ARGS) const {
      return (cPtr_lexicalActualArgument *) mPointer ;
    }
  #endif

//--- Galgas RTTI
AC_galgasClassRunTimeInformation * _galgasObjectRunTimeInfo (void) const ;

} ;

//---------------------------------------------------------------------------*

extern C_galgasRootClassRunTimeInformation gClassInfoFor__lexicalActualArgument ;

//---------------------------------------------------------------------------*
//                                                                           *
//               list '@lexicalRoutineCallActualArgumentList'                *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_lexicalRoutineCallActualArgumentList ;

class GGS_lexicalRoutineCallActualArgumentList : public AC_galgas_list {
  public : typedef elementOf_GGS_lexicalRoutineCallActualArgumentList cElement ;

//--- Constructor 'emptyList'
  public : static GGS_lexicalRoutineCallActualArgumentList constructor_emptyList (void) ;
  public : static GGS_lexicalRoutineCallActualArgumentList constructor_listWithValue (const GGS_lexicalActualArgument & argument_0) ;
//--- Get sublist
  protected : void
  internalSubListWithRange (GGS_lexicalRoutineCallActualArgumentList & ioList,
                            const sint32 inFirstIndex,
                            const sint32 inCount) const ;

  public : GGS_lexicalRoutineCallActualArgumentList
  reader_subListWithRange (C_Compiler & inLexique,
                           const GGS_uint & inFirstIndex,
                           const GGS_uint & inCount
                           COMMA_LOCATION_ARGS) const ;

  public : GGS_lexicalRoutineCallActualArgumentList
  reader_subListFromIndex (C_Compiler & inLexique,
                           const GGS_uint & inIndex
                           COMMA_LOCATION_ARGS) const ;

//--- Get first object
  public : inline cElement * firstObject (void) const {
    return (cElement *) internalFirstObject () ;
  }
//--- Get last object
  public : inline cElement * lastObject (void) const {
    return (cElement *) internalLastObject () ;
  }
//--- Operator () used for method call
  public : const GGS_lexicalRoutineCallActualArgumentList * operator () (UNUSED_LOCATION_ARGS) const { return this ;} 
//--- Method 'first'
  public : void method_first (C_Compiler & inLexique,
                              GGS_lexicalActualArgument & _out_0
                              COMMA_LOCATION_ARGS) const ;
//--- Method 'last'
  public : void method_last (C_Compiler & inLexique,
                             GGS_lexicalActualArgument & _out_0
                             COMMA_LOCATION_ARGS) const ;
//--- Modifier 'popLast'
  public : void modifier_popLast (C_Compiler & inLexique,
                                GGS_lexicalActualArgument & _out_0
                                COMMA_LOCATION_ARGS) ;
//--- Modifier 'popFirst'
  public : void modifier_popFirst (C_Compiler & inLexique,
                                 GGS_lexicalActualArgument & _out_0
                                 COMMA_LOCATION_ARGS) ;
//--- Handle '.=' operator
  public : void _dotAssign_operation (const GGS_lexicalRoutineCallActualArgumentList inOperand) ;

//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lexicalActualArgument & argument_0) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalRoutineCallActualArgumentList _operator_concat (const GGS_lexicalRoutineCallActualArgumentList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & inLexique,
                                const GGS_lexicalActualArgument & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lexicalActualArgument & argument_0
                                COMMA_LOCATION_ARGS) ;

  protected : void _internalPrependValues (const GGS_lexicalActualArgument & argument_0
                                COMMA_LOCATION_ARGS) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--------------------------------- Direct Read Access
  public : GGS_lexicalActualArgument 
  reader_mLexicalActualArgumentAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const ;

//--------------------------------- Direct Write Access
  public : void
  modifier_setMLexicalActualArgumentAtIndex (C_Compiler & inLexique,
                              const GGS_lexicalActualArgument  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const ;

//--------------------------------- List Enumerator
  public : class cEnumerator : public cAbstractListEnumerator {
  //--- Constructor
    public : inline cEnumerator (const GGS_lexicalRoutineCallActualArgumentList & inList,
                                 const bool inAscending) :
    cAbstractListEnumerator (inList, inAscending) {
    }
  //--- Iterator method
    public : inline cElement * nextObject (void) {
      return (cElement *) internalNextObject () ;
    }
  public : /* const */ GGS_lexicalActualArgument   & _mLexicalActualArgument (LOCATION_ARGS) const ;
  } ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_lexicalFormalInputArgument'                *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalFormalInputArgument : public GGS_lexicalActualArgument {
//--- Default constructor
  public : inline GGS_lexicalFormalInputArgument (void) :
  GGS_lexicalActualArgument () {}

//--- Pointer assignment constructor
  public : GGS_lexicalFormalInputArgument (cPtr__AC_galgas_class * inPointer) ;

//--- Object assignment constructor
  public : GGS_lexicalFormalInputArgument (cPtr__AC_galgas_class & inObject) ;

//--- _castFrom class method (implements cast expression)
  public : static GGS_lexicalFormalInputArgument
  _castFrom (C_Compiler & inLexique,
             cPtr__AC_galgas_class * inPointer,
             const bool inUseKindOfClass,
             const GGS_location & inErrorLocation
             COMMA_LOCATION_ARGS) ;

//--- getPtr
  public : inline cPtr_lexicalFormalInputArgument * getPtr (void) const {
    return (cPtr_lexicalFormalInputArgument *) mPointer ;
  }

//--- 'description' reader
  public : virtual const char * actualTypeName (void) const ;

//--- Readers

//--- Modifiers

//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalFormalInputArgument * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalFormalInputArgument * operator () (LOCATION_ARGS) const {
      return (cPtr_lexicalFormalInputArgument *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*

extern C_galgasClassRunTimeInformation gClassInfoFor__lexicalFormalInputArgument ;

//---------------------------------------------------------------------------*
//                                                                           *
//              list '@lexicalFunctionCallActualArgumentList'                *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_lexicalFunctionCallActualArgumentList ;

class GGS_lexicalFunctionCallActualArgumentList : public AC_galgas_list {
  public : typedef elementOf_GGS_lexicalFunctionCallActualArgumentList cElement ;

//--- Constructor 'emptyList'
  public : static GGS_lexicalFunctionCallActualArgumentList constructor_emptyList (void) ;
  public : static GGS_lexicalFunctionCallActualArgumentList constructor_listWithValue (const GGS_lexicalFormalInputArgument & argument_0) ;
//--- Get sublist
  protected : void
  internalSubListWithRange (GGS_lexicalFunctionCallActualArgumentList & ioList,
                            const sint32 inFirstIndex,
                            const sint32 inCount) const ;

  public : GGS_lexicalFunctionCallActualArgumentList
  reader_subListWithRange (C_Compiler & inLexique,
                           const GGS_uint & inFirstIndex,
                           const GGS_uint & inCount
                           COMMA_LOCATION_ARGS) const ;

  public : GGS_lexicalFunctionCallActualArgumentList
  reader_subListFromIndex (C_Compiler & inLexique,
                           const GGS_uint & inIndex
                           COMMA_LOCATION_ARGS) const ;

//--- Get first object
  public : inline cElement * firstObject (void) const {
    return (cElement *) internalFirstObject () ;
  }
//--- Get last object
  public : inline cElement * lastObject (void) const {
    return (cElement *) internalLastObject () ;
  }
//--- Operator () used for method call
  public : const GGS_lexicalFunctionCallActualArgumentList * operator () (UNUSED_LOCATION_ARGS) const { return this ;} 
//--- Method 'first'
  public : void method_first (C_Compiler & inLexique,
                              GGS_lexicalFormalInputArgument & _out_0
                              COMMA_LOCATION_ARGS) const ;
//--- Method 'last'
  public : void method_last (C_Compiler & inLexique,
                             GGS_lexicalFormalInputArgument & _out_0
                             COMMA_LOCATION_ARGS) const ;
//--- Modifier 'popLast'
  public : void modifier_popLast (C_Compiler & inLexique,
                                GGS_lexicalFormalInputArgument & _out_0
                                COMMA_LOCATION_ARGS) ;
//--- Modifier 'popFirst'
  public : void modifier_popFirst (C_Compiler & inLexique,
                                 GGS_lexicalFormalInputArgument & _out_0
                                 COMMA_LOCATION_ARGS) ;
//--- Handle '.=' operator
  public : void _dotAssign_operation (const GGS_lexicalFunctionCallActualArgumentList inOperand) ;

//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lexicalFormalInputArgument & argument_0) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalFunctionCallActualArgumentList _operator_concat (const GGS_lexicalFunctionCallActualArgumentList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & inLexique,
                                const GGS_lexicalFormalInputArgument & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lexicalFormalInputArgument & argument_0
                                COMMA_LOCATION_ARGS) ;

  protected : void _internalPrependValues (const GGS_lexicalFormalInputArgument & argument_0
                                COMMA_LOCATION_ARGS) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--------------------------------- Direct Read Access
  public : GGS_lexicalFormalInputArgument 
  reader_mLexicalActualInputArgumentAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const ;

//--------------------------------- Direct Write Access
  public : void
  modifier_setMLexicalActualInputArgumentAtIndex (C_Compiler & inLexique,
                              const GGS_lexicalFormalInputArgument  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const ;

//--------------------------------- List Enumerator
  public : class cEnumerator : public cAbstractListEnumerator {
  //--- Constructor
    public : inline cEnumerator (const GGS_lexicalFunctionCallActualArgumentList & inList,
                                 const bool inAscending) :
    cAbstractListEnumerator (inList, inAscending) {
    }
  //--- Iterator method
    public : inline cElement * nextObject (void) {
      return (cElement *) internalNextObject () ;
    }
  public : /* const */ GGS_lexicalFormalInputArgument   & _mLexicalActualInputArgument (LOCATION_ARGS) const ;
  } ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_lexicalAttributeInputOutputArgument'           *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalAttributeInputOutputArgument : public GGS_lexicalFormalInputArgument {
//--- Default constructor
  public : inline GGS_lexicalAttributeInputOutputArgument (void) :
  GGS_lexicalFormalInputArgument () {}

//--- Pointer assignment constructor
  public : GGS_lexicalAttributeInputOutputArgument (cPtr__AC_galgas_class * inPointer) ;

//--- Object assignment constructor
  public : GGS_lexicalAttributeInputOutputArgument (cPtr__AC_galgas_class & inObject) ;

//--- _castFrom class method (implements cast expression)
  public : static GGS_lexicalAttributeInputOutputArgument
  _castFrom (C_Compiler & inLexique,
             cPtr__AC_galgas_class * inPointer,
             const bool inUseKindOfClass,
             const GGS_location & inErrorLocation
             COMMA_LOCATION_ARGS) ;

//--- 'new' constructor
  public : static GGS_lexicalAttributeInputOutputArgument constructor_new (C_Compiler & inLexique,
                                const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) ;

//--- getPtr
  public : inline cPtr_lexicalAttributeInputOutputArgument * getPtr (void) const {
    return (cPtr_lexicalAttributeInputOutputArgument *) mPointer ;
  }

//--- 'description' reader
  public : virtual const char * actualTypeName (void) const ;

//--- Readers
  public : GGS_lstring  reader_mAttributeName (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;

//--- Modifiers

//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalAttributeInputOutputArgument * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalAttributeInputOutputArgument * operator () (LOCATION_ARGS) const {
      return (cPtr_lexicalAttributeInputOutputArgument *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*

extern C_galgasClassRunTimeInformation gClassInfoFor__lexicalAttributeInputOutputArgument ;

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_lexicalAttributeInputArgument'              *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalAttributeInputArgument : public GGS_lexicalFormalInputArgument {
//--- Default constructor
  public : inline GGS_lexicalAttributeInputArgument (void) :
  GGS_lexicalFormalInputArgument () {}

//--- Pointer assignment constructor
  public : GGS_lexicalAttributeInputArgument (cPtr__AC_galgas_class * inPointer) ;

//--- Object assignment constructor
  public : GGS_lexicalAttributeInputArgument (cPtr__AC_galgas_class & inObject) ;

//--- _castFrom class method (implements cast expression)
  public : static GGS_lexicalAttributeInputArgument
  _castFrom (C_Compiler & inLexique,
             cPtr__AC_galgas_class * inPointer,
             const bool inUseKindOfClass,
             const GGS_location & inErrorLocation
             COMMA_LOCATION_ARGS) ;

//--- 'new' constructor
  public : static GGS_lexicalAttributeInputArgument constructor_new (C_Compiler & inLexique,
                                const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) ;

//--- getPtr
  public : inline cPtr_lexicalAttributeInputArgument * getPtr (void) const {
    return (cPtr_lexicalAttributeInputArgument *) mPointer ;
  }

//--- 'description' reader
  public : virtual const char * actualTypeName (void) const ;

//--- Readers
  public : GGS_lstring  reader_mAttributeName (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;

//--- Modifiers

//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalAttributeInputArgument * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalAttributeInputArgument * operator () (LOCATION_ARGS) const {
      return (cPtr_lexicalAttributeInputArgument *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*

extern C_galgasClassRunTimeInformation gClassInfoFor__lexicalAttributeInputArgument ;

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_lexicalCharacterInputArgument'              *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalCharacterInputArgument : public GGS_lexicalFormalInputArgument {
//--- Default constructor
  public : inline GGS_lexicalCharacterInputArgument (void) :
  GGS_lexicalFormalInputArgument () {}

//--- Pointer assignment constructor
  public : GGS_lexicalCharacterInputArgument (cPtr__AC_galgas_class * inPointer) ;

//--- Object assignment constructor
  public : GGS_lexicalCharacterInputArgument (cPtr__AC_galgas_class & inObject) ;

//--- _castFrom class method (implements cast expression)
  public : static GGS_lexicalCharacterInputArgument
  _castFrom (C_Compiler & inLexique,
             cPtr__AC_galgas_class * inPointer,
             const bool inUseKindOfClass,
             const GGS_location & inErrorLocation
             COMMA_LOCATION_ARGS) ;

//--- 'new' constructor
  public : static GGS_lexicalCharacterInputArgument constructor_new (C_Compiler & inLexique,
                                const GGS_lchar & argument_0
                                COMMA_LOCATION_ARGS) ;

//--- getPtr
  public : inline cPtr_lexicalCharacterInputArgument * getPtr (void) const {
    return (cPtr_lexicalCharacterInputArgument *) mPointer ;
  }

//--- 'description' reader
  public : virtual const char * actualTypeName (void) const ;

//--- Readers
  public : GGS_lchar  reader_mCharacter (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;

//--- Modifiers

//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalCharacterInputArgument * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalCharacterInputArgument * operator () (LOCATION_ARGS) const {
      return (cPtr_lexicalCharacterInputArgument *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*

extern C_galgasClassRunTimeInformation gClassInfoFor__lexicalCharacterInputArgument ;

//---------------------------------------------------------------------------*
//                                                                           *
//         GALGAS class 'GGS_lexicalCurrentCharacterInputArgument'           *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalCurrentCharacterInputArgument : public GGS_lexicalFormalInputArgument {
//--- Default constructor
  public : inline GGS_lexicalCurrentCharacterInputArgument (void) :
  GGS_lexicalFormalInputArgument () {}

//--- Pointer assignment constructor
  public : GGS_lexicalCurrentCharacterInputArgument (cPtr__AC_galgas_class * inPointer) ;

//--- Object assignment constructor
  public : GGS_lexicalCurrentCharacterInputArgument (cPtr__AC_galgas_class & inObject) ;

//--- _castFrom class method (implements cast expression)
  public : static GGS_lexicalCurrentCharacterInputArgument
  _castFrom (C_Compiler & inLexique,
             cPtr__AC_galgas_class * inPointer,
             const bool inUseKindOfClass,
             const GGS_location & inErrorLocation
             COMMA_LOCATION_ARGS) ;

//--- 'new' constructor
  public : static GGS_lexicalCurrentCharacterInputArgument constructor_new (C_Compiler & inLexique
                                COMMA_LOCATION_ARGS) ;

//--- getPtr
  public : inline cPtr_lexicalCurrentCharacterInputArgument * getPtr (void) const {
    return (cPtr_lexicalCurrentCharacterInputArgument *) mPointer ;
  }

//--- 'description' reader
  public : virtual const char * actualTypeName (void) const ;

//--- Readers

//--- Modifiers

//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalCurrentCharacterInputArgument * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalCurrentCharacterInputArgument * operator () (LOCATION_ARGS) const {
      return (cPtr_lexicalCurrentCharacterInputArgument *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*

extern C_galgasClassRunTimeInformation gClassInfoFor__lexicalCurrentCharacterInputArgument ;

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_lexicalFunctionInputArgument'               *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalFunctionInputArgument : public GGS_lexicalFormalInputArgument {
//--- Default constructor
  public : inline GGS_lexicalFunctionInputArgument (void) :
  GGS_lexicalFormalInputArgument () {}

//--- Pointer assignment constructor
  public : GGS_lexicalFunctionInputArgument (cPtr__AC_galgas_class * inPointer) ;

//--- Object assignment constructor
  public : GGS_lexicalFunctionInputArgument (cPtr__AC_galgas_class & inObject) ;

//--- _castFrom class method (implements cast expression)
  public : static GGS_lexicalFunctionInputArgument
  _castFrom (C_Compiler & inLexique,
             cPtr__AC_galgas_class * inPointer,
             const bool inUseKindOfClass,
             const GGS_location & inErrorLocation
             COMMA_LOCATION_ARGS) ;

//--- 'new' constructor
  public : static GGS_lexicalFunctionInputArgument constructor_new (C_Compiler & inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lexicalFunctionCallActualArgumentList & argument_1
                                COMMA_LOCATION_ARGS) ;

//--- getPtr
  public : inline cPtr_lexicalFunctionInputArgument * getPtr (void) const {
    return (cPtr_lexicalFunctionInputArgument *) mPointer ;
  }

//--- 'description' reader
  public : virtual const char * actualTypeName (void) const ;

//--- Readers
  public : GGS_lstring  reader_mFunctionName (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_lexicalFunctionCallActualArgumentList  reader_mFunctionActualArgumentList (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;

//--- Modifiers

//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalFunctionInputArgument * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalFunctionInputArgument * operator () (LOCATION_ARGS) const {
      return (cPtr_lexicalFunctionInputArgument *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*

extern C_galgasClassRunTimeInformation gClassInfoFor__lexicalFunctionInputArgument ;

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_lexicalDropInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalDropInstruction : public GGS_lexicalInstruction {
//--- Default constructor
  public : inline GGS_lexicalDropInstruction (void) :
  GGS_lexicalInstruction () {}

//--- Pointer assignment constructor
  public : GGS_lexicalDropInstruction (cPtr__AC_galgas_class * inPointer) ;

//--- Object assignment constructor
  public : GGS_lexicalDropInstruction (cPtr__AC_galgas_class & inObject) ;

//--- _castFrom class method (implements cast expression)
  public : static GGS_lexicalDropInstruction
  _castFrom (C_Compiler & inLexique,
             cPtr__AC_galgas_class * inPointer,
             const bool inUseKindOfClass,
             const GGS_location & inErrorLocation
             COMMA_LOCATION_ARGS) ;

//--- 'new' constructor
  public : static GGS_lexicalDropInstruction constructor_new (C_Compiler & inLexique,
                                const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) ;

//--- getPtr
  public : inline cPtr_lexicalDropInstruction * getPtr (void) const {
    return (cPtr_lexicalDropInstruction *) mPointer ;
  }

//--- 'description' reader
  public : virtual const char * actualTypeName (void) const ;

//--- Readers
  public : GGS_lstring  reader_mTerminalName (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;

//--- Modifiers

//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalDropInstruction * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalDropInstruction * operator () (LOCATION_ARGS) const {
      return (cPtr_lexicalDropInstruction *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*

extern C_galgasClassRunTimeInformation gClassInfoFor__lexicalDropInstruction ;

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_lexicalErrorInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalErrorInstruction : public GGS_lexicalInstruction {
//--- Default constructor
  public : inline GGS_lexicalErrorInstruction (void) :
  GGS_lexicalInstruction () {}

//--- Pointer assignment constructor
  public : GGS_lexicalErrorInstruction (cPtr__AC_galgas_class * inPointer) ;

//--- Object assignment constructor
  public : GGS_lexicalErrorInstruction (cPtr__AC_galgas_class & inObject) ;

//--- _castFrom class method (implements cast expression)
  public : static GGS_lexicalErrorInstruction
  _castFrom (C_Compiler & inLexique,
             cPtr__AC_galgas_class * inPointer,
             const bool inUseKindOfClass,
             const GGS_location & inErrorLocation
             COMMA_LOCATION_ARGS) ;

//--- 'new' constructor
  public : static GGS_lexicalErrorInstruction constructor_new (C_Compiler & inLexique,
                                const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) ;

//--- getPtr
  public : inline cPtr_lexicalErrorInstruction * getPtr (void) const {
    return (cPtr_lexicalErrorInstruction *) mPointer ;
  }

//--- 'description' reader
  public : virtual const char * actualTypeName (void) const ;

//--- Readers
  public : GGS_lstring  reader_mErrorMessageName (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;

//--- Modifiers

//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalErrorInstruction * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalErrorInstruction * operator () (LOCATION_ARGS) const {
      return (cPtr_lexicalErrorInstruction *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*

extern C_galgasClassRunTimeInformation gClassInfoFor__lexicalErrorInstruction ;

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_lexicalWarningInstruction'                *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalWarningInstruction : public GGS_lexicalInstruction {
//--- Default constructor
  public : inline GGS_lexicalWarningInstruction (void) :
  GGS_lexicalInstruction () {}

//--- Pointer assignment constructor
  public : GGS_lexicalWarningInstruction (cPtr__AC_galgas_class * inPointer) ;

//--- Object assignment constructor
  public : GGS_lexicalWarningInstruction (cPtr__AC_galgas_class & inObject) ;

//--- _castFrom class method (implements cast expression)
  public : static GGS_lexicalWarningInstruction
  _castFrom (C_Compiler & inLexique,
             cPtr__AC_galgas_class * inPointer,
             const bool inUseKindOfClass,
             const GGS_location & inErrorLocation
             COMMA_LOCATION_ARGS) ;

//--- 'new' constructor
  public : static GGS_lexicalWarningInstruction constructor_new (C_Compiler & inLexique,
                                const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) ;

//--- getPtr
  public : inline cPtr_lexicalWarningInstruction * getPtr (void) const {
    return (cPtr_lexicalWarningInstruction *) mPointer ;
  }

//--- 'description' reader
  public : virtual const char * actualTypeName (void) const ;

//--- Readers
  public : GGS_lstring  reader_mWarningMessageName (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;

//--- Modifiers

//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalWarningInstruction * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalWarningInstruction * operator () (LOCATION_ARGS) const {
      return (cPtr_lexicalWarningInstruction *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*

extern C_galgasClassRunTimeInformation gClassInfoFor__lexicalWarningInstruction ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_lexicalTagInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalTagInstruction : public GGS_lexicalInstruction {
//--- Default constructor
  public : inline GGS_lexicalTagInstruction (void) :
  GGS_lexicalInstruction () {}

//--- Pointer assignment constructor
  public : GGS_lexicalTagInstruction (cPtr__AC_galgas_class * inPointer) ;

//--- Object assignment constructor
  public : GGS_lexicalTagInstruction (cPtr__AC_galgas_class & inObject) ;

//--- _castFrom class method (implements cast expression)
  public : static GGS_lexicalTagInstruction
  _castFrom (C_Compiler & inLexique,
             cPtr__AC_galgas_class * inPointer,
             const bool inUseKindOfClass,
             const GGS_location & inErrorLocation
             COMMA_LOCATION_ARGS) ;

//--- 'new' constructor
  public : static GGS_lexicalTagInstruction constructor_new (C_Compiler & inLexique,
                                const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) ;

//--- getPtr
  public : inline cPtr_lexicalTagInstruction * getPtr (void) const {
    return (cPtr_lexicalTagInstruction *) mPointer ;
  }

//--- 'description' reader
  public : virtual const char * actualTypeName (void) const ;

//--- Readers
  public : GGS_lstring  reader_mTagName (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;

//--- Modifiers

//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalTagInstruction * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalTagInstruction * operator () (LOCATION_ARGS) const {
      return (cPtr_lexicalTagInstruction *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*

extern C_galgasClassRunTimeInformation gClassInfoFor__lexicalTagInstruction ;

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_lexicalRewindInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalRewindInstruction : public GGS_lexicalInstruction {
//--- Default constructor
  public : inline GGS_lexicalRewindInstruction (void) :
  GGS_lexicalInstruction () {}

//--- Pointer assignment constructor
  public : GGS_lexicalRewindInstruction (cPtr__AC_galgas_class * inPointer) ;

//--- Object assignment constructor
  public : GGS_lexicalRewindInstruction (cPtr__AC_galgas_class & inObject) ;

//--- _castFrom class method (implements cast expression)
  public : static GGS_lexicalRewindInstruction
  _castFrom (C_Compiler & inLexique,
             cPtr__AC_galgas_class * inPointer,
             const bool inUseKindOfClass,
             const GGS_location & inErrorLocation
             COMMA_LOCATION_ARGS) ;

//--- 'new' constructor
  public : static GGS_lexicalRewindInstruction constructor_new (C_Compiler & inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) ;

//--- getPtr
  public : inline cPtr_lexicalRewindInstruction * getPtr (void) const {
    return (cPtr_lexicalRewindInstruction *) mPointer ;
  }

//--- 'description' reader
  public : virtual const char * actualTypeName (void) const ;

//--- Readers
  public : GGS_lstring  reader_mTagName (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_lstring  reader_mTerminalName (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;

//--- Modifiers

//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalRewindInstruction * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalRewindInstruction * operator () (LOCATION_ARGS) const {
      return (cPtr_lexicalRewindInstruction *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*

extern C_galgasClassRunTimeInformation gClassInfoFor__lexicalRewindInstruction ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_lexicalLogInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalLogInstruction : public GGS_lexicalInstruction {
//--- Default constructor
  public : inline GGS_lexicalLogInstruction (void) :
  GGS_lexicalInstruction () {}

//--- Pointer assignment constructor
  public : GGS_lexicalLogInstruction (cPtr__AC_galgas_class * inPointer) ;

//--- Object assignment constructor
  public : GGS_lexicalLogInstruction (cPtr__AC_galgas_class & inObject) ;

//--- _castFrom class method (implements cast expression)
  public : static GGS_lexicalLogInstruction
  _castFrom (C_Compiler & inLexique,
             cPtr__AC_galgas_class * inPointer,
             const bool inUseKindOfClass,
             const GGS_location & inErrorLocation
             COMMA_LOCATION_ARGS) ;

//--- 'new' constructor
  public : static GGS_lexicalLogInstruction constructor_new (C_Compiler & inLexique
                                COMMA_LOCATION_ARGS) ;

//--- getPtr
  public : inline cPtr_lexicalLogInstruction * getPtr (void) const {
    return (cPtr_lexicalLogInstruction *) mPointer ;
  }

//--- 'description' reader
  public : virtual const char * actualTypeName (void) const ;

//--- Readers

//--- Modifiers

//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalLogInstruction * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalLogInstruction * operator () (LOCATION_ARGS) const {
      return (cPtr_lexicalLogInstruction *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*

extern C_galgasClassRunTimeInformation gClassInfoFor__lexicalLogInstruction ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_lexiqueComponentRoot'                   *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexiqueComponentRoot : public AC_galgas_class {
//--- Default constructor
  public : inline GGS_lexiqueComponentRoot (void) :
  AC_galgas_class () {}

//--- Pointer assignment constructor
  public : GGS_lexiqueComponentRoot (cPtr__AC_galgas_class * inPointer) ;

//--- Object assignment constructor
  public : GGS_lexiqueComponentRoot (cPtr__AC_galgas_class & inObject) ;

//--- _castFrom class method (implements cast expression)
  public : static GGS_lexiqueComponentRoot
  _castFrom (C_Compiler & inLexique,
             cPtr__AC_galgas_class * inPointer,
             const bool inUseKindOfClass,
             const GGS_location & inErrorLocation
             COMMA_LOCATION_ARGS) ;

//--- 'new' constructor
  public : static GGS_lexiqueComponentRoot constructor_new (C_Compiler & inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_bool& argument_1,
                                const GGS_templateDelimitorList & argument_2,
                                const GGS_templateReplacementList & argument_3,
                                const GGS_lexicalAttributeList & argument_4,
                                const GGS_lexicalStyleList & argument_5,
                                const GGS_terminalDeclarationList & argument_6,
                                const GGS_lexicalErrorMessageDeclarationList & argument_7,
                                const GGS_lexicalListDeclarationList & argument_8,
                                const GGS_lexicalImplicitRuleList & argument_9,
                                const GGS_lexicalExplicitRuleList & argument_10
                                COMMA_LOCATION_ARGS) ;

//--- getPtr
  public : inline cPtr_lexiqueComponentRoot * getPtr (void) const {
    return (cPtr_lexiqueComponentRoot *) mPointer ;
  }

//--- 'description' reader
  public : virtual const char * actualTypeName (void) const ;

//--- Readers
  public : GGS_lstring  reader_mLexiqueComponentName (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_lexicalAttributeList  reader_mLexicalAttributeList (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_terminalDeclarationList  reader_mTerminalDeclarationList (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_lexicalListDeclarationList  reader_mLexicalListDeclarationList (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;

//--- Modifiers

//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexiqueComponentRoot * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexiqueComponentRoot * operator () (LOCATION_ARGS) const {
      return (cPtr_lexiqueComponentRoot *) mPointer ;
    }
  #endif

//--- Galgas RTTI
AC_galgasClassRunTimeInformation * _galgasObjectRunTimeInfo (void) const ;

} ;

//---------------------------------------------------------------------------*

extern C_galgasRootClassRunTimeInformation gClassInfoFor__lexiqueComponentRoot ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@templateDelimitorList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_templateDelimitorList : public AC_galgas_list::cListElement {
//--- Attributes
  public : GGS_lstring  mStartString ;
  public : GGS_lstringlist  mOptionList ;
  public : GGS_lstring  mEndString ;
//--- Constructor
  public : elementOf_GGS_templateDelimitorList (const GGS_lstring & ,
                                const GGS_lstringlist & ,
                                const GGS_lstring & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline elementOf_GGS_templateDelimitorList * nextObject (void) const { return (elementOf_GGS_templateDelimitorList *) internalNextItem () ; }

//--- Access to previous
  public : inline elementOf_GGS_templateDelimitorList * previousObject (void) const { return (elementOf_GGS_templateDelimitorList *) internalPreviousItem () ; }

//--- Element comparison
  protected : virtual bool
  isEqualToObject (const cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Friend class declaration
  friend class GGS_templateDelimitorList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@templateReplacementList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_templateReplacementList : public AC_galgas_list::cListElement {
//--- Attributes
  public : GGS_lstring  mMatchString ;
  public : GGS_lstring  mReplacementString ;
  public : GGS_lstring  mReplacementFunction ;
//--- Constructor
  public : elementOf_GGS_templateReplacementList (const GGS_lstring & ,
                                const GGS_lstring & ,
                                const GGS_lstring & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline elementOf_GGS_templateReplacementList * nextObject (void) const { return (elementOf_GGS_templateReplacementList *) internalNextItem () ; }

//--- Access to previous
  public : inline elementOf_GGS_templateReplacementList * previousObject (void) const { return (elementOf_GGS_templateReplacementList *) internalPreviousItem () ; }

//--- Element comparison
  protected : virtual bool
  isEqualToObject (const cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Friend class declaration
  friend class GGS_templateReplacementList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@lexicalImplicitRuleList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_lexicalImplicitRuleList : public AC_galgas_list::cListElement {
//--- Attributes
  public : GGS_lstring  mListName ;
//--- Constructor
  public : elementOf_GGS_lexicalImplicitRuleList (const GGS_lstring & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline elementOf_GGS_lexicalImplicitRuleList * nextObject (void) const { return (elementOf_GGS_lexicalImplicitRuleList *) internalNextItem () ; }

//--- Access to previous
  public : inline elementOf_GGS_lexicalImplicitRuleList * previousObject (void) const { return (elementOf_GGS_lexicalImplicitRuleList *) internalPreviousItem () ; }

//--- Element comparison
  protected : virtual bool
  isEqualToObject (const cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Friend class declaration
  friend class GGS_lexicalImplicitRuleList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//          Element of list '@lexicalErrorMessageDeclarationList'            *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_lexicalErrorMessageDeclarationList : public AC_galgas_list::cListElement {
//--- Attributes
  public : GGS_lstring  mMessageName ;
  public : GGS_lstring  mMessageValue ;
//--- Constructor
  public : elementOf_GGS_lexicalErrorMessageDeclarationList (const GGS_lstring & ,
                                const GGS_lstring & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline elementOf_GGS_lexicalErrorMessageDeclarationList * nextObject (void) const { return (elementOf_GGS_lexicalErrorMessageDeclarationList *) internalNextItem () ; }

//--- Access to previous
  public : inline elementOf_GGS_lexicalErrorMessageDeclarationList * previousObject (void) const { return (elementOf_GGS_lexicalErrorMessageDeclarationList *) internalPreviousItem () ; }

//--- Element comparison
  protected : virtual bool
  isEqualToObject (const cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Friend class declaration
  friend class GGS_lexicalErrorMessageDeclarationList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@lexicalAttributeList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_lexicalAttributeList : public AC_galgas_list::cListElement {
//--- Attributes
  public : GGS_lstring  mTypeName ;
  public : GGS_lstring  mName ;
//--- Constructor
  public : elementOf_GGS_lexicalAttributeList (const GGS_lstring & ,
                                const GGS_lstring & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline elementOf_GGS_lexicalAttributeList * nextObject (void) const { return (elementOf_GGS_lexicalAttributeList *) internalNextItem () ; }

//--- Access to previous
  public : inline elementOf_GGS_lexicalAttributeList * previousObject (void) const { return (elementOf_GGS_lexicalAttributeList *) internalPreviousItem () ; }

//--- Element comparison
  protected : virtual bool
  isEqualToObject (const cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Friend class declaration
  friend class GGS_lexicalAttributeList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   Element of list '@lexicalStyleList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_lexicalStyleList : public AC_galgas_list::cListElement {
//--- Attributes
  public : GGS_lstring  mName ;
  public : GGS_lstring  mComment ;
//--- Constructor
  public : elementOf_GGS_lexicalStyleList (const GGS_lstring & ,
                                const GGS_lstring & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline elementOf_GGS_lexicalStyleList * nextObject (void) const { return (elementOf_GGS_lexicalStyleList *) internalNextItem () ; }

//--- Access to previous
  public : inline elementOf_GGS_lexicalStyleList * previousObject (void) const { return (elementOf_GGS_lexicalStyleList *) internalPreviousItem () ; }

//--- Element comparison
  protected : virtual bool
  isEqualToObject (const cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Friend class declaration
  friend class GGS_lexicalStyleList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@terminalDeclarationList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_terminalDeclarationList : public AC_galgas_list::cListElement {
//--- Attributes
  public : GGS_lstring  mName ;
  public : GGS_lstringlist  mSentAttributeList ;
  public : GGS_lstring  mErrorMessage ;
  public : GGS_lstring  mStyle ;
  public : GGS_lstringlist  mOptionList ;
//--- Constructor
  public : elementOf_GGS_terminalDeclarationList (const GGS_lstring & ,
                                const GGS_lstringlist & ,
                                const GGS_lstring & ,
                                const GGS_lstring & ,
                                const GGS_lstringlist & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline elementOf_GGS_terminalDeclarationList * nextObject (void) const { return (elementOf_GGS_terminalDeclarationList *) internalNextItem () ; }

//--- Access to previous
  public : inline elementOf_GGS_terminalDeclarationList * previousObject (void) const { return (elementOf_GGS_terminalDeclarationList *) internalPreviousItem () ; }

//--- Element comparison
  protected : virtual bool
  isEqualToObject (const cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Friend class declaration
  friend class GGS_terminalDeclarationList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@lexicalListEntryList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_lexicalListEntryList : public AC_galgas_list::cListElement {
//--- Attributes
  public : GGS_lstring  mEntrySpelling ;
  public : GGS_lstring  mTerminalSpelling ;
  public : GGS_lstringlist  mOptionList ;
//--- Constructor
  public : elementOf_GGS_lexicalListEntryList (const GGS_lstring & ,
                                const GGS_lstring & ,
                                const GGS_lstringlist & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline elementOf_GGS_lexicalListEntryList * nextObject (void) const { return (elementOf_GGS_lexicalListEntryList *) internalNextItem () ; }

//--- Access to previous
  public : inline elementOf_GGS_lexicalListEntryList * previousObject (void) const { return (elementOf_GGS_lexicalListEntryList *) internalPreviousItem () ; }

//--- Element comparison
  protected : virtual bool
  isEqualToObject (const cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Friend class declaration
  friend class GGS_lexicalListEntryList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@lexicalListDeclarationList'                *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_lexicalListDeclarationList : public AC_galgas_list::cListElement {
//--- Attributes
  public : GGS_lstring  mName ;
  public : GGS_lstring  mStyle ;
  public : GGS_lstring  mErrorMessage ;
  public : GGS_lstringlist  mSentAttributeList ;
  public : GGS_lexicalListEntryList  mEntryList ;
//--- Constructor
  public : elementOf_GGS_lexicalListDeclarationList (const GGS_lstring & ,
                                const GGS_lstring & ,
                                const GGS_lstring & ,
                                const GGS_lstringlist & ,
                                const GGS_lexicalListEntryList & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline elementOf_GGS_lexicalListDeclarationList * nextObject (void) const { return (elementOf_GGS_lexicalListDeclarationList *) internalNextItem () ; }

//--- Access to previous
  public : inline elementOf_GGS_lexicalListDeclarationList * previousObject (void) const { return (elementOf_GGS_lexicalListDeclarationList *) internalPreviousItem () ; }

//--- Element comparison
  protected : virtual bool
  isEqualToObject (const cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Friend class declaration
  friend class GGS_lexicalListDeclarationList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_lexicalExpression'                   *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalExpression : public cPtr__AC_galgas_class {
//--- Constructor
  public : cPtr_lexicalExpression (LOCATION_ARGS) ;

//--- Declaring a protected virtual destructor enables the compiler to raise
//    an error if a direct delete is performed; only the static method
//    C_GGS_Object::detachPointer may invoke delete.
  #ifndef DO_NOT_GENERATE_CHECKINGS
    protected : virtual ~cPtr_lexicalExpression (void) {}
  #endif

//--- Attributes
//--- Class message
  public : virtual const char * _message (void) const ;
  public : static const char * _static_message (void) ;

//--- Method for 'description' reader
  public : virtual void
  appendForDescription (C_Compiler & inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Galgas RTTI
  public : virtual AC_galgasClassRunTimeInformation * galgasRTTI (void) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@lexicalExplicitRuleList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_lexicalExplicitRuleList : public AC_galgas_list::cListElement {
//--- Attributes
  public : GGS_lexicalExpression  mLexicalRuleExpression ;
  public : GGS_lexicalInstructionList  mInstructionList ;
//--- Constructor
  public : elementOf_GGS_lexicalExplicitRuleList (const GGS_lexicalExpression & ,
                                const GGS_lexicalInstructionList & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline elementOf_GGS_lexicalExplicitRuleList * nextObject (void) const { return (elementOf_GGS_lexicalExplicitRuleList *) internalNextItem () ; }

//--- Access to previous
  public : inline elementOf_GGS_lexicalExplicitRuleList * previousObject (void) const { return (elementOf_GGS_lexicalExplicitRuleList *) internalPreviousItem () ; }

//--- Element comparison
  protected : virtual bool
  isEqualToObject (const cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Friend class declaration
  friend class GGS_lexicalExplicitRuleList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                abstract class 'cPtr_lexicalOrExpression'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalOrExpression : public cPtr_lexicalExpression {
  private : typedef cPtr_lexicalExpression inherited ;
//--- Constructor
  public : cPtr_lexicalOrExpression (const GGS_lexicalExpression & ,
                                const GGS_lexicalExpression & 
                                COMMA_LOCATION_ARGS) ;

//--- Declaring a protected virtual destructor enables the compiler to raise
//    an error if a direct delete is performed; only the static method
//    C_GGS_Object::detachPointer may invoke delete.
  #ifndef DO_NOT_GENERATE_CHECKINGS
    protected : virtual ~cPtr_lexicalOrExpression (void) {}
  #endif

//--- Attributes
  public : GGS_lexicalExpression  mLeftOperand ;
  public : GGS_lexicalExpression  mRightOperand ;
//--- Class message
  public : virtual const char * _message (void) const ;
  public : static const char * _static_message (void) ;

//--- Method for 'description' reader
  public : virtual void
  appendForDescription (C_Compiler & inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Comparison
  public : virtual bool
  isEqualToObject (const cPtr__AC_galgas_class * inOperand) const ;

//--- Galgas RTTI
  public : virtual AC_galgasClassRunTimeInformation * galgasRTTI (void) const ;

//--- Make clone
  public : virtual cPtr__AC_galgas_class * makeClone (void) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//              abstract class 'cPtr_lexicalCharacterSetMatch'               *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalCharacterSetMatch : public cPtr_lexicalExpression {
  private : typedef cPtr_lexicalExpression inherited ;
//--- Constructor
  public : cPtr_lexicalCharacterSetMatch (const GGS_lstring & 
                                COMMA_LOCATION_ARGS) ;

//--- Declaring a protected virtual destructor enables the compiler to raise
//    an error if a direct delete is performed; only the static method
//    C_GGS_Object::detachPointer may invoke delete.
  #ifndef DO_NOT_GENERATE_CHECKINGS
    protected : virtual ~cPtr_lexicalCharacterSetMatch (void) {}
  #endif

//--- Attributes
  public : GGS_lstring  mCharacterSetName ;
//--- Class message
  public : virtual const char * _message (void) const ;
  public : static const char * _static_message (void) ;

//--- Method for 'description' reader
  public : virtual void
  appendForDescription (C_Compiler & inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Comparison
  public : virtual bool
  isEqualToObject (const cPtr__AC_galgas_class * inOperand) const ;

//--- Galgas RTTI
  public : virtual AC_galgasClassRunTimeInformation * galgasRTTI (void) const ;

//--- Make clone
  public : virtual cPtr__AC_galgas_class * makeClone (void) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//               abstract class 'cPtr_lexicalCharacterMatch'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalCharacterMatch : public cPtr_lexicalExpression {
  private : typedef cPtr_lexicalExpression inherited ;
//--- Constructor
  public : cPtr_lexicalCharacterMatch (const GGS_lchar & 
                                COMMA_LOCATION_ARGS) ;

//--- Declaring a protected virtual destructor enables the compiler to raise
//    an error if a direct delete is performed; only the static method
//    C_GGS_Object::detachPointer may invoke delete.
  #ifndef DO_NOT_GENERATE_CHECKINGS
    protected : virtual ~cPtr_lexicalCharacterMatch (void) {}
  #endif

//--- Attributes
  public : GGS_lchar  mCharacter ;
//--- Class message
  public : virtual const char * _message (void) const ;
  public : static const char * _static_message (void) ;

//--- Method for 'description' reader
  public : virtual void
  appendForDescription (C_Compiler & inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Comparison
  public : virtual bool
  isEqualToObject (const cPtr__AC_galgas_class * inOperand) const ;

//--- Galgas RTTI
  public : virtual AC_galgasClassRunTimeInformation * galgasRTTI (void) const ;

//--- Make clone
  public : virtual cPtr__AC_galgas_class * makeClone (void) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//           abstract class 'cPtr_lexicalCharacterIntervalMatch'             *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalCharacterIntervalMatch : public cPtr_lexicalExpression {
  private : typedef cPtr_lexicalExpression inherited ;
//--- Constructor
  public : cPtr_lexicalCharacterIntervalMatch (const GGS_lchar & ,
                                const GGS_lchar & 
                                COMMA_LOCATION_ARGS) ;

//--- Declaring a protected virtual destructor enables the compiler to raise
//    an error if a direct delete is performed; only the static method
//    C_GGS_Object::detachPointer may invoke delete.
  #ifndef DO_NOT_GENERATE_CHECKINGS
    protected : virtual ~cPtr_lexicalCharacterIntervalMatch (void) {}
  #endif

//--- Attributes
  public : GGS_lchar  mLowerBound ;
  public : GGS_lchar  mUpperBound ;
//--- Class message
  public : virtual const char * _message (void) const ;
  public : static const char * _static_message (void) ;

//--- Method for 'description' reader
  public : virtual void
  appendForDescription (C_Compiler & inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Comparison
  public : virtual bool
  isEqualToObject (const cPtr__AC_galgas_class * inOperand) const ;

//--- Galgas RTTI
  public : virtual AC_galgasClassRunTimeInformation * galgasRTTI (void) const ;

//--- Make clone
  public : virtual cPtr__AC_galgas_class * makeClone (void) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_lexicalStringMatch'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalStringMatch : public cPtr_lexicalExpression {
  private : typedef cPtr_lexicalExpression inherited ;
//--- Constructor
  public : cPtr_lexicalStringMatch (const GGS_lstring & 
                                COMMA_LOCATION_ARGS) ;

//--- Declaring a protected virtual destructor enables the compiler to raise
//    an error if a direct delete is performed; only the static method
//    C_GGS_Object::detachPointer may invoke delete.
  #ifndef DO_NOT_GENERATE_CHECKINGS
    protected : virtual ~cPtr_lexicalStringMatch (void) {}
  #endif

//--- Attributes
  public : GGS_lstring  mString ;
//--- Class message
  public : virtual const char * _message (void) const ;
  public : static const char * _static_message (void) ;

//--- Method for 'description' reader
  public : virtual void
  appendForDescription (C_Compiler & inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Comparison
  public : virtual bool
  isEqualToObject (const cPtr__AC_galgas_class * inOperand) const ;

//--- Galgas RTTI
  public : virtual AC_galgasClassRunTimeInformation * galgasRTTI (void) const ;

//--- Make clone
  public : virtual cPtr__AC_galgas_class * makeClone (void) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//               abstract class 'cPtr_lexicalStringNotMatch'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalStringNotMatch : public cPtr_lexicalExpression {
  private : typedef cPtr_lexicalExpression inherited ;
//--- Constructor
  public : cPtr_lexicalStringNotMatch (const GGS_lstring & ,
                                const GGS_lstring & 
                                COMMA_LOCATION_ARGS) ;

//--- Declaring a protected virtual destructor enables the compiler to raise
//    an error if a direct delete is performed; only the static method
//    C_GGS_Object::detachPointer may invoke delete.
  #ifndef DO_NOT_GENERATE_CHECKINGS
    protected : virtual ~cPtr_lexicalStringNotMatch (void) {}
  #endif

//--- Attributes
  public : GGS_lstring  mString ;
  public : GGS_lstring  mErrorMessage ;
//--- Class message
  public : virtual const char * _message (void) const ;
  public : static const char * _static_message (void) ;

//--- Method for 'description' reader
  public : virtual void
  appendForDescription (C_Compiler & inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Comparison
  public : virtual bool
  isEqualToObject (const cPtr__AC_galgas_class * inOperand) const ;

//--- Galgas RTTI
  public : virtual AC_galgasClassRunTimeInformation * galgasRTTI (void) const ;

//--- Make clone
  public : virtual cPtr__AC_galgas_class * makeClone (void) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_lexicalInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalInstruction : public cPtr__AC_galgas_class {
//--- Constructor
  public : cPtr_lexicalInstruction (LOCATION_ARGS) ;

//--- Declaring a protected virtual destructor enables the compiler to raise
//    an error if a direct delete is performed; only the static method
//    C_GGS_Object::detachPointer may invoke delete.
  #ifndef DO_NOT_GENERATE_CHECKINGS
    protected : virtual ~cPtr_lexicalInstruction (void) {}
  #endif

//--- Attributes
//--- Class message
  public : virtual const char * _message (void) const ;
  public : static const char * _static_message (void) ;

//--- Method for 'description' reader
  public : virtual void
  appendForDescription (C_Compiler & inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Galgas RTTI
  public : virtual AC_galgasClassRunTimeInformation * galgasRTTI (void) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//              abstract class 'cPtr_lexicalSendDefaultAction'               *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalSendDefaultAction : public cPtr__AC_galgas_class {
//--- Constructor
  public : cPtr_lexicalSendDefaultAction (LOCATION_ARGS) ;

//--- Declaring a protected virtual destructor enables the compiler to raise
//    an error if a direct delete is performed; only the static method
//    C_GGS_Object::detachPointer may invoke delete.
  #ifndef DO_NOT_GENERATE_CHECKINGS
    protected : virtual ~cPtr_lexicalSendDefaultAction (void) {}
  #endif

//--- Attributes
//--- Class message
  public : virtual const char * _message (void) const ;
  public : static const char * _static_message (void) ;

//--- Method for 'description' reader
  public : virtual void
  appendForDescription (C_Compiler & inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Galgas RTTI
  public : virtual AC_galgasClassRunTimeInformation * galgasRTTI (void) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//          abstract class 'cPtr_lexicalStructuredSendInstruction'           *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalStructuredSendInstruction : public cPtr_lexicalInstruction {
  private : typedef cPtr_lexicalInstruction inherited ;
//--- Constructor
  public : cPtr_lexicalStructuredSendInstruction (const GGS_lexicalSendSearchList & ,
                                const GGS_lexicalSendDefaultAction & 
                                COMMA_LOCATION_ARGS) ;

//--- Declaring a protected virtual destructor enables the compiler to raise
//    an error if a direct delete is performed; only the static method
//    C_GGS_Object::detachPointer may invoke delete.
  #ifndef DO_NOT_GENERATE_CHECKINGS
    protected : virtual ~cPtr_lexicalStructuredSendInstruction (void) {}
  #endif

//--- Attributes
  public : GGS_lexicalSendSearchList  mLexicalSendSearchList ;
  public : GGS_lexicalSendDefaultAction  mLexicalSendDefaultAction ;
//--- Class message
  public : virtual const char * _message (void) const ;
  public : static const char * _static_message (void) ;

//--- Method for 'description' reader
  public : virtual void
  appendForDescription (C_Compiler & inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Comparison
  public : virtual bool
  isEqualToObject (const cPtr__AC_galgas_class * inOperand) const ;

//--- Galgas RTTI
  public : virtual AC_galgasClassRunTimeInformation * galgasRTTI (void) const ;

//--- Make clone
  public : virtual cPtr__AC_galgas_class * makeClone (void) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//            abstract class 'cPtr_lexicalSimpleSendInstruction'             *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalSimpleSendInstruction : public cPtr_lexicalInstruction {
  private : typedef cPtr_lexicalInstruction inherited ;
//--- Constructor
  public : cPtr_lexicalSimpleSendInstruction (const GGS_lstring & 
                                COMMA_LOCATION_ARGS) ;

//--- Declaring a protected virtual destructor enables the compiler to raise
//    an error if a direct delete is performed; only the static method
//    C_GGS_Object::detachPointer may invoke delete.
  #ifndef DO_NOT_GENERATE_CHECKINGS
    protected : virtual ~cPtr_lexicalSimpleSendInstruction (void) {}
  #endif

//--- Attributes
  public : GGS_lstring  mSentTerminal ;
//--- Class message
  public : virtual const char * _message (void) const ;
  public : static const char * _static_message (void) ;

//--- Method for 'description' reader
  public : virtual void
  appendForDescription (C_Compiler & inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Comparison
  public : virtual bool
  isEqualToObject (const cPtr__AC_galgas_class * inOperand) const ;

//--- Galgas RTTI
  public : virtual AC_galgasClassRunTimeInformation * galgasRTTI (void) const ;

//--- Make clone
  public : virtual cPtr__AC_galgas_class * makeClone (void) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//            abstract class 'cPtr_lexicalSendTerminalByDefault'             *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalSendTerminalByDefault : public cPtr_lexicalSendDefaultAction {
  private : typedef cPtr_lexicalSendDefaultAction inherited ;
//--- Constructor
  public : cPtr_lexicalSendTerminalByDefault (const GGS_lstring & 
                                COMMA_LOCATION_ARGS) ;

//--- Declaring a protected virtual destructor enables the compiler to raise
//    an error if a direct delete is performed; only the static method
//    C_GGS_Object::detachPointer may invoke delete.
  #ifndef DO_NOT_GENERATE_CHECKINGS
    protected : virtual ~cPtr_lexicalSendTerminalByDefault (void) {}
  #endif

//--- Attributes
  public : GGS_lstring  mDefaultSentTerminal ;
//--- Class message
  public : virtual const char * _message (void) const ;
  public : static const char * _static_message (void) ;

//--- Method for 'description' reader
  public : virtual void
  appendForDescription (C_Compiler & inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Comparison
  public : virtual bool
  isEqualToObject (const cPtr__AC_galgas_class * inOperand) const ;

//--- Galgas RTTI
  public : virtual AC_galgasClassRunTimeInformation * galgasRTTI (void) const ;

//--- Make clone
  public : virtual cPtr__AC_galgas_class * makeClone (void) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//               abstract class 'cPtr_lexicalErrorByDefault'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalErrorByDefault : public cPtr_lexicalSendDefaultAction {
  private : typedef cPtr_lexicalSendDefaultAction inherited ;
//--- Constructor
  public : cPtr_lexicalErrorByDefault (const GGS_lstring & 
                                COMMA_LOCATION_ARGS) ;

//--- Declaring a protected virtual destructor enables the compiler to raise
//    an error if a direct delete is performed; only the static method
//    C_GGS_Object::detachPointer may invoke delete.
  #ifndef DO_NOT_GENERATE_CHECKINGS
    protected : virtual ~cPtr_lexicalErrorByDefault (void) {}
  #endif

//--- Attributes
  public : GGS_lstring  mDefaultErrorMessageName ;
//--- Class message
  public : virtual const char * _message (void) const ;
  public : static const char * _static_message (void) ;

//--- Method for 'description' reader
  public : virtual void
  appendForDescription (C_Compiler & inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Comparison
  public : virtual bool
  isEqualToObject (const cPtr__AC_galgas_class * inOperand) const ;

//--- Galgas RTTI
  public : virtual AC_galgasClassRunTimeInformation * galgasRTTI (void) const ;

//--- Make clone
  public : virtual cPtr__AC_galgas_class * makeClone (void) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@lexicalSendSearchList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_lexicalSendSearchList : public AC_galgas_list::cListElement {
//--- Attributes
  public : GGS_lstring  mAttributeName ;
  public : GGS_lstring  mSearchListName ;
//--- Constructor
  public : elementOf_GGS_lexicalSendSearchList (const GGS_lstring & ,
                                const GGS_lstring & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline elementOf_GGS_lexicalSendSearchList * nextObject (void) const { return (elementOf_GGS_lexicalSendSearchList *) internalNextItem () ; }

//--- Access to previous
  public : inline elementOf_GGS_lexicalSendSearchList * previousObject (void) const { return (elementOf_GGS_lexicalSendSearchList *) internalPreviousItem () ; }

//--- Element comparison
  protected : virtual bool
  isEqualToObject (const cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Friend class declaration
  friend class GGS_lexicalSendSearchList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//              abstract class 'cPtr_lexicalRepeatInstruction'               *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalRepeatInstruction : public cPtr_lexicalInstruction {
  private : typedef cPtr_lexicalInstruction inherited ;
//--- Constructor
  public : cPtr_lexicalRepeatInstruction (const GGS_lexicalInstructionList & ,
                                const GGS_lexicalWhileBranchList & 
                                COMMA_LOCATION_ARGS) ;

//--- Declaring a protected virtual destructor enables the compiler to raise
//    an error if a direct delete is performed; only the static method
//    C_GGS_Object::detachPointer may invoke delete.
  #ifndef DO_NOT_GENERATE_CHECKINGS
    protected : virtual ~cPtr_lexicalRepeatInstruction (void) {}
  #endif

//--- Attributes
  public : GGS_lexicalInstructionList  mRepeatedInstructionList ;
  public : GGS_lexicalWhileBranchList  mLexicalWhileBranchList ;
//--- Class message
  public : virtual const char * _message (void) const ;
  public : static const char * _static_message (void) ;

//--- Method for 'description' reader
  public : virtual void
  appendForDescription (C_Compiler & inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Comparison
  public : virtual bool
  isEqualToObject (const cPtr__AC_galgas_class * inOperand) const ;

//--- Galgas RTTI
  public : virtual AC_galgasClassRunTimeInformation * galgasRTTI (void) const ;

//--- Make clone
  public : virtual cPtr__AC_galgas_class * makeClone (void) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@lexicalWhileBranchList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_lexicalWhileBranchList : public AC_galgas_list::cListElement {
//--- Attributes
  public : GGS_lexicalExpression  mWhileExpression ;
  public : GGS_lexicalInstructionList  mWhileInstructionList ;
//--- Constructor
  public : elementOf_GGS_lexicalWhileBranchList (const GGS_lexicalExpression & ,
                                const GGS_lexicalInstructionList & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline elementOf_GGS_lexicalWhileBranchList * nextObject (void) const { return (elementOf_GGS_lexicalWhileBranchList *) internalNextItem () ; }

//--- Access to previous
  public : inline elementOf_GGS_lexicalWhileBranchList * previousObject (void) const { return (elementOf_GGS_lexicalWhileBranchList *) internalPreviousItem () ; }

//--- Element comparison
  protected : virtual bool
  isEqualToObject (const cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Friend class declaration
  friend class GGS_lexicalWhileBranchList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//              abstract class 'cPtr_lexicalSelectInstruction'               *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalSelectInstruction : public cPtr_lexicalInstruction {
  private : typedef cPtr_lexicalInstruction inherited ;
//--- Constructor
  public : cPtr_lexicalSelectInstruction (const GGS_lexicalSelectBranchList & ,
                                const GGS_lexicalInstructionList & 
                                COMMA_LOCATION_ARGS) ;

//--- Declaring a protected virtual destructor enables the compiler to raise
//    an error if a direct delete is performed; only the static method
//    C_GGS_Object::detachPointer may invoke delete.
  #ifndef DO_NOT_GENERATE_CHECKINGS
    protected : virtual ~cPtr_lexicalSelectInstruction (void) {}
  #endif

//--- Attributes
  public : GGS_lexicalSelectBranchList  mLexicalWhileBranchList ;
  public : GGS_lexicalInstructionList  mDefaultInstructionList ;
//--- Class message
  public : virtual const char * _message (void) const ;
  public : static const char * _static_message (void) ;

//--- Method for 'description' reader
  public : virtual void
  appendForDescription (C_Compiler & inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Comparison
  public : virtual bool
  isEqualToObject (const cPtr__AC_galgas_class * inOperand) const ;

//--- Galgas RTTI
  public : virtual AC_galgasClassRunTimeInformation * galgasRTTI (void) const ;

//--- Make clone
  public : virtual cPtr__AC_galgas_class * makeClone (void) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@lexicalInstructionList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_lexicalInstructionList : public AC_galgas_list::cListElement {
//--- Attributes
  public : GGS_lexicalInstruction  mInstructionList ;
//--- Constructor
  public : elementOf_GGS_lexicalInstructionList (const GGS_lexicalInstruction & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline elementOf_GGS_lexicalInstructionList * nextObject (void) const { return (elementOf_GGS_lexicalInstructionList *) internalNextItem () ; }

//--- Access to previous
  public : inline elementOf_GGS_lexicalInstructionList * previousObject (void) const { return (elementOf_GGS_lexicalInstructionList *) internalPreviousItem () ; }

//--- Element comparison
  protected : virtual bool
  isEqualToObject (const cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Friend class declaration
  friend class GGS_lexicalInstructionList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@lexicalSelectBranchList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_lexicalSelectBranchList : public AC_galgas_list::cListElement {
//--- Attributes
  public : GGS_lexicalExpression  mSelectExpression ;
  public : GGS_lexicalInstructionList  mSelectInstructionList ;
//--- Constructor
  public : elementOf_GGS_lexicalSelectBranchList (const GGS_lexicalExpression & ,
                                const GGS_lexicalInstructionList & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline elementOf_GGS_lexicalSelectBranchList * nextObject (void) const { return (elementOf_GGS_lexicalSelectBranchList *) internalNextItem () ; }

//--- Access to previous
  public : inline elementOf_GGS_lexicalSelectBranchList * previousObject (void) const { return (elementOf_GGS_lexicalSelectBranchList *) internalPreviousItem () ; }

//--- Element comparison
  protected : virtual bool
  isEqualToObject (const cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Friend class declaration
  friend class GGS_lexicalSelectBranchList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//              abstract class 'cPtr_lexicalActionInstruction'               *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalActionInstruction : public cPtr_lexicalInstruction {
  private : typedef cPtr_lexicalInstruction inherited ;
//--- Constructor
  public : cPtr_lexicalActionInstruction (const GGS_lstring & ,
                                const GGS_lexicalRoutineCallActualArgumentList & ,
                                const GGS_lstringlist & 
                                COMMA_LOCATION_ARGS) ;

//--- Declaring a protected virtual destructor enables the compiler to raise
//    an error if a direct delete is performed; only the static method
//    C_GGS_Object::detachPointer may invoke delete.
  #ifndef DO_NOT_GENERATE_CHECKINGS
    protected : virtual ~cPtr_lexicalActionInstruction (void) {}
  #endif

//--- Attributes
  public : GGS_lstring  mActionName ;
  public : GGS_lexicalRoutineCallActualArgumentList  mActualArgumentList ;
  public : GGS_lstringlist  mErrorMessageList ;
//--- Class message
  public : virtual const char * _message (void) const ;
  public : static const char * _static_message (void) ;

//--- Method for 'description' reader
  public : virtual void
  appendForDescription (C_Compiler & inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Comparison
  public : virtual bool
  isEqualToObject (const cPtr__AC_galgas_class * inOperand) const ;

//--- Galgas RTTI
  public : virtual AC_galgasClassRunTimeInformation * galgasRTTI (void) const ;

//--- Make clone
  public : virtual cPtr__AC_galgas_class * makeClone (void) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//               abstract class 'cPtr_lexicalActualArgument'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalActualArgument : public cPtr__AC_galgas_class {
//--- Constructor
  public : cPtr_lexicalActualArgument (LOCATION_ARGS) ;

//--- Declaring a protected virtual destructor enables the compiler to raise
//    an error if a direct delete is performed; only the static method
//    C_GGS_Object::detachPointer may invoke delete.
  #ifndef DO_NOT_GENERATE_CHECKINGS
    protected : virtual ~cPtr_lexicalActualArgument (void) {}
  #endif

//--- Attributes
//--- Class message
  public : virtual const char * _message (void) const ;
  public : static const char * _static_message (void) ;

//--- Method for 'description' reader
  public : virtual void
  appendForDescription (C_Compiler & inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Galgas RTTI
  public : virtual AC_galgasClassRunTimeInformation * galgasRTTI (void) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//         Element of list '@lexicalRoutineCallActualArgumentList'           *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_lexicalRoutineCallActualArgumentList : public AC_galgas_list::cListElement {
//--- Attributes
  public : GGS_lexicalActualArgument  mLexicalActualArgument ;
//--- Constructor
  public : elementOf_GGS_lexicalRoutineCallActualArgumentList (const GGS_lexicalActualArgument & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline elementOf_GGS_lexicalRoutineCallActualArgumentList * nextObject (void) const { return (elementOf_GGS_lexicalRoutineCallActualArgumentList *) internalNextItem () ; }

//--- Access to previous
  public : inline elementOf_GGS_lexicalRoutineCallActualArgumentList * previousObject (void) const { return (elementOf_GGS_lexicalRoutineCallActualArgumentList *) internalPreviousItem () ; }

//--- Element comparison
  protected : virtual bool
  isEqualToObject (const cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Friend class declaration
  friend class GGS_lexicalRoutineCallActualArgumentList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//             abstract class 'cPtr_lexicalFormalInputArgument'              *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalFormalInputArgument : public cPtr_lexicalActualArgument {
  private : typedef cPtr_lexicalActualArgument inherited ;
//--- Constructor
  public : cPtr_lexicalFormalInputArgument (LOCATION_ARGS) ;

//--- Declaring a protected virtual destructor enables the compiler to raise
//    an error if a direct delete is performed; only the static method
//    C_GGS_Object::detachPointer may invoke delete.
  #ifndef DO_NOT_GENERATE_CHECKINGS
    protected : virtual ~cPtr_lexicalFormalInputArgument (void) {}
  #endif

//--- Attributes
//--- Class message
  public : virtual const char * _message (void) const ;
  public : static const char * _static_message (void) ;

//--- Method for 'description' reader
  public : virtual void
  appendForDescription (C_Compiler & inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Galgas RTTI
  public : virtual AC_galgasClassRunTimeInformation * galgasRTTI (void) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//         Element of list '@lexicalFunctionCallActualArgumentList'          *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_lexicalFunctionCallActualArgumentList : public AC_galgas_list::cListElement {
//--- Attributes
  public : GGS_lexicalFormalInputArgument  mLexicalActualInputArgument ;
//--- Constructor
  public : elementOf_GGS_lexicalFunctionCallActualArgumentList (const GGS_lexicalFormalInputArgument & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline elementOf_GGS_lexicalFunctionCallActualArgumentList * nextObject (void) const { return (elementOf_GGS_lexicalFunctionCallActualArgumentList *) internalNextItem () ; }

//--- Access to previous
  public : inline elementOf_GGS_lexicalFunctionCallActualArgumentList * previousObject (void) const { return (elementOf_GGS_lexicalFunctionCallActualArgumentList *) internalPreviousItem () ; }

//--- Element comparison
  protected : virtual bool
  isEqualToObject (const cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Friend class declaration
  friend class GGS_lexicalFunctionCallActualArgumentList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//        abstract class 'cPtr_lexicalAttributeInputOutputArgument'          *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalAttributeInputOutputArgument : public cPtr_lexicalFormalInputArgument {
  private : typedef cPtr_lexicalFormalInputArgument inherited ;
//--- Constructor
  public : cPtr_lexicalAttributeInputOutputArgument (const GGS_lstring & 
                                COMMA_LOCATION_ARGS) ;

//--- Declaring a protected virtual destructor enables the compiler to raise
//    an error if a direct delete is performed; only the static method
//    C_GGS_Object::detachPointer may invoke delete.
  #ifndef DO_NOT_GENERATE_CHECKINGS
    protected : virtual ~cPtr_lexicalAttributeInputOutputArgument (void) {}
  #endif

//--- Attributes
  public : GGS_lstring  mAttributeName ;
//--- Class message
  public : virtual const char * _message (void) const ;
  public : static const char * _static_message (void) ;

//--- Method for 'description' reader
  public : virtual void
  appendForDescription (C_Compiler & inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Comparison
  public : virtual bool
  isEqualToObject (const cPtr__AC_galgas_class * inOperand) const ;

//--- Galgas RTTI
  public : virtual AC_galgasClassRunTimeInformation * galgasRTTI (void) const ;

//--- Make clone
  public : virtual cPtr__AC_galgas_class * makeClone (void) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//           abstract class 'cPtr_lexicalAttributeInputArgument'             *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalAttributeInputArgument : public cPtr_lexicalFormalInputArgument {
  private : typedef cPtr_lexicalFormalInputArgument inherited ;
//--- Constructor
  public : cPtr_lexicalAttributeInputArgument (const GGS_lstring & 
                                COMMA_LOCATION_ARGS) ;

//--- Declaring a protected virtual destructor enables the compiler to raise
//    an error if a direct delete is performed; only the static method
//    C_GGS_Object::detachPointer may invoke delete.
  #ifndef DO_NOT_GENERATE_CHECKINGS
    protected : virtual ~cPtr_lexicalAttributeInputArgument (void) {}
  #endif

//--- Attributes
  public : GGS_lstring  mAttributeName ;
//--- Class message
  public : virtual const char * _message (void) const ;
  public : static const char * _static_message (void) ;

//--- Method for 'description' reader
  public : virtual void
  appendForDescription (C_Compiler & inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Comparison
  public : virtual bool
  isEqualToObject (const cPtr__AC_galgas_class * inOperand) const ;

//--- Galgas RTTI
  public : virtual AC_galgasClassRunTimeInformation * galgasRTTI (void) const ;

//--- Make clone
  public : virtual cPtr__AC_galgas_class * makeClone (void) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//           abstract class 'cPtr_lexicalCharacterInputArgument'             *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalCharacterInputArgument : public cPtr_lexicalFormalInputArgument {
  private : typedef cPtr_lexicalFormalInputArgument inherited ;
//--- Constructor
  public : cPtr_lexicalCharacterInputArgument (const GGS_lchar & 
                                COMMA_LOCATION_ARGS) ;

//--- Declaring a protected virtual destructor enables the compiler to raise
//    an error if a direct delete is performed; only the static method
//    C_GGS_Object::detachPointer may invoke delete.
  #ifndef DO_NOT_GENERATE_CHECKINGS
    protected : virtual ~cPtr_lexicalCharacterInputArgument (void) {}
  #endif

//--- Attributes
  public : GGS_lchar  mCharacter ;
//--- Class message
  public : virtual const char * _message (void) const ;
  public : static const char * _static_message (void) ;

//--- Method for 'description' reader
  public : virtual void
  appendForDescription (C_Compiler & inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Comparison
  public : virtual bool
  isEqualToObject (const cPtr__AC_galgas_class * inOperand) const ;

//--- Galgas RTTI
  public : virtual AC_galgasClassRunTimeInformation * galgasRTTI (void) const ;

//--- Make clone
  public : virtual cPtr__AC_galgas_class * makeClone (void) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//        abstract class 'cPtr_lexicalCurrentCharacterInputArgument'         *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalCurrentCharacterInputArgument : public cPtr_lexicalFormalInputArgument {
  private : typedef cPtr_lexicalFormalInputArgument inherited ;
//--- Constructor
  public : cPtr_lexicalCurrentCharacterInputArgument (LOCATION_ARGS) ;

//--- Declaring a protected virtual destructor enables the compiler to raise
//    an error if a direct delete is performed; only the static method
//    C_GGS_Object::detachPointer may invoke delete.
  #ifndef DO_NOT_GENERATE_CHECKINGS
    protected : virtual ~cPtr_lexicalCurrentCharacterInputArgument (void) {}
  #endif

//--- Attributes
//--- Class message
  public : virtual const char * _message (void) const ;
  public : static const char * _static_message (void) ;

//--- Method for 'description' reader
  public : virtual void
  appendForDescription (C_Compiler & inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Comparison
  public : virtual bool
  isEqualToObject (const cPtr__AC_galgas_class * inOperand) const ;

//--- Galgas RTTI
  public : virtual AC_galgasClassRunTimeInformation * galgasRTTI (void) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//            abstract class 'cPtr_lexicalFunctionInputArgument'             *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalFunctionInputArgument : public cPtr_lexicalFormalInputArgument {
  private : typedef cPtr_lexicalFormalInputArgument inherited ;
//--- Constructor
  public : cPtr_lexicalFunctionInputArgument (const GGS_lstring & ,
                                const GGS_lexicalFunctionCallActualArgumentList & 
                                COMMA_LOCATION_ARGS) ;

//--- Declaring a protected virtual destructor enables the compiler to raise
//    an error if a direct delete is performed; only the static method
//    C_GGS_Object::detachPointer may invoke delete.
  #ifndef DO_NOT_GENERATE_CHECKINGS
    protected : virtual ~cPtr_lexicalFunctionInputArgument (void) {}
  #endif

//--- Attributes
  public : GGS_lstring  mFunctionName ;
  public : GGS_lexicalFunctionCallActualArgumentList  mFunctionActualArgumentList ;
//--- Class message
  public : virtual const char * _message (void) const ;
  public : static const char * _static_message (void) ;

//--- Method for 'description' reader
  public : virtual void
  appendForDescription (C_Compiler & inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Comparison
  public : virtual bool
  isEqualToObject (const cPtr__AC_galgas_class * inOperand) const ;

//--- Galgas RTTI
  public : virtual AC_galgasClassRunTimeInformation * galgasRTTI (void) const ;

//--- Make clone
  public : virtual cPtr__AC_galgas_class * makeClone (void) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//               abstract class 'cPtr_lexicalDropInstruction'                *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalDropInstruction : public cPtr_lexicalInstruction {
  private : typedef cPtr_lexicalInstruction inherited ;
//--- Constructor
  public : cPtr_lexicalDropInstruction (const GGS_lstring & 
                                COMMA_LOCATION_ARGS) ;

//--- Declaring a protected virtual destructor enables the compiler to raise
//    an error if a direct delete is performed; only the static method
//    C_GGS_Object::detachPointer may invoke delete.
  #ifndef DO_NOT_GENERATE_CHECKINGS
    protected : virtual ~cPtr_lexicalDropInstruction (void) {}
  #endif

//--- Attributes
  public : GGS_lstring  mTerminalName ;
//--- Class message
  public : virtual const char * _message (void) const ;
  public : static const char * _static_message (void) ;

//--- Method for 'description' reader
  public : virtual void
  appendForDescription (C_Compiler & inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Comparison
  public : virtual bool
  isEqualToObject (const cPtr__AC_galgas_class * inOperand) const ;

//--- Galgas RTTI
  public : virtual AC_galgasClassRunTimeInformation * galgasRTTI (void) const ;

//--- Make clone
  public : virtual cPtr__AC_galgas_class * makeClone (void) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//              abstract class 'cPtr_lexicalErrorInstruction'                *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalErrorInstruction : public cPtr_lexicalInstruction {
  private : typedef cPtr_lexicalInstruction inherited ;
//--- Constructor
  public : cPtr_lexicalErrorInstruction (const GGS_lstring & 
                                COMMA_LOCATION_ARGS) ;

//--- Declaring a protected virtual destructor enables the compiler to raise
//    an error if a direct delete is performed; only the static method
//    C_GGS_Object::detachPointer may invoke delete.
  #ifndef DO_NOT_GENERATE_CHECKINGS
    protected : virtual ~cPtr_lexicalErrorInstruction (void) {}
  #endif

//--- Attributes
  public : GGS_lstring  mErrorMessageName ;
//--- Class message
  public : virtual const char * _message (void) const ;
  public : static const char * _static_message (void) ;

//--- Method for 'description' reader
  public : virtual void
  appendForDescription (C_Compiler & inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Comparison
  public : virtual bool
  isEqualToObject (const cPtr__AC_galgas_class * inOperand) const ;

//--- Galgas RTTI
  public : virtual AC_galgasClassRunTimeInformation * galgasRTTI (void) const ;

//--- Make clone
  public : virtual cPtr__AC_galgas_class * makeClone (void) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//             abstract class 'cPtr_lexicalWarningInstruction'               *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalWarningInstruction : public cPtr_lexicalInstruction {
  private : typedef cPtr_lexicalInstruction inherited ;
//--- Constructor
  public : cPtr_lexicalWarningInstruction (const GGS_lstring & 
                                COMMA_LOCATION_ARGS) ;

//--- Declaring a protected virtual destructor enables the compiler to raise
//    an error if a direct delete is performed; only the static method
//    C_GGS_Object::detachPointer may invoke delete.
  #ifndef DO_NOT_GENERATE_CHECKINGS
    protected : virtual ~cPtr_lexicalWarningInstruction (void) {}
  #endif

//--- Attributes
  public : GGS_lstring  mWarningMessageName ;
//--- Class message
  public : virtual const char * _message (void) const ;
  public : static const char * _static_message (void) ;

//--- Method for 'description' reader
  public : virtual void
  appendForDescription (C_Compiler & inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Comparison
  public : virtual bool
  isEqualToObject (const cPtr__AC_galgas_class * inOperand) const ;

//--- Galgas RTTI
  public : virtual AC_galgasClassRunTimeInformation * galgasRTTI (void) const ;

//--- Make clone
  public : virtual cPtr__AC_galgas_class * makeClone (void) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//               abstract class 'cPtr_lexicalTagInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalTagInstruction : public cPtr_lexicalInstruction {
  private : typedef cPtr_lexicalInstruction inherited ;
//--- Constructor
  public : cPtr_lexicalTagInstruction (const GGS_lstring & 
                                COMMA_LOCATION_ARGS) ;

//--- Declaring a protected virtual destructor enables the compiler to raise
//    an error if a direct delete is performed; only the static method
//    C_GGS_Object::detachPointer may invoke delete.
  #ifndef DO_NOT_GENERATE_CHECKINGS
    protected : virtual ~cPtr_lexicalTagInstruction (void) {}
  #endif

//--- Attributes
  public : GGS_lstring  mTagName ;
//--- Class message
  public : virtual const char * _message (void) const ;
  public : static const char * _static_message (void) ;

//--- Method for 'description' reader
  public : virtual void
  appendForDescription (C_Compiler & inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Comparison
  public : virtual bool
  isEqualToObject (const cPtr__AC_galgas_class * inOperand) const ;

//--- Galgas RTTI
  public : virtual AC_galgasClassRunTimeInformation * galgasRTTI (void) const ;

//--- Make clone
  public : virtual cPtr__AC_galgas_class * makeClone (void) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//              abstract class 'cPtr_lexicalRewindInstruction'               *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalRewindInstruction : public cPtr_lexicalInstruction {
  private : typedef cPtr_lexicalInstruction inherited ;
//--- Constructor
  public : cPtr_lexicalRewindInstruction (const GGS_lstring & ,
                                const GGS_lstring & 
                                COMMA_LOCATION_ARGS) ;

//--- Declaring a protected virtual destructor enables the compiler to raise
//    an error if a direct delete is performed; only the static method
//    C_GGS_Object::detachPointer may invoke delete.
  #ifndef DO_NOT_GENERATE_CHECKINGS
    protected : virtual ~cPtr_lexicalRewindInstruction (void) {}
  #endif

//--- Attributes
  public : GGS_lstring  mTagName ;
  public : GGS_lstring  mTerminalName ;
//--- Class message
  public : virtual const char * _message (void) const ;
  public : static const char * _static_message (void) ;

//--- Method for 'description' reader
  public : virtual void
  appendForDescription (C_Compiler & inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Comparison
  public : virtual bool
  isEqualToObject (const cPtr__AC_galgas_class * inOperand) const ;

//--- Galgas RTTI
  public : virtual AC_galgasClassRunTimeInformation * galgasRTTI (void) const ;

//--- Make clone
  public : virtual cPtr__AC_galgas_class * makeClone (void) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//               abstract class 'cPtr_lexicalLogInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalLogInstruction : public cPtr_lexicalInstruction {
  private : typedef cPtr_lexicalInstruction inherited ;
//--- Constructor
  public : cPtr_lexicalLogInstruction (LOCATION_ARGS) ;

//--- Declaring a protected virtual destructor enables the compiler to raise
//    an error if a direct delete is performed; only the static method
//    C_GGS_Object::detachPointer may invoke delete.
  #ifndef DO_NOT_GENERATE_CHECKINGS
    protected : virtual ~cPtr_lexicalLogInstruction (void) {}
  #endif

//--- Attributes
//--- Class message
  public : virtual const char * _message (void) const ;
  public : static const char * _static_message (void) ;

//--- Method for 'description' reader
  public : virtual void
  appendForDescription (C_Compiler & inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Comparison
  public : virtual bool
  isEqualToObject (const cPtr__AC_galgas_class * inOperand) const ;

//--- Galgas RTTI
  public : virtual AC_galgasClassRunTimeInformation * galgasRTTI (void) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                abstract class 'cPtr_lexiqueComponentRoot'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexiqueComponentRoot : public cPtr__AC_galgas_class {
//--- Constructor
  public : cPtr_lexiqueComponentRoot (const GGS_lstring & ,
                                const GGS_bool& ,
                                const GGS_templateDelimitorList & ,
                                const GGS_templateReplacementList & ,
                                const GGS_lexicalAttributeList & ,
                                const GGS_lexicalStyleList & ,
                                const GGS_terminalDeclarationList & ,
                                const GGS_lexicalErrorMessageDeclarationList & ,
                                const GGS_lexicalListDeclarationList & ,
                                const GGS_lexicalImplicitRuleList & ,
                                const GGS_lexicalExplicitRuleList & 
                                COMMA_LOCATION_ARGS) ;

//--- Declaring a protected virtual destructor enables the compiler to raise
//    an error if a direct delete is performed; only the static method
//    C_GGS_Object::detachPointer may invoke delete.
  #ifndef DO_NOT_GENERATE_CHECKINGS
    protected : virtual ~cPtr_lexiqueComponentRoot (void) {}
  #endif

//--- Attributes
  public : GGS_lstring  mLexiqueComponentName ;
  public : GGS_bool mIsTemplate ;
  public : GGS_templateDelimitorList  mTemplateDelimitorList ;
  public : GGS_templateReplacementList  mTemplateReplacementList ;
  public : GGS_lexicalAttributeList  mLexicalAttributeList ;
  public : GGS_lexicalStyleList  mLexicalStyleList ;
  public : GGS_terminalDeclarationList  mTerminalDeclarationList ;
  public : GGS_lexicalErrorMessageDeclarationList  mLexicalErrorMessageDeclarationList ;
  public : GGS_lexicalListDeclarationList  mLexicalListDeclarationList ;
  public : GGS_lexicalImplicitRuleList  mLexicalImplicitRuleList ;
  public : GGS_lexicalExplicitRuleList  mLexicalExplicitRuleList ;
//--- Class message
  public : virtual const char * _message (void) const ;
  public : static const char * _static_message (void) ;

//--- Method for 'description' reader
  public : virtual void
  appendForDescription (C_Compiler & inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Comparison
  public : virtual bool
  isEqualToObject (const cPtr__AC_galgas_class * inOperand) const ;

//--- Galgas RTTI
  public : virtual AC_galgasClassRunTimeInformation * galgasRTTI (void) const ;

//--- Make clone
  public : virtual cPtr__AC_galgas_class * makeClone (void) const ;
} ;

//---------------------------------------------------------------------------*

#endif
