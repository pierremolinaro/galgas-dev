//---------------------------------------------------------------------------*
//                                                                           *
//                        File 'lexiqueMetamodel.h'                          *
//         Generated by version GALGAS_BETA_VERSION (LL(1) grammar)          *
//                       june 1st, 2007, at 21h20'3"                         *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

#ifndef lexiqueMetamodel_METAMODEL_DEFINED
#define lexiqueMetamodel_METAMODEL_DEFINED

#include <string.h>

//---------------------------------------------------------------------------*

#include "galgas/predefined_types.h"

//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*

uint32 _metamodel_index_for_lexiqueMetamodel (void) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                          Class Predeclarations                            *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexiqueComponentRootList ;
class GGS_lexiqueComponentRoot ;
class cPtr_lexiqueComponentRoot ;
class GGS_lexicalImplicitRuleList ;
class GGS_lexicalImplicitRule ;
class cPtr_lexicalImplicitRule ;
class GGS_lexicalErrorMessageDeclarationList ;
class GGS_lexicalErrorMessageDeclaration ;
class cPtr_lexicalErrorMessageDeclaration ;
class GGS_lexicalAttributeList ;
class GGS_lexicalAttribute ;
class cPtr_lexicalAttribute ;
class GGS_lexicalStyleList ;
class GGS_lexicalStyle ;
class cPtr_lexicalStyle ;
class GGS_terminalDeclarationList ;
class GGS_terminalDeclaration ;
class cPtr_terminalDeclaration ;
class GGS_lexicalListDeclarationList ;
class GGS_lexicalListDeclaration ;
class cPtr_lexicalListDeclaration ;
class GGS_lexicalListEntryList ;
class GGS_lexicalListEntry ;
class cPtr_lexicalListEntry ;
class GGS_lexicalExplicitRuleList ;
class GGS_lexicalExplicitRule ;
class cPtr_lexicalExplicitRule ;
class GGS_lexicalExpressionList ;
class GGS_lexicalExpression ;
class cPtr_lexicalExpression ;
class GGS_lexicalOrExpressionList ;
class GGS_lexicalOrExpression ;
class cPtr_lexicalOrExpression ;
class GGS_lexicalCharacterMatchList ;
class GGS_lexicalCharacterMatch ;
class cPtr_lexicalCharacterMatch ;
class GGS_lexicalCharacterIntervalMatchList ;
class GGS_lexicalCharacterIntervalMatch ;
class cPtr_lexicalCharacterIntervalMatch ;
class GGS_lexicalStringMatchList ;
class GGS_lexicalStringMatch ;
class cPtr_lexicalStringMatch ;
class GGS_lexicalStringNotMatchList ;
class GGS_lexicalStringNotMatch ;
class cPtr_lexicalStringNotMatch ;
class GGS_lexicalInstructionList ;
class GGS_lexicalInstruction ;
class cPtr_lexicalInstruction ;
class GGS_lexicalStructuredSendInstructionList ;
class GGS_lexicalStructuredSendInstruction ;
class cPtr_lexicalStructuredSendInstruction ;
class GGS_lexicalSimpleSendInstructionList ;
class GGS_lexicalSimpleSendInstruction ;
class cPtr_lexicalSimpleSendInstruction ;
class GGS_lexicalSendDefaultActionList ;
class GGS_lexicalSendDefaultAction ;
class cPtr_lexicalSendDefaultAction ;
class GGS_lexicalSendTerminalByDefaultList ;
class GGS_lexicalSendTerminalByDefault ;
class cPtr_lexicalSendTerminalByDefault ;
class GGS_lexicalErrorByDefaultList ;
class GGS_lexicalErrorByDefault ;
class cPtr_lexicalErrorByDefault ;
class GGS_lexicalSendSearchList ;
class GGS_lexicalSendSearch ;
class cPtr_lexicalSendSearch ;
class GGS_lexicalRepeatInstructionList ;
class GGS_lexicalRepeatInstruction ;
class cPtr_lexicalRepeatInstruction ;
class GGS_lexicalWhileBranchList ;
class GGS_lexicalWhileBranch ;
class cPtr_lexicalWhileBranch ;
class GGS_lexicalSelectInstructionList ;
class GGS_lexicalSelectInstruction ;
class cPtr_lexicalSelectInstruction ;
class GGS_lexicalSelectBranchList ;
class GGS_lexicalSelectBranch ;
class cPtr_lexicalSelectBranch ;
class GGS_lexicalActionInstructionList ;
class GGS_lexicalActionInstruction ;
class cPtr_lexicalActionInstruction ;
class GGS_lexicalActualArgumentList ;
class GGS_lexicalActualArgument ;
class cPtr_lexicalActualArgument ;
class GGS_lexicalAttributeArgumentList ;
class GGS_lexicalAttributeArgument ;
class cPtr_lexicalAttributeArgument ;
class GGS_lexicalCharacterArgumentList ;
class GGS_lexicalCharacterArgument ;
class cPtr_lexicalCharacterArgument ;
class GGS_lexicalCurrentCharacterArgumentList ;
class GGS_lexicalCurrentCharacterArgument ;
class cPtr_lexicalCurrentCharacterArgument ;
class GGS_lexicalFunctionArgumentList ;
class GGS_lexicalFunctionArgument ;
class cPtr_lexicalFunctionArgument ;
class GGS_lexicalDropInstructionList ;
class GGS_lexicalDropInstruction ;
class cPtr_lexicalDropInstruction ;
class GGS_lexicalErrorInstructionList ;
class GGS_lexicalErrorInstruction ;
class cPtr_lexicalErrorInstruction ;
class GGS_lexicalTagInstructionList ;
class GGS_lexicalTagInstruction ;
class cPtr_lexicalTagInstruction ;
class GGS_lexicalRewindInstructionList ;
class GGS_lexicalRewindInstruction ;
class cPtr_lexicalRewindInstruction ;
class GGS_lexicalLogInstructionList ;
class GGS_lexicalLogInstruction ;
class cPtr_lexicalLogInstruction ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_lexiqueComponentRoot'                   *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexiqueComponentRoot : public AC_galgas_entity {
//--- 'new' constructor
  public : static GGS_lexiqueComponentRoot constructor_new (C_Compiler & inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lexicalAttributeList & argument_1,
                                const GGS_lexicalStyleList & argument_2,
                                const GGS_terminalDeclarationList & argument_3,
                                const GGS_lexicalErrorMessageDeclarationList & argument_4,
                                const GGS_lexicalListDeclarationList & argument_5,
                                const GGS_lexicalImplicitRuleList & argument_6,
                                const GGS_lexicalExplicitRuleList & argument_7
                                COMMA_LOCATION_ARGS) ;
//--- getPtr
  public : inline cPtr_lexiqueComponentRoot * getPtr (void) const {
    return (cPtr_lexiqueComponentRoot *) mPointer ;
  }

//--- 'description' reader
  public : virtual const char * actualTypeName (void) const ;

//--- Readers
  public : GGS_lstring  reader_mLexiqueComponentName (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_lexicalAttributeList  reader_mLexicalAttributeList (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_lexicalStyleList  reader_mLexicalStyleList (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_terminalDeclarationList  reader_mTerminalDeclarationList (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_lexicalErrorMessageDeclarationList  reader_mLexicalErrorMessageDeclarationList (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_lexicalListDeclarationList  reader_mLexicalListDeclarationList (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_lexicalImplicitRuleList  reader_mLexicalImplicitRuleList (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_lexicalExplicitRuleList  reader_mLexicalExplicitRuleList (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexiqueComponentRoot * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexiqueComponentRoot * operator () (void) const {
      return (cPtr_lexiqueComponentRoot *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     list '@lexiqueComponentRootList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexiqueComponentRootList : public AC_galgas_list {
  public : typedef cPtr_lexiqueComponentRoot element_type ;
//--- Constructor 'emptyList'
  public : static GGS_lexiqueComponentRootList constructor_emptyList (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_lexiqueComponentRootList constructor_listWithValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lexicalAttributeList & argument_1,
                                const GGS_lexicalStyleList & argument_2,
                                const GGS_terminalDeclarationList & argument_3,
                                const GGS_lexicalErrorMessageDeclarationList & argument_4,
                                const GGS_lexicalListDeclarationList & argument_5,
                                const GGS_lexicalImplicitRuleList & argument_6,
                                const GGS_lexicalExplicitRuleList & argument_7
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operator () used for method call
  public : inline const GGS_lexiqueComponentRootList * operator () (UNUSED_LOCATION_ARGS) const { return this ;}

//--- Method 'first'
/*  public : void method_first (C_Compiler & _inLexique,
                              GGS_lexiqueComponentRoot & outElement
                              COMMA_LOCATION_ARGS) const ; */
//--- Method 'last'
/*  public : void method_last (C_Compiler & _inLexique,
                             GGS_lexiqueComponentRoot & outElement
                             COMMA_LOCATION_ARGS) const ; */
//--- Modifier 'popLast'
/*  public : void modifier_popLast (C_Compiler & _inLexique,
                                  GGS_lexiqueComponentRoot & outElement
                                  COMMA_LOCATION_ARGS) ; */
//--- Modifier 'popFirst'
/*  public : void modifier_popFirst (C_Compiler & _inLexique,
                                   GGS_lexiqueComponentRoot & outElement
                                   COMMA_LOCATION_ARGS) ; */
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lexiqueComponentRoot & inElement) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexiqueComponentRootList _operator_concat (const GGS_lexiqueComponentRootList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lexicalAttributeList & argument_1,
                                const GGS_lexicalStyleList & argument_2,
                                const GGS_terminalDeclarationList & argument_3,
                                const GGS_lexicalErrorMessageDeclarationList & argument_4,
                                const GGS_lexicalListDeclarationList & argument_5,
                                const GGS_lexicalImplicitRuleList & argument_6,
                                const GGS_lexicalExplicitRuleList & argument_7
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lstring & argument_0,
                                const GGS_lexicalAttributeList & argument_1,
                                const GGS_lexicalStyleList & argument_2,
                                const GGS_terminalDeclarationList & argument_3,
                                const GGS_lexicalErrorMessageDeclarationList & argument_4,
                                const GGS_lexicalListDeclarationList & argument_5,
                                const GGS_lexicalImplicitRuleList & argument_6,
                                const GGS_lexicalExplicitRuleList & argument_7) ;

  protected : void _internalPrependValues (const GGS_lstring & argument_0,
                                const GGS_lexicalAttributeList & argument_1,
                                const GGS_lexicalStyleList & argument_2,
                                const GGS_terminalDeclarationList & argument_3,
                                const GGS_lexicalErrorMessageDeclarationList & argument_4,
                                const GGS_lexicalListDeclarationList & argument_5,
                                const GGS_lexicalImplicitRuleList & argument_6,
                                const GGS_lexicalExplicitRuleList & argument_7) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & _inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--- Metamodel Add method
  public : void _addModel (const GGS_lexiqueComponentRoot & inOperand) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_lexicalImplicitRule'                   *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalImplicitRule : public AC_galgas_entity {
//--- 'new' constructor
  public : static GGS_lexicalImplicitRule constructor_new (C_Compiler & inLexique,
                                const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- getPtr
  public : inline cPtr_lexicalImplicitRule * getPtr (void) const {
    return (cPtr_lexicalImplicitRule *) mPointer ;
  }

//--- 'description' reader
  public : virtual const char * actualTypeName (void) const ;

//--- Readers
  public : GGS_lstring  reader_mListName (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalImplicitRule * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalImplicitRule * operator () (void) const {
      return (cPtr_lexicalImplicitRule *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     list '@lexicalImplicitRuleList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalImplicitRuleList : public AC_galgas_list {
  public : typedef cPtr_lexicalImplicitRule element_type ;
//--- Constructor 'emptyList'
  public : static GGS_lexicalImplicitRuleList constructor_emptyList (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_lexicalImplicitRuleList constructor_listWithValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operator () used for method call
  public : inline const GGS_lexicalImplicitRuleList * operator () (UNUSED_LOCATION_ARGS) const { return this ;}

//--- Method 'first'
/*  public : void method_first (C_Compiler & _inLexique,
                              GGS_lexicalImplicitRule & outElement
                              COMMA_LOCATION_ARGS) const ; */
//--- Method 'last'
/*  public : void method_last (C_Compiler & _inLexique,
                             GGS_lexicalImplicitRule & outElement
                             COMMA_LOCATION_ARGS) const ; */
//--- Modifier 'popLast'
/*  public : void modifier_popLast (C_Compiler & _inLexique,
                                  GGS_lexicalImplicitRule & outElement
                                  COMMA_LOCATION_ARGS) ; */
//--- Modifier 'popFirst'
/*  public : void modifier_popFirst (C_Compiler & _inLexique,
                                   GGS_lexicalImplicitRule & outElement
                                   COMMA_LOCATION_ARGS) ; */
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lexicalImplicitRule & inElement) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalImplicitRuleList _operator_concat (const GGS_lexicalImplicitRuleList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lstring & argument_0) ;

  protected : void _internalPrependValues (const GGS_lstring & argument_0) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & _inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--- Metamodel Add method
  public : void _addModel (const GGS_lexicalImplicitRule & inOperand) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_lexicalErrorMessageDeclaration'              *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalErrorMessageDeclaration : public AC_galgas_entity {
//--- 'new' constructor
  public : static GGS_lexicalErrorMessageDeclaration constructor_new (C_Compiler & inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- getPtr
  public : inline cPtr_lexicalErrorMessageDeclaration * getPtr (void) const {
    return (cPtr_lexicalErrorMessageDeclaration *) mPointer ;
  }

//--- 'description' reader
  public : virtual const char * actualTypeName (void) const ;

//--- Readers
  public : GGS_lstring  reader_mMessageName (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_lstring  reader_mMessageValue (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalErrorMessageDeclaration * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalErrorMessageDeclaration * operator () (void) const {
      return (cPtr_lexicalErrorMessageDeclaration *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                list '@lexicalErrorMessageDeclarationList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalErrorMessageDeclarationList : public AC_galgas_list {
  public : typedef cPtr_lexicalErrorMessageDeclaration element_type ;
//--- Constructor 'emptyList'
  public : static GGS_lexicalErrorMessageDeclarationList constructor_emptyList (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_lexicalErrorMessageDeclarationList constructor_listWithValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operator () used for method call
  public : inline const GGS_lexicalErrorMessageDeclarationList * operator () (UNUSED_LOCATION_ARGS) const { return this ;}

//--- Method 'first'
/*  public : void method_first (C_Compiler & _inLexique,
                              GGS_lexicalErrorMessageDeclaration & outElement
                              COMMA_LOCATION_ARGS) const ; */
//--- Method 'last'
/*  public : void method_last (C_Compiler & _inLexique,
                             GGS_lexicalErrorMessageDeclaration & outElement
                             COMMA_LOCATION_ARGS) const ; */
//--- Modifier 'popLast'
/*  public : void modifier_popLast (C_Compiler & _inLexique,
                                  GGS_lexicalErrorMessageDeclaration & outElement
                                  COMMA_LOCATION_ARGS) ; */
//--- Modifier 'popFirst'
/*  public : void modifier_popFirst (C_Compiler & _inLexique,
                                   GGS_lexicalErrorMessageDeclaration & outElement
                                   COMMA_LOCATION_ARGS) ; */
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lexicalErrorMessageDeclaration & inElement) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalErrorMessageDeclarationList _operator_concat (const GGS_lexicalErrorMessageDeclarationList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) ;

  protected : void _internalPrependValues (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & _inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--- Metamodel Add method
  public : void _addModel (const GGS_lexicalErrorMessageDeclaration & inOperand) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_lexicalAttribute'                     *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalAttribute : public AC_galgas_entity {
//--- 'new' constructor
  public : static GGS_lexicalAttribute constructor_new (C_Compiler & inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- getPtr
  public : inline cPtr_lexicalAttribute * getPtr (void) const {
    return (cPtr_lexicalAttribute *) mPointer ;
  }

//--- 'description' reader
  public : virtual const char * actualTypeName (void) const ;

//--- Readers
  public : GGS_lstring  reader_mTypeName (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_lstring  reader_mName (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalAttribute * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalAttribute * operator () (void) const {
      return (cPtr_lexicalAttribute *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       list '@lexicalAttributeList'                        *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalAttributeList : public AC_galgas_list {
  public : typedef cPtr_lexicalAttribute element_type ;
//--- Constructor 'emptyList'
  public : static GGS_lexicalAttributeList constructor_emptyList (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_lexicalAttributeList constructor_listWithValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operator () used for method call
  public : inline const GGS_lexicalAttributeList * operator () (UNUSED_LOCATION_ARGS) const { return this ;}

//--- Method 'first'
/*  public : void method_first (C_Compiler & _inLexique,
                              GGS_lexicalAttribute & outElement
                              COMMA_LOCATION_ARGS) const ; */
//--- Method 'last'
/*  public : void method_last (C_Compiler & _inLexique,
                             GGS_lexicalAttribute & outElement
                             COMMA_LOCATION_ARGS) const ; */
//--- Modifier 'popLast'
/*  public : void modifier_popLast (C_Compiler & _inLexique,
                                  GGS_lexicalAttribute & outElement
                                  COMMA_LOCATION_ARGS) ; */
//--- Modifier 'popFirst'
/*  public : void modifier_popFirst (C_Compiler & _inLexique,
                                   GGS_lexicalAttribute & outElement
                                   COMMA_LOCATION_ARGS) ; */
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lexicalAttribute & inElement) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalAttributeList _operator_concat (const GGS_lexicalAttributeList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) ;

  protected : void _internalPrependValues (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & _inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--- Metamodel Add method
  public : void _addModel (const GGS_lexicalAttribute & inOperand) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_lexicalStyle'                       *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalStyle : public AC_galgas_entity {
//--- 'new' constructor
  public : static GGS_lexicalStyle constructor_new (C_Compiler & inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- getPtr
  public : inline cPtr_lexicalStyle * getPtr (void) const {
    return (cPtr_lexicalStyle *) mPointer ;
  }

//--- 'description' reader
  public : virtual const char * actualTypeName (void) const ;

//--- Readers
  public : GGS_lstring  reader_mName (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_lstring  reader_mComment (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalStyle * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalStyle * operator () (void) const {
      return (cPtr_lexicalStyle *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         list '@lexicalStyleList'                          *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalStyleList : public AC_galgas_list {
  public : typedef cPtr_lexicalStyle element_type ;
//--- Constructor 'emptyList'
  public : static GGS_lexicalStyleList constructor_emptyList (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_lexicalStyleList constructor_listWithValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operator () used for method call
  public : inline const GGS_lexicalStyleList * operator () (UNUSED_LOCATION_ARGS) const { return this ;}

//--- Method 'first'
/*  public : void method_first (C_Compiler & _inLexique,
                              GGS_lexicalStyle & outElement
                              COMMA_LOCATION_ARGS) const ; */
//--- Method 'last'
/*  public : void method_last (C_Compiler & _inLexique,
                             GGS_lexicalStyle & outElement
                             COMMA_LOCATION_ARGS) const ; */
//--- Modifier 'popLast'
/*  public : void modifier_popLast (C_Compiler & _inLexique,
                                  GGS_lexicalStyle & outElement
                                  COMMA_LOCATION_ARGS) ; */
//--- Modifier 'popFirst'
/*  public : void modifier_popFirst (C_Compiler & _inLexique,
                                   GGS_lexicalStyle & outElement
                                   COMMA_LOCATION_ARGS) ; */
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lexicalStyle & inElement) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalStyleList _operator_concat (const GGS_lexicalStyleList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) ;

  protected : void _internalPrependValues (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & _inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--- Metamodel Add method
  public : void _addModel (const GGS_lexicalStyle & inOperand) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_terminalDeclaration'                   *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_terminalDeclaration : public AC_galgas_entity {
//--- 'new' constructor
  public : static GGS_terminalDeclaration constructor_new (C_Compiler & inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3
                                COMMA_LOCATION_ARGS) ;
//--- getPtr
  public : inline cPtr_terminalDeclaration * getPtr (void) const {
    return (cPtr_terminalDeclaration *) mPointer ;
  }

//--- 'description' reader
  public : virtual const char * actualTypeName (void) const ;

//--- Readers
  public : GGS_lstring  reader_mName (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_lstringlist  reader_mSentAttributeList (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_lstring  reader_mErrorMessage (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_lstring  reader_mStyle (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_terminalDeclaration * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_terminalDeclaration * operator () (void) const {
      return (cPtr_terminalDeclaration *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     list '@terminalDeclarationList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_terminalDeclarationList : public AC_galgas_list {
  public : typedef cPtr_terminalDeclaration element_type ;
//--- Constructor 'emptyList'
  public : static GGS_terminalDeclarationList constructor_emptyList (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_terminalDeclarationList constructor_listWithValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operator () used for method call
  public : inline const GGS_terminalDeclarationList * operator () (UNUSED_LOCATION_ARGS) const { return this ;}

//--- Method 'first'
/*  public : void method_first (C_Compiler & _inLexique,
                              GGS_terminalDeclaration & outElement
                              COMMA_LOCATION_ARGS) const ; */
//--- Method 'last'
/*  public : void method_last (C_Compiler & _inLexique,
                             GGS_terminalDeclaration & outElement
                             COMMA_LOCATION_ARGS) const ; */
//--- Modifier 'popLast'
/*  public : void modifier_popLast (C_Compiler & _inLexique,
                                  GGS_terminalDeclaration & outElement
                                  COMMA_LOCATION_ARGS) ; */
//--- Modifier 'popFirst'
/*  public : void modifier_popFirst (C_Compiler & _inLexique,
                                   GGS_terminalDeclaration & outElement
                                   COMMA_LOCATION_ARGS) ; */
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_terminalDeclaration & inElement) ;
//--- Handling '.' GALGAS operator
  public : GGS_terminalDeclarationList _operator_concat (const GGS_terminalDeclarationList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lstring & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3) ;

  protected : void _internalPrependValues (const GGS_lstring & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & _inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--- Metamodel Add method
  public : void _addModel (const GGS_terminalDeclaration & inOperand) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_lexicalListDeclaration'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalListDeclaration : public AC_galgas_entity {
//--- 'new' constructor
  public : static GGS_lexicalListDeclaration constructor_new (C_Compiler & inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstringlist & argument_3,
                                const GGS_lexicalListEntryList & argument_4
                                COMMA_LOCATION_ARGS) ;
//--- getPtr
  public : inline cPtr_lexicalListDeclaration * getPtr (void) const {
    return (cPtr_lexicalListDeclaration *) mPointer ;
  }

//--- 'description' reader
  public : virtual const char * actualTypeName (void) const ;

//--- Readers
  public : GGS_lstring  reader_mName (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_lstring  reader_mStyle (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_lstring  reader_mErrorMessage (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_lstringlist  reader_mSentAttributeList (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_lexicalListEntryList  reader_mEntryList (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalListDeclaration * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalListDeclaration * operator () (void) const {
      return (cPtr_lexicalListDeclaration *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    list '@lexicalListDeclarationList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalListDeclarationList : public AC_galgas_list {
  public : typedef cPtr_lexicalListDeclaration element_type ;
//--- Constructor 'emptyList'
  public : static GGS_lexicalListDeclarationList constructor_emptyList (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_lexicalListDeclarationList constructor_listWithValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstringlist & argument_3,
                                const GGS_lexicalListEntryList & argument_4
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operator () used for method call
  public : inline const GGS_lexicalListDeclarationList * operator () (UNUSED_LOCATION_ARGS) const { return this ;}

//--- Method 'first'
/*  public : void method_first (C_Compiler & _inLexique,
                              GGS_lexicalListDeclaration & outElement
                              COMMA_LOCATION_ARGS) const ; */
//--- Method 'last'
/*  public : void method_last (C_Compiler & _inLexique,
                             GGS_lexicalListDeclaration & outElement
                             COMMA_LOCATION_ARGS) const ; */
//--- Modifier 'popLast'
/*  public : void modifier_popLast (C_Compiler & _inLexique,
                                  GGS_lexicalListDeclaration & outElement
                                  COMMA_LOCATION_ARGS) ; */
//--- Modifier 'popFirst'
/*  public : void modifier_popFirst (C_Compiler & _inLexique,
                                   GGS_lexicalListDeclaration & outElement
                                   COMMA_LOCATION_ARGS) ; */
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lexicalListDeclaration & inElement) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalListDeclarationList _operator_concat (const GGS_lexicalListDeclarationList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstringlist & argument_3,
                                const GGS_lexicalListEntryList & argument_4
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstringlist & argument_3,
                                const GGS_lexicalListEntryList & argument_4) ;

  protected : void _internalPrependValues (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstringlist & argument_3,
                                const GGS_lexicalListEntryList & argument_4) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & _inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--- Metamodel Add method
  public : void _addModel (const GGS_lexicalListDeclaration & inOperand) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_lexicalListEntry'                     *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalListEntry : public AC_galgas_entity {
//--- 'new' constructor
  public : static GGS_lexicalListEntry constructor_new (C_Compiler & inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- getPtr
  public : inline cPtr_lexicalListEntry * getPtr (void) const {
    return (cPtr_lexicalListEntry *) mPointer ;
  }

//--- 'description' reader
  public : virtual const char * actualTypeName (void) const ;

//--- Readers
  public : GGS_lstring  reader_mEntrySpelling (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_lstring  reader_mTerminalSpelling (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalListEntry * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalListEntry * operator () (void) const {
      return (cPtr_lexicalListEntry *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       list '@lexicalListEntryList'                        *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalListEntryList : public AC_galgas_list {
  public : typedef cPtr_lexicalListEntry element_type ;
//--- Constructor 'emptyList'
  public : static GGS_lexicalListEntryList constructor_emptyList (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_lexicalListEntryList constructor_listWithValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operator () used for method call
  public : inline const GGS_lexicalListEntryList * operator () (UNUSED_LOCATION_ARGS) const { return this ;}

//--- Method 'first'
/*  public : void method_first (C_Compiler & _inLexique,
                              GGS_lexicalListEntry & outElement
                              COMMA_LOCATION_ARGS) const ; */
//--- Method 'last'
/*  public : void method_last (C_Compiler & _inLexique,
                             GGS_lexicalListEntry & outElement
                             COMMA_LOCATION_ARGS) const ; */
//--- Modifier 'popLast'
/*  public : void modifier_popLast (C_Compiler & _inLexique,
                                  GGS_lexicalListEntry & outElement
                                  COMMA_LOCATION_ARGS) ; */
//--- Modifier 'popFirst'
/*  public : void modifier_popFirst (C_Compiler & _inLexique,
                                   GGS_lexicalListEntry & outElement
                                   COMMA_LOCATION_ARGS) ; */
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lexicalListEntry & inElement) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalListEntryList _operator_concat (const GGS_lexicalListEntryList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) ;

  protected : void _internalPrependValues (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & _inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--- Metamodel Add method
  public : void _addModel (const GGS_lexicalListEntry & inOperand) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_lexicalExplicitRule'                   *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalExplicitRule : public AC_galgas_entity {
//--- 'new' constructor
  public : static GGS_lexicalExplicitRule constructor_new (C_Compiler & inLexique,
                                const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalInstructionList & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- getPtr
  public : inline cPtr_lexicalExplicitRule * getPtr (void) const {
    return (cPtr_lexicalExplicitRule *) mPointer ;
  }

//--- 'description' reader
  public : virtual const char * actualTypeName (void) const ;

//--- Readers
  public : GGS_lexicalExpression  reader_mLexicalRuleExpression (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_lexicalInstructionList  reader_mInstructionList (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalExplicitRule * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalExplicitRule * operator () (void) const {
      return (cPtr_lexicalExplicitRule *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     list '@lexicalExplicitRuleList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalExplicitRuleList : public AC_galgas_list {
  public : typedef cPtr_lexicalExplicitRule element_type ;
//--- Constructor 'emptyList'
  public : static GGS_lexicalExplicitRuleList constructor_emptyList (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_lexicalExplicitRuleList constructor_listWithValue (C_Compiler & _inLexique,
                                const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalInstructionList & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operator () used for method call
  public : inline const GGS_lexicalExplicitRuleList * operator () (UNUSED_LOCATION_ARGS) const { return this ;}

//--- Method 'first'
/*  public : void method_first (C_Compiler & _inLexique,
                              GGS_lexicalExplicitRule & outElement
                              COMMA_LOCATION_ARGS) const ; */
//--- Method 'last'
/*  public : void method_last (C_Compiler & _inLexique,
                             GGS_lexicalExplicitRule & outElement
                             COMMA_LOCATION_ARGS) const ; */
//--- Modifier 'popLast'
/*  public : void modifier_popLast (C_Compiler & _inLexique,
                                  GGS_lexicalExplicitRule & outElement
                                  COMMA_LOCATION_ARGS) ; */
//--- Modifier 'popFirst'
/*  public : void modifier_popFirst (C_Compiler & _inLexique,
                                   GGS_lexicalExplicitRule & outElement
                                   COMMA_LOCATION_ARGS) ; */
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lexicalExplicitRule & inElement) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalExplicitRuleList _operator_concat (const GGS_lexicalExplicitRuleList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & _inLexique,
                                const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalInstructionList & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalInstructionList & argument_1) ;

  protected : void _internalPrependValues (const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalInstructionList & argument_1) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & _inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--- Metamodel Add method
  public : void _addModel (const GGS_lexicalExplicitRule & inOperand) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_lexicalExpression'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalExpression : public AC_galgas_entity {
//--- getPtr
  public : inline cPtr_lexicalExpression * getPtr (void) const {
    return (cPtr_lexicalExpression *) mPointer ;
  }

//--- 'description' reader
  public : virtual const char * actualTypeName (void) const ;

//--- Readers
//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalExpression * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalExpression * operator () (void) const {
      return (cPtr_lexicalExpression *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      list '@lexicalExpressionList'                        *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalExpressionList : public AC_galgas_list {
  public : typedef cPtr_lexicalExpression element_type ;
//--- Constructor 'emptyList'
  public : static GGS_lexicalExpressionList constructor_emptyList (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_lexicalExpressionList constructor_listWithValue (C_Compiler & _inLexique
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operator () used for method call
  public : inline const GGS_lexicalExpressionList * operator () (UNUSED_LOCATION_ARGS) const { return this ;}

//--- Method 'first'
/*  public : void method_first (C_Compiler & _inLexique,
                              GGS_lexicalExpression & outElement
                              COMMA_LOCATION_ARGS) const ; */
//--- Method 'last'
/*  public : void method_last (C_Compiler & _inLexique,
                             GGS_lexicalExpression & outElement
                             COMMA_LOCATION_ARGS) const ; */
//--- Modifier 'popLast'
/*  public : void modifier_popLast (C_Compiler & _inLexique,
                                  GGS_lexicalExpression & outElement
                                  COMMA_LOCATION_ARGS) ; */
//--- Modifier 'popFirst'
/*  public : void modifier_popFirst (C_Compiler & _inLexique,
                                   GGS_lexicalExpression & outElement
                                   COMMA_LOCATION_ARGS) ; */
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lexicalExpression & inElement) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalExpressionList _operator_concat (const GGS_lexicalExpressionList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & _inLexique
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues () ;

  protected : void _internalPrependValues () ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & _inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--- Metamodel Add method
  public : void _addModel (const GGS_lexicalExpression & inOperand) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_lexicalOrExpression'                   *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalOrExpression : public GGS_lexicalExpression {
//--- 'new' constructor
  public : static GGS_lexicalOrExpression constructor_new (C_Compiler & inLexique,
                                const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalExpression & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- 'description' reader
  public : virtual const char * actualTypeName (void) const ;

//--- Readers
  public : GGS_lexicalExpression  reader_mLeftOperand (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_lexicalExpression  reader_mRightOperand (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalOrExpression * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalOrExpression * operator () (void) const {
      return (cPtr_lexicalOrExpression *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     list '@lexicalOrExpressionList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalOrExpressionList : public AC_galgas_list {
  public : typedef cPtr_lexicalOrExpression element_type ;
//--- Constructor 'emptyList'
  public : static GGS_lexicalOrExpressionList constructor_emptyList (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_lexicalOrExpressionList constructor_listWithValue (C_Compiler & _inLexique,
                                const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalExpression & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operator () used for method call
  public : inline const GGS_lexicalOrExpressionList * operator () (UNUSED_LOCATION_ARGS) const { return this ;}

//--- Method 'first'
/*  public : void method_first (C_Compiler & _inLexique,
                              GGS_lexicalOrExpression & outElement
                              COMMA_LOCATION_ARGS) const ; */
//--- Method 'last'
/*  public : void method_last (C_Compiler & _inLexique,
                             GGS_lexicalOrExpression & outElement
                             COMMA_LOCATION_ARGS) const ; */
//--- Modifier 'popLast'
/*  public : void modifier_popLast (C_Compiler & _inLexique,
                                  GGS_lexicalOrExpression & outElement
                                  COMMA_LOCATION_ARGS) ; */
//--- Modifier 'popFirst'
/*  public : void modifier_popFirst (C_Compiler & _inLexique,
                                   GGS_lexicalOrExpression & outElement
                                   COMMA_LOCATION_ARGS) ; */
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lexicalOrExpression & inElement) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalOrExpressionList _operator_concat (const GGS_lexicalOrExpressionList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & _inLexique,
                                const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalExpression & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalExpression & argument_1) ;

  protected : void _internalPrependValues (const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalExpression & argument_1) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & _inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--- Metamodel Add method
  public : void _addModel (const GGS_lexicalOrExpression & inOperand) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_lexicalCharacterMatch'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalCharacterMatch : public GGS_lexicalExpression {
//--- 'new' constructor
  public : static GGS_lexicalCharacterMatch constructor_new (C_Compiler & inLexique,
                                const GGS_lchar & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- 'description' reader
  public : virtual const char * actualTypeName (void) const ;

//--- Readers
  public : GGS_lchar  reader_mCharacter (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalCharacterMatch * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalCharacterMatch * operator () (void) const {
      return (cPtr_lexicalCharacterMatch *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    list '@lexicalCharacterMatchList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalCharacterMatchList : public AC_galgas_list {
  public : typedef cPtr_lexicalCharacterMatch element_type ;
//--- Constructor 'emptyList'
  public : static GGS_lexicalCharacterMatchList constructor_emptyList (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_lexicalCharacterMatchList constructor_listWithValue (C_Compiler & _inLexique,
                                const GGS_lchar & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operator () used for method call
  public : inline const GGS_lexicalCharacterMatchList * operator () (UNUSED_LOCATION_ARGS) const { return this ;}

//--- Method 'first'
/*  public : void method_first (C_Compiler & _inLexique,
                              GGS_lexicalCharacterMatch & outElement
                              COMMA_LOCATION_ARGS) const ; */
//--- Method 'last'
/*  public : void method_last (C_Compiler & _inLexique,
                             GGS_lexicalCharacterMatch & outElement
                             COMMA_LOCATION_ARGS) const ; */
//--- Modifier 'popLast'
/*  public : void modifier_popLast (C_Compiler & _inLexique,
                                  GGS_lexicalCharacterMatch & outElement
                                  COMMA_LOCATION_ARGS) ; */
//--- Modifier 'popFirst'
/*  public : void modifier_popFirst (C_Compiler & _inLexique,
                                   GGS_lexicalCharacterMatch & outElement
                                   COMMA_LOCATION_ARGS) ; */
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lexicalCharacterMatch & inElement) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalCharacterMatchList _operator_concat (const GGS_lexicalCharacterMatchList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & _inLexique,
                                const GGS_lchar & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lchar & argument_0) ;

  protected : void _internalPrependValues (const GGS_lchar & argument_0) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & _inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--- Metamodel Add method
  public : void _addModel (const GGS_lexicalCharacterMatch & inOperand) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_lexicalCharacterIntervalMatch'              *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalCharacterIntervalMatch : public GGS_lexicalExpression {
//--- 'new' constructor
  public : static GGS_lexicalCharacterIntervalMatch constructor_new (C_Compiler & inLexique,
                                const GGS_lchar & argument_0,
                                const GGS_lchar & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- 'description' reader
  public : virtual const char * actualTypeName (void) const ;

//--- Readers
  public : GGS_lchar  reader_mLowerBound (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_lchar  reader_mUpperBound (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalCharacterIntervalMatch * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalCharacterIntervalMatch * operator () (void) const {
      return (cPtr_lexicalCharacterIntervalMatch *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                list '@lexicalCharacterIntervalMatchList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalCharacterIntervalMatchList : public AC_galgas_list {
  public : typedef cPtr_lexicalCharacterIntervalMatch element_type ;
//--- Constructor 'emptyList'
  public : static GGS_lexicalCharacterIntervalMatchList constructor_emptyList (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_lexicalCharacterIntervalMatchList constructor_listWithValue (C_Compiler & _inLexique,
                                const GGS_lchar & argument_0,
                                const GGS_lchar & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operator () used for method call
  public : inline const GGS_lexicalCharacterIntervalMatchList * operator () (UNUSED_LOCATION_ARGS) const { return this ;}

//--- Method 'first'
/*  public : void method_first (C_Compiler & _inLexique,
                              GGS_lexicalCharacterIntervalMatch & outElement
                              COMMA_LOCATION_ARGS) const ; */
//--- Method 'last'
/*  public : void method_last (C_Compiler & _inLexique,
                             GGS_lexicalCharacterIntervalMatch & outElement
                             COMMA_LOCATION_ARGS) const ; */
//--- Modifier 'popLast'
/*  public : void modifier_popLast (C_Compiler & _inLexique,
                                  GGS_lexicalCharacterIntervalMatch & outElement
                                  COMMA_LOCATION_ARGS) ; */
//--- Modifier 'popFirst'
/*  public : void modifier_popFirst (C_Compiler & _inLexique,
                                   GGS_lexicalCharacterIntervalMatch & outElement
                                   COMMA_LOCATION_ARGS) ; */
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lexicalCharacterIntervalMatch & inElement) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalCharacterIntervalMatchList _operator_concat (const GGS_lexicalCharacterIntervalMatchList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & _inLexique,
                                const GGS_lchar & argument_0,
                                const GGS_lchar & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lchar & argument_0,
                                const GGS_lchar & argument_1) ;

  protected : void _internalPrependValues (const GGS_lchar & argument_0,
                                const GGS_lchar & argument_1) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & _inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--- Metamodel Add method
  public : void _addModel (const GGS_lexicalCharacterIntervalMatch & inOperand) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_lexicalStringMatch'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalStringMatch : public GGS_lexicalExpression {
//--- 'new' constructor
  public : static GGS_lexicalStringMatch constructor_new (C_Compiler & inLexique,
                                const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- 'description' reader
  public : virtual const char * actualTypeName (void) const ;

//--- Readers
  public : GGS_lstring  reader_mString (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalStringMatch * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalStringMatch * operator () (void) const {
      return (cPtr_lexicalStringMatch *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      list '@lexicalStringMatchList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalStringMatchList : public AC_galgas_list {
  public : typedef cPtr_lexicalStringMatch element_type ;
//--- Constructor 'emptyList'
  public : static GGS_lexicalStringMatchList constructor_emptyList (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_lexicalStringMatchList constructor_listWithValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operator () used for method call
  public : inline const GGS_lexicalStringMatchList * operator () (UNUSED_LOCATION_ARGS) const { return this ;}

//--- Method 'first'
/*  public : void method_first (C_Compiler & _inLexique,
                              GGS_lexicalStringMatch & outElement
                              COMMA_LOCATION_ARGS) const ; */
//--- Method 'last'
/*  public : void method_last (C_Compiler & _inLexique,
                             GGS_lexicalStringMatch & outElement
                             COMMA_LOCATION_ARGS) const ; */
//--- Modifier 'popLast'
/*  public : void modifier_popLast (C_Compiler & _inLexique,
                                  GGS_lexicalStringMatch & outElement
                                  COMMA_LOCATION_ARGS) ; */
//--- Modifier 'popFirst'
/*  public : void modifier_popFirst (C_Compiler & _inLexique,
                                   GGS_lexicalStringMatch & outElement
                                   COMMA_LOCATION_ARGS) ; */
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lexicalStringMatch & inElement) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalStringMatchList _operator_concat (const GGS_lexicalStringMatchList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lstring & argument_0) ;

  protected : void _internalPrependValues (const GGS_lstring & argument_0) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & _inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--- Metamodel Add method
  public : void _addModel (const GGS_lexicalStringMatch & inOperand) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_lexicalStringNotMatch'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalStringNotMatch : public GGS_lexicalExpression {
//--- 'new' constructor
  public : static GGS_lexicalStringNotMatch constructor_new (C_Compiler & inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- 'description' reader
  public : virtual const char * actualTypeName (void) const ;

//--- Readers
  public : GGS_lstring  reader_mString (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_lstring  reader_mErrorMessage (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalStringNotMatch * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalStringNotMatch * operator () (void) const {
      return (cPtr_lexicalStringNotMatch *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    list '@lexicalStringNotMatchList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalStringNotMatchList : public AC_galgas_list {
  public : typedef cPtr_lexicalStringNotMatch element_type ;
//--- Constructor 'emptyList'
  public : static GGS_lexicalStringNotMatchList constructor_emptyList (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_lexicalStringNotMatchList constructor_listWithValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operator () used for method call
  public : inline const GGS_lexicalStringNotMatchList * operator () (UNUSED_LOCATION_ARGS) const { return this ;}

//--- Method 'first'
/*  public : void method_first (C_Compiler & _inLexique,
                              GGS_lexicalStringNotMatch & outElement
                              COMMA_LOCATION_ARGS) const ; */
//--- Method 'last'
/*  public : void method_last (C_Compiler & _inLexique,
                             GGS_lexicalStringNotMatch & outElement
                             COMMA_LOCATION_ARGS) const ; */
//--- Modifier 'popLast'
/*  public : void modifier_popLast (C_Compiler & _inLexique,
                                  GGS_lexicalStringNotMatch & outElement
                                  COMMA_LOCATION_ARGS) ; */
//--- Modifier 'popFirst'
/*  public : void modifier_popFirst (C_Compiler & _inLexique,
                                   GGS_lexicalStringNotMatch & outElement
                                   COMMA_LOCATION_ARGS) ; */
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lexicalStringNotMatch & inElement) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalStringNotMatchList _operator_concat (const GGS_lexicalStringNotMatchList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) ;

  protected : void _internalPrependValues (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & _inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--- Metamodel Add method
  public : void _addModel (const GGS_lexicalStringNotMatch & inOperand) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_lexicalInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalInstruction : public AC_galgas_entity {
//--- getPtr
  public : inline cPtr_lexicalInstruction * getPtr (void) const {
    return (cPtr_lexicalInstruction *) mPointer ;
  }

//--- 'description' reader
  public : virtual const char * actualTypeName (void) const ;

//--- Readers
//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalInstruction * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalInstruction * operator () (void) const {
      return (cPtr_lexicalInstruction *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      list '@lexicalInstructionList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalInstructionList : public AC_galgas_list {
  public : typedef cPtr_lexicalInstruction element_type ;
//--- Constructor 'emptyList'
  public : static GGS_lexicalInstructionList constructor_emptyList (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_lexicalInstructionList constructor_listWithValue (C_Compiler & _inLexique
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operator () used for method call
  public : inline const GGS_lexicalInstructionList * operator () (UNUSED_LOCATION_ARGS) const { return this ;}

//--- Method 'first'
/*  public : void method_first (C_Compiler & _inLexique,
                              GGS_lexicalInstruction & outElement
                              COMMA_LOCATION_ARGS) const ; */
//--- Method 'last'
/*  public : void method_last (C_Compiler & _inLexique,
                             GGS_lexicalInstruction & outElement
                             COMMA_LOCATION_ARGS) const ; */
//--- Modifier 'popLast'
/*  public : void modifier_popLast (C_Compiler & _inLexique,
                                  GGS_lexicalInstruction & outElement
                                  COMMA_LOCATION_ARGS) ; */
//--- Modifier 'popFirst'
/*  public : void modifier_popFirst (C_Compiler & _inLexique,
                                   GGS_lexicalInstruction & outElement
                                   COMMA_LOCATION_ARGS) ; */
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lexicalInstruction & inElement) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalInstructionList _operator_concat (const GGS_lexicalInstructionList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & _inLexique
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues () ;

  protected : void _internalPrependValues () ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & _inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--- Metamodel Add method
  public : void _addModel (const GGS_lexicalInstruction & inOperand) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_lexicalStructuredSendInstruction'             *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalStructuredSendInstruction : public GGS_lexicalInstruction {
//--- 'new' constructor
  public : static GGS_lexicalStructuredSendInstruction constructor_new (C_Compiler & inLexique,
                                const GGS_lexicalSendSearchList & argument_0,
                                const GGS_lexicalSendDefaultAction & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- 'description' reader
  public : virtual const char * actualTypeName (void) const ;

//--- Readers
  public : GGS_lexicalSendSearchList  reader_mLexicalSendSearchList (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_lexicalSendDefaultAction  reader_mLexicalSendDefaultAction (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalStructuredSendInstruction * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalStructuredSendInstruction * operator () (void) const {
      return (cPtr_lexicalStructuredSendInstruction *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//               list '@lexicalStructuredSendInstructionList'                *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalStructuredSendInstructionList : public AC_galgas_list {
  public : typedef cPtr_lexicalStructuredSendInstruction element_type ;
//--- Constructor 'emptyList'
  public : static GGS_lexicalStructuredSendInstructionList constructor_emptyList (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_lexicalStructuredSendInstructionList constructor_listWithValue (C_Compiler & _inLexique,
                                const GGS_lexicalSendSearchList & argument_0,
                                const GGS_lexicalSendDefaultAction & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operator () used for method call
  public : inline const GGS_lexicalStructuredSendInstructionList * operator () (UNUSED_LOCATION_ARGS) const { return this ;}

//--- Method 'first'
/*  public : void method_first (C_Compiler & _inLexique,
                              GGS_lexicalStructuredSendInstruction & outElement
                              COMMA_LOCATION_ARGS) const ; */
//--- Method 'last'
/*  public : void method_last (C_Compiler & _inLexique,
                             GGS_lexicalStructuredSendInstruction & outElement
                             COMMA_LOCATION_ARGS) const ; */
//--- Modifier 'popLast'
/*  public : void modifier_popLast (C_Compiler & _inLexique,
                                  GGS_lexicalStructuredSendInstruction & outElement
                                  COMMA_LOCATION_ARGS) ; */
//--- Modifier 'popFirst'
/*  public : void modifier_popFirst (C_Compiler & _inLexique,
                                   GGS_lexicalStructuredSendInstruction & outElement
                                   COMMA_LOCATION_ARGS) ; */
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lexicalStructuredSendInstruction & inElement) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalStructuredSendInstructionList _operator_concat (const GGS_lexicalStructuredSendInstructionList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & _inLexique,
                                const GGS_lexicalSendSearchList & argument_0,
                                const GGS_lexicalSendDefaultAction & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lexicalSendSearchList & argument_0,
                                const GGS_lexicalSendDefaultAction & argument_1) ;

  protected : void _internalPrependValues (const GGS_lexicalSendSearchList & argument_0,
                                const GGS_lexicalSendDefaultAction & argument_1) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & _inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--- Metamodel Add method
  public : void _addModel (const GGS_lexicalStructuredSendInstruction & inOperand) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_lexicalSimpleSendInstruction'               *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalSimpleSendInstruction : public GGS_lexicalInstruction {
//--- 'new' constructor
  public : static GGS_lexicalSimpleSendInstruction constructor_new (C_Compiler & inLexique,
                                const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- 'description' reader
  public : virtual const char * actualTypeName (void) const ;

//--- Readers
  public : GGS_lstring  reader_mSentTerminal (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalSimpleSendInstruction * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalSimpleSendInstruction * operator () (void) const {
      return (cPtr_lexicalSimpleSendInstruction *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 list '@lexicalSimpleSendInstructionList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalSimpleSendInstructionList : public AC_galgas_list {
  public : typedef cPtr_lexicalSimpleSendInstruction element_type ;
//--- Constructor 'emptyList'
  public : static GGS_lexicalSimpleSendInstructionList constructor_emptyList (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_lexicalSimpleSendInstructionList constructor_listWithValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operator () used for method call
  public : inline const GGS_lexicalSimpleSendInstructionList * operator () (UNUSED_LOCATION_ARGS) const { return this ;}

//--- Method 'first'
/*  public : void method_first (C_Compiler & _inLexique,
                              GGS_lexicalSimpleSendInstruction & outElement
                              COMMA_LOCATION_ARGS) const ; */
//--- Method 'last'
/*  public : void method_last (C_Compiler & _inLexique,
                             GGS_lexicalSimpleSendInstruction & outElement
                             COMMA_LOCATION_ARGS) const ; */
//--- Modifier 'popLast'
/*  public : void modifier_popLast (C_Compiler & _inLexique,
                                  GGS_lexicalSimpleSendInstruction & outElement
                                  COMMA_LOCATION_ARGS) ; */
//--- Modifier 'popFirst'
/*  public : void modifier_popFirst (C_Compiler & _inLexique,
                                   GGS_lexicalSimpleSendInstruction & outElement
                                   COMMA_LOCATION_ARGS) ; */
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lexicalSimpleSendInstruction & inElement) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalSimpleSendInstructionList _operator_concat (const GGS_lexicalSimpleSendInstructionList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lstring & argument_0) ;

  protected : void _internalPrependValues (const GGS_lstring & argument_0) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & _inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--- Metamodel Add method
  public : void _addModel (const GGS_lexicalSimpleSendInstruction & inOperand) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_lexicalSendDefaultAction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalSendDefaultAction : public AC_galgas_entity {
//--- getPtr
  public : inline cPtr_lexicalSendDefaultAction * getPtr (void) const {
    return (cPtr_lexicalSendDefaultAction *) mPointer ;
  }

//--- 'description' reader
  public : virtual const char * actualTypeName (void) const ;

//--- Readers
//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalSendDefaultAction * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalSendDefaultAction * operator () (void) const {
      return (cPtr_lexicalSendDefaultAction *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   list '@lexicalSendDefaultActionList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalSendDefaultActionList : public AC_galgas_list {
  public : typedef cPtr_lexicalSendDefaultAction element_type ;
//--- Constructor 'emptyList'
  public : static GGS_lexicalSendDefaultActionList constructor_emptyList (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_lexicalSendDefaultActionList constructor_listWithValue (C_Compiler & _inLexique
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operator () used for method call
  public : inline const GGS_lexicalSendDefaultActionList * operator () (UNUSED_LOCATION_ARGS) const { return this ;}

//--- Method 'first'
/*  public : void method_first (C_Compiler & _inLexique,
                              GGS_lexicalSendDefaultAction & outElement
                              COMMA_LOCATION_ARGS) const ; */
//--- Method 'last'
/*  public : void method_last (C_Compiler & _inLexique,
                             GGS_lexicalSendDefaultAction & outElement
                             COMMA_LOCATION_ARGS) const ; */
//--- Modifier 'popLast'
/*  public : void modifier_popLast (C_Compiler & _inLexique,
                                  GGS_lexicalSendDefaultAction & outElement
                                  COMMA_LOCATION_ARGS) ; */
//--- Modifier 'popFirst'
/*  public : void modifier_popFirst (C_Compiler & _inLexique,
                                   GGS_lexicalSendDefaultAction & outElement
                                   COMMA_LOCATION_ARGS) ; */
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lexicalSendDefaultAction & inElement) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalSendDefaultActionList _operator_concat (const GGS_lexicalSendDefaultActionList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & _inLexique
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues () ;

  protected : void _internalPrependValues () ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & _inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--- Metamodel Add method
  public : void _addModel (const GGS_lexicalSendDefaultAction & inOperand) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_lexicalSendTerminalByDefault'               *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalSendTerminalByDefault : public GGS_lexicalSendDefaultAction {
//--- 'new' constructor
  public : static GGS_lexicalSendTerminalByDefault constructor_new (C_Compiler & inLexique,
                                const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- 'description' reader
  public : virtual const char * actualTypeName (void) const ;

//--- Readers
  public : GGS_lstring  reader_mDefaultSentTerminal (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalSendTerminalByDefault * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalSendTerminalByDefault * operator () (void) const {
      return (cPtr_lexicalSendTerminalByDefault *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 list '@lexicalSendTerminalByDefaultList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalSendTerminalByDefaultList : public AC_galgas_list {
  public : typedef cPtr_lexicalSendTerminalByDefault element_type ;
//--- Constructor 'emptyList'
  public : static GGS_lexicalSendTerminalByDefaultList constructor_emptyList (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_lexicalSendTerminalByDefaultList constructor_listWithValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operator () used for method call
  public : inline const GGS_lexicalSendTerminalByDefaultList * operator () (UNUSED_LOCATION_ARGS) const { return this ;}

//--- Method 'first'
/*  public : void method_first (C_Compiler & _inLexique,
                              GGS_lexicalSendTerminalByDefault & outElement
                              COMMA_LOCATION_ARGS) const ; */
//--- Method 'last'
/*  public : void method_last (C_Compiler & _inLexique,
                             GGS_lexicalSendTerminalByDefault & outElement
                             COMMA_LOCATION_ARGS) const ; */
//--- Modifier 'popLast'
/*  public : void modifier_popLast (C_Compiler & _inLexique,
                                  GGS_lexicalSendTerminalByDefault & outElement
                                  COMMA_LOCATION_ARGS) ; */
//--- Modifier 'popFirst'
/*  public : void modifier_popFirst (C_Compiler & _inLexique,
                                   GGS_lexicalSendTerminalByDefault & outElement
                                   COMMA_LOCATION_ARGS) ; */
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lexicalSendTerminalByDefault & inElement) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalSendTerminalByDefaultList _operator_concat (const GGS_lexicalSendTerminalByDefaultList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lstring & argument_0) ;

  protected : void _internalPrependValues (const GGS_lstring & argument_0) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & _inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--- Metamodel Add method
  public : void _addModel (const GGS_lexicalSendTerminalByDefault & inOperand) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_lexicalErrorByDefault'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalErrorByDefault : public GGS_lexicalSendDefaultAction {
//--- 'new' constructor
  public : static GGS_lexicalErrorByDefault constructor_new (C_Compiler & inLexique,
                                const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- 'description' reader
  public : virtual const char * actualTypeName (void) const ;

//--- Readers
  public : GGS_lstring  reader_mDefaultErrorMessageName (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalErrorByDefault * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalErrorByDefault * operator () (void) const {
      return (cPtr_lexicalErrorByDefault *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    list '@lexicalErrorByDefaultList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalErrorByDefaultList : public AC_galgas_list {
  public : typedef cPtr_lexicalErrorByDefault element_type ;
//--- Constructor 'emptyList'
  public : static GGS_lexicalErrorByDefaultList constructor_emptyList (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_lexicalErrorByDefaultList constructor_listWithValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operator () used for method call
  public : inline const GGS_lexicalErrorByDefaultList * operator () (UNUSED_LOCATION_ARGS) const { return this ;}

//--- Method 'first'
/*  public : void method_first (C_Compiler & _inLexique,
                              GGS_lexicalErrorByDefault & outElement
                              COMMA_LOCATION_ARGS) const ; */
//--- Method 'last'
/*  public : void method_last (C_Compiler & _inLexique,
                             GGS_lexicalErrorByDefault & outElement
                             COMMA_LOCATION_ARGS) const ; */
//--- Modifier 'popLast'
/*  public : void modifier_popLast (C_Compiler & _inLexique,
                                  GGS_lexicalErrorByDefault & outElement
                                  COMMA_LOCATION_ARGS) ; */
//--- Modifier 'popFirst'
/*  public : void modifier_popFirst (C_Compiler & _inLexique,
                                   GGS_lexicalErrorByDefault & outElement
                                   COMMA_LOCATION_ARGS) ; */
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lexicalErrorByDefault & inElement) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalErrorByDefaultList _operator_concat (const GGS_lexicalErrorByDefaultList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lstring & argument_0) ;

  protected : void _internalPrependValues (const GGS_lstring & argument_0) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & _inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--- Metamodel Add method
  public : void _addModel (const GGS_lexicalErrorByDefault & inOperand) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_lexicalSendSearch'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalSendSearch : public AC_galgas_entity {
//--- 'new' constructor
  public : static GGS_lexicalSendSearch constructor_new (C_Compiler & inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- getPtr
  public : inline cPtr_lexicalSendSearch * getPtr (void) const {
    return (cPtr_lexicalSendSearch *) mPointer ;
  }

//--- 'description' reader
  public : virtual const char * actualTypeName (void) const ;

//--- Readers
  public : GGS_lstring  reader_mAttributeName (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_lstring  reader_mSearchListName (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalSendSearch * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalSendSearch * operator () (void) const {
      return (cPtr_lexicalSendSearch *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      list '@lexicalSendSearchList'                        *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalSendSearchList : public AC_galgas_list {
  public : typedef cPtr_lexicalSendSearch element_type ;
//--- Constructor 'emptyList'
  public : static GGS_lexicalSendSearchList constructor_emptyList (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_lexicalSendSearchList constructor_listWithValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operator () used for method call
  public : inline const GGS_lexicalSendSearchList * operator () (UNUSED_LOCATION_ARGS) const { return this ;}

//--- Method 'first'
/*  public : void method_first (C_Compiler & _inLexique,
                              GGS_lexicalSendSearch & outElement
                              COMMA_LOCATION_ARGS) const ; */
//--- Method 'last'
/*  public : void method_last (C_Compiler & _inLexique,
                             GGS_lexicalSendSearch & outElement
                             COMMA_LOCATION_ARGS) const ; */
//--- Modifier 'popLast'
/*  public : void modifier_popLast (C_Compiler & _inLexique,
                                  GGS_lexicalSendSearch & outElement
                                  COMMA_LOCATION_ARGS) ; */
//--- Modifier 'popFirst'
/*  public : void modifier_popFirst (C_Compiler & _inLexique,
                                   GGS_lexicalSendSearch & outElement
                                   COMMA_LOCATION_ARGS) ; */
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lexicalSendSearch & inElement) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalSendSearchList _operator_concat (const GGS_lexicalSendSearchList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) ;

  protected : void _internalPrependValues (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & _inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--- Metamodel Add method
  public : void _addModel (const GGS_lexicalSendSearch & inOperand) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_lexicalRepeatInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalRepeatInstruction : public GGS_lexicalInstruction {
//--- 'new' constructor
  public : static GGS_lexicalRepeatInstruction constructor_new (C_Compiler & inLexique,
                                const GGS_lexicalInstructionList & argument_0,
                                const GGS_lexicalWhileBranchList & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- 'description' reader
  public : virtual const char * actualTypeName (void) const ;

//--- Readers
  public : GGS_lexicalInstructionList  reader_mRepeatedInstructionList (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_lexicalWhileBranchList  reader_mLexicalWhileBranchList (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalRepeatInstruction * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalRepeatInstruction * operator () (void) const {
      return (cPtr_lexicalRepeatInstruction *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   list '@lexicalRepeatInstructionList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalRepeatInstructionList : public AC_galgas_list {
  public : typedef cPtr_lexicalRepeatInstruction element_type ;
//--- Constructor 'emptyList'
  public : static GGS_lexicalRepeatInstructionList constructor_emptyList (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_lexicalRepeatInstructionList constructor_listWithValue (C_Compiler & _inLexique,
                                const GGS_lexicalInstructionList & argument_0,
                                const GGS_lexicalWhileBranchList & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operator () used for method call
  public : inline const GGS_lexicalRepeatInstructionList * operator () (UNUSED_LOCATION_ARGS) const { return this ;}

//--- Method 'first'
/*  public : void method_first (C_Compiler & _inLexique,
                              GGS_lexicalRepeatInstruction & outElement
                              COMMA_LOCATION_ARGS) const ; */
//--- Method 'last'
/*  public : void method_last (C_Compiler & _inLexique,
                             GGS_lexicalRepeatInstruction & outElement
                             COMMA_LOCATION_ARGS) const ; */
//--- Modifier 'popLast'
/*  public : void modifier_popLast (C_Compiler & _inLexique,
                                  GGS_lexicalRepeatInstruction & outElement
                                  COMMA_LOCATION_ARGS) ; */
//--- Modifier 'popFirst'
/*  public : void modifier_popFirst (C_Compiler & _inLexique,
                                   GGS_lexicalRepeatInstruction & outElement
                                   COMMA_LOCATION_ARGS) ; */
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lexicalRepeatInstruction & inElement) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalRepeatInstructionList _operator_concat (const GGS_lexicalRepeatInstructionList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & _inLexique,
                                const GGS_lexicalInstructionList & argument_0,
                                const GGS_lexicalWhileBranchList & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lexicalInstructionList & argument_0,
                                const GGS_lexicalWhileBranchList & argument_1) ;

  protected : void _internalPrependValues (const GGS_lexicalInstructionList & argument_0,
                                const GGS_lexicalWhileBranchList & argument_1) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & _inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--- Metamodel Add method
  public : void _addModel (const GGS_lexicalRepeatInstruction & inOperand) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_lexicalWhileBranch'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalWhileBranch : public AC_galgas_entity {
//--- 'new' constructor
  public : static GGS_lexicalWhileBranch constructor_new (C_Compiler & inLexique,
                                const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalInstructionList & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- getPtr
  public : inline cPtr_lexicalWhileBranch * getPtr (void) const {
    return (cPtr_lexicalWhileBranch *) mPointer ;
  }

//--- 'description' reader
  public : virtual const char * actualTypeName (void) const ;

//--- Readers
  public : GGS_lexicalExpression  reader_mWhileExpression (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_lexicalInstructionList  reader_mWhileInstructionList (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalWhileBranch * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalWhileBranch * operator () (void) const {
      return (cPtr_lexicalWhileBranch *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      list '@lexicalWhileBranchList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalWhileBranchList : public AC_galgas_list {
  public : typedef cPtr_lexicalWhileBranch element_type ;
//--- Constructor 'emptyList'
  public : static GGS_lexicalWhileBranchList constructor_emptyList (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_lexicalWhileBranchList constructor_listWithValue (C_Compiler & _inLexique,
                                const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalInstructionList & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operator () used for method call
  public : inline const GGS_lexicalWhileBranchList * operator () (UNUSED_LOCATION_ARGS) const { return this ;}

//--- Method 'first'
/*  public : void method_first (C_Compiler & _inLexique,
                              GGS_lexicalWhileBranch & outElement
                              COMMA_LOCATION_ARGS) const ; */
//--- Method 'last'
/*  public : void method_last (C_Compiler & _inLexique,
                             GGS_lexicalWhileBranch & outElement
                             COMMA_LOCATION_ARGS) const ; */
//--- Modifier 'popLast'
/*  public : void modifier_popLast (C_Compiler & _inLexique,
                                  GGS_lexicalWhileBranch & outElement
                                  COMMA_LOCATION_ARGS) ; */
//--- Modifier 'popFirst'
/*  public : void modifier_popFirst (C_Compiler & _inLexique,
                                   GGS_lexicalWhileBranch & outElement
                                   COMMA_LOCATION_ARGS) ; */
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lexicalWhileBranch & inElement) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalWhileBranchList _operator_concat (const GGS_lexicalWhileBranchList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & _inLexique,
                                const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalInstructionList & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalInstructionList & argument_1) ;

  protected : void _internalPrependValues (const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalInstructionList & argument_1) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & _inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--- Metamodel Add method
  public : void _addModel (const GGS_lexicalWhileBranch & inOperand) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_lexicalSelectInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalSelectInstruction : public GGS_lexicalInstruction {
//--- 'new' constructor
  public : static GGS_lexicalSelectInstruction constructor_new (C_Compiler & inLexique,
                                const GGS_lexicalSelectBranchList & argument_0,
                                const GGS_lexicalInstructionList & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- 'description' reader
  public : virtual const char * actualTypeName (void) const ;

//--- Readers
  public : GGS_lexicalSelectBranchList  reader_mLexicalWhileBranchList (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_lexicalInstructionList  reader_mDefaultInstructionList (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalSelectInstruction * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalSelectInstruction * operator () (void) const {
      return (cPtr_lexicalSelectInstruction *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   list '@lexicalSelectInstructionList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalSelectInstructionList : public AC_galgas_list {
  public : typedef cPtr_lexicalSelectInstruction element_type ;
//--- Constructor 'emptyList'
  public : static GGS_lexicalSelectInstructionList constructor_emptyList (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_lexicalSelectInstructionList constructor_listWithValue (C_Compiler & _inLexique,
                                const GGS_lexicalSelectBranchList & argument_0,
                                const GGS_lexicalInstructionList & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operator () used for method call
  public : inline const GGS_lexicalSelectInstructionList * operator () (UNUSED_LOCATION_ARGS) const { return this ;}

//--- Method 'first'
/*  public : void method_first (C_Compiler & _inLexique,
                              GGS_lexicalSelectInstruction & outElement
                              COMMA_LOCATION_ARGS) const ; */
//--- Method 'last'
/*  public : void method_last (C_Compiler & _inLexique,
                             GGS_lexicalSelectInstruction & outElement
                             COMMA_LOCATION_ARGS) const ; */
//--- Modifier 'popLast'
/*  public : void modifier_popLast (C_Compiler & _inLexique,
                                  GGS_lexicalSelectInstruction & outElement
                                  COMMA_LOCATION_ARGS) ; */
//--- Modifier 'popFirst'
/*  public : void modifier_popFirst (C_Compiler & _inLexique,
                                   GGS_lexicalSelectInstruction & outElement
                                   COMMA_LOCATION_ARGS) ; */
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lexicalSelectInstruction & inElement) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalSelectInstructionList _operator_concat (const GGS_lexicalSelectInstructionList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & _inLexique,
                                const GGS_lexicalSelectBranchList & argument_0,
                                const GGS_lexicalInstructionList & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lexicalSelectBranchList & argument_0,
                                const GGS_lexicalInstructionList & argument_1) ;

  protected : void _internalPrependValues (const GGS_lexicalSelectBranchList & argument_0,
                                const GGS_lexicalInstructionList & argument_1) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & _inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--- Metamodel Add method
  public : void _addModel (const GGS_lexicalSelectInstruction & inOperand) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_lexicalSelectBranch'                   *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalSelectBranch : public AC_galgas_entity {
//--- 'new' constructor
  public : static GGS_lexicalSelectBranch constructor_new (C_Compiler & inLexique,
                                const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalInstructionList & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- getPtr
  public : inline cPtr_lexicalSelectBranch * getPtr (void) const {
    return (cPtr_lexicalSelectBranch *) mPointer ;
  }

//--- 'description' reader
  public : virtual const char * actualTypeName (void) const ;

//--- Readers
  public : GGS_lexicalExpression  reader_mSelectExpression (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_lexicalInstructionList  reader_mSelectInstructionList (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalSelectBranch * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalSelectBranch * operator () (void) const {
      return (cPtr_lexicalSelectBranch *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     list '@lexicalSelectBranchList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalSelectBranchList : public AC_galgas_list {
  public : typedef cPtr_lexicalSelectBranch element_type ;
//--- Constructor 'emptyList'
  public : static GGS_lexicalSelectBranchList constructor_emptyList (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_lexicalSelectBranchList constructor_listWithValue (C_Compiler & _inLexique,
                                const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalInstructionList & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operator () used for method call
  public : inline const GGS_lexicalSelectBranchList * operator () (UNUSED_LOCATION_ARGS) const { return this ;}

//--- Method 'first'
/*  public : void method_first (C_Compiler & _inLexique,
                              GGS_lexicalSelectBranch & outElement
                              COMMA_LOCATION_ARGS) const ; */
//--- Method 'last'
/*  public : void method_last (C_Compiler & _inLexique,
                             GGS_lexicalSelectBranch & outElement
                             COMMA_LOCATION_ARGS) const ; */
//--- Modifier 'popLast'
/*  public : void modifier_popLast (C_Compiler & _inLexique,
                                  GGS_lexicalSelectBranch & outElement
                                  COMMA_LOCATION_ARGS) ; */
//--- Modifier 'popFirst'
/*  public : void modifier_popFirst (C_Compiler & _inLexique,
                                   GGS_lexicalSelectBranch & outElement
                                   COMMA_LOCATION_ARGS) ; */
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lexicalSelectBranch & inElement) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalSelectBranchList _operator_concat (const GGS_lexicalSelectBranchList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & _inLexique,
                                const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalInstructionList & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalInstructionList & argument_1) ;

  protected : void _internalPrependValues (const GGS_lexicalExpression & argument_0,
                                const GGS_lexicalInstructionList & argument_1) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & _inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--- Metamodel Add method
  public : void _addModel (const GGS_lexicalSelectBranch & inOperand) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_lexicalActionInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalActionInstruction : public GGS_lexicalInstruction {
//--- 'new' constructor
  public : static GGS_lexicalActionInstruction constructor_new (C_Compiler & inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lexicalActualArgumentList & argument_1,
                                const GGS_lstringlist & argument_2
                                COMMA_LOCATION_ARGS) ;
//--- 'description' reader
  public : virtual const char * actualTypeName (void) const ;

//--- Readers
  public : GGS_lstring  reader_mActionName (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_lexicalActualArgumentList  reader_mActualArgumentList (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_lstringlist  reader_mErrorMessageList (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalActionInstruction * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalActionInstruction * operator () (void) const {
      return (cPtr_lexicalActionInstruction *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   list '@lexicalActionInstructionList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalActionInstructionList : public AC_galgas_list {
  public : typedef cPtr_lexicalActionInstruction element_type ;
//--- Constructor 'emptyList'
  public : static GGS_lexicalActionInstructionList constructor_emptyList (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_lexicalActionInstructionList constructor_listWithValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lexicalActualArgumentList & argument_1,
                                const GGS_lstringlist & argument_2
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operator () used for method call
  public : inline const GGS_lexicalActionInstructionList * operator () (UNUSED_LOCATION_ARGS) const { return this ;}

//--- Method 'first'
/*  public : void method_first (C_Compiler & _inLexique,
                              GGS_lexicalActionInstruction & outElement
                              COMMA_LOCATION_ARGS) const ; */
//--- Method 'last'
/*  public : void method_last (C_Compiler & _inLexique,
                             GGS_lexicalActionInstruction & outElement
                             COMMA_LOCATION_ARGS) const ; */
//--- Modifier 'popLast'
/*  public : void modifier_popLast (C_Compiler & _inLexique,
                                  GGS_lexicalActionInstruction & outElement
                                  COMMA_LOCATION_ARGS) ; */
//--- Modifier 'popFirst'
/*  public : void modifier_popFirst (C_Compiler & _inLexique,
                                   GGS_lexicalActionInstruction & outElement
                                   COMMA_LOCATION_ARGS) ; */
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lexicalActionInstruction & inElement) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalActionInstructionList _operator_concat (const GGS_lexicalActionInstructionList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lexicalActualArgumentList & argument_1,
                                const GGS_lstringlist & argument_2
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lstring & argument_0,
                                const GGS_lexicalActualArgumentList & argument_1,
                                const GGS_lstringlist & argument_2) ;

  protected : void _internalPrependValues (const GGS_lstring & argument_0,
                                const GGS_lexicalActualArgumentList & argument_1,
                                const GGS_lstringlist & argument_2) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & _inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--- Metamodel Add method
  public : void _addModel (const GGS_lexicalActionInstruction & inOperand) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_lexicalActualArgument'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalActualArgument : public AC_galgas_entity {
//--- getPtr
  public : inline cPtr_lexicalActualArgument * getPtr (void) const {
    return (cPtr_lexicalActualArgument *) mPointer ;
  }

//--- 'description' reader
  public : virtual const char * actualTypeName (void) const ;

//--- Readers
//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalActualArgument * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalActualArgument * operator () (void) const {
      return (cPtr_lexicalActualArgument *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    list '@lexicalActualArgumentList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalActualArgumentList : public AC_galgas_list {
  public : typedef cPtr_lexicalActualArgument element_type ;
//--- Constructor 'emptyList'
  public : static GGS_lexicalActualArgumentList constructor_emptyList (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_lexicalActualArgumentList constructor_listWithValue (C_Compiler & _inLexique
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operator () used for method call
  public : inline const GGS_lexicalActualArgumentList * operator () (UNUSED_LOCATION_ARGS) const { return this ;}

//--- Method 'first'
/*  public : void method_first (C_Compiler & _inLexique,
                              GGS_lexicalActualArgument & outElement
                              COMMA_LOCATION_ARGS) const ; */
//--- Method 'last'
/*  public : void method_last (C_Compiler & _inLexique,
                             GGS_lexicalActualArgument & outElement
                             COMMA_LOCATION_ARGS) const ; */
//--- Modifier 'popLast'
/*  public : void modifier_popLast (C_Compiler & _inLexique,
                                  GGS_lexicalActualArgument & outElement
                                  COMMA_LOCATION_ARGS) ; */
//--- Modifier 'popFirst'
/*  public : void modifier_popFirst (C_Compiler & _inLexique,
                                   GGS_lexicalActualArgument & outElement
                                   COMMA_LOCATION_ARGS) ; */
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lexicalActualArgument & inElement) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalActualArgumentList _operator_concat (const GGS_lexicalActualArgumentList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & _inLexique
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues () ;

  protected : void _internalPrependValues () ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & _inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--- Metamodel Add method
  public : void _addModel (const GGS_lexicalActualArgument & inOperand) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_lexicalAttributeArgument'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalAttributeArgument : public GGS_lexicalActualArgument {
//--- 'new' constructor
  public : static GGS_lexicalAttributeArgument constructor_new (C_Compiler & inLexique,
                                const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- 'description' reader
  public : virtual const char * actualTypeName (void) const ;

//--- Readers
  public : GGS_lstring  reader_mAttributeName (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalAttributeArgument * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalAttributeArgument * operator () (void) const {
      return (cPtr_lexicalAttributeArgument *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   list '@lexicalAttributeArgumentList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalAttributeArgumentList : public AC_galgas_list {
  public : typedef cPtr_lexicalAttributeArgument element_type ;
//--- Constructor 'emptyList'
  public : static GGS_lexicalAttributeArgumentList constructor_emptyList (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_lexicalAttributeArgumentList constructor_listWithValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operator () used for method call
  public : inline const GGS_lexicalAttributeArgumentList * operator () (UNUSED_LOCATION_ARGS) const { return this ;}

//--- Method 'first'
/*  public : void method_first (C_Compiler & _inLexique,
                              GGS_lexicalAttributeArgument & outElement
                              COMMA_LOCATION_ARGS) const ; */
//--- Method 'last'
/*  public : void method_last (C_Compiler & _inLexique,
                             GGS_lexicalAttributeArgument & outElement
                             COMMA_LOCATION_ARGS) const ; */
//--- Modifier 'popLast'
/*  public : void modifier_popLast (C_Compiler & _inLexique,
                                  GGS_lexicalAttributeArgument & outElement
                                  COMMA_LOCATION_ARGS) ; */
//--- Modifier 'popFirst'
/*  public : void modifier_popFirst (C_Compiler & _inLexique,
                                   GGS_lexicalAttributeArgument & outElement
                                   COMMA_LOCATION_ARGS) ; */
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lexicalAttributeArgument & inElement) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalAttributeArgumentList _operator_concat (const GGS_lexicalAttributeArgumentList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lstring & argument_0) ;

  protected : void _internalPrependValues (const GGS_lstring & argument_0) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & _inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--- Metamodel Add method
  public : void _addModel (const GGS_lexicalAttributeArgument & inOperand) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_lexicalCharacterArgument'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalCharacterArgument : public GGS_lexicalActualArgument {
//--- 'new' constructor
  public : static GGS_lexicalCharacterArgument constructor_new (C_Compiler & inLexique,
                                const GGS_lchar & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- 'description' reader
  public : virtual const char * actualTypeName (void) const ;

//--- Readers
  public : GGS_lchar  reader_mCharacter (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalCharacterArgument * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalCharacterArgument * operator () (void) const {
      return (cPtr_lexicalCharacterArgument *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   list '@lexicalCharacterArgumentList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalCharacterArgumentList : public AC_galgas_list {
  public : typedef cPtr_lexicalCharacterArgument element_type ;
//--- Constructor 'emptyList'
  public : static GGS_lexicalCharacterArgumentList constructor_emptyList (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_lexicalCharacterArgumentList constructor_listWithValue (C_Compiler & _inLexique,
                                const GGS_lchar & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operator () used for method call
  public : inline const GGS_lexicalCharacterArgumentList * operator () (UNUSED_LOCATION_ARGS) const { return this ;}

//--- Method 'first'
/*  public : void method_first (C_Compiler & _inLexique,
                              GGS_lexicalCharacterArgument & outElement
                              COMMA_LOCATION_ARGS) const ; */
//--- Method 'last'
/*  public : void method_last (C_Compiler & _inLexique,
                             GGS_lexicalCharacterArgument & outElement
                             COMMA_LOCATION_ARGS) const ; */
//--- Modifier 'popLast'
/*  public : void modifier_popLast (C_Compiler & _inLexique,
                                  GGS_lexicalCharacterArgument & outElement
                                  COMMA_LOCATION_ARGS) ; */
//--- Modifier 'popFirst'
/*  public : void modifier_popFirst (C_Compiler & _inLexique,
                                   GGS_lexicalCharacterArgument & outElement
                                   COMMA_LOCATION_ARGS) ; */
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lexicalCharacterArgument & inElement) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalCharacterArgumentList _operator_concat (const GGS_lexicalCharacterArgumentList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & _inLexique,
                                const GGS_lchar & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lchar & argument_0) ;

  protected : void _internalPrependValues (const GGS_lchar & argument_0) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & _inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--- Metamodel Add method
  public : void _addModel (const GGS_lexicalCharacterArgument & inOperand) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_lexicalCurrentCharacterArgument'             *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalCurrentCharacterArgument : public GGS_lexicalActualArgument {
//--- 'new' constructor
  public : static GGS_lexicalCurrentCharacterArgument constructor_new (C_Compiler & inLexique
                                COMMA_LOCATION_ARGS) ;
//--- 'description' reader
  public : virtual const char * actualTypeName (void) const ;

//--- Readers
//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalCurrentCharacterArgument * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalCurrentCharacterArgument * operator () (void) const {
      return (cPtr_lexicalCurrentCharacterArgument *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//               list '@lexicalCurrentCharacterArgumentList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalCurrentCharacterArgumentList : public AC_galgas_list {
  public : typedef cPtr_lexicalCurrentCharacterArgument element_type ;
//--- Constructor 'emptyList'
  public : static GGS_lexicalCurrentCharacterArgumentList constructor_emptyList (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_lexicalCurrentCharacterArgumentList constructor_listWithValue (C_Compiler & _inLexique
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operator () used for method call
  public : inline const GGS_lexicalCurrentCharacterArgumentList * operator () (UNUSED_LOCATION_ARGS) const { return this ;}

//--- Method 'first'
/*  public : void method_first (C_Compiler & _inLexique,
                              GGS_lexicalCurrentCharacterArgument & outElement
                              COMMA_LOCATION_ARGS) const ; */
//--- Method 'last'
/*  public : void method_last (C_Compiler & _inLexique,
                             GGS_lexicalCurrentCharacterArgument & outElement
                             COMMA_LOCATION_ARGS) const ; */
//--- Modifier 'popLast'
/*  public : void modifier_popLast (C_Compiler & _inLexique,
                                  GGS_lexicalCurrentCharacterArgument & outElement
                                  COMMA_LOCATION_ARGS) ; */
//--- Modifier 'popFirst'
/*  public : void modifier_popFirst (C_Compiler & _inLexique,
                                   GGS_lexicalCurrentCharacterArgument & outElement
                                   COMMA_LOCATION_ARGS) ; */
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lexicalCurrentCharacterArgument & inElement) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalCurrentCharacterArgumentList _operator_concat (const GGS_lexicalCurrentCharacterArgumentList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & _inLexique
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues () ;

  protected : void _internalPrependValues () ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & _inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--- Metamodel Add method
  public : void _addModel (const GGS_lexicalCurrentCharacterArgument & inOperand) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_lexicalFunctionArgument'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalFunctionArgument : public GGS_lexicalActualArgument {
//--- 'new' constructor
  public : static GGS_lexicalFunctionArgument constructor_new (C_Compiler & inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lexicalActualArgumentList & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- 'description' reader
  public : virtual const char * actualTypeName (void) const ;

//--- Readers
  public : GGS_lstring  reader_mFunctionName (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_lexicalActualArgumentList  reader_mFunctionActualArgumentList (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalFunctionArgument * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalFunctionArgument * operator () (void) const {
      return (cPtr_lexicalFunctionArgument *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   list '@lexicalFunctionArgumentList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalFunctionArgumentList : public AC_galgas_list {
  public : typedef cPtr_lexicalFunctionArgument element_type ;
//--- Constructor 'emptyList'
  public : static GGS_lexicalFunctionArgumentList constructor_emptyList (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_lexicalFunctionArgumentList constructor_listWithValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lexicalActualArgumentList & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operator () used for method call
  public : inline const GGS_lexicalFunctionArgumentList * operator () (UNUSED_LOCATION_ARGS) const { return this ;}

//--- Method 'first'
/*  public : void method_first (C_Compiler & _inLexique,
                              GGS_lexicalFunctionArgument & outElement
                              COMMA_LOCATION_ARGS) const ; */
//--- Method 'last'
/*  public : void method_last (C_Compiler & _inLexique,
                             GGS_lexicalFunctionArgument & outElement
                             COMMA_LOCATION_ARGS) const ; */
//--- Modifier 'popLast'
/*  public : void modifier_popLast (C_Compiler & _inLexique,
                                  GGS_lexicalFunctionArgument & outElement
                                  COMMA_LOCATION_ARGS) ; */
//--- Modifier 'popFirst'
/*  public : void modifier_popFirst (C_Compiler & _inLexique,
                                   GGS_lexicalFunctionArgument & outElement
                                   COMMA_LOCATION_ARGS) ; */
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lexicalFunctionArgument & inElement) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalFunctionArgumentList _operator_concat (const GGS_lexicalFunctionArgumentList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lexicalActualArgumentList & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lstring & argument_0,
                                const GGS_lexicalActualArgumentList & argument_1) ;

  protected : void _internalPrependValues (const GGS_lstring & argument_0,
                                const GGS_lexicalActualArgumentList & argument_1) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & _inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--- Metamodel Add method
  public : void _addModel (const GGS_lexicalFunctionArgument & inOperand) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_lexicalDropInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalDropInstruction : public GGS_lexicalInstruction {
//--- 'new' constructor
  public : static GGS_lexicalDropInstruction constructor_new (C_Compiler & inLexique,
                                const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- 'description' reader
  public : virtual const char * actualTypeName (void) const ;

//--- Readers
  public : GGS_lstring  reader_mTerminalName (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalDropInstruction * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalDropInstruction * operator () (void) const {
      return (cPtr_lexicalDropInstruction *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    list '@lexicalDropInstructionList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalDropInstructionList : public AC_galgas_list {
  public : typedef cPtr_lexicalDropInstruction element_type ;
//--- Constructor 'emptyList'
  public : static GGS_lexicalDropInstructionList constructor_emptyList (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_lexicalDropInstructionList constructor_listWithValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operator () used for method call
  public : inline const GGS_lexicalDropInstructionList * operator () (UNUSED_LOCATION_ARGS) const { return this ;}

//--- Method 'first'
/*  public : void method_first (C_Compiler & _inLexique,
                              GGS_lexicalDropInstruction & outElement
                              COMMA_LOCATION_ARGS) const ; */
//--- Method 'last'
/*  public : void method_last (C_Compiler & _inLexique,
                             GGS_lexicalDropInstruction & outElement
                             COMMA_LOCATION_ARGS) const ; */
//--- Modifier 'popLast'
/*  public : void modifier_popLast (C_Compiler & _inLexique,
                                  GGS_lexicalDropInstruction & outElement
                                  COMMA_LOCATION_ARGS) ; */
//--- Modifier 'popFirst'
/*  public : void modifier_popFirst (C_Compiler & _inLexique,
                                   GGS_lexicalDropInstruction & outElement
                                   COMMA_LOCATION_ARGS) ; */
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lexicalDropInstruction & inElement) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalDropInstructionList _operator_concat (const GGS_lexicalDropInstructionList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lstring & argument_0) ;

  protected : void _internalPrependValues (const GGS_lstring & argument_0) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & _inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--- Metamodel Add method
  public : void _addModel (const GGS_lexicalDropInstruction & inOperand) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_lexicalErrorInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalErrorInstruction : public GGS_lexicalInstruction {
//--- 'new' constructor
  public : static GGS_lexicalErrorInstruction constructor_new (C_Compiler & inLexique,
                                const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- 'description' reader
  public : virtual const char * actualTypeName (void) const ;

//--- Readers
  public : GGS_lstring  reader_mErrorMessageName (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalErrorInstruction * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalErrorInstruction * operator () (void) const {
      return (cPtr_lexicalErrorInstruction *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   list '@lexicalErrorInstructionList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalErrorInstructionList : public AC_galgas_list {
  public : typedef cPtr_lexicalErrorInstruction element_type ;
//--- Constructor 'emptyList'
  public : static GGS_lexicalErrorInstructionList constructor_emptyList (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_lexicalErrorInstructionList constructor_listWithValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operator () used for method call
  public : inline const GGS_lexicalErrorInstructionList * operator () (UNUSED_LOCATION_ARGS) const { return this ;}

//--- Method 'first'
/*  public : void method_first (C_Compiler & _inLexique,
                              GGS_lexicalErrorInstruction & outElement
                              COMMA_LOCATION_ARGS) const ; */
//--- Method 'last'
/*  public : void method_last (C_Compiler & _inLexique,
                             GGS_lexicalErrorInstruction & outElement
                             COMMA_LOCATION_ARGS) const ; */
//--- Modifier 'popLast'
/*  public : void modifier_popLast (C_Compiler & _inLexique,
                                  GGS_lexicalErrorInstruction & outElement
                                  COMMA_LOCATION_ARGS) ; */
//--- Modifier 'popFirst'
/*  public : void modifier_popFirst (C_Compiler & _inLexique,
                                   GGS_lexicalErrorInstruction & outElement
                                   COMMA_LOCATION_ARGS) ; */
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lexicalErrorInstruction & inElement) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalErrorInstructionList _operator_concat (const GGS_lexicalErrorInstructionList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lstring & argument_0) ;

  protected : void _internalPrependValues (const GGS_lstring & argument_0) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & _inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--- Metamodel Add method
  public : void _addModel (const GGS_lexicalErrorInstruction & inOperand) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_lexicalTagInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalTagInstruction : public GGS_lexicalInstruction {
//--- 'new' constructor
  public : static GGS_lexicalTagInstruction constructor_new (C_Compiler & inLexique,
                                const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- 'description' reader
  public : virtual const char * actualTypeName (void) const ;

//--- Readers
  public : GGS_lstring  reader_mTagName (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalTagInstruction * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalTagInstruction * operator () (void) const {
      return (cPtr_lexicalTagInstruction *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    list '@lexicalTagInstructionList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalTagInstructionList : public AC_galgas_list {
  public : typedef cPtr_lexicalTagInstruction element_type ;
//--- Constructor 'emptyList'
  public : static GGS_lexicalTagInstructionList constructor_emptyList (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_lexicalTagInstructionList constructor_listWithValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operator () used for method call
  public : inline const GGS_lexicalTagInstructionList * operator () (UNUSED_LOCATION_ARGS) const { return this ;}

//--- Method 'first'
/*  public : void method_first (C_Compiler & _inLexique,
                              GGS_lexicalTagInstruction & outElement
                              COMMA_LOCATION_ARGS) const ; */
//--- Method 'last'
/*  public : void method_last (C_Compiler & _inLexique,
                             GGS_lexicalTagInstruction & outElement
                             COMMA_LOCATION_ARGS) const ; */
//--- Modifier 'popLast'
/*  public : void modifier_popLast (C_Compiler & _inLexique,
                                  GGS_lexicalTagInstruction & outElement
                                  COMMA_LOCATION_ARGS) ; */
//--- Modifier 'popFirst'
/*  public : void modifier_popFirst (C_Compiler & _inLexique,
                                   GGS_lexicalTagInstruction & outElement
                                   COMMA_LOCATION_ARGS) ; */
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lexicalTagInstruction & inElement) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalTagInstructionList _operator_concat (const GGS_lexicalTagInstructionList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lstring & argument_0) ;

  protected : void _internalPrependValues (const GGS_lstring & argument_0) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & _inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--- Metamodel Add method
  public : void _addModel (const GGS_lexicalTagInstruction & inOperand) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_lexicalRewindInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalRewindInstruction : public GGS_lexicalInstruction {
//--- 'new' constructor
  public : static GGS_lexicalRewindInstruction constructor_new (C_Compiler & inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- 'description' reader
  public : virtual const char * actualTypeName (void) const ;

//--- Readers
  public : GGS_lstring  reader_mTagName (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
  public : GGS_lstring  reader_mTerminalName (C_Compiler & inLexique COMMA_LOCATION_ARGS) const ;
//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalRewindInstruction * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalRewindInstruction * operator () (void) const {
      return (cPtr_lexicalRewindInstruction *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   list '@lexicalRewindInstructionList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalRewindInstructionList : public AC_galgas_list {
  public : typedef cPtr_lexicalRewindInstruction element_type ;
//--- Constructor 'emptyList'
  public : static GGS_lexicalRewindInstructionList constructor_emptyList (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_lexicalRewindInstructionList constructor_listWithValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operator () used for method call
  public : inline const GGS_lexicalRewindInstructionList * operator () (UNUSED_LOCATION_ARGS) const { return this ;}

//--- Method 'first'
/*  public : void method_first (C_Compiler & _inLexique,
                              GGS_lexicalRewindInstruction & outElement
                              COMMA_LOCATION_ARGS) const ; */
//--- Method 'last'
/*  public : void method_last (C_Compiler & _inLexique,
                             GGS_lexicalRewindInstruction & outElement
                             COMMA_LOCATION_ARGS) const ; */
//--- Modifier 'popLast'
/*  public : void modifier_popLast (C_Compiler & _inLexique,
                                  GGS_lexicalRewindInstruction & outElement
                                  COMMA_LOCATION_ARGS) ; */
//--- Modifier 'popFirst'
/*  public : void modifier_popFirst (C_Compiler & _inLexique,
                                   GGS_lexicalRewindInstruction & outElement
                                   COMMA_LOCATION_ARGS) ; */
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lexicalRewindInstruction & inElement) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalRewindInstructionList _operator_concat (const GGS_lexicalRewindInstructionList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & _inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) ;

  protected : void _internalPrependValues (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & _inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--- Metamodel Add method
  public : void _addModel (const GGS_lexicalRewindInstruction & inOperand) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_lexicalLogInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalLogInstruction : public GGS_lexicalInstruction {
//--- 'new' constructor
  public : static GGS_lexicalLogInstruction constructor_new (C_Compiler & inLexique
                                COMMA_LOCATION_ARGS) ;
//--- 'description' reader
  public : virtual const char * actualTypeName (void) const ;

//--- Readers
//--- operator ()
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_lexicalLogInstruction * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_lexicalLogInstruction * operator () (void) const {
      return (cPtr_lexicalLogInstruction *) mPointer ;
    }
  #endif

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    list '@lexicalLogInstructionList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_lexicalLogInstructionList : public AC_galgas_list {
  public : typedef cPtr_lexicalLogInstruction element_type ;
//--- Constructor 'emptyList'
  public : static GGS_lexicalLogInstructionList constructor_emptyList (C_Compiler & inLexique COMMA_LOCATION_ARGS) ;
  public : static GGS_lexicalLogInstructionList constructor_listWithValue (C_Compiler & _inLexique
                                COMMA_LOCATION_ARGS) ;
//--- Get first object
  public : inline element_type * firstObject (void) const {
    return (element_type *) internalFirstObject () ;
  }
//--- Get last object
  public : inline element_type * lastObject (void) const {
    return (element_type *) internalLastObject () ;
  }
//--- Operator () used for method call
  public : inline const GGS_lexicalLogInstructionList * operator () (UNUSED_LOCATION_ARGS) const { return this ;}

//--- Method 'first'
/*  public : void method_first (C_Compiler & _inLexique,
                              GGS_lexicalLogInstruction & outElement
                              COMMA_LOCATION_ARGS) const ; */
//--- Method 'last'
/*  public : void method_last (C_Compiler & _inLexique,
                             GGS_lexicalLogInstruction & outElement
                             COMMA_LOCATION_ARGS) const ; */
//--- Modifier 'popLast'
/*  public : void modifier_popLast (C_Compiler & _inLexique,
                                  GGS_lexicalLogInstruction & outElement
                                  COMMA_LOCATION_ARGS) ; */
//--- Modifier 'popFirst'
/*  public : void modifier_popFirst (C_Compiler & _inLexique,
                                   GGS_lexicalLogInstruction & outElement
                                   COMMA_LOCATION_ARGS) ; */
//--- Handling '+=' GALGAS operator
  public : void _addAssign_operation (const GGS_lexicalLogInstruction & inElement) ;
//--- Handling '.' GALGAS operator
  public : GGS_lexicalLogInstructionList _operator_concat (const GGS_lexicalLogInstructionList & inOperand) const ;
  public : void modifier_prependValue (C_Compiler & _inLexique
                                COMMA_LOCATION_ARGS) ;
//--- Internal Methods
  protected : void _internalAppendValues () ;

  protected : void _internalPrependValues () ;

//--- List Insulation
  protected : void _insulateList (void) ;

//--- Reader 'description
  public : GGS_string
  reader_description (C_Compiler & _inLexique
                      COMMA_LOCATION_ARGS,
                      const sint32 inIndentation = 0) const ;

//--- Metamodel Add method
  public : void _addModel (const GGS_lexicalLogInstruction & inOperand) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@lexiqueComponentRootList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexiqueComponentRoot : public C_GGS_MetamodelEntity {
//--- Attributes
  public : GGS_lstring  mLexiqueComponentName ;
  public : GGS_lexicalAttributeList  mLexicalAttributeList ;
  public : GGS_lexicalStyleList  mLexicalStyleList ;
  public : GGS_terminalDeclarationList  mTerminalDeclarationList ;
  public : GGS_lexicalErrorMessageDeclarationList  mLexicalErrorMessageDeclarationList ;
  public : GGS_lexicalListDeclarationList  mLexicalListDeclarationList ;
  public : GGS_lexicalImplicitRuleList  mLexicalImplicitRuleList ;
  public : GGS_lexicalExplicitRuleList  mLexicalExplicitRuleList ;
//--- Constructor
  public : cPtr_lexiqueComponentRoot (const GGS_lstring & ,
                                const GGS_lexicalAttributeList & ,
                                const GGS_lexicalStyleList & ,
                                const GGS_terminalDeclarationList & ,
                                const GGS_lexicalErrorMessageDeclarationList & ,
                                const GGS_lexicalListDeclarationList & ,
                                const GGS_lexicalImplicitRuleList & ,
                                const GGS_lexicalExplicitRuleList & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline cPtr_lexiqueComponentRoot * nextObject (void) const {
    return (cPtr_lexiqueComponentRoot *) internalNextItem () ;
  }

//--- Access to previous
  public : inline cPtr_lexiqueComponentRoot * previousObject (void) const {
    return (cPtr_lexiqueComponentRoot *) internalPreviousItem () ;
  }

//--- Element comparison
  public : virtual bool isEqualToObject (const cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & _inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Metamodel Index
  public : virtual uint32 _metamodelIndex (void) const ;

//--- Metamodel Class ID
  public : virtual uint32 _metamodelClassID (void) const ;

//--- 'clone' virtual method
  public : virtual cPtr_lexiqueComponentRoot * _cloneObject (void) const ;

//--- Friend class declarations
  friend class GGS_lexiqueComponentRootList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@lexicalImplicitRuleList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalImplicitRule : public C_GGS_MetamodelEntity {
//--- Attributes
  public : GGS_lstring  mListName ;
//--- Constructor
  public : cPtr_lexicalImplicitRule (const GGS_lstring & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline cPtr_lexicalImplicitRule * nextObject (void) const {
    return (cPtr_lexicalImplicitRule *) internalNextItem () ;
  }

//--- Access to previous
  public : inline cPtr_lexicalImplicitRule * previousObject (void) const {
    return (cPtr_lexicalImplicitRule *) internalPreviousItem () ;
  }

//--- Element comparison
  public : virtual bool isEqualToObject (const cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & _inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Metamodel Index
  public : virtual uint32 _metamodelIndex (void) const ;

//--- Metamodel Class ID
  public : virtual uint32 _metamodelClassID (void) const ;

//--- 'clone' virtual method
  public : virtual cPtr_lexicalImplicitRule * _cloneObject (void) const ;

//--- Friend class declarations
  friend class GGS_lexicalImplicitRuleList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//          Element of list '@lexicalErrorMessageDeclarationList'            *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalErrorMessageDeclaration : public C_GGS_MetamodelEntity {
//--- Attributes
  public : GGS_lstring  mMessageName ;
  public : GGS_lstring  mMessageValue ;
//--- Constructor
  public : cPtr_lexicalErrorMessageDeclaration (const GGS_lstring & ,
                                const GGS_lstring & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline cPtr_lexicalErrorMessageDeclaration * nextObject (void) const {
    return (cPtr_lexicalErrorMessageDeclaration *) internalNextItem () ;
  }

//--- Access to previous
  public : inline cPtr_lexicalErrorMessageDeclaration * previousObject (void) const {
    return (cPtr_lexicalErrorMessageDeclaration *) internalPreviousItem () ;
  }

//--- Element comparison
  public : virtual bool isEqualToObject (const cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & _inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Metamodel Index
  public : virtual uint32 _metamodelIndex (void) const ;

//--- Metamodel Class ID
  public : virtual uint32 _metamodelClassID (void) const ;

//--- 'clone' virtual method
  public : virtual cPtr_lexicalErrorMessageDeclaration * _cloneObject (void) const ;

//--- Friend class declarations
  friend class GGS_lexicalErrorMessageDeclarationList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@lexicalAttributeList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalAttribute : public C_GGS_MetamodelEntity {
//--- Attributes
  public : GGS_lstring  mTypeName ;
  public : GGS_lstring  mName ;
//--- Constructor
  public : cPtr_lexicalAttribute (const GGS_lstring & ,
                                const GGS_lstring & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline cPtr_lexicalAttribute * nextObject (void) const {
    return (cPtr_lexicalAttribute *) internalNextItem () ;
  }

//--- Access to previous
  public : inline cPtr_lexicalAttribute * previousObject (void) const {
    return (cPtr_lexicalAttribute *) internalPreviousItem () ;
  }

//--- Element comparison
  public : virtual bool isEqualToObject (const cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & _inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Metamodel Index
  public : virtual uint32 _metamodelIndex (void) const ;

//--- Metamodel Class ID
  public : virtual uint32 _metamodelClassID (void) const ;

//--- 'clone' virtual method
  public : virtual cPtr_lexicalAttribute * _cloneObject (void) const ;

//--- Friend class declarations
  friend class GGS_lexicalAttributeList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   Element of list '@lexicalStyleList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalStyle : public C_GGS_MetamodelEntity {
//--- Attributes
  public : GGS_lstring  mName ;
  public : GGS_lstring  mComment ;
//--- Constructor
  public : cPtr_lexicalStyle (const GGS_lstring & ,
                                const GGS_lstring & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline cPtr_lexicalStyle * nextObject (void) const {
    return (cPtr_lexicalStyle *) internalNextItem () ;
  }

//--- Access to previous
  public : inline cPtr_lexicalStyle * previousObject (void) const {
    return (cPtr_lexicalStyle *) internalPreviousItem () ;
  }

//--- Element comparison
  public : virtual bool isEqualToObject (const cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & _inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Metamodel Index
  public : virtual uint32 _metamodelIndex (void) const ;

//--- Metamodel Class ID
  public : virtual uint32 _metamodelClassID (void) const ;

//--- 'clone' virtual method
  public : virtual cPtr_lexicalStyle * _cloneObject (void) const ;

//--- Friend class declarations
  friend class GGS_lexicalStyleList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@terminalDeclarationList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_terminalDeclaration : public C_GGS_MetamodelEntity {
//--- Attributes
  public : GGS_lstring  mName ;
  public : GGS_lstringlist  mSentAttributeList ;
  public : GGS_lstring  mErrorMessage ;
  public : GGS_lstring  mStyle ;
//--- Constructor
  public : cPtr_terminalDeclaration (const GGS_lstring & ,
                                const GGS_lstringlist & ,
                                const GGS_lstring & ,
                                const GGS_lstring & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline cPtr_terminalDeclaration * nextObject (void) const {
    return (cPtr_terminalDeclaration *) internalNextItem () ;
  }

//--- Access to previous
  public : inline cPtr_terminalDeclaration * previousObject (void) const {
    return (cPtr_terminalDeclaration *) internalPreviousItem () ;
  }

//--- Element comparison
  public : virtual bool isEqualToObject (const cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & _inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Metamodel Index
  public : virtual uint32 _metamodelIndex (void) const ;

//--- Metamodel Class ID
  public : virtual uint32 _metamodelClassID (void) const ;

//--- 'clone' virtual method
  public : virtual cPtr_terminalDeclaration * _cloneObject (void) const ;

//--- Friend class declarations
  friend class GGS_terminalDeclarationList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@lexicalListDeclarationList'                *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalListDeclaration : public C_GGS_MetamodelEntity {
//--- Attributes
  public : GGS_lstring  mName ;
  public : GGS_lstring  mStyle ;
  public : GGS_lstring  mErrorMessage ;
  public : GGS_lstringlist  mSentAttributeList ;
  public : GGS_lexicalListEntryList  mEntryList ;
//--- Constructor
  public : cPtr_lexicalListDeclaration (const GGS_lstring & ,
                                const GGS_lstring & ,
                                const GGS_lstring & ,
                                const GGS_lstringlist & ,
                                const GGS_lexicalListEntryList & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline cPtr_lexicalListDeclaration * nextObject (void) const {
    return (cPtr_lexicalListDeclaration *) internalNextItem () ;
  }

//--- Access to previous
  public : inline cPtr_lexicalListDeclaration * previousObject (void) const {
    return (cPtr_lexicalListDeclaration *) internalPreviousItem () ;
  }

//--- Element comparison
  public : virtual bool isEqualToObject (const cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & _inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Metamodel Index
  public : virtual uint32 _metamodelIndex (void) const ;

//--- Metamodel Class ID
  public : virtual uint32 _metamodelClassID (void) const ;

//--- 'clone' virtual method
  public : virtual cPtr_lexicalListDeclaration * _cloneObject (void) const ;

//--- Friend class declarations
  friend class GGS_lexicalListDeclarationList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@lexicalListEntryList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalListEntry : public C_GGS_MetamodelEntity {
//--- Attributes
  public : GGS_lstring  mEntrySpelling ;
  public : GGS_lstring  mTerminalSpelling ;
//--- Constructor
  public : cPtr_lexicalListEntry (const GGS_lstring & ,
                                const GGS_lstring & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline cPtr_lexicalListEntry * nextObject (void) const {
    return (cPtr_lexicalListEntry *) internalNextItem () ;
  }

//--- Access to previous
  public : inline cPtr_lexicalListEntry * previousObject (void) const {
    return (cPtr_lexicalListEntry *) internalPreviousItem () ;
  }

//--- Element comparison
  public : virtual bool isEqualToObject (const cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & _inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Metamodel Index
  public : virtual uint32 _metamodelIndex (void) const ;

//--- Metamodel Class ID
  public : virtual uint32 _metamodelClassID (void) const ;

//--- 'clone' virtual method
  public : virtual cPtr_lexicalListEntry * _cloneObject (void) const ;

//--- Friend class declarations
  friend class GGS_lexicalListEntryList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@lexicalExplicitRuleList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalExplicitRule : public C_GGS_MetamodelEntity {
//--- Attributes
  public : GGS_lexicalExpression  mLexicalRuleExpression ;
  public : GGS_lexicalInstructionList  mInstructionList ;
//--- Constructor
  public : cPtr_lexicalExplicitRule (const GGS_lexicalExpression & ,
                                const GGS_lexicalInstructionList & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline cPtr_lexicalExplicitRule * nextObject (void) const {
    return (cPtr_lexicalExplicitRule *) internalNextItem () ;
  }

//--- Access to previous
  public : inline cPtr_lexicalExplicitRule * previousObject (void) const {
    return (cPtr_lexicalExplicitRule *) internalPreviousItem () ;
  }

//--- Element comparison
  public : virtual bool isEqualToObject (const cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & _inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Metamodel Index
  public : virtual uint32 _metamodelIndex (void) const ;

//--- Metamodel Class ID
  public : virtual uint32 _metamodelClassID (void) const ;

//--- 'clone' virtual method
  public : virtual cPtr_lexicalExplicitRule * _cloneObject (void) const ;

//--- Friend class declarations
  friend class GGS_lexicalExplicitRuleList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@lexicalExpressionList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalExpression : public C_GGS_MetamodelEntity {
//--- Attributes
//--- Constructor
  public : cPtr_lexicalExpression (LOCATION_ARGS) ;

//--- Access to next
  public : inline cPtr_lexicalExpression * nextObject (void) const {
    return (cPtr_lexicalExpression *) internalNextItem () ;
  }

//--- Access to previous
  public : inline cPtr_lexicalExpression * previousObject (void) const {
    return (cPtr_lexicalExpression *) internalPreviousItem () ;
  }

//--- Element comparison
  public : virtual bool isEqualToObject (const cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & _inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Metamodel Index
  public : virtual uint32 _metamodelIndex (void) const ;

//--- Metamodel Class ID
  public : virtual uint32 _metamodelClassID (void) const ;

//--- 'clone' virtual method
  public : virtual cPtr_lexicalExpression * _cloneObject (void) const ;

//--- Friend class declarations
  friend class GGS_lexicalExpressionList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@lexicalOrExpressionList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalOrExpression : public cPtr_lexicalExpression {
//--- Attributes
  public : GGS_lexicalExpression  mLeftOperand ;
  public : GGS_lexicalExpression  mRightOperand ;
//--- Constructor
  public : cPtr_lexicalOrExpression (const GGS_lexicalExpression & ,
                                const GGS_lexicalExpression & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline cPtr_lexicalOrExpression * nextObject (void) const {
    return (cPtr_lexicalOrExpression *) internalNextItem () ;
  }

//--- Access to previous
  public : inline cPtr_lexicalOrExpression * previousObject (void) const {
    return (cPtr_lexicalOrExpression *) internalPreviousItem () ;
  }

//--- Element comparison
  public : virtual bool isEqualToObject (const cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & _inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Metamodel Index
  public : virtual uint32 _metamodelIndex (void) const ;

//--- Metamodel Class ID
  public : virtual uint32 _metamodelClassID (void) const ;

//--- 'clone' virtual method
  public : virtual cPtr_lexicalOrExpression * _cloneObject (void) const ;

//--- Friend class declarations
  friend class GGS_lexicalOrExpressionList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@lexicalCharacterMatchList'                *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalCharacterMatch : public cPtr_lexicalExpression {
//--- Attributes
  public : GGS_lchar  mCharacter ;
//--- Constructor
  public : cPtr_lexicalCharacterMatch (const GGS_lchar & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline cPtr_lexicalCharacterMatch * nextObject (void) const {
    return (cPtr_lexicalCharacterMatch *) internalNextItem () ;
  }

//--- Access to previous
  public : inline cPtr_lexicalCharacterMatch * previousObject (void) const {
    return (cPtr_lexicalCharacterMatch *) internalPreviousItem () ;
  }

//--- Element comparison
  public : virtual bool isEqualToObject (const cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & _inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Metamodel Index
  public : virtual uint32 _metamodelIndex (void) const ;

//--- Metamodel Class ID
  public : virtual uint32 _metamodelClassID (void) const ;

//--- 'clone' virtual method
  public : virtual cPtr_lexicalCharacterMatch * _cloneObject (void) const ;

//--- Friend class declarations
  friend class GGS_lexicalCharacterMatchList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//           Element of list '@lexicalCharacterIntervalMatchList'            *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalCharacterIntervalMatch : public cPtr_lexicalExpression {
//--- Attributes
  public : GGS_lchar  mLowerBound ;
  public : GGS_lchar  mUpperBound ;
//--- Constructor
  public : cPtr_lexicalCharacterIntervalMatch (const GGS_lchar & ,
                                const GGS_lchar & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline cPtr_lexicalCharacterIntervalMatch * nextObject (void) const {
    return (cPtr_lexicalCharacterIntervalMatch *) internalNextItem () ;
  }

//--- Access to previous
  public : inline cPtr_lexicalCharacterIntervalMatch * previousObject (void) const {
    return (cPtr_lexicalCharacterIntervalMatch *) internalPreviousItem () ;
  }

//--- Element comparison
  public : virtual bool isEqualToObject (const cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & _inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Metamodel Index
  public : virtual uint32 _metamodelIndex (void) const ;

//--- Metamodel Class ID
  public : virtual uint32 _metamodelClassID (void) const ;

//--- 'clone' virtual method
  public : virtual cPtr_lexicalCharacterIntervalMatch * _cloneObject (void) const ;

//--- Friend class declarations
  friend class GGS_lexicalCharacterIntervalMatchList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@lexicalStringMatchList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalStringMatch : public cPtr_lexicalExpression {
//--- Attributes
  public : GGS_lstring  mString ;
//--- Constructor
  public : cPtr_lexicalStringMatch (const GGS_lstring & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline cPtr_lexicalStringMatch * nextObject (void) const {
    return (cPtr_lexicalStringMatch *) internalNextItem () ;
  }

//--- Access to previous
  public : inline cPtr_lexicalStringMatch * previousObject (void) const {
    return (cPtr_lexicalStringMatch *) internalPreviousItem () ;
  }

//--- Element comparison
  public : virtual bool isEqualToObject (const cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & _inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Metamodel Index
  public : virtual uint32 _metamodelIndex (void) const ;

//--- Metamodel Class ID
  public : virtual uint32 _metamodelClassID (void) const ;

//--- 'clone' virtual method
  public : virtual cPtr_lexicalStringMatch * _cloneObject (void) const ;

//--- Friend class declarations
  friend class GGS_lexicalStringMatchList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@lexicalStringNotMatchList'                *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalStringNotMatch : public cPtr_lexicalExpression {
//--- Attributes
  public : GGS_lstring  mString ;
  public : GGS_lstring  mErrorMessage ;
//--- Constructor
  public : cPtr_lexicalStringNotMatch (const GGS_lstring & ,
                                const GGS_lstring & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline cPtr_lexicalStringNotMatch * nextObject (void) const {
    return (cPtr_lexicalStringNotMatch *) internalNextItem () ;
  }

//--- Access to previous
  public : inline cPtr_lexicalStringNotMatch * previousObject (void) const {
    return (cPtr_lexicalStringNotMatch *) internalPreviousItem () ;
  }

//--- Element comparison
  public : virtual bool isEqualToObject (const cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & _inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Metamodel Index
  public : virtual uint32 _metamodelIndex (void) const ;

//--- Metamodel Class ID
  public : virtual uint32 _metamodelClassID (void) const ;

//--- 'clone' virtual method
  public : virtual cPtr_lexicalStringNotMatch * _cloneObject (void) const ;

//--- Friend class declarations
  friend class GGS_lexicalStringNotMatchList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@lexicalInstructionList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalInstruction : public C_GGS_MetamodelEntity {
//--- Attributes
//--- Constructor
  public : cPtr_lexicalInstruction (LOCATION_ARGS) ;

//--- Access to next
  public : inline cPtr_lexicalInstruction * nextObject (void) const {
    return (cPtr_lexicalInstruction *) internalNextItem () ;
  }

//--- Access to previous
  public : inline cPtr_lexicalInstruction * previousObject (void) const {
    return (cPtr_lexicalInstruction *) internalPreviousItem () ;
  }

//--- Element comparison
  public : virtual bool isEqualToObject (const cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & _inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Metamodel Index
  public : virtual uint32 _metamodelIndex (void) const ;

//--- Metamodel Class ID
  public : virtual uint32 _metamodelClassID (void) const ;

//--- 'clone' virtual method
  public : virtual cPtr_lexicalInstruction * _cloneObject (void) const ;

//--- Friend class declarations
  friend class GGS_lexicalInstructionList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//         Element of list '@lexicalStructuredSendInstructionList'           *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalStructuredSendInstruction : public cPtr_lexicalInstruction {
//--- Attributes
  public : GGS_lexicalSendSearchList  mLexicalSendSearchList ;
  public : GGS_lexicalSendDefaultAction  mLexicalSendDefaultAction ;
//--- Constructor
  public : cPtr_lexicalStructuredSendInstruction (const GGS_lexicalSendSearchList & ,
                                const GGS_lexicalSendDefaultAction & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline cPtr_lexicalStructuredSendInstruction * nextObject (void) const {
    return (cPtr_lexicalStructuredSendInstruction *) internalNextItem () ;
  }

//--- Access to previous
  public : inline cPtr_lexicalStructuredSendInstruction * previousObject (void) const {
    return (cPtr_lexicalStructuredSendInstruction *) internalPreviousItem () ;
  }

//--- Element comparison
  public : virtual bool isEqualToObject (const cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & _inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Metamodel Index
  public : virtual uint32 _metamodelIndex (void) const ;

//--- Metamodel Class ID
  public : virtual uint32 _metamodelClassID (void) const ;

//--- 'clone' virtual method
  public : virtual cPtr_lexicalStructuredSendInstruction * _cloneObject (void) const ;

//--- Friend class declarations
  friend class GGS_lexicalStructuredSendInstructionList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//           Element of list '@lexicalSimpleSendInstructionList'             *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalSimpleSendInstruction : public cPtr_lexicalInstruction {
//--- Attributes
  public : GGS_lstring  mSentTerminal ;
//--- Constructor
  public : cPtr_lexicalSimpleSendInstruction (const GGS_lstring & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline cPtr_lexicalSimpleSendInstruction * nextObject (void) const {
    return (cPtr_lexicalSimpleSendInstruction *) internalNextItem () ;
  }

//--- Access to previous
  public : inline cPtr_lexicalSimpleSendInstruction * previousObject (void) const {
    return (cPtr_lexicalSimpleSendInstruction *) internalPreviousItem () ;
  }

//--- Element comparison
  public : virtual bool isEqualToObject (const cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & _inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Metamodel Index
  public : virtual uint32 _metamodelIndex (void) const ;

//--- Metamodel Class ID
  public : virtual uint32 _metamodelClassID (void) const ;

//--- 'clone' virtual method
  public : virtual cPtr_lexicalSimpleSendInstruction * _cloneObject (void) const ;

//--- Friend class declarations
  friend class GGS_lexicalSimpleSendInstructionList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@lexicalSendDefaultActionList'               *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalSendDefaultAction : public C_GGS_MetamodelEntity {
//--- Attributes
//--- Constructor
  public : cPtr_lexicalSendDefaultAction (LOCATION_ARGS) ;

//--- Access to next
  public : inline cPtr_lexicalSendDefaultAction * nextObject (void) const {
    return (cPtr_lexicalSendDefaultAction *) internalNextItem () ;
  }

//--- Access to previous
  public : inline cPtr_lexicalSendDefaultAction * previousObject (void) const {
    return (cPtr_lexicalSendDefaultAction *) internalPreviousItem () ;
  }

//--- Element comparison
  public : virtual bool isEqualToObject (const cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & _inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Metamodel Index
  public : virtual uint32 _metamodelIndex (void) const ;

//--- Metamodel Class ID
  public : virtual uint32 _metamodelClassID (void) const ;

//--- 'clone' virtual method
  public : virtual cPtr_lexicalSendDefaultAction * _cloneObject (void) const ;

//--- Friend class declarations
  friend class GGS_lexicalSendDefaultActionList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//           Element of list '@lexicalSendTerminalByDefaultList'             *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalSendTerminalByDefault : public cPtr_lexicalSendDefaultAction {
//--- Attributes
  public : GGS_lstring  mDefaultSentTerminal ;
//--- Constructor
  public : cPtr_lexicalSendTerminalByDefault (const GGS_lstring & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline cPtr_lexicalSendTerminalByDefault * nextObject (void) const {
    return (cPtr_lexicalSendTerminalByDefault *) internalNextItem () ;
  }

//--- Access to previous
  public : inline cPtr_lexicalSendTerminalByDefault * previousObject (void) const {
    return (cPtr_lexicalSendTerminalByDefault *) internalPreviousItem () ;
  }

//--- Element comparison
  public : virtual bool isEqualToObject (const cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & _inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Metamodel Index
  public : virtual uint32 _metamodelIndex (void) const ;

//--- Metamodel Class ID
  public : virtual uint32 _metamodelClassID (void) const ;

//--- 'clone' virtual method
  public : virtual cPtr_lexicalSendTerminalByDefault * _cloneObject (void) const ;

//--- Friend class declarations
  friend class GGS_lexicalSendTerminalByDefaultList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@lexicalErrorByDefaultList'                *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalErrorByDefault : public cPtr_lexicalSendDefaultAction {
//--- Attributes
  public : GGS_lstring  mDefaultErrorMessageName ;
//--- Constructor
  public : cPtr_lexicalErrorByDefault (const GGS_lstring & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline cPtr_lexicalErrorByDefault * nextObject (void) const {
    return (cPtr_lexicalErrorByDefault *) internalNextItem () ;
  }

//--- Access to previous
  public : inline cPtr_lexicalErrorByDefault * previousObject (void) const {
    return (cPtr_lexicalErrorByDefault *) internalPreviousItem () ;
  }

//--- Element comparison
  public : virtual bool isEqualToObject (const cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & _inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Metamodel Index
  public : virtual uint32 _metamodelIndex (void) const ;

//--- Metamodel Class ID
  public : virtual uint32 _metamodelClassID (void) const ;

//--- 'clone' virtual method
  public : virtual cPtr_lexicalErrorByDefault * _cloneObject (void) const ;

//--- Friend class declarations
  friend class GGS_lexicalErrorByDefaultList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@lexicalSendSearchList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalSendSearch : public C_GGS_MetamodelEntity {
//--- Attributes
  public : GGS_lstring  mAttributeName ;
  public : GGS_lstring  mSearchListName ;
//--- Constructor
  public : cPtr_lexicalSendSearch (const GGS_lstring & ,
                                const GGS_lstring & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline cPtr_lexicalSendSearch * nextObject (void) const {
    return (cPtr_lexicalSendSearch *) internalNextItem () ;
  }

//--- Access to previous
  public : inline cPtr_lexicalSendSearch * previousObject (void) const {
    return (cPtr_lexicalSendSearch *) internalPreviousItem () ;
  }

//--- Element comparison
  public : virtual bool isEqualToObject (const cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & _inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Metamodel Index
  public : virtual uint32 _metamodelIndex (void) const ;

//--- Metamodel Class ID
  public : virtual uint32 _metamodelClassID (void) const ;

//--- 'clone' virtual method
  public : virtual cPtr_lexicalSendSearch * _cloneObject (void) const ;

//--- Friend class declarations
  friend class GGS_lexicalSendSearchList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@lexicalRepeatInstructionList'               *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalRepeatInstruction : public cPtr_lexicalInstruction {
//--- Attributes
  public : GGS_lexicalInstructionList  mRepeatedInstructionList ;
  public : GGS_lexicalWhileBranchList  mLexicalWhileBranchList ;
//--- Constructor
  public : cPtr_lexicalRepeatInstruction (const GGS_lexicalInstructionList & ,
                                const GGS_lexicalWhileBranchList & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline cPtr_lexicalRepeatInstruction * nextObject (void) const {
    return (cPtr_lexicalRepeatInstruction *) internalNextItem () ;
  }

//--- Access to previous
  public : inline cPtr_lexicalRepeatInstruction * previousObject (void) const {
    return (cPtr_lexicalRepeatInstruction *) internalPreviousItem () ;
  }

//--- Element comparison
  public : virtual bool isEqualToObject (const cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & _inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Metamodel Index
  public : virtual uint32 _metamodelIndex (void) const ;

//--- Metamodel Class ID
  public : virtual uint32 _metamodelClassID (void) const ;

//--- 'clone' virtual method
  public : virtual cPtr_lexicalRepeatInstruction * _cloneObject (void) const ;

//--- Friend class declarations
  friend class GGS_lexicalRepeatInstructionList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@lexicalWhileBranchList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalWhileBranch : public C_GGS_MetamodelEntity {
//--- Attributes
  public : GGS_lexicalExpression  mWhileExpression ;
  public : GGS_lexicalInstructionList  mWhileInstructionList ;
//--- Constructor
  public : cPtr_lexicalWhileBranch (const GGS_lexicalExpression & ,
                                const GGS_lexicalInstructionList & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline cPtr_lexicalWhileBranch * nextObject (void) const {
    return (cPtr_lexicalWhileBranch *) internalNextItem () ;
  }

//--- Access to previous
  public : inline cPtr_lexicalWhileBranch * previousObject (void) const {
    return (cPtr_lexicalWhileBranch *) internalPreviousItem () ;
  }

//--- Element comparison
  public : virtual bool isEqualToObject (const cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & _inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Metamodel Index
  public : virtual uint32 _metamodelIndex (void) const ;

//--- Metamodel Class ID
  public : virtual uint32 _metamodelClassID (void) const ;

//--- 'clone' virtual method
  public : virtual cPtr_lexicalWhileBranch * _cloneObject (void) const ;

//--- Friend class declarations
  friend class GGS_lexicalWhileBranchList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@lexicalSelectInstructionList'               *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalSelectInstruction : public cPtr_lexicalInstruction {
//--- Attributes
  public : GGS_lexicalSelectBranchList  mLexicalWhileBranchList ;
  public : GGS_lexicalInstructionList  mDefaultInstructionList ;
//--- Constructor
  public : cPtr_lexicalSelectInstruction (const GGS_lexicalSelectBranchList & ,
                                const GGS_lexicalInstructionList & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline cPtr_lexicalSelectInstruction * nextObject (void) const {
    return (cPtr_lexicalSelectInstruction *) internalNextItem () ;
  }

//--- Access to previous
  public : inline cPtr_lexicalSelectInstruction * previousObject (void) const {
    return (cPtr_lexicalSelectInstruction *) internalPreviousItem () ;
  }

//--- Element comparison
  public : virtual bool isEqualToObject (const cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & _inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Metamodel Index
  public : virtual uint32 _metamodelIndex (void) const ;

//--- Metamodel Class ID
  public : virtual uint32 _metamodelClassID (void) const ;

//--- 'clone' virtual method
  public : virtual cPtr_lexicalSelectInstruction * _cloneObject (void) const ;

//--- Friend class declarations
  friend class GGS_lexicalSelectInstructionList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@lexicalSelectBranchList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalSelectBranch : public C_GGS_MetamodelEntity {
//--- Attributes
  public : GGS_lexicalExpression  mSelectExpression ;
  public : GGS_lexicalInstructionList  mSelectInstructionList ;
//--- Constructor
  public : cPtr_lexicalSelectBranch (const GGS_lexicalExpression & ,
                                const GGS_lexicalInstructionList & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline cPtr_lexicalSelectBranch * nextObject (void) const {
    return (cPtr_lexicalSelectBranch *) internalNextItem () ;
  }

//--- Access to previous
  public : inline cPtr_lexicalSelectBranch * previousObject (void) const {
    return (cPtr_lexicalSelectBranch *) internalPreviousItem () ;
  }

//--- Element comparison
  public : virtual bool isEqualToObject (const cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & _inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Metamodel Index
  public : virtual uint32 _metamodelIndex (void) const ;

//--- Metamodel Class ID
  public : virtual uint32 _metamodelClassID (void) const ;

//--- 'clone' virtual method
  public : virtual cPtr_lexicalSelectBranch * _cloneObject (void) const ;

//--- Friend class declarations
  friend class GGS_lexicalSelectBranchList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@lexicalActionInstructionList'               *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalActionInstruction : public cPtr_lexicalInstruction {
//--- Attributes
  public : GGS_lstring  mActionName ;
  public : GGS_lexicalActualArgumentList  mActualArgumentList ;
  public : GGS_lstringlist  mErrorMessageList ;
//--- Constructor
  public : cPtr_lexicalActionInstruction (const GGS_lstring & ,
                                const GGS_lexicalActualArgumentList & ,
                                const GGS_lstringlist & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline cPtr_lexicalActionInstruction * nextObject (void) const {
    return (cPtr_lexicalActionInstruction *) internalNextItem () ;
  }

//--- Access to previous
  public : inline cPtr_lexicalActionInstruction * previousObject (void) const {
    return (cPtr_lexicalActionInstruction *) internalPreviousItem () ;
  }

//--- Element comparison
  public : virtual bool isEqualToObject (const cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & _inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Metamodel Index
  public : virtual uint32 _metamodelIndex (void) const ;

//--- Metamodel Class ID
  public : virtual uint32 _metamodelClassID (void) const ;

//--- 'clone' virtual method
  public : virtual cPtr_lexicalActionInstruction * _cloneObject (void) const ;

//--- Friend class declarations
  friend class GGS_lexicalActionInstructionList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@lexicalActualArgumentList'                *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalActualArgument : public C_GGS_MetamodelEntity {
//--- Attributes
//--- Constructor
  public : cPtr_lexicalActualArgument (LOCATION_ARGS) ;

//--- Access to next
  public : inline cPtr_lexicalActualArgument * nextObject (void) const {
    return (cPtr_lexicalActualArgument *) internalNextItem () ;
  }

//--- Access to previous
  public : inline cPtr_lexicalActualArgument * previousObject (void) const {
    return (cPtr_lexicalActualArgument *) internalPreviousItem () ;
  }

//--- Element comparison
  public : virtual bool isEqualToObject (const cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & _inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Metamodel Index
  public : virtual uint32 _metamodelIndex (void) const ;

//--- Metamodel Class ID
  public : virtual uint32 _metamodelClassID (void) const ;

//--- 'clone' virtual method
  public : virtual cPtr_lexicalActualArgument * _cloneObject (void) const ;

//--- Friend class declarations
  friend class GGS_lexicalActualArgumentList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@lexicalAttributeArgumentList'               *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalAttributeArgument : public cPtr_lexicalActualArgument {
//--- Attributes
  public : GGS_lstring  mAttributeName ;
//--- Constructor
  public : cPtr_lexicalAttributeArgument (const GGS_lstring & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline cPtr_lexicalAttributeArgument * nextObject (void) const {
    return (cPtr_lexicalAttributeArgument *) internalNextItem () ;
  }

//--- Access to previous
  public : inline cPtr_lexicalAttributeArgument * previousObject (void) const {
    return (cPtr_lexicalAttributeArgument *) internalPreviousItem () ;
  }

//--- Element comparison
  public : virtual bool isEqualToObject (const cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & _inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Metamodel Index
  public : virtual uint32 _metamodelIndex (void) const ;

//--- Metamodel Class ID
  public : virtual uint32 _metamodelClassID (void) const ;

//--- 'clone' virtual method
  public : virtual cPtr_lexicalAttributeArgument * _cloneObject (void) const ;

//--- Friend class declarations
  friend class GGS_lexicalAttributeArgumentList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@lexicalCharacterArgumentList'               *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalCharacterArgument : public cPtr_lexicalActualArgument {
//--- Attributes
  public : GGS_lchar  mCharacter ;
//--- Constructor
  public : cPtr_lexicalCharacterArgument (const GGS_lchar & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline cPtr_lexicalCharacterArgument * nextObject (void) const {
    return (cPtr_lexicalCharacterArgument *) internalNextItem () ;
  }

//--- Access to previous
  public : inline cPtr_lexicalCharacterArgument * previousObject (void) const {
    return (cPtr_lexicalCharacterArgument *) internalPreviousItem () ;
  }

//--- Element comparison
  public : virtual bool isEqualToObject (const cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & _inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Metamodel Index
  public : virtual uint32 _metamodelIndex (void) const ;

//--- Metamodel Class ID
  public : virtual uint32 _metamodelClassID (void) const ;

//--- 'clone' virtual method
  public : virtual cPtr_lexicalCharacterArgument * _cloneObject (void) const ;

//--- Friend class declarations
  friend class GGS_lexicalCharacterArgumentList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//          Element of list '@lexicalCurrentCharacterArgumentList'           *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalCurrentCharacterArgument : public cPtr_lexicalActualArgument {
//--- Attributes
//--- Constructor
  public : cPtr_lexicalCurrentCharacterArgument (LOCATION_ARGS) ;

//--- Access to next
  public : inline cPtr_lexicalCurrentCharacterArgument * nextObject (void) const {
    return (cPtr_lexicalCurrentCharacterArgument *) internalNextItem () ;
  }

//--- Access to previous
  public : inline cPtr_lexicalCurrentCharacterArgument * previousObject (void) const {
    return (cPtr_lexicalCurrentCharacterArgument *) internalPreviousItem () ;
  }

//--- Element comparison
  public : virtual bool isEqualToObject (const cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & _inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Metamodel Index
  public : virtual uint32 _metamodelIndex (void) const ;

//--- Metamodel Class ID
  public : virtual uint32 _metamodelClassID (void) const ;

//--- 'clone' virtual method
  public : virtual cPtr_lexicalCurrentCharacterArgument * _cloneObject (void) const ;

//--- Friend class declarations
  friend class GGS_lexicalCurrentCharacterArgumentList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@lexicalFunctionArgumentList'               *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalFunctionArgument : public cPtr_lexicalActualArgument {
//--- Attributes
  public : GGS_lstring  mFunctionName ;
  public : GGS_lexicalActualArgumentList  mFunctionActualArgumentList ;
//--- Constructor
  public : cPtr_lexicalFunctionArgument (const GGS_lstring & ,
                                const GGS_lexicalActualArgumentList & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline cPtr_lexicalFunctionArgument * nextObject (void) const {
    return (cPtr_lexicalFunctionArgument *) internalNextItem () ;
  }

//--- Access to previous
  public : inline cPtr_lexicalFunctionArgument * previousObject (void) const {
    return (cPtr_lexicalFunctionArgument *) internalPreviousItem () ;
  }

//--- Element comparison
  public : virtual bool isEqualToObject (const cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & _inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Metamodel Index
  public : virtual uint32 _metamodelIndex (void) const ;

//--- Metamodel Class ID
  public : virtual uint32 _metamodelClassID (void) const ;

//--- 'clone' virtual method
  public : virtual cPtr_lexicalFunctionArgument * _cloneObject (void) const ;

//--- Friend class declarations
  friend class GGS_lexicalFunctionArgumentList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@lexicalDropInstructionList'                *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalDropInstruction : public cPtr_lexicalInstruction {
//--- Attributes
  public : GGS_lstring  mTerminalName ;
//--- Constructor
  public : cPtr_lexicalDropInstruction (const GGS_lstring & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline cPtr_lexicalDropInstruction * nextObject (void) const {
    return (cPtr_lexicalDropInstruction *) internalNextItem () ;
  }

//--- Access to previous
  public : inline cPtr_lexicalDropInstruction * previousObject (void) const {
    return (cPtr_lexicalDropInstruction *) internalPreviousItem () ;
  }

//--- Element comparison
  public : virtual bool isEqualToObject (const cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & _inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Metamodel Index
  public : virtual uint32 _metamodelIndex (void) const ;

//--- Metamodel Class ID
  public : virtual uint32 _metamodelClassID (void) const ;

//--- 'clone' virtual method
  public : virtual cPtr_lexicalDropInstruction * _cloneObject (void) const ;

//--- Friend class declarations
  friend class GGS_lexicalDropInstructionList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@lexicalErrorInstructionList'               *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalErrorInstruction : public cPtr_lexicalInstruction {
//--- Attributes
  public : GGS_lstring  mErrorMessageName ;
//--- Constructor
  public : cPtr_lexicalErrorInstruction (const GGS_lstring & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline cPtr_lexicalErrorInstruction * nextObject (void) const {
    return (cPtr_lexicalErrorInstruction *) internalNextItem () ;
  }

//--- Access to previous
  public : inline cPtr_lexicalErrorInstruction * previousObject (void) const {
    return (cPtr_lexicalErrorInstruction *) internalPreviousItem () ;
  }

//--- Element comparison
  public : virtual bool isEqualToObject (const cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & _inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Metamodel Index
  public : virtual uint32 _metamodelIndex (void) const ;

//--- Metamodel Class ID
  public : virtual uint32 _metamodelClassID (void) const ;

//--- 'clone' virtual method
  public : virtual cPtr_lexicalErrorInstruction * _cloneObject (void) const ;

//--- Friend class declarations
  friend class GGS_lexicalErrorInstructionList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@lexicalTagInstructionList'                *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalTagInstruction : public cPtr_lexicalInstruction {
//--- Attributes
  public : GGS_lstring  mTagName ;
//--- Constructor
  public : cPtr_lexicalTagInstruction (const GGS_lstring & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline cPtr_lexicalTagInstruction * nextObject (void) const {
    return (cPtr_lexicalTagInstruction *) internalNextItem () ;
  }

//--- Access to previous
  public : inline cPtr_lexicalTagInstruction * previousObject (void) const {
    return (cPtr_lexicalTagInstruction *) internalPreviousItem () ;
  }

//--- Element comparison
  public : virtual bool isEqualToObject (const cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & _inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Metamodel Index
  public : virtual uint32 _metamodelIndex (void) const ;

//--- Metamodel Class ID
  public : virtual uint32 _metamodelClassID (void) const ;

//--- 'clone' virtual method
  public : virtual cPtr_lexicalTagInstruction * _cloneObject (void) const ;

//--- Friend class declarations
  friend class GGS_lexicalTagInstructionList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@lexicalRewindInstructionList'               *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalRewindInstruction : public cPtr_lexicalInstruction {
//--- Attributes
  public : GGS_lstring  mTagName ;
  public : GGS_lstring  mTerminalName ;
//--- Constructor
  public : cPtr_lexicalRewindInstruction (const GGS_lstring & ,
                                const GGS_lstring & 
                                COMMA_LOCATION_ARGS) ;

//--- Access to next
  public : inline cPtr_lexicalRewindInstruction * nextObject (void) const {
    return (cPtr_lexicalRewindInstruction *) internalNextItem () ;
  }

//--- Access to previous
  public : inline cPtr_lexicalRewindInstruction * previousObject (void) const {
    return (cPtr_lexicalRewindInstruction *) internalPreviousItem () ;
  }

//--- Element comparison
  public : virtual bool isEqualToObject (const cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & _inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Metamodel Index
  public : virtual uint32 _metamodelIndex (void) const ;

//--- Metamodel Class ID
  public : virtual uint32 _metamodelClassID (void) const ;

//--- 'clone' virtual method
  public : virtual cPtr_lexicalRewindInstruction * _cloneObject (void) const ;

//--- Friend class declarations
  friend class GGS_lexicalRewindInstructionList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@lexicalLogInstructionList'                *
//                                                                           *
//---------------------------------------------------------------------------*

class cPtr_lexicalLogInstruction : public cPtr_lexicalInstruction {
//--- Attributes
//--- Constructor
  public : cPtr_lexicalLogInstruction (LOCATION_ARGS) ;

//--- Access to next
  public : inline cPtr_lexicalLogInstruction * nextObject (void) const {
    return (cPtr_lexicalLogInstruction *) internalNextItem () ;
  }

//--- Access to previous
  public : inline cPtr_lexicalLogInstruction * previousObject (void) const {
    return (cPtr_lexicalLogInstruction *) internalPreviousItem () ;
  }

//--- Element comparison
  public : virtual bool isEqualToObject (const cListElement * inOperand) const ;

//--- Method used for description
  public : virtual void
  appendForDescription (C_Compiler & _inLexique,
                        C_String & ioString,
                        const sint32 inIndentation
                        COMMA_LOCATION_ARGS) const ;

//--- Metamodel Index
  public : virtual uint32 _metamodelIndex (void) const ;

//--- Metamodel Class ID
  public : virtual uint32 _metamodelClassID (void) const ;

//--- 'clone' virtual method
  public : virtual cPtr_lexicalLogInstruction * _cloneObject (void) const ;

//--- Friend class declarations
  friend class GGS_lexicalLogInstructionList ;
} ;

//---------------------------------------------------------------------------*

#endif
