//---------------------------------------------------------------------------*
//                                                                           *
//                  File 'programComponentCompilation.cpp'                   *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                      october 2nd, 2010, at 14h5'51"                       *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if CURRENT_LIBPM_VERSION != VERSION_OF_LIBPM_USED_BY_GALGAS_COMPILER
  #error "This file has been compiled with a version of GALGAS that uses libpm version VERSION_OF_LIBPM_USED_BY_GALGAS_COMPILER, different than the current version (CURRENT_LIBPM_VERSION) of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "galgas/C_galgas_CLI_Options.h"
#include "programComponentCompilation.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "programComponentCompilation.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//             Include directives generated by grammar includes              *
//                                                                           *
//---------------------------------------------------------------------------*

#include "programSLRgrammar.h"

//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//        Implementation of wrapper 'programFileGenerationTemplate'          *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

//--- All files of '' directory

static const cRegularFileWrapper * gWrapperAllFiles_programFileGenerationTemplate_0 [1] = {
  NULL
} ;

//---------------------------------------------------------------------------*

//--- All sub-directories of '' directory

static const cDirectoryWrapper * gWrapperAllDirectories_programFileGenerationTemplate_0 [1] = {
  NULL
} ;

//---------------------------------------------------------------------------*

//--- Directory ''

const cDirectoryWrapper gWrapperDirectory_0_programFileGenerationTemplate (
  "",
  0,
  gWrapperAllFiles_programFileGenerationTemplate_0,
  0,
  gWrapperAllDirectories_programFileGenerationTemplate_0
) ;

//---------------------------------------------------------------------------*
//                                                                           *
//'programFileHeader' template of 'programFileGenerationTemplate' filewrapper*
//                                                                           *
//---------------------------------------------------------------------------*

GGS_string
template_filewrapper_programFileGenerationTemplate_programFileHeader (C_Compiler & /* inLexique */,
                                const GGS_string& var_cas_COMPONENT_NAME,
                                const GGS_stringlist & var_cas_IMPORTED_COMPONENT_LIST,
                                const GGS_lstringlist & var_cas_TYPE_PREDECLARATION_LIST) {
  C_String result ;
  const bool isBuilt = var_cas_COMPONENT_NAME.isBuilt ()
    && var_cas_IMPORTED_COMPONENT_LIST.isBuilt ()
    && var_cas_TYPE_PREDECLARATION_LIST.isBuilt () ;
  if (isBuilt) {
    result << "#ifndef " ;
    result << var_cas_COMPONENT_NAME ;
    result << "_ENTITIES_DEFINED\n"
      "#define " ;
    result << var_cas_COMPONENT_NAME ;
    result << "_ENTITIES_DEFINED\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "\n"
      "#include \"galgas2/predefined-types.h\"\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "\n" ;
    GGS_stringlist::cEnumerator enumerator_321 (var_cas_IMPORTED_COMPONENT_LIST, true) ;
    const GGS_stringlist::cElement * operand_321 = NULL ;
    while (((operand_321 = enumerator_321.nextObject ()))) {
      macroValidPointer (operand_321) ;
      result << "#include \"" ;
      result << operand_321->mValue ;
      result << ".h\"\n" ;
    }
    result << "\n"
      "//---------------------------------------------------------------------------*\n"
      "\n" ;
    GGS_lstringlist::cEnumerator enumerator_485 (var_cas_TYPE_PREDECLARATION_LIST, true) ;
    const GGS_lstringlist::cElement * operand_485 = NULL ;
    while (((operand_485 = enumerator_485.nextObject ()))) {
      macroValidPointer (operand_485) ;
      result << "class GALGAS_" ;
      result << operand_485->mValue.ggs_string ().reader_identifierRepresentation () ;
      result << " ;\n" ;
    }
    result << "\n" ;
  }
  return GGS_string (isBuilt, result) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//'programFileImplementation' template of 'programFileGenerationTemplate' filewrapper*
//                                                                           *
//---------------------------------------------------------------------------*

GGS_string
template_filewrapper_programFileGenerationTemplate_programFileImplementation (C_Compiler & inLexique,
                                const GGS_string& var_cas_COMPONENT_NAME,
                                const GGS_stringlist & var_cas_IMPORTED_COMPONENT_LIST,
                                const GGS_programRuleList & var_cas_PROGRAM_RULE_LIST,
                                const GGS_string& var_cas_VERSION) {
  C_String result ;
  const bool isBuilt = var_cas_COMPONENT_NAME.isBuilt ()
    && var_cas_IMPORTED_COMPONENT_LIST.isBuilt ()
    && var_cas_PROGRAM_RULE_LIST.isBuilt ()
    && var_cas_VERSION.isBuilt () ;
  if (isBuilt) {
    result << "#include \"version_libpm.h\"\n"
      "#if CURRENT_LIBPM_VERSION != VERSION_OF_LIBPM_USED_BY_GALGAS_COMPILER\n"
      "  #error \"This file has been compiled with a version of GALGAS that uses libpm version VERSION_OF_LIBPM_USED_BY_GALGAS_COMPILER, different than the current version (CURRENT_LIBPM_VERSION) of libpm\"\n"
      "#endif\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "\n"
      "#include \"" ;
    result << var_cas_COMPONENT_NAME ;
    result << ".h\"\n"
      "#include \"galgas/C_galgas_CLI_Options.h\"\n"
      "#include \"utilities/F_DisplayException.h\"\n"
      "#include \"utilities/basic-allocation.h\"\n"
      "#include \"utilities/cpp-allocation.h\"\n"
      "#include \"command_line_interface/mainForLIBPM.h\"\n"
      "#include \"command_line_interface/F_Analyze_CLI_Options.h\"\n"
      "#include \"command_line_interface/C_builtin_CLI_Options.h\"\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "\n" ;
    GGS_stringlist::cEnumerator enumerator_856 (var_cas_IMPORTED_COMPONENT_LIST, true) ;
    const GGS_stringlist::cElement * operand_856 = NULL ;
    while (((operand_856 = enumerator_856.nextObject ()))) {
      macroValidPointer (operand_856) ;
      result << "#include \"" ;
      result << operand_856->mValue ;
      result << ".h\"\n" ;
    }
    result << "\n"
      "//---------------------------------------------------------------------------*\n"
      "\n"
      "#ifndef DO_NOT_GENERATE_CHECKINGS\n"
      "  #define SOURCE_FILE_AT_LINE(line) \"" ;
    result << var_cas_COMPONENT_NAME ;
    result << ".gProgram\", line\n"
      "  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)\n"
      "#else\n"
      "  #define SOURCE_FILE_AT_LINE(line) \n"
      "  #define COMMA_SOURCE_FILE_AT_LINE(line) \n"
      "#endif\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "//                                                                           *\n"
      "//                      M A I N    F O R    L I B P M                        *\n"
      "//                                                                           *\n"
      "//---------------------------------------------------------------------------*\n"
      "\n"
      "int mainForLIBPM  (const int argc, const char * argv []) {\n"
      "  bool verboseOptionOn = true ;\n"
      "  PMSInt16 returnCode = 0 ; // No error\n"
      "  {\n"
      "  //--- Input/output parameters\n"
      "    const char * extensions [] = {\n" ;
    GGS_programRuleList::cEnumerator enumerator_1882 (var_cas_PROGRAM_RULE_LIST, true) ;
    const GGS_programRuleList::cElement * operand_1882 = NULL ;
    while (((operand_1882 = enumerator_1882.nextObject ()))) {
      macroValidPointer (operand_1882) ;
      result << "      " ;
      result << operand_1882->mSourceFileExtension.ggs_string ().reader_utf8Representation () ;
      result << ",\n" ;
    }
    result << "      NULL\n"
      "    } ;    \n"
      "    const char * helpMessages [] = {\n" ;
    GGS_programRuleList::cEnumerator enumerator_2050 (var_cas_PROGRAM_RULE_LIST, true) ;
    const GGS_programRuleList::cElement * operand_2050 = NULL ;
    while (((operand_2050 = enumerator_2050.nextObject ()))) {
      macroValidPointer (operand_2050) ;
      result << "      " ;
      result << operand_2050->mSourceFileHelp.ggs_string ().reader_utf8Representation () ;
      result << ",\n" ;
    }
    result << "      NULL\n"
      "    } ;    \n"
      "    TC_UniqueArray <C_String> sourceFilesArray ;\n"
      "  //--- Analyze Command Line Options\n"
      "    F_Analyze_CLI_Options (argc, argv,\n"
      "      #ifndef DO_NOT_GENERATE_CHECKINGS\n"
      "        \"version \" " ;
    result << var_cas_VERSION.reader_utf8Representation () ;
    result << " \" [debug]\",\n"
      "      #else\n"
      "        \"version \" " ;
    result << var_cas_VERSION.reader_utf8Representation () ;
    result << ",\n"
      "      #endif\n"
      "                           sourceFilesArray,\n"
      "                           extensions,\n"
      "                           helpMessages) ;\n"
      "  //--- Build galgas io object\n"
      "    C_galgas_io * galgasIOptr = NULL ;\n"
      "    macroMyNew (galgasIOptr, C_galgas_io (HERE)) ;\n"
      "  //--- Common lexique object\n"
      "    C_Compiler * commonLexique = NULL ;\n"
      "    macroMyNew (commonLexique, C_Compiler (NULL, \"\", \"\", galgasIOptr COMMA_HERE)) ;\n"
      "  //--- Ask Save On Close \? (Carbon and Windows SIOUX Only)\n"
      "    #ifdef SIOUX_IS_IMPLEMENTED\n"
      "      SIOUXSettings.asktosaveonclose = gOption_generic_5F_cli_5F_options_options_asktosaveonclose.mValue ;\n"
      "    #endif\n"
      "  //--- Enable 64 bit alloc debug \? Only if compiled in 64 bit and in debug mode\n"
      "    #ifndef DO_NOT_GENERATE_CHECKINGS\n"
      "      #ifdef __LP64__\n"
      "        if (gOption_generic_5F_cli_5F_options_enable_5F_allocation_5F_debugging.mValue) {\n"
      "          enableAllocDebugFor64BitTool () ;\n"
      "        }\n"
      "      #endif\n"
      "    #endif\n"
      "    try{\n"
      "      verboseOptionOn = gOption_galgas_5F_cli_5F_options_verbose_5F_output.mValue ;\n"
      "      routine_before (commonLexique COMMA_HERE) ;\n"
      "      for (PMSInt32 i=0 ; i<sourceFilesArray.count () ; i++) {\n"
      "        const C_String fileExtension = sourceFilesArray (i COMMA_HERE).pathExtension () ;\n"
      "        const GALGAS_string sfp = GALGAS_string (sourceFilesArray (i COMMA_HERE)) ;\n"
      "        const GALGAS_location location = commonLexique->here (HERE) ;\n"
      "        const GALGAS_lstring sourceFilePath = GALGASap_lstring (sfp, location) ;\n"
      "        PMSInt16 r = 0 ;\n"
      "        " ;
    GGS_programRuleList::cEnumerator enumerator_3970 (var_cas_PROGRAM_RULE_LIST, true) ;
    const GGS_programRuleList::cElement * operand_3970 = NULL ;
    { GGS_uint var_cas_IDX (true, 0) ;
  while (((operand_3970 = enumerator_3970.nextObject ()))) {
    macroValidPointer (operand_3970) ;
    result << "if (fileExtension == " ;
    result << operand_3970->mSourceFileExtension.ggs_string ().reader_utf8Representation () ;
    result << ") {\n"
      "          routine_" ;
    result << (GGS_string ("programRule_")).operator_concat (var_cas_IDX.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (99))).reader_identifierRepresentation () ;
    result << " (sourceFilePath, commonLexique COMMA_HERE) ;\n" ;
    if (enumerator_3970.hasNextObject ()) {
      result << "        }else " ;
    }
    var_cas_IDX.increment_operation (inLexique COMMA_HERE) ;
  }
}
result << "        }else{\n"
  "          printf (\"*** Error: unhandled extension for file '%s' ***\\n\", sourceFilesArray (i COMMA_HERE).cString (HERE)) ;\n"
  "          r = 1 ;\n"
  "        }\n"
  "        if (r != 0) {\n"
  "          returnCode = r ;\n"
  "        }\n"
  "      }\n"
  "    //--- Error or warnings \?\n"
  "      if (commonLexique->totalErrorCount () > 0) {\n"
  "        returnCode = 1 ; // Error code\n"
  "      }else if (commonLexique->totalWarningCount () > 0) {\n"
  "        if (gOption_galgas_5F_cli_5F_options_treat_5F_warnings_5F_as_5F_error.mValue) {\n"
  "          returnCode = 1 ; // Error code\n"
  "          if (verboseOptionOn) {\n"
  "            printf (\"** Note: warnings are treated as errors. **\\n\") ;\n"
  "          }\n"
  "        }\n"
  "      }\n"
  "    //--- Epilogue\n"
  "      routine_after (commonLexique COMMA_HERE) ;\n"
  "    }catch (const M_STD_NAMESPACE exception & e) {\n"
  "      F_default_display_exception (e) ;\n"
  "      returnCode = 1 ; // Error code\n"
  "    }catch (...) {\n"
  "      throw ;\n"
  "    }\n"
  "    macroReleaseObject (galgasIOptr) ;\n"
  "    macroReleaseObject (commonLexique) ;\n"
  "  }\n"
  "  return returnCode ;\n"
  "}\n"
  "\n" ;
}
return GGS_string (isBuilt, result) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Implementation of routine "compileBeforeClause"               *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_compileBeforeClause (C_Compiler & inLexique,
                                const GGS_semanticContext  var_cas_inSemanticContext,
                                const GGS_predefinedTypes  var_cas_inPredefinedTypes,
                                const GGS_programComponentAST  var_cas_inProgramComponentAST,
                                GGS_semanticDeclarationListForGeneration  & var_cas_ioDecoratedDeclarationListForGeneration
                        COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_compileBeforeClause at %s:%d\n", __FILE__, __LINE__) ;
  #endif
GGS_semanticInstructionListForGeneration  var_cas_semanticInstructionListForGeneration ;
GGS_formalParameterListForGeneration  automatic_var_3691_0 ;
::routine_analyzeRoutineBody (inLexique,  var_cas_inSemanticContext,  var_cas_inPredefinedTypes,  GGS_formalParameterListAST ::constructor_emptyList (),  GGS_localConstantList ::constructor_emptyList (),  GGS_typedAttributeList ::constructor_emptyList (),  var_cas_inProgramComponentAST.reader_mPrologueInstructionList (inLexique COMMA_SOURCE_FILE_AT_LINE (69)),  var_cas_inProgramComponentAST.reader_mEndOfPrologue (inLexique COMMA_SOURCE_FILE_AT_LINE (70)),  var_cas_semanticInstructionListForGeneration,  automatic_var_3691_0 COMMA_SOURCE_FILE_AT_LINE (63)) ;
var_cas_ioDecoratedDeclarationListForGeneration.addAssign_operation (GGS_routineImplementationForGeneration ::constructor_new (inLexique, GGS_string ("before"), GGS_formalParameterListForGeneration ::constructor_emptyList (), var_cas_semanticInstructionListForGeneration COMMA_SOURCE_FILE_AT_LINE (74))) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_compileBeforeClause\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Implementation of routine "compileProgramRules"               *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_compileProgramRules (C_Compiler & inLexique,
                                const GGS_semanticContext  var_cas_inSemanticContext,
                                const GGS_predefinedTypes  var_cas_inPredefinedTypes,
                                const GGS_programComponentAST  var_cas_inProgramComponentAST,
                                GGS_semanticDeclarationListForGeneration  & var_cas_ioDecoratedDeclarationListForGeneration
                        COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_compileProgramRules at %s:%d\n", __FILE__, __LINE__) ;
  #endif
GGS_uint  var_cas_ruleIndex = GGS_uint (0U) ;
{
GGS_programRuleList::cEnumerator enumerator_4571 (var_cas_inProgramComponentAST.reader_mProgramRules (inLexique COMMA_SOURCE_FILE_AT_LINE (94)), true) ;
const GGS_programRuleList::cElement * operand_4571 = NULL ;
while (((operand_4571 = enumerator_4571.nextObject ()))) {
  macroValidPointer (operand_4571) ;
  GGS_formalParameterListAST  var_cas_argumentList = GGS_formalParameterListAST ::constructor_emptyList () ;
  var_cas_argumentList.addAssign_operation (GGS_formalArgumentPassingModeAST::constructor_argumentConstantIn (inLexique COMMA_SOURCE_FILE_AT_LINE (97)), GGS_lstring ::constructor_new (inLexique, GGS_string ("lstring"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (98)), operand_4571->mSourceFileVariableName, operand_4571->mSourceFileVariableNameIsUnused) ;
  GGS_semanticInstructionListForGeneration  var_cas_semanticInstructionListForGeneration ;
  GGS_formalParameterListForGeneration  var_cas_routineSignature ;
  ::routine_analyzeRoutineBody (inLexique,  var_cas_inSemanticContext,  var_cas_inPredefinedTypes,  var_cas_argumentList,  GGS_localConstantList ::constructor_emptyList (),  GGS_typedAttributeList ::constructor_emptyList (),  operand_4571->mInstructionList,  operand_4571->mEndOfInstructionList,  var_cas_semanticInstructionListForGeneration,  var_cas_routineSignature COMMA_SOURCE_FILE_AT_LINE (104)) ;
  var_cas_ioDecoratedDeclarationListForGeneration.addAssign_operation (GGS_routineImplementationForGeneration ::constructor_new (inLexique, (GGS_string ("programRule_")).operator_concat (var_cas_ruleIndex.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (116))), var_cas_routineSignature, var_cas_semanticInstructionListForGeneration COMMA_SOURCE_FILE_AT_LINE (115))) ;
  var_cas_ruleIndex.increment_operation (inLexique COMMA_SOURCE_FILE_AT_LINE (120)) ;
}
}
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_compileProgramRules\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Implementation of routine "compileAfterClause"               *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_compileAfterClause (C_Compiler & inLexique,
                                const GGS_semanticContext  var_cas_inSemanticContext,
                                const GGS_predefinedTypes  var_cas_inPredefinedTypes,
                                const GGS_programComponentAST  var_cas_inProgramComponentAST,
                                GGS_semanticDeclarationListForGeneration  & var_cas_ioDecoratedDeclarationListForGeneration
                        COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_compileAfterClause at %s:%d\n", __FILE__, __LINE__) ;
  #endif
GGS_semanticInstructionListForGeneration  var_cas_semanticInstructionListForGeneration ;
GGS_formalParameterListForGeneration  automatic_var_6723_0 ;
::routine_analyzeRoutineBody (inLexique,  var_cas_inSemanticContext,  var_cas_inPredefinedTypes,  GGS_formalParameterListAST ::constructor_emptyList (),  GGS_localConstantList ::constructor_emptyList (),  GGS_typedAttributeList ::constructor_emptyList (),  var_cas_inProgramComponentAST.reader_mEpilogueInstructionList (inLexique COMMA_SOURCE_FILE_AT_LINE (143)),  var_cas_inProgramComponentAST.reader_mEndOfEpilogue (inLexique COMMA_SOURCE_FILE_AT_LINE (144)),  var_cas_semanticInstructionListForGeneration,  automatic_var_6723_0 COMMA_SOURCE_FILE_AT_LINE (137)) ;
var_cas_ioDecoratedDeclarationListForGeneration.addAssign_operation (GGS_routineImplementationForGeneration ::constructor_new (inLexique, GGS_string ("after"), GGS_formalParameterListForGeneration ::constructor_emptyList (), var_cas_semanticInstructionListForGeneration COMMA_SOURCE_FILE_AT_LINE (148))) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_compileAfterClause\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Implementation of routine "compileProgramComponent"             *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_compileProgramComponent (C_Compiler & inLexique,
                                const GGS_lstring   var_cas_inSourceFile,
                                const GGS_string  var_cas_inOutputDirectory,
                                GGS_parsedComponentStruct & var_cas_ioParsedComponentStruct
                        COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_compileProgramComponent at %s:%d\n", __FILE__, __LINE__) ;
  #endif
GGS_programComponentAST var_cas_programComponentRoot ;
const GGS_string var_cas_basename = var_cas_inSourceFile.ggs_string ().reader_lastPathComponent ().reader_stringByDeletingPathExtension () ;
const GGS_lstring  var_cas_basenameKey = GGS_lstring ::constructor_new (inLexique, var_cas_basename, GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (170)) ;
GGS_programComponentAST var_cas_programComponentAST ;
const GGS_bool cond_7923 = var_cas_ioParsedComponentStruct.mParsedSyntaxComponentMap.reader_hasKey (var_cas_basename) ;
if (cond_7923.isBuiltAndTrue ()) {
if (var_cas_ioParsedComponentStruct.mParsedProgramComponentMap.isBuilt ()) {
  var_cas_ioParsedComponentStruct.mParsedProgramComponentMap (HERE)->method_searchKey (inLexique, var_cas_basenameKey, var_cas_programComponentAST COMMA_SOURCE_FILE_AT_LINE (173)) ;
}
}else if (cond_7923.isBuiltAndFalse ()) {
const GGS_string _depExtension = GGS_string ("") ;
const GGS_string _depPath = GGS_string ("") ;
if (_depExtension.isBuilt () && _depPath.isBuilt ()) {
  C_Grammar_programSLRgrammar::_performSourceFileParsing_ (inLexique,
                                _depExtension.string (),
                                _depPath.string (),
                                NULL,
                                var_cas_inSourceFile,
                                var_cas_programComponentAST
                                COMMA_SOURCE_FILE_AT_LINE (175)) ;
}
var_cas_ioParsedComponentStruct.mParsedProgramComponentMap.modifier_insertKey (inLexique, var_cas_basenameKey, var_cas_programComponentAST COMMA_SOURCE_FILE_AT_LINE (176)) ;
}
const GGS_lstring  var_cas_componentName = var_cas_programComponentAST.reader_mProgramComponentName (inLexique COMMA_SOURCE_FILE_AT_LINE (179)) ;
const GGS_bool cond_8463 = (var_cas_componentName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (180))).operator_isNotEqual (var_cas_basename) ;
if (cond_8463.isBuiltAndTrue ()) {
var_cas_componentName.reader_location (inLexique COMMA_HERE).signalGGSSemanticWarning (inLexique, ((((GGS_string ("GALGAS checks "
  "the component name ('")).operator_concat (var_cas_componentName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (182)))).operator_concat (GGS_string ("') against the source file base name ('"))).operator_concat (var_cas_basename)).operator_concat (GGS_string ("'): they should be identical")) COMMA_SOURCE_FILE_AT_LINE (184)) ;
}
GGS_semanticDeclarationListAST  var_cas_semanticDeclarationList = var_cas_programComponentAST.reader_mSemanticDeclarationList (inLexique COMMA_SOURCE_FILE_AT_LINE (187)) ;
GGS_stringset  var_cas_parsedFileSet = GGS_stringset ::constructor_setWithString (var_cas_inSourceFile.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (188))) ;
GGS_lstringlist  var_cas_optionComponentFileNameList = GGS_lstringlist ::constructor_emptyList () ;
GGS_grammarComponentASTList  var_cas_grammarComponentASTList = GGS_grammarComponentASTList ::constructor_emptyList () ;
GGS_stringlist  var_cas_headerIncludeList = GGS_stringlist ::constructor_emptyList () ;
GGS_stringlist  var_cas_implementationIncludeList = GGS_stringlist ::constructor_emptyList () ;
::routine_recursivelyImportSemanticComponent (inLexique,  var_cas_ioParsedComponentStruct,  var_cas_optionComponentFileNameList,  var_cas_grammarComponentASTList,  var_cas_semanticDeclarationList,  var_cas_parsedFileSet,  var_cas_headerIncludeList,  var_cas_implementationIncludeList,  var_cas_programComponentAST.reader_mImportedComponentFileNameList (inLexique COMMA_SOURCE_FILE_AT_LINE (201)),  var_cas_inSourceFile.ggs_string ().reader_stringByDeletingLastPathComponent () COMMA_SOURCE_FILE_AT_LINE (193)) ;
GGS_semanticDeclarationListAST  var_cas_semanticDeclarationListWithPredefinedTypes = var_cas_semanticDeclarationList ;
::routine_appendPredefinedTypesASTs (inLexique,  var_cas_semanticDeclarationListWithPredefinedTypes COMMA_SOURCE_FILE_AT_LINE (206)) ;
GGS_semanticContext var_cas_semanticContext ;
::routine_buildSemanticContext (inLexique,  var_cas_semanticDeclarationListWithPredefinedTypes,  var_cas_programComponentAST.reader_mEndOfSourceFile (inLexique COMMA_SOURCE_FILE_AT_LINE (211)),  var_cas_semanticContext COMMA_SOURCE_FILE_AT_LINE (209)) ;
::routine_buildGrammarComponentMapForSemanticAnalysis (inLexique,  var_cas_grammarComponentASTList,  var_cas_semanticContext COMMA_SOURCE_FILE_AT_LINE (215)) ;
::routine_buildOptionComponentMapForSemanticAnalysis (inLexique,  var_cas_optionComponentFileNameList,  var_cas_ioParsedComponentStruct,  var_cas_semanticContext.mOptionComponentMapForSemanticAnalysis COMMA_SOURCE_FILE_AT_LINE (220)) ;
GGS_semanticDeclarationListForGeneration  var_cas_decoratedDeclarationListForGeneration ;
::routine_performSemanticAnalysis (inLexique,  var_cas_programComponentAST.reader_mSemanticDeclarationList (inLexique COMMA_SOURCE_FILE_AT_LINE (228)),  var_cas_semanticContext,  var_cas_decoratedDeclarationListForGeneration COMMA_SOURCE_FILE_AT_LINE (227)) ;
const GGS_predefinedTypes var_cas_predefinedTypes = function_buildPredefinedTypes (inLexique, var_cas_semanticContext COMMA_SOURCE_FILE_AT_LINE (233)) ;
::routine_compileBeforeClause (inLexique,  var_cas_semanticContext,  var_cas_predefinedTypes,  var_cas_programComponentAST,  var_cas_decoratedDeclarationListForGeneration COMMA_SOURCE_FILE_AT_LINE (235)) ;
::routine_compileProgramRules (inLexique,  var_cas_semanticContext,  var_cas_predefinedTypes,  var_cas_programComponentAST,  var_cas_decoratedDeclarationListForGeneration COMMA_SOURCE_FILE_AT_LINE (242)) ;
::routine_compileAfterClause (inLexique,  var_cas_semanticContext,  var_cas_predefinedTypes,  var_cas_programComponentAST,  var_cas_decoratedDeclarationListForGeneration COMMA_SOURCE_FILE_AT_LINE (249)) ;
const GGS_bool cond_11678 = (GGS_uint ::constructor_errorCount (inLexique COMMA_SOURCE_FILE_AT_LINE (256))).operator_isEqual (GGS_uint (0U)) ;
if (cond_11678.isBuiltAndTrue ()) {
GGS_string var_cas_headerString = template_filewrapper_programFileGenerationTemplate_programFileHeader (inLexique, var_cas_componentName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (258)), var_cas_headerIncludeList, var_cas_semanticContext.mTypeMap.reader_allKeyList (inLexique COMMA_SOURCE_FILE_AT_LINE (260))) ;
{
  GGS_semanticDeclarationListForGeneration::cEnumerator enumerator_11250 (var_cas_decoratedDeclarationListForGeneration, true) ;
  const GGS_semanticDeclarationListForGeneration::cElement * operand_11250 = NULL ;
  while (((operand_11250 = enumerator_11250.nextObject ()))) {
    macroValidPointer (operand_11250) ;
    var_cas_headerString.dotAssign_operation ((findCategoryReader__semanticDeclarationForGeneration__appendDeclaration1 (operand_11250->mDeclaration (HERE)->galgasRTTI ()) (inLexique, operand_11250->mDeclaration.getPtr () COMMA_SOURCE_FILE_AT_LINE (263)))) ;
  }
}
{
  GGS_semanticDeclarationListForGeneration::cEnumerator enumerator_11379 (var_cas_decoratedDeclarationListForGeneration, true) ;
  const GGS_semanticDeclarationListForGeneration::cElement * operand_11379 = NULL ;
  while (((operand_11379 = enumerator_11379.nextObject ()))) {
    macroValidPointer (operand_11379) ;
    var_cas_headerString.dotAssign_operation ((findCategoryReader__semanticDeclarationForGeneration__appendDeclaration2 (operand_11379->mDeclaration (HERE)->galgasRTTI ()) (inLexique, operand_11379->mDeclaration.getPtr () COMMA_SOURCE_FILE_AT_LINE (266)))) ;
  }
}
GGS_string::class_method_generateFile (inLexique, var_cas_inOutputDirectory, (var_cas_componentName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (270))).operator_concat (GGS_string (".h")), GGS_string ("//"), GGS_string ("\n"
  "\n"), var_cas_headerString, GGS_string ("\n"
  "\n"), GGS_string ("#endif\n") COMMA_SOURCE_FILE_AT_LINE (268)) ;
}
const GGS_bool cond_12476 = (GGS_uint ::constructor_errorCount (inLexique COMMA_SOURCE_FILE_AT_LINE (279))).operator_isEqual (GGS_uint (0U)) ;
if (cond_12476.isBuiltAndTrue ()) {
GGS_string var_cas_implementationString = template_filewrapper_programFileGenerationTemplate_programFileImplementation (inLexique, var_cas_componentName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (281)), var_cas_implementationIncludeList, var_cas_programComponentAST.reader_mProgramRules (inLexique COMMA_SOURCE_FILE_AT_LINE (283)), var_cas_programComponentAST.reader_mVersionString (inLexique COMMA_SOURCE_FILE_AT_LINE (284)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (284))) ;
{
  GGS_semanticDeclarationListForGeneration::cEnumerator enumerator_12076 (var_cas_decoratedDeclarationListForGeneration, true) ;
  const GGS_semanticDeclarationListForGeneration::cElement * operand_12076 = NULL ;
  while (((operand_12076 = enumerator_12076.nextObject ()))) {
    macroValidPointer (operand_12076) ;
    var_cas_implementationString.dotAssign_operation ((findCategoryReader__semanticDeclarationForGeneration__appendTypeGenericImplementation (operand_12076->mDeclaration (HERE)->galgasRTTI ()) (inLexique, operand_12076->mDeclaration.getPtr () COMMA_SOURCE_FILE_AT_LINE (287)))) ;
    var_cas_implementationString.dotAssign_operation ((findCategoryReader__semanticDeclarationForGeneration__appendSpecificImplementation (operand_12076->mDeclaration (HERE)->galgasRTTI ()) (inLexique, operand_12076->mDeclaration.getPtr () COMMA_SOURCE_FILE_AT_LINE (288)))) ;
  }
}
GGS_string::class_method_generateFile (inLexique, var_cas_inOutputDirectory, (var_cas_componentName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (292))).operator_concat (GGS_string (".cpp")), GGS_string ("//"), GGS_string ("\n"
  "\n"), var_cas_implementationString, GGS_string ("\n"
  "\n"), GGS_string ("\n") COMMA_SOURCE_FILE_AT_LINE (290)) ;
}
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_compileProgramComponent\n") ;
  #endif
}

//---------------------------------------------------------------------------*

